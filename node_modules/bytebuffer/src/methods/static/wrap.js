/**
 * Wraps a buffer or a string. Sets the allocated ByteBuffer's ***REMOVED***@link ByteBuffer#offset***REMOVED*** to `0` and its
 *  ***REMOVED***@link ByteBuffer#limit***REMOVED*** to the length of the wrapped data.
//? if (NODE) ***REMOVED***
 * @param ***REMOVED***!ByteBuffer|!Buffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>***REMOVED*** buffer Anything that can be wrapped
//? ***REMOVED*** else ***REMOVED***
 * @param ***REMOVED***!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>***REMOVED*** buffer Anything that can be wrapped
//? ***REMOVED***
 * @param ***REMOVED***(string|boolean)=***REMOVED*** encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
 *  "utf8")
 * @param ***REMOVED***boolean=***REMOVED*** littleEndian Whether to use little or big endian byte order. Defaults to
 *  ***REMOVED***@link ByteBuffer.DEFAULT_ENDIAN***REMOVED***.
 * @param ***REMOVED***boolean=***REMOVED*** noAssert Whether to skip assertions of offsets and values. Defaults to
 *  ***REMOVED***@link ByteBuffer.DEFAULT_NOASSERT***REMOVED***.
 * @returns ***REMOVED***!ByteBuffer***REMOVED*** A ByteBuffer wrapping `buffer`
 * @expose
 */
ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) ***REMOVED***
    if (typeof encoding !== 'string') ***REMOVED***
        noAssert = littleEndian;
        littleEndian = encoding;
        encoding = undefined;
    ***REMOVED***
    if (typeof buffer === 'string') ***REMOVED***
        if (typeof encoding === 'undefined')
            encoding = "utf8";
        switch (encoding) ***REMOVED***
            //? if (BASE64) ***REMOVED***
            case "base64":
                return ByteBuffer.fromBase64(buffer, littleEndian);
            //? ***REMOVED*** if (HEX) ***REMOVED***
            case "hex":
                return ByteBuffer.fromHex(buffer, littleEndian);
            //? ***REMOVED*** if (BINARY) ***REMOVED***
            case "binary":
                return ByteBuffer.fromBinary(buffer, littleEndian);
            //? ***REMOVED*** if (UTF8) ***REMOVED***
            case "utf8":
                return ByteBuffer.fromUTF8(buffer, littleEndian);
            //? ***REMOVED*** if (DEBUG) ***REMOVED***
            case "debug":
                return ByteBuffer.fromDebug(buffer, littleEndian);
            //? ***REMOVED***
            default:
                throw Error("Unsupported encoding: "+encoding);
        ***REMOVED***
    ***REMOVED***
    if (buffer === null || typeof buffer !== 'object')
        throw TypeError("Illegal buffer");
    var bb;
    if (ByteBuffer.isByteBuffer(buffer)) ***REMOVED***
        bb = ByteBufferPrototype.clone.call(buffer);
        bb.markedOffset = -1;
        return bb;
    ***REMOVED***
    //? if (NODE) ***REMOVED***
    var i = 0,
        k = 0,
        b;
    if (buffer instanceof Uint8Array) ***REMOVED*** // Extract bytes from Uint8Array
        b = new Buffer(buffer.length);
        if (memcpy) ***REMOVED*** // Fast
            memcpy(b, 0, buffer.buffer, buffer.byteOffset, buffer.byteOffset + buffer.length);
        ***REMOVED*** else ***REMOVED*** // Slow
            for (i=0, k=buffer.length; i<k; ++i)
                b[i] = buffer[i];
        ***REMOVED***
        buffer = b;
    ***REMOVED*** else if (buffer instanceof ArrayBuffer) ***REMOVED*** // Convert ArrayBuffer to Buffer
        b = new Buffer(buffer.byteLength);
        if (memcpy) ***REMOVED*** // Fast
            memcpy(b, 0, buffer, 0, buffer.byteLength);
        ***REMOVED*** else ***REMOVED*** // Slow
            buffer = new Uint8Array(buffer);
            for (i=0, k=buffer.length; i<k; ++i) ***REMOVED***
                b[i] = buffer[i];
            ***REMOVED***
        ***REMOVED***
        buffer = b;
    ***REMOVED*** else if (!(buffer instanceof Buffer)) ***REMOVED*** // Create from octets if it is an error, otherwise fail
        if (Object.prototype.toString.call(buffer) !== "[object Array]")
            throw TypeError("Illegal buffer");
        buffer = new Buffer(buffer);
    ***REMOVED***
    bb = new ByteBuffer(0, littleEndian, noAssert);
    if (buffer.length > 0) ***REMOVED*** // Avoid references to more than one EMPTY_BUFFER
        bb.buffer = buffer;
        bb.limit = buffer.length;
    ***REMOVED***
    //? ***REMOVED*** else ***REMOVED***
    if (buffer instanceof Uint8Array) ***REMOVED*** // Extract ArrayBuffer from Uint8Array
        bb = new ByteBuffer(0, littleEndian, noAssert);
        if (buffer.length > 0) ***REMOVED*** // Avoid references to more than one EMPTY_BUFFER
            bb.buffer = buffer.buffer;
            bb.offset = buffer.byteOffset;
            bb.limit = buffer.byteOffset + buffer.byteLength;
            //? if (DATAVIEW)
            bb.view = new DataView(buffer.buffer);
            //? else
            bb.view = new Uint8Array(buffer.buffer);
        ***REMOVED***
    ***REMOVED*** else if (buffer instanceof ArrayBuffer) ***REMOVED*** // Reuse ArrayBuffer
        bb = new ByteBuffer(0, littleEndian, noAssert);
        if (buffer.byteLength > 0) ***REMOVED***
            bb.buffer = buffer;
            bb.offset = 0;
            bb.limit = buffer.byteLength;
            //? if (DATAVIEW)
            bb.view = buffer.byteLength > 0 ? new DataView(buffer) : null;
            //? else
            bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
        ***REMOVED***
    ***REMOVED*** else if (Object.prototype.toString.call(buffer) === "[object Array]") ***REMOVED*** // Create from octets
        bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
        bb.limit = buffer.length;
        for (var i=0; i<buffer.length; ++i)
            //? if (DATAVIEW)
            bb.view.setUint8(i, buffer[i]);
            //? else
            bb.view[i] = buffer[i];
    ***REMOVED*** else
        throw TypeError("Illegal buffer"); // Otherwise fail
    //? ***REMOVED***
    return bb;
***REMOVED***;
