/**
 * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
 *  ***REMOVED***@link ByteBuffer#offset***REMOVED*** and ***REMOVED***@link ByteBuffer#limit***REMOVED***.
 * @param ***REMOVED***boolean=***REMOVED*** forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
 *  possible. Defaults to `false`
//? if (NODE) ***REMOVED***
 * @returns ***REMOVED***!Buffer***REMOVED*** Contents as a Buffer
//? ***REMOVED*** else ***REMOVED***
 * @returns ***REMOVED***!ArrayBuffer***REMOVED*** Contents as an ArrayBuffer
//? ***REMOVED***
 * @expose
 */
ByteBufferPrototype.toBuffer = function(forceCopy) ***REMOVED***
    var offset = this.offset,
        limit = this.limit;
    if (!this.noAssert) ***REMOVED***
        //? ASSERT_RANGE('offset', 'limit');
    ***REMOVED***
    //? if (NODE) ***REMOVED***
    if (forceCopy) ***REMOVED***
        var buffer = new Buffer(limit - offset);
        this.buffer.copy(buffer, 0, offset, limit);
        return buffer;
    ***REMOVED*** else ***REMOVED***
        if (offset === 0 && limit === this.buffer.length)
            return this.buffer;
        else
            return this.buffer.slice(offset, limit);
    ***REMOVED***
    //? ***REMOVED*** else ***REMOVED***
    // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
    // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
    if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
        return this.buffer;
    if (offset === limit)
        return EMPTY_BUFFER;
    var buffer = new ArrayBuffer(limit - offset);
    new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
    return buffer;
    //? ***REMOVED***
***REMOVED***;

//? if (NODE) ***REMOVED***
/**
 * Returns a copy of the backing buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
 *  ***REMOVED***@link ByteBuffer#offset***REMOVED*** and ***REMOVED***@link ByteBuffer#limit***REMOVED***.
 * @returns ***REMOVED***!ArrayBuffer***REMOVED*** Contents as an ArrayBuffer
 */
ByteBufferPrototype.toArrayBuffer = function() ***REMOVED***
    var offset = this.offset,
        limit = this.limit;
    if (!this.noAssert) ***REMOVED***
        //? ASSERT_RANGE('offset', 'limit');
    ***REMOVED***
    var ab = new ArrayBuffer(limit - offset);
    if (memcpy) ***REMOVED*** // Fast
        memcpy(ab, 0, this.buffer, offset, limit);
    ***REMOVED*** else ***REMOVED*** // Slow
        var dst = new Uint8Array(ab);
        for (var i=offset; i<limit; ++i)
            dst[i-offset] = this.buffer[i];
    ***REMOVED***
    return ab;
***REMOVED***;
//? ***REMOVED*** else ***REMOVED***
/**
 * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
 *  ***REMOVED***@link ByteBuffer#offset***REMOVED*** and ***REMOVED***@link ByteBuffer#limit***REMOVED***. This is an alias of ***REMOVED***@link ByteBuffer#toBuffer***REMOVED***.
 * @function
 * @param ***REMOVED***boolean=***REMOVED*** forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
 *  Defaults to `false`
 * @returns ***REMOVED***!ArrayBuffer***REMOVED*** Contents as an ArrayBuffer
 * @expose
 */
ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;
//? ***REMOVED***

