// encodings/impl/utf8

/**
 * Encodes a standard JavaScript string to UTF8 bytes.
 * @param ***REMOVED***string***REMOVED*** src Source string
 * @param ***REMOVED***number***REMOVED*** srcOffset Source offset
 * @param ***REMOVED***!ByteBuffer***REMOVED*** dst Destination ByteBuffer
 * @param ***REMOVED***number***REMOVED*** dstOffset Destination offset
 * @param ***REMOVED***number***REMOVED*** count Number of char codes to encode
 * @returns ***REMOVED***number***REMOVED*** Number of bytes encoded
 * @inner
 */
function utf8_encode(src, srcOffset, dst, dstOffset, count) ***REMOVED***
    if (count === 0)
        return 0;
    var n = 0;
    //? // SET(varValue, varOffset, varTarget) with varTarget referencing a ByteBuffer
    do ***REMOVED***
        var cc = src.charCodeAt(srcOffset++);
        --count;
        if (cc < 0x80) ***REMOVED***
            n += 1;
            //? SET('cc', 'dstOffset++', 'dst');
        ***REMOVED*** else if (cc < 0x800) ***REMOVED***
            n += 2;
            //? SET('0xC0 | (cc >> 6)', 'dstOffset++', 'dst');
            //? SET('0x80 | (cc & 0x3F)', 'dstOffset++', 'dst');
        ***REMOVED*** else if (cc < 0xD800 || cc >= 0xE000) ***REMOVED***
            n += 3;
            //? SET('0xE0 | (cc >> 12)', 'dstOffset++', 'dst');
            //? SET('0x80 | ((cc >> 6) & 0x3F)', 'dstOffset++', 'dst');
            //? SET('0x80 | (cc & 0x3F)', 'dstOffset++', 'dst');
        ***REMOVED*** else ***REMOVED*** // surrogate
            if (count === 0)
                throw Error("truncated utf8 surrogate");
            cc = 0x10000 + (((cc & 0x3FF) << 10) | (src.charCodeAt(srcOffset++) & 0x3FF));
            --count;
            n += 4;
            //? SET('0xF0 | (cc >> 18)', 'dstOffset++', 'dst');
            //? SET('0x80 | ((cc >> 12) & 0x3F)', 'dstOffset++', 'dst');
            //? SET('0x80 | ((cc >> 6) & 0x3F)', 'dstOffset++', 'dst');
            //? SET('0x80 | (cc & 0x3F)', 'dstOffset++', 'dst');
        ***REMOVED***
    ***REMOVED*** while (count > 0);
    return n;
***REMOVED***

/**
 * Decodes UTF8 bytes to a standard JavaScript string.
 * @param ***REMOVED***!ByteBuffer***REMOVED*** src Source ByteBuffer
 * @param ***REMOVED***number***REMOVED*** srcOffset Source offset
 * @param ***REMOVED***number***REMOVED*** count Number of bytes to decode
 * @returns ***REMOVED***string***REMOVED*** Decoded string
 * @inner
 */
function utf8_decode(src, srcOffset, count) ***REMOVED***
    if (count === 0)
        return "";
    var parts = [], // readily assembled parts
        batch = []; // char codes for batch processing
    //? // GET(varOffset, varTarget) with varTarget referencing a ByteBuffer
    while (count--) ***REMOVED***
        var c = /*? GET('srcOffset++', 'src') */,
            c2, c3;
        switch (c >> 4) ***REMOVED***
            case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
                batch.push(c);
                break;
            case 12: case 13:
                if (count < 1)
                    throw Error("truncated utf8 sequence");
                c2 = /*? GET('srcOffset++', 'src') */;
                --count;
                batch.push(((c & 0x1F) << 6) | (c2 & 0x3F));
                break;
            case 14:
                if (count < 2)
                    throw Error("truncated utf8 sequence");
                c2 = /*? GET('srcOffset++', 'src') */;
                c3 = /*? GET('srcOffset++', 'src') */;
                count -= 2;
                batch.push(((c & 0x0F) << 12) | ((c2 & 0x3F) << 6) | ((c3 & 0x3F) << 0));
                break;
        ***REMOVED***
        if (batch.length > 1023) ***REMOVED***
            parts.push(String.fromCharCode.apply(String, batch));
            batch.length = 0;
        ***REMOVED***
    ***REMOVED***
    if (batch.length > 0) ***REMOVED***
        if (parts.length === 0)
            return String.fromCharCode.apply(String, batch);
        parts.push(String.fromCharCode.apply(String, batch));
    ***REMOVED***
    return parts.join('');
***REMOVED***

/**
 * Calculates the number of UTF8 bytes required to store a standard JavaScript string.
 * @param ***REMOVED***string***REMOVED*** src Source string
 * @param ***REMOVED***number***REMOVED*** srcOffset Source offset
 * @param ***REMOVED***number***REMOVED*** count Number of char codes to calculate
 * @returns ***REMOVED***number***REMOVED*** Number of bytes required
 * @inner
 */
function utf8_calculate(src, srcOffset, count) ***REMOVED***
    if (count === 0)
        return 0;
    var n = 0;
    do ***REMOVED***
        var cc = src.charCodeAt(srcOffset++);
        --count;
        if (cc < 0x80) ***REMOVED***
            n += 1;
        ***REMOVED*** else if (cc < 0x800) ***REMOVED***
            n += 2;
        ***REMOVED*** else if (cc < 0xD800 || cc >= 0xE000) ***REMOVED***
            n += 3;
        ***REMOVED*** else ***REMOVED***
            n += 4;
        ***REMOVED***
    ***REMOVED*** while (count > 0);
    return n;
***REMOVED***

ByteBuffer.registerEncoding("utf8", utf8_encode, utf8_decode, utf8_calculate);
