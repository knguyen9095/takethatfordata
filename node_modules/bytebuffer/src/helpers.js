// helpers
//? if (NODE) ***REMOVED***

/**
 * @type ***REMOVED***!Buffer***REMOVED***
 * @inner
 */
var EMPTY_BUFFER = new Buffer(0);
//? ***REMOVED*** else ***REMOVED***

/**
 * @type ***REMOVED***!ArrayBuffer***REMOVED***
 * @inner
 */
var EMPTY_BUFFER = new ArrayBuffer(0);
//? ***REMOVED***
//? if (!INLINE) ***REMOVED***

/**
 * Asserts that a value is an integer and returns the type-safe value.
 * @param ***REMOVED***number***REMOVED*** value Value to assert
 * @param ***REMOVED***boolean=***REMOVED*** unsigned Whether explicitly unsigned
 * @returns ***REMOVED***number***REMOVED*** Type-safe value
 * @throws ***REMOVED***TypeError***REMOVED*** If `value` is not an integer
 * @inner
 */
function assertInteger(value, unsigned) ***REMOVED***
    if (typeof value !== 'number' || value % 1 !== 0)
        throw TypeError("Illegal value: "+offset+" (not an integer)");
    return unsigned ? value >>> 0 : value | 0;
***REMOVED***

/**
 * Asserts that a value is an integer or Long.
 * @param ***REMOVED***number|!Long***REMOVED*** value Value to assert
 * @param ***REMOVED***boolean=***REMOVED*** unsigned Whether explicitly unsigned
 * @returns ***REMOVED***number|!Long***REMOVED*** Type-safe value
 * @throws ***REMOVED***TypeError***REMOVED*** If `value` is not an integer or Long
 * @inner
 */
function assertLong(value, unsigned) ***REMOVED***
    if (typeof value === 'number') ***REMOVED***
        return Long.fromNumber(value, unsigned);
    ***REMOVED*** else if (typeof value === 'string') ***REMOVED***
        return Long.fromString(value, unsigned);
    ***REMOVED*** else if (value && value instanceof Long) ***REMOVED***
        if (typeof unsigned !== 'undefined') ***REMOVED***
            if (unsigned && !value.unsigned) return value.toUnsigned();
            if (!unsigned && value.unsigned) return value.toSigned();
        ***REMOVED***
        return value;
    ***REMOVED*** else
        throw TypeError("Illegal value: "+value+" (not an integer or Long)");
***REMOVED***

/**
 * Asserts that `min <= offset <= cap-size` and returns the type-safe offset.
 * @param ***REMOVED***number***REMOVED*** offset Offset to assert
 * @param ***REMOVED***number***REMOVED*** min Minimum offset
 * @param ***REMOVED***number***REMOVED*** cap Cap offset
 * @param ***REMOVED***number***REMOVED*** size Required size in bytes
 * @returns ***REMOVED***number***REMOVED*** Type-safe offset
 * @throws ***REMOVED***TypeError***REMOVED*** If `offset` is not an integer
 * @throws ***REMOVED***RangeError***REMOVED*** If `offset < min || offset > cap-size`
 * @inner
 */
function assertOffset(offset, min, cap, size) ***REMOVED***
    if (typeof offset !== 'number' || offset % 1 !== 0)
        throw TypeError("Illegal offset: "+offset+" (not an integer)");
    offset = offset | 0;
    if (offset < min || offset > cap-size)
        throw RangeError("Illegal offset: "+min+" <= "+value+" <= "+cap+"-"+size);
    return offset;
***REMOVED***

/**
 * assertRange return value.
 * @type ***REMOVED***Array.<number>***REMOVED***
 */
var rangeVal = new Array(2);

/**
 * Asserts that `min <= begin <= end <= cap`. Updates `rangeVal` with the type-safe range.
 * @param ***REMOVED***number***REMOVED*** begin Begin offset
 * @param ***REMOVED***number***REMOVED*** end End offset
 * @param ***REMOVED***number***REMOVED*** min Minimum offset
 * @param ***REMOVED***number***REMOVED*** cap Cap offset
 * @throws ***REMOVED***TypeError***REMOVED*** If `begin` or `end` is not an integer
 * @throws ***REMOVED***RangeError***REMOVED*** If `begin < min || begin > end || end > cap`
 * @inner
 */
function assertRange(begin, end, min, cap) ***REMOVED***
    if (typeof begin !== 'number' || begin % 1 !== 0)
        throw TypeError("Illegal begin: "+begin+" (not a number)");
    begin = begin | 0;
    if (typeof end !== 'number' || end % 1 !== 0)
        throw TypeError("Illegal end: "+range[1]+" (not a number)");
    end = end | 0;
    if (begin < min || begin > end || end > cap)
        throw RangeError("Illegal range: "+min+" <= "+begin+" <= "+end+" <= "+cap);
    rangeVal[0] = begin; rangeVal[1] = end;
***REMOVED***
//? ***REMOVED***
//? if (BASE64 || UTF8) ***REMOVED***

/**
 * String.fromCharCode reference for compile-time renaming.
 * @type ***REMOVED***function(...number):string***REMOVED***
 * @inner
 */
var stringFromCharCode = String.fromCharCode;

/**
 * Creates a source function for a string.
 * @param ***REMOVED***string***REMOVED*** s String to read from
 * @returns ***REMOVED***function():number|null***REMOVED*** Source function returning the next char code respectively `null` if there are
 *  no more characters left.
 * @throws ***REMOVED***TypeError***REMOVED*** If the argument is invalid
 * @inner
 */
function stringSource(s) ***REMOVED***
    var i=0; return function() ***REMOVED***
        return i < s.length ? s.charCodeAt(i++) : null;
    ***REMOVED***;
***REMOVED***

/**
 * Creates a destination function for a string.
 * @returns ***REMOVED***function(number=):undefined|string***REMOVED*** Destination function successively called with the next char code.
 *  Returns the final string when called without arguments.
 * @inner
 */
function stringDestination() ***REMOVED***
    var cs = [], ps = []; return function() ***REMOVED***
        if (arguments.length === 0)
            return ps.join('')+stringFromCharCode.apply(String, cs);
        if (cs.length + arguments.length > 1024)
            ps.push(stringFromCharCode.apply(String, cs)),
                cs.length = 0;
        Array.prototype.push.apply(cs, arguments);
    ***REMOVED***;
***REMOVED***
//? ***REMOVED***
