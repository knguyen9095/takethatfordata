//? if (CSTRING) ***REMOVED***
// types/strings/cstring

/**
 * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
 *  characters itself.
 * @param ***REMOVED***string***REMOVED*** str String to write
 * @param ***REMOVED***number=***REMOVED*** offset Offset to write to. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  contained in `str` + 1 if omitted.
 * @returns ***REMOVED***!ByteBuffer|number***REMOVED*** this if offset is omitted, else the actual number of bytes written
 * @expose
 */
ByteBufferPrototype.writeCString = function(str, offset) ***REMOVED***
    //? RELATIVE();
    var i,
        k = str.length;
    if (!this.noAssert) ***REMOVED***
        if (typeof str !== 'string')
            throw TypeError("Illegal str: Not a string");
        for (i=0; i<k; ++i) ***REMOVED***
            if (str.charCodeAt(i) === 0)
                throw RangeError("Illegal str: Contains NULL-characters");
        ***REMOVED***
        //? ASSERT_OFFSET();
    ***REMOVED***
    // UTF8 strings do not contain zero bytes in between except for the zero character, so:
    //? if (NODE) ***REMOVED***
    k = Buffer.byteLength(str, "utf8");
    //? ENSURE_CAPACITY('k+1');
    offset += this.buffer.write(str, offset, k, "utf8");
    this.buffer[offset++] = 0;
    //? ***REMOVED*** else ***REMOVED***
    k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
    //? ENSURE_CAPACITY('k+1');
    utfx.encodeUTF16toUTF8(stringSource(str), function(b) ***REMOVED***
        //? if (DATAVIEW)
        this.view.setUint8(offset++, b);
        //? else
        this.view[offset++] = b;
    ***REMOVED***.bind(this));
    //? if (DATAVIEW)
    this.view.setUint8(offset++, 0);
    //? else
    this.view[offset++] = 0;
    //? ***REMOVED***
    if (relative) ***REMOVED***
        this.offset = offset;
        return this;
    ***REMOVED***
    return k;
***REMOVED***;

/**
 * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
 *  itself.
 * @param ***REMOVED***number=***REMOVED*** offset Offset to read from. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  read if omitted.
 * @returns ***REMOVED***string|!***REMOVED***string: string, length: number***REMOVED******REMOVED*** The string read if offset is omitted, else the string
 *  read and the actual number of bytes read.
 * @expose
 */
ByteBufferPrototype.readCString = function(offset) ***REMOVED***
    //? RELATIVE();
    if (!this.noAssert) ***REMOVED***
        //? ASSERT_OFFSET(1);
    ***REMOVED***
    var start = offset,
        temp;
    // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
    //? if (NODE) ***REMOVED***
    do ***REMOVED***
        if (offset >= this.buffer.length)
            throw RangeError("Index out of range: "+offset+" <= "+this.buffer.length);
        temp = this.buffer[offset++];
    ***REMOVED*** while (temp !== 0);
    var str = this.buffer.toString("utf8", start, offset-1);
    if (relative) ***REMOVED***
        this.offset = offset;
        return str;
    ***REMOVED*** else ***REMOVED***
        return ***REMOVED***
            "string": str,
            "length": offset - start
        ***REMOVED***;
    ***REMOVED***
    //? ***REMOVED*** else ***REMOVED*** // getUint8 asserts on its own
    var sd, b = -1;
    utfx.decodeUTF8toUTF16(function() ***REMOVED***
        if (b === 0) return null;
        if (offset >= this.limit)
            throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
        //? if (DATAVIEW)
        b = this.view.getUint8(offset++);
        //? else
        b = this.view[offset++];
        return b === 0 ? null : b;
    ***REMOVED***.bind(this), sd = stringDestination(), true);
    if (relative) ***REMOVED***
        this.offset = offset;
        return sd();
    ***REMOVED*** else ***REMOVED***
        return ***REMOVED***
            "string": sd(),
            "length": offset - start
        ***REMOVED***;
    ***REMOVED***
    //? ***REMOVED***
***REMOVED***;

//? ***REMOVED***
