//? if (ISTRING) ***REMOVED***
// types/strings/istring

/**
 * Writes a length as uint32 prefixed UTF8 encoded string.
 * @param ***REMOVED***string***REMOVED*** str String to write
 * @param ***REMOVED***number=***REMOVED*** offset Offset to write to. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  written if omitted.
 * @returns ***REMOVED***!ByteBuffer|number***REMOVED*** `this` if `offset` is omitted, else the actual number of bytes written
 * @expose
 * @see ByteBuffer#writeVarint32
 */
ByteBufferPrototype.writeIString = function(str, offset) ***REMOVED***
    //? RELATIVE();
    if (!this.noAssert) ***REMOVED***
        if (typeof str !== 'string')
            throw TypeError("Illegal str: Not a string");
        //? ASSERT_OFFSET();
    ***REMOVED***
    var start = offset,
        k;
    //? if (NODE) ***REMOVED***
    k = Buffer.byteLength(str, "utf8");
    //? ENSURE_CAPACITY('4+k');
    //? WRITE_UINT32_ARRAY('k');
    offset += 4;
    offset += this.buffer.write(str, offset, k, "utf8");
    //? ***REMOVED*** else ***REMOVED***
    k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
    //? ENSURE_CAPACITY('4+k');
    //? if (DATAVIEW)
    this.view.setUint32(offset, k, this.littleEndian);
    //? else
    //? WRITE_UINT32_ARRAY('k');
    offset += 4;
    utfx.encodeUTF16toUTF8(stringSource(str), function(b) ***REMOVED***
        //? if (DATAVIEW)
        this.view.setUint8(offset++, b);
        //? else
        this.view[offset++] = b;
    ***REMOVED***.bind(this));
    if (offset !== start + 4 + k)
        throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
    //? ***REMOVED***
    if (relative) ***REMOVED***
        this.offset = offset;
        return this;
    ***REMOVED***
    return offset - start;
***REMOVED***;

/**
 * Reads a length as uint32 prefixed UTF8 encoded string.
 * @param ***REMOVED***number=***REMOVED*** offset Offset to read from. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  read if omitted.
 * @returns ***REMOVED***string|!***REMOVED***string: string, length: number***REMOVED******REMOVED*** The string read if offset is omitted, else the string
 *  read and the actual number of bytes read.
 * @expose
 * @see ByteBuffer#readVarint32
 */
ByteBufferPrototype.readIString = function(offset) ***REMOVED***
    //? RELATIVE();
    if (!this.noAssert) ***REMOVED***
        //? ASSERT_OFFSET(4);
    ***REMOVED***
    var start = offset;
    var len = this.readUint32(offset);
    var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
    offset += str['length'];
    if (relative) ***REMOVED***
        this.offset = offset;
        return str['string'];
    ***REMOVED*** else ***REMOVED***
        return ***REMOVED***
            'string': str['string'],
            'length': offset - start
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;

//? ***REMOVED***