//? if (UTF8STRING && UTF8) ***REMOVED***
// types/strings/utf8string

/**
 * Metrics representing number of UTF8 characters. Evaluates to `c`.
 * @type ***REMOVED***string***REMOVED***
 * @const
 * @expose
 */
ByteBuffer.METRICS_CHARS = 'c';

/**
 * Metrics representing number of bytes. Evaluates to `b`.
 * @type ***REMOVED***string***REMOVED***
 * @const
 * @expose
 */
ByteBuffer.METRICS_BYTES = 'b';

/**
 * Writes an UTF8 encoded string.
 * @param ***REMOVED***string***REMOVED*** str String to write
 * @param ***REMOVED***number=***REMOVED*** offset Offset to write to. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** if omitted.
 * @returns ***REMOVED***!ByteBuffer|number***REMOVED*** this if offset is omitted, else the actual number of bytes written.
 * @expose
 */
ByteBufferPrototype.writeUTF8String = function(str, offset) ***REMOVED***
    //? RELATIVE();
    if (!this.noAssert) ***REMOVED***
        //? ASSERT_OFFSET();
    ***REMOVED***
    var k;
    //? if (NODE) ***REMOVED***
    k = Buffer.byteLength(str, "utf8");
    //? ENSURE_CAPACITY('k');
    offset += this.buffer.write(str, offset, k, "utf8");
    if (relative) ***REMOVED***
        this.offset = offset;
        return this;
    ***REMOVED***
    return k;
    //? ***REMOVED*** else ***REMOVED***
    var start = offset;
    k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
    //? ENSURE_CAPACITY('k');
    utfx.encodeUTF16toUTF8(stringSource(str), function(b) ***REMOVED***
        //? if (DATAVIEW)
        this.view.setUint8(offset++, b);
        //? else
        this.view[offset++] = b;
    ***REMOVED***.bind(this));
    if (relative) ***REMOVED***
        this.offset = offset;
        return this;
    ***REMOVED***
    return offset - start;
    //? ***REMOVED***
***REMOVED***;
//? if (ALIASES) ***REMOVED***

/**
 * Writes an UTF8 encoded string. This is an alias of ***REMOVED***@link ByteBuffer#writeUTF8String***REMOVED***.
 * @function
 * @param ***REMOVED***string***REMOVED*** str String to write
 * @param ***REMOVED***number=***REMOVED*** offset Offset to write to. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** if omitted.
 * @returns ***REMOVED***!ByteBuffer|number***REMOVED*** this if offset is omitted, else the actual number of bytes written.
 * @expose
 */
ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;
//? ***REMOVED***

/**
 * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
 *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
 * @param ***REMOVED***string***REMOVED*** str String to calculate
 * @returns ***REMOVED***number***REMOVED*** Number of UTF8 characters
 * @expose
 */
ByteBuffer.calculateUTF8Chars = function(str) ***REMOVED***
    return utfx.calculateUTF16asUTF8(stringSource(str))[0];
***REMOVED***;

/**
 * Calculates the number of UTF8 bytes of a string.
 * @param ***REMOVED***string***REMOVED*** str String to calculate
 * @returns ***REMOVED***number***REMOVED*** Number of UTF8 bytes
 * @expose
 */
ByteBuffer.calculateUTF8Bytes = function(str) ***REMOVED***
    //? if (NODE) ***REMOVED***
    if (typeof str !== 'string')
        throw TypeError("Illegal argument: "+(typeof str));
    return Buffer.byteLength(str, "utf8");
    //? ***REMOVED*** else
    return utfx.calculateUTF16asUTF8(stringSource(str))[1];
***REMOVED***;
//? if (ALIASES) ***REMOVED***

/**
 * Calculates the number of UTF8 bytes of a string. This is an alias of ***REMOVED***@link ByteBuffer.calculateUTF8Bytes***REMOVED***.
 * @function
 * @param ***REMOVED***string***REMOVED*** str String to calculate
 * @returns ***REMOVED***number***REMOVED*** Number of UTF8 bytes
 * @expose
 */
ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;
//? ***REMOVED***

/**
 * Reads an UTF8 encoded string.
 * @param ***REMOVED***number***REMOVED*** length Number of characters or bytes to read.
 * @param ***REMOVED***string=***REMOVED*** metrics Metrics specifying what `length` is meant to count. Defaults to
 *  ***REMOVED***@link ByteBuffer.METRICS_CHARS***REMOVED***.
 * @param ***REMOVED***number=***REMOVED*** offset Offset to read from. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  read if omitted.
 * @returns ***REMOVED***string|!***REMOVED***string: string, length: number***REMOVED******REMOVED*** The string read if offset is omitted, else the string
 *  read and the actual number of bytes read.
 * @expose
 */
ByteBufferPrototype.readUTF8String = function(length, metrics, offset) ***REMOVED***
    if (typeof metrics === 'number') ***REMOVED***
        offset = metrics;
        metrics = undefined;
    ***REMOVED***
    //? RELATIVE();
    if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
    if (!this.noAssert) ***REMOVED***
        //? ASSERT_INTEGER('length');
        //? ASSERT_OFFSET();
    ***REMOVED***
    var i = 0,
        start = offset,
        //? if (NODE)
        temp,
        sd;
    if (metrics === ByteBuffer.METRICS_CHARS) ***REMOVED*** // The same for node and the browser
        sd = stringDestination();
        utfx.decodeUTF8(function() ***REMOVED***
            //? if (NODE)
            return i < length && offset < this.limit ? this.buffer[offset++] : null;
            //? else if (DATAVIEW)
            return i < length && offset < this.limit ? this.view.getUint8(offset++) : null;
            //? else
            return i < length && offset < this.limit ? this.view[offset++] : null;
        ***REMOVED***.bind(this), function(cp) ***REMOVED***
            ++i; utfx.UTF8toUTF16(cp, sd);
        ***REMOVED***);
        if (i !== length)
            throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
        if (relative) ***REMOVED***
            this.offset = offset;
            return sd();
        ***REMOVED*** else ***REMOVED***
            return ***REMOVED***
                "string": sd(),
                "length": offset - start
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED*** else if (metrics === ByteBuffer.METRICS_BYTES) ***REMOVED***
        if (!this.noAssert) ***REMOVED***
            //? ASSERT_OFFSET('length');
        ***REMOVED***
        //? if (NODE) ***REMOVED***
        temp = this.buffer.toString("utf8", offset, offset+length);
        if (relative) ***REMOVED***
            this.offset += length;
            return temp;
        ***REMOVED*** else ***REMOVED***
            return ***REMOVED***
                'string': temp,
                'length': length
            ***REMOVED***;
        ***REMOVED***
        //? ***REMOVED*** else ***REMOVED***
        var k = offset + length;
        utfx.decodeUTF8toUTF16(function() ***REMOVED***
            //? if (DATAVIEW)
            return offset < k ? this.view.getUint8(offset++) : null;
            //? else
            return offset < k ? this.view[offset++] : null;
        ***REMOVED***.bind(this), sd = stringDestination(), this.noAssert);
        if (offset !== k)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
        if (relative) ***REMOVED***
            this.offset = offset;
            return sd();
        ***REMOVED*** else ***REMOVED***
            return ***REMOVED***
                'string': sd(),
                'length': offset - start
            ***REMOVED***;
        ***REMOVED***
        //? ***REMOVED***
    ***REMOVED*** else
        throw TypeError("Unsupported metrics: "+metrics);
***REMOVED***;
//? if (ALIASES) ***REMOVED***

/**
 * Reads an UTF8 encoded string. This is an alias of ***REMOVED***@link ByteBuffer#readUTF8String***REMOVED***.
 * @function
 * @param ***REMOVED***number***REMOVED*** length Number of characters or bytes to read
 * @param ***REMOVED***number=***REMOVED*** metrics Metrics specifying what `n` is meant to count. Defaults to
 *  ***REMOVED***@link ByteBuffer.METRICS_CHARS***REMOVED***.
 * @param ***REMOVED***number=***REMOVED*** offset Offset to read from. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  read if omitted.
 * @returns ***REMOVED***string|!***REMOVED***string: string, length: number***REMOVED******REMOVED*** The string read if offset is omitted, else the string
 *  read and the actual number of bytes read.
 * @expose
 */
ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;
//? ***REMOVED***

//? ***REMOVED***