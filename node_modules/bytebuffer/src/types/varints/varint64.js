//? if (VARINT64) ***REMOVED***
// types/varints/varint64

if (Long) ***REMOVED***
    
    /**
     * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
     * @type ***REMOVED***number***REMOVED***
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT64_BYTES = 10;
    
    /**
     * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
     * @param ***REMOVED***number|!Long***REMOVED*** value Value to encode
     * @returns ***REMOVED***number***REMOVED*** Number of bytes required. Capped to ***REMOVED***@link ByteBuffer.MAX_VARINT64_BYTES***REMOVED***
     * @expose
     */
    ByteBuffer.calculateVarint64 = function(value) ***REMOVED***
        //? LONG('value');
        // ref: src/google/protobuf/io/coded_stream.cc
        var part0 = value.toInt() >>> 0,
            part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
            part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
        if (part2 == 0) ***REMOVED***
            if (part1 == 0) ***REMOVED***
                if (part0 < 1 << 14)
                    return part0 < 1 << 7 ? 1 : 2;
                else
                    return part0 < 1 << 21 ? 3 : 4;
            ***REMOVED*** else ***REMOVED***
                if (part1 < 1 << 14)
                    return part1 < 1 << 7 ? 5 : 6;
                else
                    return part1 < 1 << 21 ? 7 : 8;
            ***REMOVED***
        ***REMOVED*** else
            return part2 < 1 << 7 ? 9 : 10;
    ***REMOVED***;
    
    /**
     * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
     * @param ***REMOVED***number|!Long***REMOVED*** value Signed long
     * @returns ***REMOVED***!Long***REMOVED*** Unsigned zigzag encoded long
     * @expose
     */
    ByteBuffer.zigZagEncode64 = function(value) ***REMOVED***
        //? LONG('value', false);
        // ref: src/google/protobuf/wire_format_lite.h
        return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
    ***REMOVED***;
    
    /**
     * Decodes a zigzag encoded signed 64bit integer.
     * @param ***REMOVED***!Long|number***REMOVED*** value Unsigned zigzag encoded long or JavaScript number
     * @returns ***REMOVED***!Long***REMOVED*** Signed long
     * @expose
     */
    ByteBuffer.zigZagDecode64 = function(value) ***REMOVED***
        //? LONG('value', false);
        // ref: src/google/protobuf/wire_format_lite.h
        return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
    ***REMOVED***;
    
    /**
     * Writes a 64bit base 128 variable-length integer.
     * @param ***REMOVED***number|Long***REMOVED*** value Value to write
     * @param ***REMOVED***number=***REMOVED*** offset Offset to write to. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
     *  written if omitted.
     * @returns ***REMOVED***!ByteBuffer|number***REMOVED*** `this` if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeVarint64 = function(value, offset) ***REMOVED***
        //? RELATIVE();
        if (!this.noAssert) ***REMOVED***
            //? ASSERT_LONG('value');
            //? ASSERT_OFFSET();
        ***REMOVED***
        //? LONG('value', false);
        var size = ByteBuffer.calculateVarint64(value),
            part0 = value.toInt() >>> 0,
            part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
            part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
        //? ENSURE_CAPACITY('size');
        switch (size) ***REMOVED***
        //? if (NODE || !DATAVIEW) ***REMOVED*** var dst = NODE ? 'this.buffer' : 'this.view';
            case 10: /*?= dst */[offset+9] = (part2 >>>  7) & 0x01;
            case 9 : /*?= dst */[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
            case 8 : /*?= dst */[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
            case 7 : /*?= dst */[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
            case 6 : /*?= dst */[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
            case 5 : /*?= dst */[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
            case 4 : /*?= dst */[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
            case 3 : /*?= dst */[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
            case 2 : /*?= dst */[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
            case 1 : /*?= dst */[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
        //? ***REMOVED*** else ***REMOVED***
            case 10: this.view.setUint8(offset+9, (part2 >>>  7) & 0x01);
            case 9 : this.view.setUint8(offset+8, size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F);
            case 8 : this.view.setUint8(offset+7, size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F);
            case 7 : this.view.setUint8(offset+6, size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F);
            case 6 : this.view.setUint8(offset+5, size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F);
            case 5 : this.view.setUint8(offset+4, size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F);
            case 4 : this.view.setUint8(offset+3, size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F);
            case 3 : this.view.setUint8(offset+2, size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F);
            case 2 : this.view.setUint8(offset+1, size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F);
            case 1 : this.view.setUint8(offset  , size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F);
        //? ***REMOVED***
        ***REMOVED***
        if (relative) ***REMOVED***
            this.offset += size;
            return this;
        ***REMOVED*** else ***REMOVED***
            return size;
        ***REMOVED***
    ***REMOVED***;

    /**
     * Writes a zig-zag encoded 64bit base 128 variable-length integer.
     * @param ***REMOVED***number|Long***REMOVED*** value Value to write
     * @param ***REMOVED***number=***REMOVED*** offset Offset to write to. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
     *  written if omitted.
     * @returns ***REMOVED***!ByteBuffer|number***REMOVED*** `this` if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) ***REMOVED***
        return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
    ***REMOVED***;
    
    /**
     * Reads a 64bit base 128 variable-length integer. Requires Long.js.
     * @param ***REMOVED***number=***REMOVED*** offset Offset to read from. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
     *  read if omitted.
     * @returns ***REMOVED***!Long|!***REMOVED***value: Long, length: number***REMOVED******REMOVED*** The value read if offset is omitted, else the value read and
     *  the actual number of bytes read.
     * @throws ***REMOVED***Error***REMOVED*** If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint64 = function(offset) ***REMOVED***
        //? RELATIVE(); 
        if (!this.noAssert) ***REMOVED***
            //? ASSERT_OFFSET(1);
        ***REMOVED***
        // ref: src/google/protobuf/io/coded_stream.cc
        var start = offset,
            part0 = 0,
            part1 = 0,
            part2 = 0,
            b  = 0;
    //? if (NODE || !DATAVIEW) ***REMOVED*** var dst = NODE ? 'this.buffer' : 'this.view';
        b = /*?= dst */[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) ***REMOVED***
        b = /*?= dst */[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) ***REMOVED***
        b = /*?= dst */[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) ***REMOVED***
        b = /*?= dst */[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) ***REMOVED***
        b = /*?= dst */[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) ***REMOVED***
        b = /*?= dst */[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) ***REMOVED***
        b = /*?= dst */[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) ***REMOVED***
        b = /*?= dst */[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) ***REMOVED***
        b = /*?= dst */[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) ***REMOVED***
        b = /*?= dst */[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) ***REMOVED***
        throw Error("Buffer overrun"); ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
    //? ***REMOVED*** else ***REMOVED*** // Asserts on its own
        b = this.view.getUint8(offset++); part0  = (b & 0x7F)      ; if (b & 0x80) ***REMOVED***
        b = this.view.getUint8(offset++); part0 |= (b & 0x7F) <<  7; if (b & 0x80) ***REMOVED***
        b = this.view.getUint8(offset++); part0 |= (b & 0x7F) << 14; if (b & 0x80) ***REMOVED***
        b = this.view.getUint8(offset++); part0 |= (b & 0x7F) << 21; if (b & 0x80) ***REMOVED***
        b = this.view.getUint8(offset++); part1  = (b & 0x7F)      ; if (b & 0x80) ***REMOVED***
        b = this.view.getUint8(offset++); part1 |= (b & 0x7F) <<  7; if (b & 0x80) ***REMOVED***
        b = this.view.getUint8(offset++); part1 |= (b & 0x7F) << 14; if (b & 0x80) ***REMOVED***
        b = this.view.getUint8(offset++); part1 |= (b & 0x7F) << 21; if (b & 0x80) ***REMOVED***
        b = this.view.getUint8(offset++); part2  = (b & 0x7F)      ; if (b & 0x80) ***REMOVED***
        b = this.view.getUint8(offset++); part2 |= (b & 0x7F) <<  7; if (b & 0x80) ***REMOVED***
        throw Error("Buffer overrun"); ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
    //? ***REMOVED***
        var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
        if (relative) ***REMOVED***
            this.offset = offset;
            return value;
        ***REMOVED*** else ***REMOVED***
            return ***REMOVED***
                'value': value,
                'length': offset-start
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***;

    /**
     * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
     * @param ***REMOVED***number=***REMOVED*** offset Offset to read from. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
     *  read if omitted.
     * @returns ***REMOVED***!Long|!***REMOVED***value: Long, length: number***REMOVED******REMOVED*** The value read if offset is omitted, else the value read and
     *  the actual number of bytes read.
     * @throws ***REMOVED***Error***REMOVED*** If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint64ZigZag = function(offset) ***REMOVED***
        var val = this.readVarint64(offset);
        if (val && val['value'] instanceof Long)
            val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
        else
            val = ByteBuffer.zigZagDecode64(val);
        return val;
    ***REMOVED***;
    
***REMOVED*** // Long

//? ***REMOVED***