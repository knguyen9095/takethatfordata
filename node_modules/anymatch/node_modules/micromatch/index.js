'use strict';

/**
 * Module dependencies
 */

var util = require('util');
var braces = require('braces');
var toRegex = require('to-regex');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var cache = require('./lib/cache');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * The main function takes a list of strings and one or more
 * glob patterns to use for matching.
 *
 * ```js
 * var mm = require('micromatch');
 * mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param ***REMOVED***Array***REMOVED*** `list` A list of strings to match
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Array***REMOVED*** Returns an array of matches
 * @summary false
 * @api public
 */

function micromatch(list, patterns, options) ***REMOVED***
  patterns = utils.arrayify(patterns);
  list = utils.arrayify(list);

  var len = patterns.length;
  if (list.length === 0 || len === 0) ***REMOVED***
    return [];
  ***REMOVED***

  if (len === 1) ***REMOVED***
    return micromatch.match(list, patterns[0], options);
  ***REMOVED***

  var omit = [];
  var keep = [];
  var idx = -1;

  while (++idx < len) ***REMOVED***
    var pattern = patterns[idx];

    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) ***REMOVED***
      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));
    ***REMOVED*** else ***REMOVED***
      keep.push.apply(keep, micromatch.match(list, pattern, options));
    ***REMOVED***
  ***REMOVED***

  var matches = utils.diff(keep, omit);
  if (!options || options.nodupes !== false) ***REMOVED***
    return utils.unique(matches);
  ***REMOVED***

  return matches;
***REMOVED***

/**
 * Similar to the main function, but `pattern` must be a string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.match(list, pattern[, options]);
 *
 * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
 * //=> ['a.a', 'a.aa']
 * ```
 * @param ***REMOVED***Array***REMOVED*** `list` Array of strings to match
 * @param ***REMOVED***String***REMOVED*** `pattern` Glob pattern to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Array***REMOVED*** Returns an array of matches
 * @api public
 */

micromatch.match = function(list, pattern, options) ***REMOVED***
  if (Array.isArray(pattern)) ***REMOVED***
    throw new TypeError('expected pattern to be a string');
  ***REMOVED***

  var unixify = utils.unixify(options);
  var isMatch = memoize('match', pattern, options, micromatch.matcher);
  var matches = [];

  list = utils.arrayify(list);
  var len = list.length;
  var idx = -1;

  while (++idx < len) ***REMOVED***
    var ele = list[idx];
    if (ele === pattern || isMatch(ele)) ***REMOVED***
      matches.push(utils.value(ele, unixify, options));
    ***REMOVED***
  ***REMOVED***

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') ***REMOVED***
    return utils.unique(matches);
  ***REMOVED***

  if (matches.length === 0) ***REMOVED***
    if (options.failglob === true) ***REMOVED***
      throw new Error('no matches found for "' + pattern + '"');
    ***REMOVED***
    if (options.nonull === true || options.nullglob === true) ***REMOVED***
      return [options.unescape ? utils.unescape(pattern) : pattern];
    ***REMOVED***
  ***REMOVED***

  // if `opts.ignore` was defined, diff ignored list
  if (options.ignore) ***REMOVED***
    matches = micromatch.not(matches, options.ignore, options);
  ***REMOVED***

  return options.nodupes !== false ? utils.unique(matches) : matches;
***REMOVED***;

/**
 * Returns true if the specified `string` matches the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.isMatch(string, pattern[, options]);
 *
 * console.log(mm.isMatch('a.a', '*.a'));
 * //=> true
 * console.log(mm.isMatch('a.b', '*.a'));
 * //=> false
 * ```
 * @param ***REMOVED***String***REMOVED*** `string` String to match
 * @param ***REMOVED***String***REMOVED*** `pattern` Glob pattern to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if the string matches the glob pattern.
 * @api public
 */

micromatch.isMatch = function(str, pattern, options) ***REMOVED***
  if (typeof str !== 'string') ***REMOVED***
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  ***REMOVED***

  if (isEmptyString(str) || isEmptyString(pattern)) ***REMOVED***
    return false;
  ***REMOVED***

  var equals = utils.equalsPattern(options);
  if (equals(str)) ***REMOVED***
    return true;
  ***REMOVED***

  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);
  return isMatch(str);
***REMOVED***;

/**
 * Returns true if some of the strings in the given `list` match any of the
 * given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  ***REMOVED***String|Array***REMOVED*** `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if any patterns match `str`
 * @api public
 */

micromatch.some = function(list, patterns, options) ***REMOVED***
  if (typeof list === 'string') ***REMOVED***
    list = [list];
  ***REMOVED***
  for (var i = 0; i < list.length; i++) ***REMOVED***
    if (micromatch(list[i], patterns, options).length === 1) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  ***REMOVED***String|Array***REMOVED*** `list` The string or array of strings to test.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if any patterns match `str`
 * @api public
 */

micromatch.every = function(list, patterns, options) ***REMOVED***
  if (typeof list === 'string') ***REMOVED***
    list = [list];
  ***REMOVED***
  for (var i = 0; i < list.length; i++) ***REMOVED***
    if (micromatch(list[i], patterns, options).length !== 1) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***
  return true;
***REMOVED***;

/**
 * Returns true if **any** of the given glob `patterns`
 * match the specified `string`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.any(string, patterns[, options]);
 *
 * console.log(mm.any('a.a', ['b.*', '*.a']));
 * //=> true
 * console.log(mm.any('a.a', 'b.*'));
 * //=> false
 * ```
 * @param  ***REMOVED***String|Array***REMOVED*** `str` The string to test.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if any patterns match `str`
 * @api public
 */

micromatch.any = function(str, patterns, options) ***REMOVED***
  if (typeof str !== 'string') ***REMOVED***
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  ***REMOVED***

  if (isEmptyString(str) || isEmptyString(patterns)) ***REMOVED***
    return false;
  ***REMOVED***

  if (typeof patterns === 'string') ***REMOVED***
    patterns = [patterns];
  ***REMOVED***

  for (var i = 0; i < patterns.length; i++) ***REMOVED***
    if (micromatch.isMatch(str, patterns[i], options)) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param  ***REMOVED***String|Array***REMOVED*** `str` The string to test.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = function(str, patterns, options) ***REMOVED***
  if (typeof str !== 'string') ***REMOVED***
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  ***REMOVED***
  if (typeof patterns === 'string') ***REMOVED***
    patterns = [patterns];
  ***REMOVED***
  for (var i = 0; i < patterns.length; i++) ***REMOVED***
    if (!micromatch.isMatch(str, patterns[i], options)) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***
  return true;
***REMOVED***;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param ***REMOVED***Array***REMOVED*** `list` Array of strings to match.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob pattern to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Array***REMOVED*** Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = function(list, patterns, options) ***REMOVED***
  var opts = extend(***REMOVED******REMOVED***, options);
  var ignore = opts.ignore;
  delete opts.ignore;

  var unixify = utils.unixify(opts);
  list = utils.arrayify(list).map(unixify);

  var matches = utils.diff(list, micromatch(list, patterns, opts));
  if (ignore) ***REMOVED***
    matches = utils.diff(matches, micromatch(list, ignore));
  ***REMOVED***

  return opts.nodupes !== false ? utils.unique(matches) : matches;
***REMOVED***;

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param ***REMOVED***String***REMOVED*** `str` The string to match.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` Glob pattern to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if the patter matches any part of `str`.
 * @api public
 */

micromatch.contains = function(str, patterns, options) ***REMOVED***
  if (typeof str !== 'string') ***REMOVED***
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  ***REMOVED***

  if (typeof patterns === 'string') ***REMOVED***
    if (isEmptyString(str) || isEmptyString(patterns)) ***REMOVED***
      return false;
    ***REMOVED***

    var equals = utils.equalsPattern(patterns, options);
    if (equals(str)) ***REMOVED***
      return true;
    ***REMOVED***
    var contains = utils.containsPattern(patterns, options);
    if (contains(str)) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***

  var opts = extend(***REMOVED******REMOVED***, options, ***REMOVED***contains: true***REMOVED***);
  return micromatch.any(str, patterns, opts);
***REMOVED***;

/**
 * Returns true if the given pattern and options should enable
 * the `matchBase` option.
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */

micromatch.matchBase = function(pattern, options) ***REMOVED***
  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;
  return options.basename === true || options.matchBase === true;
***REMOVED***;

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matchKeys(object, patterns[, options]);
 *
 * var obj = ***REMOVED*** aa: 'a', ab: 'b', ac: 'c' ***REMOVED***;
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> ***REMOVED*** ab: 'b' ***REMOVED***
 * ```
 * @param ***REMOVED***Object***REMOVED*** `object` The object with keys to filter.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Object***REMOVED*** Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = function(obj, patterns, options) ***REMOVED***
  if (!utils.isObject(obj)) ***REMOVED***
    throw new TypeError('expected the first argument to be an object');
  ***REMOVED***
  var keys = micromatch(Object.keys(obj), patterns, options);
  return utils.pick(obj, keys);
***REMOVED***;

/**
 * Returns a memoized matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matcher(pattern[, options]);
 *
 * var isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Glob pattern
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed.
 * @return ***REMOVED***Function***REMOVED*** Returns a matcher function.
 * @api public
 */

micromatch.matcher = function matcher(pattern, options) ***REMOVED***
  if (Array.isArray(pattern)) ***REMOVED***
    return compose(pattern, options, matcher);
  ***REMOVED***

  // if pattern is a regex
  if (pattern instanceof RegExp) ***REMOVED***
    return test(pattern);
  ***REMOVED***

  // if pattern is invalid
  if (!utils.isString(pattern)) ***REMOVED***
    throw new TypeError('expected pattern to be an array, string or regex');
  ***REMOVED***

  // if pattern is a non-glob string
  if (!utils.hasSpecialChars(pattern)) ***REMOVED***
    if (options && options.nocase === true) ***REMOVED***
      pattern = pattern.toLowerCase();
    ***REMOVED***
    return utils.matchPath(pattern, options);
  ***REMOVED***

  // if pattern is a glob string
  var re = micromatch.makeRe(pattern, options);

  // if `options.matchBase` or `options.basename` is defined
  if (micromatch.matchBase(pattern, options)) ***REMOVED***
    return utils.matchBasename(re, options);
  ***REMOVED***

  function test(regex) ***REMOVED***
    var equals = utils.equalsPattern(options);
    var unixify = utils.unixify(options);

    return function(str) ***REMOVED***
      if (equals(str)) ***REMOVED***
        return true;
      ***REMOVED***

      if (regex.test(unixify(str))) ***REMOVED***
        return true;
      ***REMOVED***
      return false;
    ***REMOVED***;
  ***REMOVED***

  var fn = test(re);
  Object.defineProperty(fn, 'result', ***REMOVED***
    configurable: true,
    enumerable: false,
    value: re.result
  ***REMOVED***);
  return fn;
***REMOVED***;

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Glob pattern to use for matching.
 * @param ***REMOVED***String***REMOVED*** `string` String to match
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = function(pattern, str, options) ***REMOVED***
  var re = micromatch.makeRe(pattern, extend(***REMOVED***capture: true***REMOVED***, options));
  var unixify = utils.unixify(options);

  function match() ***REMOVED***
    return function(string) ***REMOVED***
      var match = re.exec(unixify(string));
      if (!match) ***REMOVED***
        return null;
      ***REMOVED***

      return match.slice(1);
    ***REMOVED***;
  ***REMOVED***

  var capture = memoize('capture', pattern, options, match);
  return capture(str);
***REMOVED***;

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` A glob pattern to convert to regex.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed.
 * @return ***REMOVED***RegExp***REMOVED*** Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = function(pattern, options) ***REMOVED***
  if (typeof pattern !== 'string') ***REMOVED***
    throw new TypeError('expected pattern to be a string');
  ***REMOVED***

  if (pattern.length > MAX_LENGTH) ***REMOVED***
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  ***REMOVED***

  function makeRe() ***REMOVED***
    var result = micromatch.create(pattern, options);
    var ast_array = [];
    var output = result.map(function(obj) ***REMOVED***
      obj.ast.state = obj.state;
      ast_array.push(obj.ast);
      return obj.output;
    ***REMOVED***);

    var regex = toRegex(output.join('|'), options);
    Object.defineProperty(regex, 'result', ***REMOVED***
      configurable: true,
      enumerable: false,
      value: ast_array
    ***REMOVED***);
    return regex;
  ***REMOVED***

  return memoize('makeRe', pattern, options, makeRe);
***REMOVED***;

/**
 * Expand the given brace `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * console.log(mm.braces('foo/***REMOVED***a,b***REMOVED***/bar'));
 * //=> ['foo/(a|b)/bar']
 *
 * console.log(mm.braces('foo/***REMOVED***a,b***REMOVED***/bar', ***REMOVED***expand: true***REMOVED***));
 * //=> ['foo/(a|b)/bar']
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` String with brace pattern to expand.
 * @param ***REMOVED***Object***REMOVED*** `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return ***REMOVED***Array***REMOVED***
 * @api public
 */

micromatch.braces = function(pattern, options) ***REMOVED***
  if (typeof pattern !== 'string') ***REMOVED***
    throw new TypeError('expected a string');
  ***REMOVED***

  function expand() ***REMOVED***
    if (options && options.nobrace === true) return [pattern];
    if (!/\***REMOVED***.*\***REMOVED***/.test(pattern)) return [pattern];
    // if (/[!@*?+]\***REMOVED***/.test(pattern)) ***REMOVED***
    //   options = utils.extend(***REMOVED******REMOVED***, options, ***REMOVED***expand: true***REMOVED***);
    // ***REMOVED***
    return braces(pattern, options);
  ***REMOVED***

  return memoize('braces', pattern, options, expand);
***REMOVED***;

/**
 * Proxy to the [micromatch.braces](#method), for parity with
 * minimatch.
 */

micromatch.braceExpand = function(pattern, options) ***REMOVED***
  var opts = extend(***REMOVED******REMOVED***, options, ***REMOVED***expand: true***REMOVED***);
  return micromatch.braces(pattern, opts);
***REMOVED***;

/**
 * Parses the given glob `pattern` and returns an array of abstract syntax
 * trees (ASTs), with the compiled `output` and optional source `map` on
 * each AST.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.create(pattern[, options]);
 *
 * console.log(mm.create('abc/*.js'));
 * // [***REMOVED*** options: ***REMOVED*** source: 'string', sourcemap: true ***REMOVED***,
 * //   state: ***REMOVED******REMOVED***,
 * //   compilers:
 * //    ***REMOVED*** ... ***REMOVED***,
 * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
 * //   ast:
 * //    ***REMOVED*** type: 'root',
 * //      errors: [],
 * //      nodes:
 * //       [ ... ],
 * //      dot: false,
 * //      input: 'abc/*.js' ***REMOVED***,
 * //   parsingErrors: [],
 * //   map:
 * //    ***REMOVED*** version: 3,
 * //      sources: [ 'string' ],
 * //      names: [],
 * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
 * //      sourcesContent: [ 'abc/*.js' ] ***REMOVED***,
 * //   position: ***REMOVED*** line: 1, column: 28 ***REMOVED***,
 * //   content: ***REMOVED******REMOVED***,
 * //   files: ***REMOVED******REMOVED***,
 * //   idx: 6 ***REMOVED***]
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Glob pattern to parse and compile.
 * @param ***REMOVED***Object***REMOVED*** `options` Any [options](#options) to change how parsing and compiling is performed.
 * @return ***REMOVED***Object***REMOVED*** Returns an object with the parsed AST, compiled string and optional source map.
 * @api public
 */

micromatch.create = function(pattern, options) ***REMOVED***
  return memoize('create', pattern, options, function() ***REMOVED***
    function create(str, opts) ***REMOVED***
      return micromatch.compile(micromatch.parse(str, opts), opts);
    ***REMOVED***

    pattern = micromatch.braces(pattern, options);
    var len = pattern.length;
    var idx = -1;
    var res = [];

    while (++idx < len) ***REMOVED***
      res.push(create(pattern[idx], options));
    ***REMOVED***
    return res;
  ***REMOVED***);
***REMOVED***;

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.parse(pattern[, options]);
 *
 * var ast = mm.parse('a/***REMOVED***b,c***REMOVED***/d');
 * console.log(ast);
 * // ***REMOVED*** type: 'root',
 * //   errors: [],
 * //   input: 'a/***REMOVED***b,c***REMOVED***/d',
 * //   nodes:
 * //    [ ***REMOVED*** type: 'bos', val: '' ***REMOVED***,
 * //      ***REMOVED*** type: 'text', val: 'a/' ***REMOVED***,
 * //      ***REMOVED*** type: 'brace',
 * //        nodes:
 * //         [ ***REMOVED*** type: 'brace.open', val: '***REMOVED***' ***REMOVED***,
 * //           ***REMOVED*** type: 'text', val: 'b,c' ***REMOVED***,
 * //           ***REMOVED*** type: 'brace.close', val: '***REMOVED***' ***REMOVED*** ] ***REMOVED***,
 * //      ***REMOVED*** type: 'text', val: '/d' ***REMOVED***,
 * //      ***REMOVED*** type: 'eos', val: '' ***REMOVED*** ] ***REMOVED***
 * ```
 * @param ***REMOVED***String***REMOVED*** `str`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED*** Returns an AST
 * @api public
 */

micromatch.parse = function(pattern, options) ***REMOVED***
  if (typeof pattern !== 'string') ***REMOVED***
    throw new TypeError('expected a string');
  ***REMOVED***

  function parse() ***REMOVED***
    var snapdragon = utils.instantiate(null, options);
    parsers(snapdragon, options);

    var ast = snapdragon.parse(pattern, options);
    utils.define(ast, 'snapdragon', snapdragon);
    ast.input = pattern;
    return ast;
  ***REMOVED***

  return memoize('parse', pattern, options, parse);
***REMOVED***;

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.compile(ast[, options]);
 *
 * var ast = mm.parse('a/***REMOVED***b,c***REMOVED***/d');
 * console.log(mm.compile(ast));
 * // ***REMOVED*** options: ***REMOVED*** source: 'string' ***REMOVED***,
 * //   state: ***REMOVED******REMOVED***,
 * //   compilers:
 * //    ***REMOVED*** eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] ***REMOVED***,
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    ***REMOVED*** ... ***REMOVED***,
 * //   parsingErrors: [] ***REMOVED***
 * ```
 * @param ***REMOVED***Object|String***REMOVED*** `ast`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED*** Returns an object that has an `output` property with the compiled string.
 * @api public
 */

micromatch.compile = function(ast, options) ***REMOVED***
  if (typeof ast === 'string') ***REMOVED***
    ast = micromatch.parse(ast, options);
  ***REMOVED***

  return memoize('compile', ast.input, options, function() ***REMOVED***
    var snapdragon = utils.instantiate(ast, options);
    compilers(snapdragon, options);
    return snapdragon.compile(ast, options);
  ***REMOVED***);
***REMOVED***;

/**
 * Clear the regex cache.
 *
 * ```js
 * mm.clearCache();
 * ```
 * @api public
 */

micromatch.clearCache = function() ***REMOVED***
  micromatch.cache.caches = ***REMOVED******REMOVED***;
***REMOVED***;

/**
 * Returns true if the given value is effectively an empty string
 */

function isEmptyString(val) ***REMOVED***
  return String(val) === '' || String(val) === './';
***REMOVED***

/**
 * Compose a matcher function with the given patterns.
 * This allows matcher functions to be compiled once and
 * called multiple times.
 */

function compose(patterns, options, matcher) ***REMOVED***
  var matchers;

  return memoize('compose', String(patterns), options, function() ***REMOVED***
    return function(file) ***REMOVED***
      // delay composition until it's invoked the first time,
      // after that it won't be called again
      if (!matchers) ***REMOVED***
        matchers = [];
        for (var i = 0; i < patterns.length; i++) ***REMOVED***
          matchers.push(matcher(patterns[i], options));
        ***REMOVED***
      ***REMOVED***

      var len = matchers.length;
      while (len--) ***REMOVED***
        if (matchers[len](file) === true) ***REMOVED***
          return true;
        ***REMOVED***
      ***REMOVED***
      return false;
    ***REMOVED***;
  ***REMOVED***);
***REMOVED***

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the `type` (usually method name), the `pattern`, and
 * user-defined options.
 */

function memoize(type, pattern, options, fn) ***REMOVED***
  var key = utils.createKey(type + '=' + pattern, options);

  if (options && options.cache === false) ***REMOVED***
    return fn(pattern, options);
  ***REMOVED***

  if (cache.has(type, key)) ***REMOVED***
    return cache.get(type, key);
  ***REMOVED***

  var val = fn(pattern, options);
  cache.set(type, key, val);
  return val;
***REMOVED***

/**
 * Expose compiler, parser and cache on `micromatch`
 */

micromatch.compilers = compilers;
micromatch.parsers = parsers;
micromatch.caches = cache.caches;

/**
 * Expose `micromatch`
 * @type ***REMOVED***Function***REMOVED***
 */

module.exports = micromatch;
