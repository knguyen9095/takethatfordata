'use strict';

var regexNot = require('regex-not');
var toRegex = require('to-regex');
var isOdd = require('is-odd');

/**
 * Characters to use in negation regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var cached;
var NOT_REGEX = '[!*+?$^"\'.\\\\/\\[]+';
var not = createTextRegex(NOT_REGEX);

/**
 * Nanomatch parsers
 */

module.exports = function(nanomatch, options) ***REMOVED***
  var parser = nanomatch.parser;
  var opts = parser.options;

  parser.state = ***REMOVED***
    slashes: 0,
    paths: []
  ***REMOVED***;

  parser.ast.state = parser.state;
  parser

    /**
     * Beginning-of-string
     */

    .capture('prefix', function() ***REMOVED***
      if (this.parsed) return;
      var pos = this.position();
      var m = this.match(/^\.[\\/]/);
      if (!m) return;
      this.state.strictOpen = !!this.options.strictOpen;
      this.state.addPrefix = true;
    ***REMOVED***)

    /**
     * Escape: "\\."
     */

    .capture('escape', function() ***REMOVED***
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|([$^]))/);
      if (!m) return;

      return pos(***REMOVED***
        type: 'escape',
        val: m[2] || m[1]
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Quoted strings
     */

    .capture('quoted', function() ***REMOVED***
      var pos = this.position();
      var m = this.match(/^["']/);
      if (!m) return;

      var quote = m[0];
      if (this.input.indexOf(quote) === -1) ***REMOVED***
        return pos(***REMOVED***
          type: 'escape',
          val: quote
        ***REMOVED***);
      ***REMOVED***

      var tok = advanceTo(this.input, quote);
      this.consume(tok.len);

      return pos(***REMOVED***
        type: 'quoted',
        val: tok.esc
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Negations: "!"
     */

    .capture('not', function() ***REMOVED***
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(this.notRegex || /^\!+/);
      if (!m) return;
      var val = m[0];

      var isNegated = isOdd(val.length);
      if (parsed === '' && !isNegated) ***REMOVED***
        val = '';
      ***REMOVED***

      // if nothing has been parsed, we know `!` is at the start,
      // so we need to wrap the result in a negation regex
      if (parsed === '' && isNegated && this.options.nonegate !== true) ***REMOVED***
        this.bos.val = '(?!^(?:';
        this.append = ')$).*';
        val = '';
      ***REMOVED***
      return pos(***REMOVED***
        type: 'not',
        val: val
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Dot: "."
     */

    .capture('dot', function() ***REMOVED***
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\.+/);
      if (!m) return;

      var val = m[0];
      this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');

      return pos(***REMOVED***
        type: 'dot',
        dotfiles: this.state.dot,
        val: val
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Plus: "+"
     */

    .capture('plus', /^\+(?!\()/)

    /**
     * Question mark: "?"
     */

    .capture('qmark', function() ***REMOVED***
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\?+(?!\()/);
      if (!m) return;

      this.state.metachar = true;
      this.state.qmark = true;

      return pos(***REMOVED***
        type: 'qmark',
        parsed: parsed,
        val: m[0]
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Globstar: "**"
     */

    .capture('globstar', function() ***REMOVED***
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\****REMOVED***2***REMOVED***(?![*(])(?=[,\/)]|$)/);
      if (!m) return;

      var type = opts.noglobstar !== true ? 'globstar' : 'star';
      var node = pos(***REMOVED***type: type, parsed: parsed***REMOVED***);

      while (this.input.slice(0, 4) === '/**/') ***REMOVED***
        this.input = this.input.slice(3);
      ***REMOVED***

      node.isInside = ***REMOVED***
        brace: this.isInside('brace'),
        paren: this.isInside('paren')
      ***REMOVED***;

      if (type === 'globstar') ***REMOVED***
        this.state.globstar = true;
        node.val = '**';

      ***REMOVED*** else ***REMOVED***
        this.state.star = true;
        node.val = '*';
      ***REMOVED***

      this.state.metachar = true;
      return node;
    ***REMOVED***)

    /**
     * Star: "*"
     */

    .capture('star', function() ***REMOVED***
      var pos = this.position();
      var starRe = /^(?:\*(?![*(])|[*]***REMOVED***3,***REMOVED***(?!\()|[*]***REMOVED***2***REMOVED***(?![(\/]|$)|\*(?=\*\())/;
      var m = this.match(starRe);
      if (!m) return;

      this.state.metachar = true;
      this.state.star = true;
      return pos(***REMOVED***
        type: 'star',
        val: m[0]
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Slash: "/"
     */

    .capture('slash', function() ***REMOVED***
      var pos = this.position();
      var m = this.match(/^\//);
      if (!m) return;

      this.state.slashes++;
      return pos(***REMOVED***
        type: 'slash',
        val: m[0]
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Backslash: "\\"
     */

    .capture('backslash', function() ***REMOVED***
      var pos = this.position();
      var m = this.match(/^\\(?![*+?()***REMOVED******REMOVED***[\]'"])/);
      if (!m) return;

      var val = m[0];

      if (this.isInside('bracket')) ***REMOVED***
        val = '\\';
      ***REMOVED*** else if (val.length > 1) ***REMOVED***
        val = '\\\\';
      ***REMOVED***

      return pos(***REMOVED***
        type: 'backslash',
        val: val
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Square: "[.]"
     */

    .capture('square', function() ***REMOVED***
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^\[([^!^\\])\]/);
      if (!m) return;

      return pos(***REMOVED***
        type: 'square',
        val: m[1]
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Brackets: "[...]" (basic, this can be overridden by other parsers)
     */

    .capture('bracket', function() ***REMOVED***
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]+|\]\-)(\]|[^*+?]+)|\[)/);
      if (!m) return;

      var val = m[0];
      var negated = m[1] ? '^' : '';
      var inner = (m[2] || '').replace(/\\\\+/, '\\\\');
      var close = m[3] || '';

      if (m[2] && inner.length < m[2].length) ***REMOVED***
        val = val.replace(/\\\\+/, '\\\\');
      ***REMOVED***

      var esc = this.input.slice(0, 2);
      if (inner === '' && esc === '\\]') ***REMOVED***
        inner += esc;
        this.consume(2);

        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) ***REMOVED***
          this.consume(1);
          if (ch === ']') ***REMOVED***
            close = ch;
            break;
          ***REMOVED***
          inner += ch;
        ***REMOVED***
      ***REMOVED***

      return pos(***REMOVED***
        type: 'bracket',
        val: val,
        escaped: close !== ']',
        negated: negated,
        inner: inner,
        close: close
      ***REMOVED***);
    ***REMOVED***)

    /**
     * Text
     */

    .capture('text', function() ***REMOVED***
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      return pos(***REMOVED***
        type: 'text',
        val: m[0]
      ***REMOVED***);
    ***REMOVED***);

  /**
   * Allow custom parsers to be passed on options
   */

  if (options && typeof options.parsers === 'function') ***REMOVED***
    options.parsers(nanomatch.parser);
  ***REMOVED***
***REMOVED***;

/**
 * Advance to the next non-escaped character
 */

function advanceTo(input, endChar) ***REMOVED***
  var ch = input.charAt(0);
  var tok = ***REMOVED*** len: 1, val: '', esc: '' ***REMOVED***;
  var idx = 0;

  function advance() ***REMOVED***
    if (ch !== '\\') ***REMOVED***
      tok.esc += '\\' + ch;
      tok.val += ch;
    ***REMOVED***

    ch = input.charAt(++idx);
    tok.len++;

    if (ch === '\\') ***REMOVED***
      advance();
      advance();
    ***REMOVED***
  ***REMOVED***

  while (ch && ch !== endChar) ***REMOVED***
    advance();
  ***REMOVED***
  return tok;
***REMOVED***

/**
 * Create text regex
 */

function createTextRegex(pattern) ***REMOVED***
  if (cached) return cached;
  var opts = ***REMOVED***contains: true, strictClose: false***REMOVED***;
  var not = regexNot.create(pattern, opts);
  var re = toRegex('^(?:[*]\\(|' + not + ')', opts);
  return (cached = re);
***REMOVED***

/**
 * Expose negation string
 */

module.exports.not = NOT_REGEX;
