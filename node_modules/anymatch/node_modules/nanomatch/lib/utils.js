'use strict';

var utils = module.exports;
var path = require('path');

/**
 * Module dependencies
 */

var Snapdragon = require('snapdragon');
utils.define = require('define-property');
utils.diff = require('arr-diff');
utils.extend = require('extend-shallow');
utils.pick = require('object.pick');
utils.typeOf = require('kind-of');
utils.unique = require('array-unique');

/**
 * Returns true if the given value is effectively an empty string
 */

utils.isEmptyString = function(val) ***REMOVED***
  return String(val) === '' || String(val) === './';
***REMOVED***;

/**
 * Returns true if the platform is windows, or `path.sep` is `\\`.
 * This is defined as a function to allow `path.sep` to be set in unit tests,
 * or by the user, if there is a reason to do so.
 * @return ***REMOVED***Boolean***REMOVED***
 */

utils.isWindows = function() ***REMOVED***
  return path.sep === '\\' || process.platform === 'win32';
***REMOVED***;

/**
 * Return the last element from an array
 */

utils.last = function(arr, n) ***REMOVED***
  return arr[arr.length - (n || 1)];
***REMOVED***;

/**
 * Get the `Snapdragon` instance to use
 */

utils.instantiate = function(ast, options) ***REMOVED***
  var snapdragon;
  // if an instance was created by `.parse`, use that instance
  if (utils.typeOf(ast) === 'object' && ast.snapdragon) ***REMOVED***
    snapdragon = ast.snapdragon;
  // if the user supplies an instance on options, use that instance
  ***REMOVED*** else if (utils.typeOf(options) === 'object' && options.snapdragon) ***REMOVED***
    snapdragon = options.snapdragon;
  // create a new instance
  ***REMOVED*** else ***REMOVED***
    snapdragon = new Snapdragon(options);
  ***REMOVED***

  utils.define(snapdragon, 'parse', function(str, options) ***REMOVED***
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strictErrors !== true) ***REMOVED***
      var open = last.nodes[0];
      var inner = last.nodes[1];
      if (last.type === 'bracket') ***REMOVED***
        if (inner.val.charAt(0) === '[') ***REMOVED***
          inner.val = '\\' + inner.val;
        ***REMOVED***

      ***REMOVED*** else ***REMOVED***
        open.val = '\\' + open.val;
        var sibling = open.parent.nodes[1];
        if (sibling.type === 'star') ***REMOVED***
          sibling.loose = true;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  ***REMOVED***);

  return snapdragon;
***REMOVED***;

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) ***REMOVED***
  if (typeof options === 'undefined') ***REMOVED***
    return pattern;
  ***REMOVED***
  var key = pattern;
  for (var prop in options) ***REMOVED***
    if (options.hasOwnProperty(prop)) ***REMOVED***
      key += ';' + prop + '=' + String(options[prop]);
    ***REMOVED***
  ***REMOVED***
  return key;
***REMOVED***;

/**
 * Cast `val` to an array
 * @return ***REMOVED***Array***REMOVED***
 */

utils.arrayify = function(val) ***REMOVED***
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
***REMOVED***;

/**
 * Return true if `val` is a non-empty string
 */

utils.isString = function(val) ***REMOVED***
  return typeof val === 'string';
***REMOVED***;

/**
 * Return true if `val` is a non-empty string
 */

utils.isRegex = function(val) ***REMOVED***
  return utils.typeOf(val) === 'regexp';
***REMOVED***;

/**
 * Return true if `val` is a non-empty string
 */

utils.isObject = function(val) ***REMOVED***
  return utils.typeOf(val) === 'object';
***REMOVED***;

/**
 * Escape regex characters in the given string
 */

utils.escapeRegex = function(str) ***REMOVED***
  return str.replace(/[-[\]***REMOVED******REMOVED***()^$|*+?.\\\/\s]/g, '\\$&');
***REMOVED***;

/**
 * Combines duplicate characters in the provided `input` string.
 * @param ***REMOVED***String***REMOVED*** `input`
 * @returns ***REMOVED***String***REMOVED***
 */

utils.combineDupes = function(input, patterns) ***REMOVED***
  patterns = utils.arrayify(patterns).join('|').split('|');
  patterns = patterns.map(function(s) ***REMOVED***
    return s.replace(/\\?([+*\\/])/g, '\\$1');
  ***REMOVED***);
  var substr = patterns.join('|');
  var regex = new RegExp('(' + substr + ')(?=\\1)', 'g');
  return input.replace(regex, '');
***REMOVED***;

/**
 * Returns true if the given `str` has special characters
 */

utils.hasSpecialChars = function(str) ***REMOVED***
  return /(?:(?:(^|\/)[!.])|[*?+()|\[\]***REMOVED******REMOVED***]|[+@]\()/.test(str);
***REMOVED***;

/**
 * Normalize slashes in the given filepath.
 *
 * @param ***REMOVED***String***REMOVED*** `filepath`
 * @return ***REMOVED***String***REMOVED***
 */

utils.toPosixPath = function(str) ***REMOVED***
  return str.replace(/\\+/g, '/');
***REMOVED***;

/**
 * Strip backslashes before special characters in a string.
 *
 * @param ***REMOVED***String***REMOVED*** `str`
 * @return ***REMOVED***String***REMOVED***
 */

utils.unescape = function(str) ***REMOVED***
  return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
***REMOVED***;

/**
 * Strip the drive letter from a windows filepath
 * @param ***REMOVED***String***REMOVED*** `fp`
 * @return ***REMOVED***String***REMOVED***
 */

utils.stripDrive = function(fp) ***REMOVED***
  return utils.isWindows() ? fp.replace(/^[a-z]:[\\\/]+?/i, '/') : fp;
***REMOVED***;

/**
 * Strip the prefix from a filepath
 * @param ***REMOVED***String***REMOVED*** `fp`
 * @return ***REMOVED***String***REMOVED***
 */

utils.stripPrefix = function(str) ***REMOVED***
  if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\')) ***REMOVED***
    return str.slice(2);
  ***REMOVED***
  return str;
***REMOVED***;

/**
 * Returns true if `str` is a common character that doesn't need
 * to be processed to be used for matching.
 * @param ***REMOVED***String***REMOVED*** `str`
 * @return ***REMOVED***Boolean***REMOVED***
 */

utils.isSimpleChar = function(str) ***REMOVED***
  return str === '' || str === ' ' || str === '.';
***REMOVED***;

/**
 * Returns true if the given str is an escaped or
 * unescaped path character
 */

utils.isSlash = function(str) ***REMOVED***
  return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
***REMOVED***;

/**
 * Returns a function that returns true if the given
 * pattern matches or contains a `filepath`
 *
 * @param ***REMOVED***String***REMOVED*** `pattern`
 * @return ***REMOVED***Function***REMOVED***
 */

utils.matchPath = function(pattern, options) ***REMOVED***
  return (options && options.contains)
    ? utils.containsPattern(pattern, options)
    : utils.equalsPattern(pattern, options);
***REMOVED***;

/**
 * Returns true if the given (original) filepath or unixified path are equal
 * to the given pattern.
 */

utils._equals = function(filepath, unixPath, pattern) ***REMOVED***
  return pattern === filepath || pattern === unixPath;
***REMOVED***;

/**
 * Returns true if the given (original) filepath or unixified path contain
 * the given pattern.
 */

utils._contains = function(filepath, unixPath, pattern) ***REMOVED***
  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
***REMOVED***;

/**
 * Returns a function that returns true if the given
 * pattern is the same as a given `filepath`
 *
 * @param ***REMOVED***String***REMOVED*** `pattern`
 * @return ***REMOVED***Function***REMOVED***
 */

utils.equalsPattern = function(pattern, options) ***REMOVED***
  var unixify = utils.unixify(options);
  options = options || ***REMOVED******REMOVED***;

  return function fn(filepath) ***REMOVED***
    var equal = utils._equals(filepath, unixify(filepath), pattern);
    if (equal === true || options.nocase !== true) ***REMOVED***
      return equal;
    ***REMOVED***
    var lower = filepath.toLowerCase();
    return utils._equals(lower, unixify(lower), pattern);
  ***REMOVED***;
***REMOVED***;

/**
 * Returns a function that returns true if the given
 * pattern contains a `filepath`
 *
 * @param ***REMOVED***String***REMOVED*** `pattern`
 * @return ***REMOVED***Function***REMOVED***
 */

utils.containsPattern = function(pattern, options) ***REMOVED***
  var unixify = utils.unixify(options);
  options = options || ***REMOVED******REMOVED***;

  return function(filepath) ***REMOVED***
    var contains = utils._contains(filepath, unixify(filepath), pattern);
    if (contains === true || options.nocase !== true) ***REMOVED***
      return contains;
    ***REMOVED***
    var lower = filepath.toLowerCase();
    return utils._contains(lower, unixify(lower), pattern);
  ***REMOVED***;
***REMOVED***;

/**
 * Returns a function that returns true if the given
 * regex matches the `filename` of a file path.
 *
 * @param ***REMOVED***RegExp***REMOVED*** `re` Matching regex
 * @return ***REMOVED***Function***REMOVED***
 */

utils.matchBasename = function(re) ***REMOVED***
  return function(filepath) ***REMOVED***
    return re.test(filepath) || re.test(path.basename(filepath));
  ***REMOVED***;
***REMOVED***;

/**
 * Returns the given value unchanced.
 * @return ***REMOVED***any***REMOVED***
 */

utils.identity = function(val) ***REMOVED***
  return val;
***REMOVED***;

/**
 * Determines the filepath to return based on the provided options.
 * @return ***REMOVED***any***REMOVED***
 */

utils.value = function(str, unixify, options) ***REMOVED***
  if (options && options.unixify === false) ***REMOVED***
    return str;
  ***REMOVED***
  if (options && typeof options.unixify === 'function') ***REMOVED***
    return options.unixify(str);
  ***REMOVED***
  return unixify(str);
***REMOVED***;

/**
 * Returns a function that normalizes slashes in a string to forward
 * slashes, strips `./` from beginning of paths, and optionally unescapes
 * special characters.
 * @return ***REMOVED***Function***REMOVED***
 */

utils.unixify = function(options) ***REMOVED***
  var opts = options || ***REMOVED******REMOVED***;
  return function(filepath) ***REMOVED***
    if (opts.stripPrefix !== false) ***REMOVED***
      filepath = utils.stripPrefix(filepath);
    ***REMOVED***
    if (opts.unescape === true) ***REMOVED***
      filepath = utils.unescape(filepath);
    ***REMOVED***
    if (opts.unixify === true || utils.isWindows()) ***REMOVED***
      filepath = utils.toPosixPath(filepath);
    ***REMOVED***
    return filepath;
  ***REMOVED***;
***REMOVED***;
