'use strict';

/**
 * Nanomatch compilers
 */

module.exports = function(nanomatch, options) ***REMOVED***
  var star = '[^/]*?';

  var ast = nanomatch.ast = nanomatch.parser.ast;
  ast.state = nanomatch.parser.state;
  nanomatch.compiler.state = ast.state;
  nanomatch.compiler

    /**
     * Negation / escaping
     */

    .set('not', function(node) ***REMOVED***
      var prev = this.prev();
      if (this.options.nonegate === true || prev.type !== 'bos') ***REMOVED***
        return this.emit('\\' + node.val, node);
      ***REMOVED***
      return this.emit(node.val, node);
    ***REMOVED***)
    .set('escape', function(node) ***REMOVED***
      if (this.options.unescape && /^[\w_.-]/.test(node.val)) ***REMOVED***
        return this.emit(node.val, node);
      ***REMOVED***
      return this.emit('\\' + node.val, node);
    ***REMOVED***)
    .set('quoted', function(node) ***REMOVED***
      return this.emit(node.val, node);
    ***REMOVED***)

    /**
     * Regex
     */

    .set('dollar', function(node) ***REMOVED***
      if (node.parent.type === 'bracket') ***REMOVED***
        return this.emit(node.val, node);
      ***REMOVED***
      return this.emit('\\' + node.val, node);
    ***REMOVED***)

    /**
     * Dot: "."
     */

    .set('dot', function(node) ***REMOVED***
      if (node.dotfiles === true) this.dotfiles = true;
      return this.emit('\\' + node.val, node);
    ***REMOVED***)

    /**
     * Slashes: "/" and "\"
     */

    .set('backslash', function(node) ***REMOVED***
      return this.emit(node.val, node);
    ***REMOVED***)
    .set('slash', function(node, nodes, i) ***REMOVED***
      var val = '\\' + node.val;
      var parent = node.parent;
      var prev = this.prev();

      // set "node.hasSlash" to true on all ancestor parens nodes
      while (parent.type === 'paren' && !parent.hasSlash) ***REMOVED***
        parent.hasSlash = true;
        parent = parent.parent;
      ***REMOVED***

      if (prev.addQmark) ***REMOVED***
        val += '?';
      ***REMOVED***

      // word boundary
      if (node.rest.slice(0, 2) === '\\b') ***REMOVED***
        return this.emit(val, node);
      ***REMOVED***

      // globstars
      if (node.parsed === '**' || node.parsed === './**') ***REMOVED***
        this.output = '(?:' + this.output;
        return this.emit(val + ')?', node);
      ***REMOVED***

      // negation
      if (node.parsed === '!**' && this.options.nonegate !== true) ***REMOVED***
        return this.emit(val + '?\\b', node);
      ***REMOVED***
      return this.emit(val, node);
    ***REMOVED***)

    /**
     * Square brackets
     */

    .set('bracket', function(node) ***REMOVED***
      var close = node.close;
      var open = !node.escaped ? '[' : '\\[';
      var negated = node.negated;
      var inner = node.inner;
      var val = node.val;

      if (node.escaped === true) ***REMOVED***
        inner = inner.replace(/\\?(\W)/g, '\\$1');
        negated = '';
      ***REMOVED***

      if (inner === ']-') ***REMOVED***
        inner = '\\]\\-';
      ***REMOVED***

      if (negated && inner.indexOf('.') === -1) ***REMOVED***
        inner += '.';
      ***REMOVED***
      if (negated && inner.indexOf('/') === -1) ***REMOVED***
        inner += '/';
      ***REMOVED***

      val = open + negated + inner + close;
      return this.emit(val, node);
    ***REMOVED***)

    /**
     * Square: "[.]" (only matches a single character in brackets)
     */

    .set('square', function(node) ***REMOVED***
      var val = !/^\w/.test(node.val) ? '\\' + node.val : node.val;
      return this.emit(val, node);
    ***REMOVED***)

    /**
     * Question mark: "?"
     */

    .set('qmark', function(node) ***REMOVED***
      var prev = this.prev();
      var val = '[^.\\\\/]';
      if (this.options.dot || (prev.type !== 'bos' && prev.type !== 'slash')) ***REMOVED***
        val = '[^\\\\/]';
      ***REMOVED***

      if (node.parsed.slice(-1) === '(') ***REMOVED***
        var ch = node.rest.charAt(0);
        if (ch === '!' || ch === '=' || ch === ':') ***REMOVED***
          return this.emit(node.val, node);
        ***REMOVED***
      ***REMOVED***

      if (node.val.length > 1) ***REMOVED***
        val += '***REMOVED***' + node.val.length + '***REMOVED***';
      ***REMOVED***
      return this.emit(val, node);
    ***REMOVED***)

    /**
     * Plus
     */

    .set('plus', function(node) ***REMOVED***
      var prev = node.parsed.slice(-1);
      if (prev === ']' || prev === ')') ***REMOVED***
        return this.emit(node.val, node);
      ***REMOVED***
      if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) ***REMOVED***
        return this.emit('\\+', node);
      ***REMOVED***
      var ch = this.output.slice(-1);
      if (/\w/.test(ch) && !node.inside) ***REMOVED***
        return this.emit('+\\+?', node);
      ***REMOVED***
      return this.emit('+', node);
    ***REMOVED***)

    /**
     * globstar: '**'
     */

    .set('globstar', function(node, nodes, i) ***REMOVED***
      if (!this.output) ***REMOVED***
        this.state.leadingGlobstar = true;
      ***REMOVED***

      var next = this.next();
      var prev = this.prev();
      var next2 = this.next(2);
      var prev2 = this.prev(2);
      var type = prev.type;
      var val = node.val;

      if (prev.type === 'slash' && next.type === 'slash') ***REMOVED***
        if (prev2.type === 'text') ***REMOVED***
          this.output += '?';

          if (next2.type !== 'text') ***REMOVED***
            this.output += '\\b';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      var parsed = node.parsed;
      if (parsed.charAt(0) === '!') ***REMOVED***
        parsed = parsed.slice(1);
      ***REMOVED***

      var isInside = node.isInside.paren || node.isInside.brace;
      if (parsed && type !== 'slash' && type !== 'bos' && !isInside) ***REMOVED***
        val = star;
      ***REMOVED*** else ***REMOVED***
        val = this.options.dot !== true
          ? '(?:(?!(?:\\/|^)\\.).)*?'
          : '(?:(?!(?:\\/|^)(?:\\.***REMOVED***1,2***REMOVED***)($|\\/))(?!\\.***REMOVED***2***REMOVED***).)*?';
      ***REMOVED***

      if ((type === 'slash' || type === 'bos') && this.options.dot !== true) ***REMOVED***
        val = '(?!\\.)' + val;
      ***REMOVED***

      if (prev.type === 'slash' && next.type === 'slash' && prev2.type !== 'text') ***REMOVED***
        if (next2.type === 'text' || next2.type === 'star') ***REMOVED***
          node.addQmark = true;
        ***REMOVED***
      ***REMOVED***

      if (this.options.capture) ***REMOVED***
        val = '(' + val + ')';
      ***REMOVED***

      return this.emit(val, node);
    ***REMOVED***)

    /**
     * Star: "*"
     */

    .set('star', function(node, nodes, i) ***REMOVED***
      var prior = nodes[i - 2] || ***REMOVED******REMOVED***;
      var prev = this.prev();
      var next = this.next();
      var type = prev.type;

      function isStart(n) ***REMOVED***
        return n.type === 'bos' || n.type === 'slash';
      ***REMOVED***

      if (this.output === '' && this.options.contains !== true) ***REMOVED***
        this.output = '(?!\\/)';
      ***REMOVED***

      if (type === 'bracket' && this.options.bash === false) ***REMOVED***
        var str = next && next.type === 'bracket' ? star : '*?';
        if (!prev.nodes || prev.nodes[1].type !== 'posix') ***REMOVED***
          return this.emit(str, node);
        ***REMOVED***
      ***REMOVED***

      var prefix = !this.dotfiles && type !== 'text' && type !== 'escape'
        ? (this.options.dot ? '(?!(?:^|\\/)\\.***REMOVED***1,2***REMOVED***(?:$|\\/))' : '(?!\\.)')
        : '';

      if (isStart(prev) || (isStart(prior) && type === 'not')) ***REMOVED***
        if (prefix !== '(?!\\.)') ***REMOVED***
          prefix += '(?!(\\.***REMOVED***2***REMOVED***|\\.\\/))(?=.)';
        ***REMOVED*** else ***REMOVED***
          prefix += '(?=.)';
        ***REMOVED***
      ***REMOVED*** else if (prefix === '(?!\\.)') ***REMOVED***
        prefix = '';
      ***REMOVED***

      if (prev.type === 'not' && prior.type === 'bos' && this.options.dot === true) ***REMOVED***
        this.output = '(?!\\.)' + this.output;
      ***REMOVED***

      var output = prefix + star;
      if (this.options.capture) ***REMOVED***
        output = '(' + output + ')';
      ***REMOVED***

      return this.emit(output, node);
    ***REMOVED***)

    /**
     * Text
     */

    .set('text', function(node) ***REMOVED***
      return this.emit(node.val, node);
    ***REMOVED***)

    /**
     * End-of-string
     */

    .set('eos', function(node) ***REMOVED***
      var prev = this.prev();
      var val = node.val;

      this.output = '(?:(?:\\.(?:\\/|\\\\))(?=.))?' + this.output;
      if (this.state.metachar && prev.type !== 'qmark' && prev.type !== 'slash') ***REMOVED***
        val += (this.options.contains ? '(?:\\/|\\\\)?' : '(?:(?:\\/|\\\\)|$)');
      ***REMOVED***

      return this.emit(val, node);
    ***REMOVED***);

  /**
   * Allow custom compilers to be passed on options
   */

  if (options && typeof options.compilers === 'function') ***REMOVED***
    options.compilers(nanomatch.compiler);
  ***REMOVED***
***REMOVED***;

