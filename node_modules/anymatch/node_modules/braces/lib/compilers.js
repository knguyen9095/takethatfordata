'use strict';

var utils = require('./utils');

module.exports = function(braces, options) ***REMOVED***
  braces.compiler

    /**
     * bos
     */

    .set('bos', function() ***REMOVED***
      if (this.output) return;
      this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
      this.ast.count = 1;
    ***REMOVED***)

    /**
     * Square brackets
     */

    .set('bracket', function(node) ***REMOVED***
      var close = node.close;
      var open = !node.escaped ? '[' : '\\[';
      var negated = node.negated;
      var inner = node.inner;

      inner = inner.replace(/\\(?=[\\\w]|$)/g, '\\\\');
      if (inner === ']-') ***REMOVED***
        inner = '\\]\\-';
      ***REMOVED***

      if (negated && inner.indexOf('.') === -1) ***REMOVED***
        inner += '.';
      ***REMOVED***
      if (negated && inner.indexOf('/') === -1) ***REMOVED***
        inner += '/';
      ***REMOVED***

      var val = open + negated + inner + close;
      var queue = node.parent.queue;
      var last = utils.arrayify(queue.pop());

      queue.push(utils.join(last, val));
      queue.push.apply(queue, []);
    ***REMOVED***)

    /**
     * Brace
     */

    .set('brace', function(node) ***REMOVED***
      node.queue = isEscaped(node) ? [node.val] : [];
      node.count = 1;
      return this.mapVisit(node.nodes);
    ***REMOVED***)

    /**
     * Open
     */

    .set('brace.open', function(node) ***REMOVED***
      node.parent.open = node.val;
    ***REMOVED***)

    /**
     * Inner
     */

    .set('text', function(node) ***REMOVED***
      var queue = node.parent.queue;
      var escaped = node.escaped;
      var segs = [node.val];

      if (node.optimize === false) ***REMOVED***
        options = utils.extend(***REMOVED******REMOVED***, options, ***REMOVED***optimize: false***REMOVED***);
      ***REMOVED***

      if (node.multiplier > 1) ***REMOVED***
        node.parent.count *= node.multiplier;
      ***REMOVED***

      if (options.quantifiers === true && utils.isQuantifier(node.val)) ***REMOVED***
        escaped = true;

      ***REMOVED*** else if (node.val.length > 1) ***REMOVED***
        if (isType(node.parent, 'brace') && !isEscaped(node)) ***REMOVED***
          var expanded = utils.expand(node.val, options);
          segs = expanded.segs;

          if (expanded.isOptimized) ***REMOVED***
            node.parent.isOptimized = true;
          ***REMOVED***

          // if nothing was expanded, we probably have a literal brace
          if (!segs.length) ***REMOVED***
            var val = (expanded.val || node.val);
            if (options.unescape !== false) ***REMOVED***
              // unescape unexpanded brace sequence/set separators
              val = val.replace(/\\([,.])/g, '$1');
              // strip quotes
              val = val.replace(/["'`]/g, '');
            ***REMOVED***

            segs = [val];
            escaped = true;
          ***REMOVED***
        ***REMOVED***

      ***REMOVED*** else if (node.val === ',') ***REMOVED***
        if (options.expand) ***REMOVED***
          node.parent.queue.push(['']);
          segs = [''];
        ***REMOVED*** else ***REMOVED***
          segs = ['|'];
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        escaped = true;
      ***REMOVED***

      if (escaped && isType(node.parent, 'brace')) ***REMOVED***
        if (node.parent.nodes.length <= 4 && node.parent.count === 1) ***REMOVED***
          node.parent.escaped = true;
        ***REMOVED*** else if (node.parent.length <= 3) ***REMOVED***
          node.parent.escaped = true;
        ***REMOVED***
      ***REMOVED***

      if (!hasQueue(node.parent)) ***REMOVED***
        node.parent.queue = segs;
        return;
      ***REMOVED***

      var last = utils.arrayify(queue.pop());
      if (node.parent.count > 1 && options.expand) ***REMOVED***
        last = multiply(last, node.parent.count);
        node.parent.count = 1;
      ***REMOVED***

      queue.push(utils.join(utils.flatten(last), segs.shift()));
      queue.push.apply(queue, segs);
    ***REMOVED***)

    /**
     * Close
     */

    .set('brace.close', function(node) ***REMOVED***
      var queue = node.parent.queue;
      var prev = node.parent.parent;
      var last = prev.queue.pop();
      var open = node.parent.open;
      var close = node.val;

      if (open && close && isOptimized(node, options)) ***REMOVED***
        open = '(';
        close = ')';
      ***REMOVED***

      // if a close brace exists, and the previous segment is one character
      // don't wrap the result in braces or parens
      var ele = utils.last(queue);
      if (node.parent.count > 1 && options.expand) ***REMOVED***
        ele = multiply(queue.pop(), node.parent.count);
        node.parent.count = 1;
        queue.push(ele);
      ***REMOVED***

      if (close && typeof ele === 'string' && ele.length === 1) ***REMOVED***
        open = '';
        close = '';
      ***REMOVED***

      if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) ***REMOVED***
        queue.push(utils.join(open, queue.pop() || ''));
        queue = utils.flatten(utils.join(queue, close));
      ***REMOVED***

      if (typeof last === 'undefined') ***REMOVED***
        prev.queue = [queue];
      ***REMOVED*** else ***REMOVED***
        prev.queue.push(utils.flatten(utils.join(last, queue)));
      ***REMOVED***
    ***REMOVED***)

    /**
     * eos
     */

    .set('eos', function(node) ***REMOVED***
      if (this.input) return;

      if (options.optimize !== false) ***REMOVED***
        this.output = utils.last(utils.flatten(this.ast.queue));
      ***REMOVED*** else if (Array.isArray(utils.last(this.ast.queue))) ***REMOVED***
        this.output = utils.flatten(this.ast.queue.pop());
      ***REMOVED*** else ***REMOVED***
        this.output = utils.flatten(this.ast.queue);
      ***REMOVED***

      if (node.parent.count > 1 && options.expand) ***REMOVED***
        this.output = multiply(this.output, node.parent.count);
      ***REMOVED***

      this.output = utils.arrayify(this.output);
      this.ast.queue = [];
    ***REMOVED***);

***REMOVED***;

/**
 * Multiply the segments in the current brace level
 */

function multiply(queue, n, options) ***REMOVED***
  return utils.flatten(utils.repeat(utils.arrayify(queue), n));
***REMOVED***

/**
 * Return true if `node` is escaped
 */

function isEscaped(node) ***REMOVED***
  return node.escaped === true;
***REMOVED***

/**
 * Returns true if regex parens should be used for sets. If the parent `type`
 * is not `brace`, then we're on a root node, which means we should never
 * expand segments and open/close braces should be `***REMOVED******REMOVED***` (since this indicates
 * a brace is missing from the set)
 */

function isOptimized(node, options) ***REMOVED***
  if (node.parent.isOptimized) return true;
  return isType(node.parent, 'brace')
    && !isEscaped(node.parent)
    && options.expand !== true;
***REMOVED***

/**
 * Returns true if the value in `node` should be wrapped in a literal brace.
 * @return ***REMOVED***Boolean***REMOVED***
 */

function isLiteralBrace(node, options) ***REMOVED***
  return isEscaped(node.parent) || options.optimize !== false;
***REMOVED***

/**
 * Returns true if the given `node` does not have an inner value.
 * @return ***REMOVED***Boolean***REMOVED***
 */

function noInner(node, type) ***REMOVED***
  if (node.parent.queue.length === 1) ***REMOVED***
    return true;
  ***REMOVED***
  var nodes = node.parent.nodes;
  return nodes.length === 3
    && isType(nodes[0], 'brace.open')
    && !isType(nodes[1], 'text')
    && isType(nodes[2], 'brace.close');
***REMOVED***

/**
 * Returns true if the given `node` is the given `type`
 * @return ***REMOVED***Boolean***REMOVED***
 */

function isType(node, type) ***REMOVED***
  return typeof node !== 'undefined' && node.type === type;
***REMOVED***

/**
 * Returns true if the given `node` has a non-empty queue.
 * @return ***REMOVED***Boolean***REMOVED***
 */

function hasQueue(node) ***REMOVED***
  return Array.isArray(node.queue) && node.queue.length;
***REMOVED***
