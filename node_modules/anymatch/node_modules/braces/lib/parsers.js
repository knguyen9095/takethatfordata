'use strict';

var Node = require('snapdragon-node');
var utils = require('./utils');

/**
 * Braces parsers
 */

module.exports = function(braces, options) ***REMOVED***
  braces.parser
    .set('bos', function() ***REMOVED***
      if (!this.parsed) ***REMOVED***
        this.ast = this.nodes[0] = new Node(this.ast);
      ***REMOVED***
    ***REMOVED***)

    /**
     * Character parsers
     */

    .set('escape', function() ***REMOVED***
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|\$\***REMOVED***)/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      var node = pos(new Node(***REMOVED***
        type: 'text',
        multiplier: 1,
        val: m[0]
      ***REMOVED***));

      if (node.val === '\\\\') ***REMOVED***
        return node;
      ***REMOVED***

      if (node.val === '$***REMOVED***') ***REMOVED***
        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) ***REMOVED***
          this.consume(1);
          node.val += ch;
          if (ch === '\\') ***REMOVED***
            node.val += str[++idx];
            continue;
          ***REMOVED***
          if (ch === '***REMOVED***') ***REMOVED***
            break;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      if (this.options.unescape !== false) ***REMOVED***
        node.val = node.val.replace(/\\([***REMOVED******REMOVED***])/g, '$1');
      ***REMOVED***

      if (last.val === '"' && this.input.charAt(0) === '"') ***REMOVED***
        last.val = node.val;
        this.consume(1);
        return;
      ***REMOVED***

      return concatNodes.call(this, pos, node, prev, options);
    ***REMOVED***)

    /**
     * Brackets: "[...]" (basic, this is overridden by
     * other parsers in more advanced implementations)
     */

    .set('bracket', function() ***REMOVED***
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]***REMOVED***2,***REMOVED***|\]\-)(\]|[^*+?]+)|\[)/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];
      var negated = m[1] ? '^' : '';
      var inner = m[2] || '';
      var close = m[3] || '';

      if (isInside && prev.type === 'brace') ***REMOVED***
        prev.text = prev.text || '';
        prev.text += val;
      ***REMOVED***

      var esc = this.input.slice(0, 2);
      if (inner === '' && esc === '\\]') ***REMOVED***
        inner += esc;
        this.consume(2);

        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) ***REMOVED***
          this.consume(1);
          if (ch === ']') ***REMOVED***
            close = ch;
            break;
          ***REMOVED***
          inner += ch;
        ***REMOVED***
      ***REMOVED***

      return pos(new Node(***REMOVED***
        type: 'bracket',
        val: val,
        escaped: close !== ']',
        negated: negated,
        inner: inner,
        close: close
      ***REMOVED***));
    ***REMOVED***)

    /**
     * Empty braces (we capture these early to
     * speed up processing in the compiler)
     */

    .set('multiplier', function() ***REMOVED***
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^\***REMOVED***(,+(?:(\***REMOVED***,+\***REMOVED***)*),*|,*(?:(\***REMOVED***,+\***REMOVED***)*),+)\***REMOVED***/);
      if (!m) return;

      this.multiplier = true;
      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') ***REMOVED***
        prev.text = prev.text || '';
        prev.text += val;
      ***REMOVED***

      var node = pos(new Node(***REMOVED***
        type: 'text',
        multiplier: 1,
        match: m,
        val: val
      ***REMOVED***));

      return concatNodes.call(this, pos, node, prev, options);
    ***REMOVED***)

    /**
     * Open
     */

    .set('brace.open', function() ***REMOVED***
      var pos = this.position();
      var m = this.match(/^\***REMOVED***(?!(?:[^\\***REMOVED***]?|,+)\***REMOVED***)/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      // if the last parsed character was an extglob character
      // we need to _not optimize_ the brace pattern because
      // it might be mistaken for an extglob by a downstream parser
      if (last && last.val && isExtglobChar(last.val.slice(-1))) ***REMOVED***
        last.optimize = false;
      ***REMOVED***

      var open = pos(new Node(***REMOVED***
        type: 'brace.open',
        val: m[0]
      ***REMOVED***));

      var node = pos(new Node(***REMOVED***
        type: 'brace',
        nodes: []
      ***REMOVED***));

      node.push(open);
      prev.push(node);
      this.push('brace', node);
    ***REMOVED***)

    /**
     * Close
     */

    .set('brace.close', function() ***REMOVED***
      var pos = this.position();
      var m = this.match(/^\***REMOVED***/);
      if (!m || !m[0]) return;

      var brace = this.pop('brace');
      var node = pos(new Node(***REMOVED***
        type: 'brace.close',
        val: m[0]
      ***REMOVED***));

      if (!this.isType(brace, 'brace')) ***REMOVED***
        if (this.options.strict) ***REMOVED***
          throw new Error('missing opening "***REMOVED***"');
        ***REMOVED***
        node.type = 'text';
        node.multiplier = 0;
        node.escaped = true;
        return node;
      ***REMOVED***

      var prev = this.prev();
      var last = utils.last(prev.nodes);
      if (last.text) ***REMOVED***
        var lastNode = utils.last(last.nodes);
        if (lastNode.val === ')' && /[!@*?+]\(/.test(last.text)) ***REMOVED***
          var open = last.nodes[0];
          var text = last.nodes[1];
          if (open.type === 'brace.open' && text && text.type === 'text') ***REMOVED***
            text.optimize = false;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      if (brace.nodes.length > 2) ***REMOVED***
        var first = brace.nodes[1];
        if (first.type === 'text' && first.val === ',') ***REMOVED***
          brace.nodes.splice(1, 1);
          brace.nodes.push(first);
        ***REMOVED***
      ***REMOVED***

      brace.push(node);
    ***REMOVED***)

    /**
     * Capture boundary characters
     */

    .set('boundary', function() ***REMOVED***
      var pos = this.position();
      var m = this.match(/^[$^](?!\***REMOVED***)/);
      if (!m) return;
      return pos(new Node(***REMOVED***
        type: 'text',
        val: m[0]
      ***REMOVED***));
    ***REMOVED***)

    /**
     * One or zero, non-comma characters wrapped in braces
     */

    .set('nobrace', function() ***REMOVED***
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^\***REMOVED***[^,]?\***REMOVED***/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') ***REMOVED***
        prev.text = prev.text || '';
        prev.text += val;
      ***REMOVED***

      return pos(new Node(***REMOVED***
        type: 'text',
        multiplier: 0,
        val: val
      ***REMOVED***));
    ***REMOVED***)

    /**
     * Text
     */

    .set('text', function() ***REMOVED***
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^((?!\\)[^$***REMOVED******REMOVED***\[\]])+/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') ***REMOVED***
        prev.text = prev.text || '';
        prev.text += val;
      ***REMOVED***

      var node = pos(new Node(***REMOVED***
        type: 'text',
        multiplier: 1,
        val: val
      ***REMOVED***));

      return concatNodes.call(this, pos, node, prev, options);
    ***REMOVED***);
***REMOVED***;

/**
 * Returns true if the character is an extglob character.
 */

function isExtglobChar(ch) ***REMOVED***
  return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';
***REMOVED***

/**
 * Combine text nodes, and calculate empty sets (`***REMOVED***,,***REMOVED***`)
 * @param ***REMOVED***Function***REMOVED*** `pos` Function to calculate node position
 * @param ***REMOVED***Object***REMOVED*** `node` AST node
 * @return ***REMOVED***Object***REMOVED***
 */

function concatNodes(pos, node, parent, options) ***REMOVED***
  node.orig = node.val;
  var prev = this.prev();
  var last = utils.last(prev.nodes);
  var isEscaped = false;

  if (node.val.length > 1) ***REMOVED***
    var a = node.val.charAt(0);
    var b = node.val.slice(-1);

    isEscaped = (a === '"' && b === '"')
      || (a === "'" && b === "'")
      || (a === '`' && b === '`');
  ***REMOVED***

  if (isEscaped && options.unescape !== false) ***REMOVED***
    node.val = node.val.slice(1, node.val.length - 1);
    node.escaped = true;
  ***REMOVED***

  if (node.match) ***REMOVED***
    var match = node.match[1];
    if (!match || match.indexOf('***REMOVED***') === -1) ***REMOVED***
      match = node.match[0];
    ***REMOVED***

    // replace each set with a single ","
    var val = match.replace(/\***REMOVED***/g, ',').replace(/\***REMOVED***/g, '');
    node.multiplier *= val.length;
    node.val = '';
  ***REMOVED***

  var simpleText = last.type === 'text'
    && last.multiplier === 1
    && node.multiplier === 1
    && node.val;

  if (simpleText) ***REMOVED***
    last.val += node.val;
    return;
  ***REMOVED***

  prev.push(node);
***REMOVED***
