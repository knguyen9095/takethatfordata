'use strict';

var Snapdragon = require('snapdragon');
var compilers = require('./compilers');
var parsers = require('./parsers');
var utils = require('./utils');

/**
 * Customize Snapdragon parser and renderer
 */

function Braces(options) ***REMOVED***
  this.options = utils.extend(***REMOVED******REMOVED***, options);
***REMOVED***

/**
 * Initialize braces
 */

Braces.prototype.init = function(options) ***REMOVED***
  var opts = utils.createOptions(***REMOVED******REMOVED***, this.options, options);
  this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
  this.compiler = this.snapdragon.compiler;
  this.parser = this.snapdragon.parser;

  compilers(this.snapdragon, opts);
  parsers(this.snapdragon, opts);

  /**
   * Call Snapdragon `.parse` method. When AST is returned, we check to
   * see if any unclosed braces are left on the stack and, if so, we iterate
   * over the stack and correct the AST so that compilers are called in the correct
   * order and unbalance braces are properly escaped.
   */

  utils.define(this.snapdragon, 'parse', function(pattern, options) ***REMOVED***
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    this.parser.ast.input = pattern;

    var stack = this.parser.stack;
    while (stack.length) ***REMOVED***
      addParent(***REMOVED***type: 'brace.close', val: ''***REMOVED***, stack.pop());
    ***REMOVED***

    function addParent(node, parent) ***REMOVED***
      utils.define(node, 'parent', parent);
      parent.nodes.push(node);
    ***REMOVED***

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  ***REMOVED***);
***REMOVED***;

/**
 * Lazily initialize braces
 */

Braces.prototype.lazyInit = function(options) ***REMOVED***
  if (!this.isInitialized) ***REMOVED***
    this.isInitialized = true;
    this.init(options);
  ***REMOVED***
***REMOVED***;

/**
 * Decorate `.parse` method
 */

Braces.prototype.parse = function(ast, options) ***REMOVED***
  if (utils.isObject(ast) && ast.nodes) return ast;
  this.lazyInit(options);
  return this.snapdragon.parse(ast, options);
***REMOVED***;

/**
 * Decorate `.compile` method
 */

Braces.prototype.compile = function(ast, options) ***REMOVED***
  if (typeof ast === 'string') ***REMOVED***
    ast = this.parse(ast, options);
  ***REMOVED*** else ***REMOVED***
    this.lazyInit(options);
  ***REMOVED***
  var res = this.snapdragon.compile(ast, options);
  return res;
***REMOVED***;

/**
 * Expand
 */

Braces.prototype.expand = function(pattern) ***REMOVED***
  var ast = this.parse(pattern, ***REMOVED***expand: true***REMOVED***);
  return this.compile(ast, ***REMOVED***expand: true***REMOVED***);
***REMOVED***;

/**
 * Optimize
 */

Braces.prototype.optimize = function(pattern) ***REMOVED***
  var ast = this.parse(pattern, ***REMOVED***optimize: true***REMOVED***);
  return this.compile(ast, ***REMOVED***optimize: true***REMOVED***);
***REMOVED***;

/**
 * Expose `Braces`
 */

module.exports = Braces;
