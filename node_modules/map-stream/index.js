//filter will reemit the data if cb(err,pass) pass is truthy

// reduce is more tricky
// maybe we want to group the reductions or emit progress updates occasionally
// the most basic reduce just emits one 'data' event after it has recieved 'end'


var Stream = require('stream').Stream


//create an event stream and apply function to each .write
//emitting each response as data
//unless it's an empty callback

module.exports = function (mapper, opts) ***REMOVED***

  var stream = new Stream()
    , self = this
    , inputs = 0
    , outputs = 0
    , ended = false
    , paused = false
    , destroyed = false
    , lastWritten = 0
    , inNext = false

  this.opts = opts || ***REMOVED******REMOVED***;
  var errorEventName = this.opts.failures ? 'failure' : 'error';

  // Items that are not ready to be written yet (because they would come out of
  // order) get stuck in a queue for later.
  var writeQueue = ***REMOVED******REMOVED***

  stream.writable = true
  stream.readable = true

  function queueData (data, number) ***REMOVED***
    var nextToWrite = lastWritten + 1

    if (number === nextToWrite) ***REMOVED***
      // If it's next, and its not undefined write it
      if (data !== undefined) ***REMOVED***
        stream.emit.apply(stream, ['data', data])
      ***REMOVED***
      lastWritten ++
      nextToWrite ++
    ***REMOVED*** else ***REMOVED***
      // Otherwise queue it for later.
      writeQueue[number] = data
    ***REMOVED***

    // If the next value is in the queue, write it
    if (writeQueue.hasOwnProperty(nextToWrite)) ***REMOVED***
      var dataToWrite = writeQueue[nextToWrite]
      delete writeQueue[nextToWrite]
      return queueData(dataToWrite, nextToWrite)
    ***REMOVED***

    outputs ++
    if(inputs === outputs) ***REMOVED***
      if(paused) paused = false, stream.emit('drain') //written all the incoming events
      if(ended) end()
    ***REMOVED***
  ***REMOVED***

  function next (err, data, number) ***REMOVED***
    if(destroyed) return
    inNext = true

    if (!err || self.opts.failures) ***REMOVED***
      queueData(data, number)
    ***REMOVED***

    if (err) ***REMOVED***
      stream.emit.apply(stream, [ errorEventName, err ]);
    ***REMOVED***

    inNext = false;
  ***REMOVED***

  // Wrap the mapper function by calling its callback with the order number of
  // the item in the stream.
  function wrappedMapper (input, number, callback) ***REMOVED***
    return mapper.call(null, input, function(err, data)***REMOVED***
      callback(err, data, number)
    ***REMOVED***)
  ***REMOVED***

  stream.write = function (data) ***REMOVED***
    if(ended) throw new Error('map stream is not writable')
    inNext = false
    inputs ++

    try ***REMOVED***
      //catch sync errors and handle them like async errors
      var written = wrappedMapper(data, inputs, next)
      paused = (written === false)
      return !paused
    ***REMOVED*** catch (err) ***REMOVED***
      //if the callback has been called syncronously, and the error
      //has occured in an listener, throw it again.
      if(inNext)
        throw err
      next(err)
      return !paused
    ***REMOVED***
  ***REMOVED***

  function end (data) ***REMOVED***
    //if end was called with args, write it, 
    ended = true //write will emit 'end' if ended is true
    stream.writable = false
    if(data !== undefined) ***REMOVED***
      return queueData(data, inputs)
    ***REMOVED*** else if (inputs == outputs) ***REMOVED*** //wait for processing 
      stream.readable = false, stream.emit('end'), stream.destroy() 
    ***REMOVED***
  ***REMOVED***

  stream.end = function (data) ***REMOVED***
    if(ended) return
    end()
  ***REMOVED***

  stream.destroy = function () ***REMOVED***
    ended = destroyed = true
    stream.writable = stream.readable = paused = false
    process.nextTick(function () ***REMOVED***
      stream.emit('close')
    ***REMOVED***)
  ***REMOVED***
  stream.pause = function () ***REMOVED***
    paused = true
  ***REMOVED***

  stream.resume = function () ***REMOVED***
    paused = false
  ***REMOVED***

  return stream
***REMOVED***




