'use strict';

var RingBuffer = require('./ring_buffer');

var Functor = function(session, method) ***REMOVED***
  this._session = session;
  this._method  = method;
  this._queue   = new RingBuffer(Functor.QUEUE_SIZE);
  this._stopped = false;
  this.pending  = 0;
***REMOVED***;

Functor.QUEUE_SIZE = 8;

Functor.prototype.call = function(error, message, callback, context) ***REMOVED***
  if (this._stopped) return;

  var record = ***REMOVED***error: error, message: message, callback: callback, context: context, done: false***REMOVED***,
      called = false,
      self   = this;

  this._queue.push(record);

  if (record.error) ***REMOVED***
    record.done = true;
    this._stop();
    return this._flushQueue();
  ***REMOVED***

  var handler = function(err, msg) ***REMOVED***
    if (!(called ^ (called = true))) return;

    if (err) ***REMOVED***
      self._stop();
      record.error   = err;
      record.message = null;
    ***REMOVED*** else ***REMOVED***
      record.message = msg;
    ***REMOVED***

    record.done = true;
    self._flushQueue();
  ***REMOVED***;

  try ***REMOVED***
    this._session[this._method](message, handler);
  ***REMOVED*** catch (err) ***REMOVED***
    handler(err);
  ***REMOVED***
***REMOVED***;

Functor.prototype._stop = function() ***REMOVED***
  this.pending  = this._queue.length;
  this._stopped = true;
***REMOVED***;

Functor.prototype._flushQueue = function() ***REMOVED***
  var queue = this._queue, record;

  while (queue.length > 0 && queue.peek().done) ***REMOVED***
    record = queue.shift();
    if (record.error) ***REMOVED***
      this.pending = 0;
      queue.clear();
    ***REMOVED*** else ***REMOVED***
      this.pending -= 1;
    ***REMOVED***
    record.callback.call(record.context, record.error, record.message);
  ***REMOVED***
***REMOVED***;

module.exports = Functor;
