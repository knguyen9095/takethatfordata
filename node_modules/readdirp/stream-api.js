'use strict';

var si =  require('set-immediate-shim');
var stream = require('readable-stream');
var util = require('util');

var Readable = stream.Readable;

module.exports = ReaddirpReadable;

util.inherits(ReaddirpReadable, Readable);

function ReaddirpReadable (opts) ***REMOVED***
  if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);

  opts = opts || ***REMOVED******REMOVED***;

  opts.objectMode = true;
  Readable.call(this, opts);

  // backpressure not implemented at this point
  this.highWaterMark = Infinity;

  this._destroyed = false;
  this._paused = false;
  this._warnings = [];
  this._errors = [];

  this._pauseResumeErrors();
***REMOVED***

var proto = ReaddirpReadable.prototype;

proto._pauseResumeErrors = function () ***REMOVED***
  var self = this;
  self.on('pause', function () ***REMOVED*** self._paused = true ***REMOVED***);
  self.on('resume', function () ***REMOVED***
    if (self._destroyed) return;
    self._paused = false;

    self._warnings.forEach(function (err) ***REMOVED*** self.emit('warn', err) ***REMOVED***);
    self._warnings.length = 0;

    self._errors.forEach(function (err) ***REMOVED*** self.emit('error', err) ***REMOVED***);
    self._errors.length = 0;
  ***REMOVED***)
***REMOVED***

// called for each entry
proto._processEntry = function (entry) ***REMOVED***
  if (this._destroyed) return;
  this.push(entry);
***REMOVED***

proto._read = function () ***REMOVED*** ***REMOVED***

proto.destroy = function () ***REMOVED***
  // when stream is destroyed it will emit nothing further, not even errors or warnings
  this.push(null);
  this.readable = false;
  this._destroyed = true;
  this.emit('close');
***REMOVED***

proto._done = function () ***REMOVED***
  this.push(null);
***REMOVED***

// we emit errors and warnings async since we may handle errors like invalid args
// within the initial event loop before any event listeners subscribed
proto._handleError = function (err) ***REMOVED***
  var self = this;
  si(function () ***REMOVED***
    if (self._paused) return self._warnings.push(err);
    if (!self._destroyed) self.emit('warn', err);
  ***REMOVED***);
***REMOVED***

proto._handleFatalError = function (err) ***REMOVED***
  var self = this;
  si(function () ***REMOVED***
    if (self._paused) return self._errors.push(err);
    if (!self._destroyed) self.emit('error', err);
  ***REMOVED***);
***REMOVED***

function createStreamAPI () ***REMOVED***
  var stream = new ReaddirpReadable();

  return ***REMOVED***
      stream           :  stream
    , processEntry     :  stream._processEntry.bind(stream)
    , done             :  stream._done.bind(stream)
    , handleError      :  stream._handleError.bind(stream)
    , handleFatalError :  stream._handleFatalError.bind(stream)
  ***REMOVED***;
***REMOVED***

module.exports = createStreamAPI;
