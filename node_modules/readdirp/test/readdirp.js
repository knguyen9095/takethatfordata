/*jshint asi:true */

var test     = require('tap').test
  , path     = require('path')
  , fs       = require('fs')
  , util     = require('util')
  , net      = require('net')
  , readdirp = require('../readdirp.js')
  , root     = path.join(__dirname, '../test/bed')
  , totalDirs          =  6
  , totalFiles         =  12
  , ext1Files          =  4
  , ext2Files          =  3
  , ext3Files          =  2
  , rootDir2Files      =  2
  , nameHasLength9Dirs =  2
  , depth1Files        =  8
  , depth0Files        =  3
  ;

/*
Structure of test bed:
    .
    ├── root_dir1
    │   ├── root_dir1_file1.ext1
    │   ├── root_dir1_file2.ext2
    │   ├── root_dir1_file3.ext3
    │   ├── root_dir1_subdir1
    │   │   └── root1_dir1_subdir1_file1.ext1
    │   └── root_dir1_subdir2
    │       └── .gitignore
    ├── root_dir2
    │   ├── root_dir2_file1.ext1
    │   ├── root_dir2_file2.ext2
    │   ├── root_dir2_subdir1
    │   │   └── .gitignore
    │   └── root_dir2_subdir2
    │       └── .gitignore
    ├── root_file1.ext1
    ├── root_file2.ext2
    └── root_file3.ext3

    6 directories, 13 files
*/

// console.log('\033[2J'); // clear console

function opts (extend) ***REMOVED***
  var o = ***REMOVED*** root: root ***REMOVED***;

  if (extend) ***REMOVED***
    for (var prop in extend) ***REMOVED***
      o[prop] = extend[prop];
    ***REMOVED***
  ***REMOVED***
  return o;
***REMOVED***

test('\nreading root without filter', function (t) ***REMOVED***
  t.plan(2);
  readdirp(opts(), function (err, res) ***REMOVED***
    t.equals(res.directories.length, totalDirs, 'all directories');
    t.equals(res.files.length, totalFiles, 'all files');
    t.end();
  ***REMOVED***)
***REMOVED***)

test('\nreading root without filter using lstat', function (t) ***REMOVED***
  t.plan(2);
  readdirp(opts(***REMOVED*** lstat: true ***REMOVED***), function (err, res) ***REMOVED***
    t.equals(res.directories.length, totalDirs, 'all directories');
    t.equals(res.files.length, totalFiles, 'all files');
    t.end();
  ***REMOVED***)
***REMOVED***)

test('\nreading root with symlinks using lstat', function (t) ***REMOVED***
  t.plan(2);
  fs.symlinkSync(path.join(root, 'root_dir1'), path.join(root, 'dirlink'));
  fs.symlinkSync(path.join(root, 'root_file1.ext1'), path.join(root, 'link.ext1'));
  readdirp(opts(***REMOVED*** lstat: true ***REMOVED***), function (err, res) ***REMOVED***
    t.equals(res.directories.length, totalDirs, 'all directories');
    t.equals(res.files.length, totalFiles + 2, 'all files + symlinks');
    fs.unlinkSync(path.join(root, 'dirlink'));
    fs.unlinkSync(path.join(root, 'link.ext1'));
    t.end();
  ***REMOVED***)
***REMOVED***)

test('\nreading non-standard fds', function (t) ***REMOVED***
  t.plan(2);
  var server = net.createServer().listen(path.join(root, 'test.sock'), function()***REMOVED***
    readdirp(opts(***REMOVED*** entryType: 'all' ***REMOVED***), function (err, res) ***REMOVED***
      t.equals(res.files.length, totalFiles + 1, 'all files + socket');
      readdirp(opts(***REMOVED*** entryType: 'both' ***REMOVED***), function (err, res) ***REMOVED***
        t.equals(res.files.length, totalFiles, 'all regular files only');
        server.close();
        t.end();
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***);
***REMOVED***)

test('\nreading root using glob filter', function (t) ***REMOVED***
  // normal
  t.test('\n# "*.ext1"', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** fileFilter: '*.ext1' ***REMOVED*** ), function (err, res) ***REMOVED***
      t.equals(res.files.length, ext1Files, 'all ext1 files');
      t.end();
    ***REMOVED***)
  ***REMOVED***)
  t.test('\n# ["*.ext1", "*.ext3"]', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** fileFilter: [ '*.ext1', '*.ext3' ] ***REMOVED*** ), function (err, res) ***REMOVED***
      t.equals(res.files.length, ext1Files + ext3Files, 'all ext1 and ext3 files');
      t.end();
    ***REMOVED***)
  ***REMOVED***)
  t.test('\n# "root_dir1"', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** directoryFilter: 'root_dir1' ***REMOVED***), function (err, res) ***REMOVED***
      t.equals(res.directories.length, 1, 'one directory');
      t.end();
    ***REMOVED***)
  ***REMOVED***)
  t.test('\n# ["root_dir1", "*dir1_subdir1"]', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** directoryFilter: [ 'root_dir1', '*dir1_subdir1' ]***REMOVED***), function (err, res) ***REMOVED***
      t.equals(res.directories.length, 2, 'two directories');
      t.end();
    ***REMOVED***)
  ***REMOVED***)

  t.test('\n# negated: "!*.ext1"', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** fileFilter: '!*.ext1' ***REMOVED*** ), function (err, res) ***REMOVED***
      t.equals(res.files.length, totalFiles - ext1Files, 'all but ext1 files');
      t.end();
    ***REMOVED***)
  ***REMOVED***)
  t.test('\n# negated: ["!*.ext1", "!*.ext3"]', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** fileFilter: [ '!*.ext1', '!*.ext3' ] ***REMOVED*** ), function (err, res) ***REMOVED***
      t.equals(res.files.length, totalFiles - ext1Files - ext3Files, 'all but ext1 and ext3 files');
      t.end();
    ***REMOVED***)
  ***REMOVED***)

  t.test('\n# mixed: ["*.ext1", "!*.ext3"]', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** fileFilter: [ '*.ext1', '!*.ext3' ] ***REMOVED*** ), function (err, res) ***REMOVED***
      t.similar(err[0].toString(), /Cannot mix negated with non negated glob filters/, 'returns meaningfull error');
      t.end();
    ***REMOVED***)
  ***REMOVED***)

  t.test('\n# leading and trailing spaces: [" *.ext1", "*.ext3 "]', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** fileFilter: [ ' *.ext1', '*.ext3 ' ] ***REMOVED*** ), function (err, res) ***REMOVED***
      t.equals(res.files.length, ext1Files + ext3Files, 'all ext1 and ext3 files');
      t.end();
    ***REMOVED***)
  ***REMOVED***)
  t.test('\n# leading and trailing spaces: [" !*.ext1", " !*.ext3 "]', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** fileFilter: [ ' !*.ext1', ' !*.ext3' ] ***REMOVED*** ), function (err, res) ***REMOVED***
      t.equals(res.files.length, totalFiles - ext1Files - ext3Files, 'all but ext1 and ext3 files');
      t.end();
    ***REMOVED***)
  ***REMOVED***)

  t.test('\n# ** glob pattern', function (t) ***REMOVED***
    t.plan(1);
    readdirp(opts( ***REMOVED*** fileFilter: '**/*.ext1' ***REMOVED*** ), function (err, res) ***REMOVED***
      t.equals(res.files.length, ext1Files, 'ignores ** in **/*.ext1 -> only *.ext1 files');
      t.end();
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

test('\n\nreading root using function filter', function (t) ***REMOVED***
  t.test('\n# file filter -> "contains root_dir2"', function (t) ***REMOVED***
    t.plan(1);
    readdirp(
        opts( ***REMOVED*** fileFilter: function (fi) ***REMOVED*** return fi.name.indexOf('root_dir2') >= 0; ***REMOVED*** ***REMOVED***)
      , function (err, res) ***REMOVED***
          t.equals(res.files.length, rootDir2Files, 'all rootDir2Files');
          t.end();
      ***REMOVED***
    )
  ***REMOVED***)

  t.test('\n# directory filter -> "name has length 9"', function (t) ***REMOVED***
    t.plan(1);
    readdirp(
        opts( ***REMOVED*** directoryFilter: function (di) ***REMOVED*** return di.name.length === 9; ***REMOVED*** ***REMOVED***)
      , function (err, res) ***REMOVED***
          t.equals(res.directories.length, nameHasLength9Dirs, 'all all dirs with name length 9');
          t.end();
      ***REMOVED***
    )
  ***REMOVED***)
***REMOVED***)

test('\nreading root specifying maximum depth', function (t) ***REMOVED***
  t.test('\n# depth 1', function (t) ***REMOVED***
    t.plan(1);
      readdirp(opts( ***REMOVED*** depth: 1 ***REMOVED*** ), function (err, res) ***REMOVED***
        t.equals(res.files.length, depth1Files, 'does not return files at depth 2');
      ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

test('\nreading root with no recursion', function (t) ***REMOVED***
  t.test('\n# depth 0', function (t) ***REMOVED***
    t.plan(1);
      readdirp(opts( ***REMOVED*** depth: 0 ***REMOVED*** ), function (err, res) ***REMOVED***
        t.equals(res.files.length, depth0Files, 'does not return files at depth 0');
      ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

test('\nprogress callbacks', function (t) ***REMOVED***
  t.plan(2);

  var pluckName = function(fi) ***REMOVED*** return fi.name; ***REMOVED***
    , processedFiles = [];

  readdirp(
      opts()
    , function(fi) ***REMOVED***
        processedFiles.push(fi);
      ***REMOVED***
    , function (err, res) ***REMOVED***
        t.equals(processedFiles.length, res.files.length, 'calls back for each file processed');
        t.deepEquals(processedFiles.map(pluckName).sort(),res.files.map(pluckName).sort(), 'same file names');
        t.end();
      ***REMOVED***
  )
***REMOVED***)

test('resolving of name, full and relative paths', function (t) ***REMOVED***
  var expected = ***REMOVED***
        name          :  'root_dir1_file1.ext1'
      , parentDirName :  'root_dir1'
      , path          :  'root_dir1/root_dir1_file1.ext1'
      , fullPath      :  'test/bed/root_dir1/root_dir1_file1.ext1'
      ***REMOVED***
    , opts = [
        ***REMOVED*** root: './bed'          ,  prefix: ''     ***REMOVED***
      , ***REMOVED*** root: './bed/'         ,  prefix: ''     ***REMOVED***
      , ***REMOVED*** root: 'bed'            ,  prefix: ''     ***REMOVED***
      , ***REMOVED*** root: 'bed/'           ,  prefix: ''     ***REMOVED***
      , ***REMOVED*** root: '../test/bed/'   ,  prefix: ''     ***REMOVED***
      , ***REMOVED*** root: '.'              ,  prefix: 'bed'  ***REMOVED***
    ]
  t.plan(opts.length);

  opts.forEach(function (op) ***REMOVED***
    op.fileFilter = 'root_dir1_file1.ext1';

    t.test('\n' + util.inspect(op), function (t) ***REMOVED***
      t.plan(4);

      readdirp (op, function(err, res) ***REMOVED***
        t.equals(res.files[0].name, expected.name, 'correct name');
        t.equals(res.files[0].path, path.join(op.prefix, expected.path), 'correct path');
      ***REMOVED***)

      fs.realpath(op.root, function(err, fullRoot) ***REMOVED***
        readdirp (op, function(err, res) ***REMOVED***
          t.equals(
              res.files[0].fullParentDir
            , path.join(fullRoot, op.prefix, expected.parentDirName)
            , 'correct parentDir'
          );
          t.equals(
              res.files[0].fullPath
            , path.join(fullRoot, op.prefix, expected.parentDirName, expected.name)
            , 'correct fullPath'
          );
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)


