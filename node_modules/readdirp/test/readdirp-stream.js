/*jshint asi:true */

var debug           //= true;
var test            = debug  ? function () ***REMOVED******REMOVED*** : require('tap').test
var test_           = !debug ? function () ***REMOVED******REMOVED*** : require('tap').test
  , path            = require('path')
  , fs              = require('fs')
  , util            = require('util')
  , TransformStream = require('readable-stream').Transform
  , through         = require('through2')
  , proxyquire      = require('proxyquire')
  , streamapi       = require('../stream-api')
  , readdirp        = require('..')
  , root            = path.join(__dirname, 'bed')
  , totalDirs       = 6
  , totalFiles      = 12
  , ext1Files       = 4
  , ext2Files       = 3
  , ext3Files       = 2
  ;
  
// see test/readdirp.js for test bed layout

function opts (extend) ***REMOVED***
  var o = ***REMOVED*** root: root ***REMOVED***;

  if (extend) ***REMOVED***
    for (var prop in extend) ***REMOVED***
      o[prop] = extend[prop];
    ***REMOVED***
  ***REMOVED***
  return o;
***REMOVED***

function capture () ***REMOVED***
  var result = ***REMOVED*** entries: [], errors: [], ended: false ***REMOVED***
    , dst = new TransformStream(***REMOVED*** objectMode: true ***REMOVED***);

  dst._transform = function (entry, _, cb) ***REMOVED***
    result.entries.push(entry);
    cb();
  ***REMOVED***

  dst._flush = function (cb) ***REMOVED***
    result.ended = true;
    this.push(result); 
    cb();
  ***REMOVED***

  return dst;
***REMOVED***

test('\nintegrated', function (t) ***REMOVED***
  t.test('\n# reading root without filter', function (t) ***REMOVED***
    t.plan(2);

    readdirp(opts())
      .on('error', function (err) ***REMOVED***
        t.fail('should not throw error', err);
      ***REMOVED***)
      .pipe(capture())
      .pipe(through.obj(
        function (result, _ , cb) ***REMOVED*** 
          t.equals(result.entries.length, totalFiles, 'emits all files');
          t.ok(result.ended, 'ends stream');
          t.end();
          cb();
        ***REMOVED***
      ));
  ***REMOVED***)

  t.test('\n# normal: ["*.ext1", "*.ext3"]', function (t) ***REMOVED***
    t.plan(2);

    readdirp(opts( ***REMOVED*** fileFilter: [ '*.ext1', '*.ext3' ] ***REMOVED*** ))
      .on('error', function (err) ***REMOVED***
        t.fail('should not throw error', err);
      ***REMOVED***)
      .pipe(capture())
      .pipe(through.obj(
        function (result, _ , cb) ***REMOVED*** 
          t.equals(result.entries.length, ext1Files + ext3Files, 'all ext1 and ext3 files');
          t.ok(result.ended, 'ends stream');
          t.end();
          cb();
        ***REMOVED***
      ))
  ***REMOVED***)

  t.test('\n# files only', function (t) ***REMOVED***
    t.plan(2);

    readdirp(opts( ***REMOVED*** entryType: 'files' ***REMOVED*** ))
      .on('error', function (err) ***REMOVED***
        t.fail('should not throw error', err);
      ***REMOVED***)
      .pipe(capture())
      .pipe(through.obj(
        function (result, _ , cb) ***REMOVED*** 
          t.equals(result.entries.length, totalFiles, 'returned files');
          t.ok(result.ended, 'ends stream');
          t.end();
          cb();
        ***REMOVED***
      ))
  ***REMOVED***)

  t.test('\n# directories only', function (t) ***REMOVED***
    t.plan(2);

    readdirp(opts( ***REMOVED*** entryType: 'directories' ***REMOVED*** ))
      .on('error', function (err) ***REMOVED***
        t.fail('should not throw error', err);
      ***REMOVED***)
      .pipe(capture())
      .pipe(through.obj(
        function (result, _ , cb) ***REMOVED*** 
          t.equals(result.entries.length, totalDirs, 'returned directories');
          t.ok(result.ended, 'ends stream');
          t.end();
          cb();
        ***REMOVED***
      ))
  ***REMOVED***)

  t.test('\n# both directories + files', function (t) ***REMOVED***
    t.plan(2);

    readdirp(opts( ***REMOVED*** entryType: 'both' ***REMOVED*** ))
      .on('error', function (err) ***REMOVED***
        t.fail('should not throw error', err);
      ***REMOVED***)
      .pipe(capture())
      .pipe(through.obj(
        function (result, _ , cb) ***REMOVED*** 
          t.equals(result.entries.length, totalDirs + totalFiles, 'returned everything');
          t.ok(result.ended, 'ends stream');
          t.end();
          cb();
        ***REMOVED***
      ))
  ***REMOVED***)

  t.test('\n# directory filter with directories only', function (t) ***REMOVED***
    t.plan(2);

    readdirp(opts( ***REMOVED*** entryType: 'directories', directoryFilter: [ 'root_dir1', '*dir1_subdir1' ] ***REMOVED*** ))
      .on('error', function (err) ***REMOVED***
        t.fail('should not throw error', err);
      ***REMOVED***)
      .pipe(capture())
      .pipe(through.obj(
        function (result, _ , cb) ***REMOVED***
          t.equals(result.entries.length, 2, 'two directories');
          t.ok(result.ended, 'ends stream');
          t.end();
          cb();
        ***REMOVED***
      ))
  ***REMOVED***)

  t.test('\n# directory and file filters with both entries', function (t) ***REMOVED***
    t.plan(2);

    readdirp(opts( ***REMOVED*** entryType: 'both', directoryFilter: [ 'root_dir1', '*dir1_subdir1' ], fileFilter: [ '!*.ext1' ] ***REMOVED*** ))
      .on('error', function (err) ***REMOVED***
        t.fail('should not throw error', err);
      ***REMOVED***)
      .pipe(capture())
      .pipe(through.obj(
        function (result, _ , cb) ***REMOVED***
          t.equals(result.entries.length, 6, '2 directories and 4 files');
          t.ok(result.ended, 'ends stream');
          t.end();
          cb();
        ***REMOVED***
      ))
  ***REMOVED***)

  t.test('\n# negated: ["!*.ext1", "!*.ext3"]', function (t) ***REMOVED***
    t.plan(2);

    readdirp(opts( ***REMOVED*** fileFilter: [ '!*.ext1', '!*.ext3' ] ***REMOVED*** ))
      .on('error', function (err) ***REMOVED***
        t.fail('should not throw error', err);
      ***REMOVED***)
      .pipe(capture())
      .pipe(through.obj(
        function (result, _ , cb) ***REMOVED*** 
          t.equals(result.entries.length, totalFiles - ext1Files - ext3Files, 'all but ext1 and ext3 files');
          t.ok(result.ended, 'ends stream');
          t.end();
        ***REMOVED***
      ))
  ***REMOVED***)

  t.test('\n# no options given', function (t) ***REMOVED***
    t.plan(1);
    readdirp()
      .on('error', function (err) ***REMOVED***
        t.similar(err.toString() , /Need to pass at least one argument/ , 'emits meaningful error');
        t.end();
      ***REMOVED***)
  ***REMOVED***)

  t.test('\n# mixed: ["*.ext1", "!*.ext3"]', function (t) ***REMOVED***
    t.plan(1);

    readdirp(opts( ***REMOVED*** fileFilter: [ '*.ext1', '!*.ext3' ] ***REMOVED*** ))
      .on('error', function (err) ***REMOVED***
        t.similar(err.toString() , /Cannot mix negated with non negated glob filters/ , 'emits meaningful error');
        t.end();
      ***REMOVED***)
  ***REMOVED***)
***REMOVED***)


test('\napi separately', function (t) ***REMOVED***

  t.test('\n# handleError', function (t) ***REMOVED***
    t.plan(1);

    var api = streamapi()
      , warning = new Error('some file caused problems');

    api.stream
      .on('warn', function (err) ***REMOVED***
        t.equals(err, warning, 'warns with the handled error');
      ***REMOVED***)
    api.handleError(warning);
  ***REMOVED***)

  t.test('\n# when stream is paused and then resumed', function (t) ***REMOVED***
    t.plan(6);
    var api = streamapi()
      , resumed = false
      , fatalError = new Error('fatal!')
      , nonfatalError = new Error('nonfatal!')
      , processedData = 'some data'
      ;

    api.stream
      .on('warn', function (err) ***REMOVED***
        t.equals(err, nonfatalError, 'emits the buffered warning');
        t.ok(resumed, 'emits warning only after it was resumed');
      ***REMOVED***)
      .on('error', function (err) ***REMOVED***
        t.equals(err, fatalError, 'emits the buffered fatal error');
        t.ok(resumed, 'emits errors only after it was resumed');
      ***REMOVED***)
      .on('data', function (data) ***REMOVED***
        t.equals(data, processedData, 'emits the buffered data');
        t.ok(resumed, 'emits data only after it was resumed');
      ***REMOVED***)
      .pause()
    
    api.processEntry(processedData);
    api.handleError(nonfatalError);
    api.handleFatalError(fatalError);
  
    setTimeout(function () ***REMOVED***
      resumed = true;
      api.stream.resume();
    ***REMOVED***, 1)
  ***REMOVED***)

  t.test('\n# when a stream is paused it stops walking the fs', function (t) ***REMOVED***
    var resumed = false,
      mockedAPI = streamapi();

    mockedAPI.processEntry = function (entry) ***REMOVED***
      if (!resumed) t.notOk(true, 'should not emit while paused')
      t.ok(entry, 'emitted while resumed')
    ***REMOVED***.bind(mockedAPI.stream)

    function wrapper () ***REMOVED***
      return mockedAPI
    ***REMOVED***

    var readdirp = proxyquire('../readdirp', ***REMOVED***'./stream-api': wrapper***REMOVED***)
      , stream = readdirp(opts())
      .on('error', function (err) ***REMOVED***
        t.fail('should not throw error', err);
      ***REMOVED***)
      .on('end', function () ***REMOVED***
        t.end()
      ***REMOVED***)
      .pause();

    setTimeout(function () ***REMOVED***
      resumed = true;
      stream.resume();
    ***REMOVED***, 5)
  ***REMOVED***)

  t.test('\n# when a stream is destroyed, it emits "closed", but no longer emits "data", "warn" and "error"', function (t) ***REMOVED***
    var api = streamapi()
      , fatalError = new Error('fatal!')
      , nonfatalError = new Error('nonfatal!')
      , processedData = 'some data'
      , plan = 0;

    t.plan(6)
    var stream = api.stream
      .on('warn', function (err) ***REMOVED***
        t.ok(!stream._destroyed, 'emits warning until destroyed');
      ***REMOVED***)
      .on('error', function (err) ***REMOVED***
        t.ok(!stream._destroyed, 'emits errors until destroyed');
      ***REMOVED***)
      .on('data', function (data) ***REMOVED***
        t.ok(!stream._destroyed, 'emits data until destroyed');
      ***REMOVED***)
      .on('close', function () ***REMOVED***
        t.ok(stream._destroyed, 'emits close when stream is destroyed');
      ***REMOVED***)
    

    api.processEntry(processedData);
    api.handleError(nonfatalError);
    api.handleFatalError(fatalError);

    setTimeout(function () ***REMOVED***
      stream.destroy()

      t.notOk(stream.readable, 'stream is no longer readable after it is destroyed')

      api.processEntry(processedData);
      api.handleError(nonfatalError);
      api.handleFatalError(fatalError);

      process.nextTick(function () ***REMOVED***
        t.pass('emits no more data, warn or error events after it was destroyed')  
        t.end();
      ***REMOVED***)
    ***REMOVED***, 10)
  ***REMOVED***)
***REMOVED***)
