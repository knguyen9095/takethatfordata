'use strict';

var fs        =  require('graceful-fs')
  , path      =  require('path')
  , minimatch =  require('minimatch')
  , toString  =  Object.prototype.toString
  , si        =  require('set-immediate-shim')
  ;


// Standard helpers
function isFunction (obj) ***REMOVED***
  return toString.call(obj) === '[object Function]';
***REMOVED***

function isString (obj) ***REMOVED***
  return toString.call(obj) === '[object String]';
***REMOVED***

function isRegExp (obj) ***REMOVED***
  return toString.call(obj) === '[object RegExp]';
***REMOVED***

function isUndefined (obj) ***REMOVED***
  return obj === void 0;
***REMOVED***

/** 
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param ***REMOVED*** Object ***REMOVED***   opts     Options to specify root (start directory), filters and recursion depth
 * @param ***REMOVED*** function ***REMOVED*** callback1  When callback2 is given calls back for each processed file - function (fileInfo) ***REMOVED*** ... ***REMOVED***,
 *                                when callback2 is not given, it behaves like explained in callback2
 * @param ***REMOVED*** function ***REMOVED*** callback2  Calls back once all files have been processed with an array of errors and file infos
 *                                function (err, fileInfos) ***REMOVED*** ... ***REMOVED***
 */
function readdir(opts, callback1, callback2) ***REMOVED***
  var stream
    , handleError
    , handleFatalError
    , pending = 0
    , errors = []
    , readdirResult = ***REMOVED***
        directories: []
      , files: []
    ***REMOVED***
    , fileProcessed
    , allProcessed
    , realRoot
    , aborted = false
    , paused = false
    ;

  // If no callbacks were given we will use a streaming interface
  if (isUndefined(callback1)) ***REMOVED***
    var api          =  require('./stream-api')();
    stream           =  api.stream;
    callback1        =  api.processEntry;
    callback2        =  api.done;
    handleError      =  api.handleError;
    handleFatalError =  api.handleFatalError;

    stream.on('close', function () ***REMOVED*** aborted = true; ***REMOVED***);
    stream.on('pause', function () ***REMOVED*** paused = true; ***REMOVED***);
    stream.on('resume', function () ***REMOVED*** paused = false; ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    handleError      =  function (err) ***REMOVED*** errors.push(err); ***REMOVED***;
    handleFatalError =  function (err) ***REMOVED***
      handleError(err);
      allProcessed(errors, null);
    ***REMOVED***;
  ***REMOVED***

  if (isUndefined(opts))***REMOVED***
    handleFatalError(new Error (
      'Need to pass at least one argument: opts! \n' +
      'https://github.com/thlorenz/readdirp#options'
      )
    );
    return stream;
  ***REMOVED***

  opts.root            =  opts.root            || '.';
  opts.fileFilter      =  opts.fileFilter      || function() ***REMOVED*** return true; ***REMOVED***;
  opts.directoryFilter =  opts.directoryFilter || function() ***REMOVED*** return true; ***REMOVED***;
  opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;
  opts.entryType       =  opts.entryType       || 'files';

  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);

  if (isUndefined(callback2)) ***REMOVED***
    fileProcessed = function() ***REMOVED*** ***REMOVED***;
    allProcessed = callback1;
  ***REMOVED*** else ***REMOVED***
    fileProcessed = callback1;
    allProcessed = callback2;
  ***REMOVED***

  function normalizeFilter (filter) ***REMOVED***

    if (isUndefined(filter)) return undefined;

    function isNegated (filters) ***REMOVED***

      function negated(f) ***REMOVED*** 
        return f.indexOf('!') === 0; 
      ***REMOVED***

      var some = filters.some(negated);
      if (!some) ***REMOVED***
        return false;
      ***REMOVED*** else ***REMOVED***
        if (filters.every(negated)) ***REMOVED***
          return true;
        ***REMOVED*** else ***REMOVED***
          // if we detect illegal filters, bail out immediately
          throw new Error(
            'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
            'https://github.com/thlorenz/readdirp#filters'
          );
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    // Turn all filters into a function
    if (isFunction(filter)) ***REMOVED***

      return filter;

    ***REMOVED*** else if (isString(filter)) ***REMOVED***

      return function (entryInfo) ***REMOVED***
        return minimatch(entryInfo.name, filter.trim());
      ***REMOVED***;

    ***REMOVED*** else if (filter && Array.isArray(filter)) ***REMOVED***

      if (filter) filter = filter.map(function (f) ***REMOVED***
        return f.trim();
      ***REMOVED***);

      return isNegated(filter) ?
        // use AND to concat multiple negated filters
        function (entryInfo) ***REMOVED***
          return filter.every(function (f) ***REMOVED***
            return minimatch(entryInfo.name, f);
          ***REMOVED***);
        ***REMOVED***
        :
        // use OR to concat multiple inclusive filters
        function (entryInfo) ***REMOVED***
          return filter.some(function (f) ***REMOVED***
            return minimatch(entryInfo.name, f);
          ***REMOVED***);
        ***REMOVED***;
    ***REMOVED***
  ***REMOVED***

  function processDir(currentDir, entries, callProcessed) ***REMOVED***
    if (aborted) return;
    var total = entries.length
      , processed = 0
      , entryInfos = []
      ;

    fs.realpath(currentDir, function(err, realCurrentDir) ***REMOVED***
      if (aborted) return;
      if (err) ***REMOVED***
        handleError(err);
        callProcessed(entryInfos);
        return;
      ***REMOVED***

      var relDir = path.relative(realRoot, realCurrentDir);

      if (entries.length === 0) ***REMOVED***
        callProcessed([]);
      ***REMOVED*** else ***REMOVED***
        entries.forEach(function (entry) ***REMOVED*** 

          var fullPath = path.join(realCurrentDir, entry)
            , relPath  = path.join(relDir, entry);

          statfn(fullPath, function (err, stat) ***REMOVED***
            if (err) ***REMOVED***
              handleError(err);
            ***REMOVED*** else ***REMOVED***
              entryInfos.push(***REMOVED***
                  name          :  entry
                , path          :  relPath   // relative to root
                , fullPath      :  fullPath

                , parentDir     :  relDir    // relative to root
                , fullParentDir :  realCurrentDir

                , stat          :  stat
              ***REMOVED***);
            ***REMOVED***
            processed++;
            if (processed === total) callProcessed(entryInfos);
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  function readdirRec(currentDir, depth, callCurrentDirProcessed) ***REMOVED***
    var args = arguments;
    if (aborted) return;
    if (paused) ***REMOVED***
      si(function () ***REMOVED***
        readdirRec.apply(null, args);
      ***REMOVED***)
      return;
    ***REMOVED*** 

    fs.readdir(currentDir, function (err, entries) ***REMOVED***
      if (err) ***REMOVED***
        handleError(err);
        callCurrentDirProcessed();
        return;
      ***REMOVED***

      processDir(currentDir, entries, function(entryInfos) ***REMOVED***

        var subdirs = entryInfos
          .filter(function (ei) ***REMOVED*** return ei.stat.isDirectory() && opts.directoryFilter(ei); ***REMOVED***);

        subdirs.forEach(function (di) ***REMOVED***
          if(opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') ***REMOVED***
            fileProcessed(di);
          ***REMOVED***
          readdirResult.directories.push(di); 
        ***REMOVED***);

        entryInfos
          .filter(function(ei) ***REMOVED***
            var isCorrectType = opts.entryType === 'all' ?
              !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();
            return isCorrectType && opts.fileFilter(ei);
          ***REMOVED***)
          .forEach(function (fi) ***REMOVED***
            if(opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') ***REMOVED***
              fileProcessed(fi);
            ***REMOVED***
            readdirResult.files.push(fi); 
          ***REMOVED***);

        var pendingSubdirs = subdirs.length;

        // Be done if no more subfolders exist or we reached the maximum desired depth
        if(pendingSubdirs === 0 || depth === opts.depth) ***REMOVED***
          callCurrentDirProcessed();
        ***REMOVED*** else ***REMOVED***
          // recurse into subdirs, keeping track of which ones are done 
          // and call back once all are processed
          subdirs.forEach(function (subdir) ***REMOVED***
            readdirRec(subdir.fullPath, depth + 1, function () ***REMOVED***
              pendingSubdirs = pendingSubdirs - 1;
              if(pendingSubdirs === 0) ***REMOVED*** 
                callCurrentDirProcessed();
              ***REMOVED***
            ***REMOVED***);
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  // Validate and normalize filters
  try ***REMOVED***
    opts.fileFilter = normalizeFilter(opts.fileFilter);
    opts.directoryFilter = normalizeFilter(opts.directoryFilter);
  ***REMOVED*** catch (err) ***REMOVED***
    // if we detect illegal filters, bail out immediately
    handleFatalError(err);
    return stream;
  ***REMOVED***

  // If filters were valid get on with the show
  fs.realpath(opts.root, function(err, res) ***REMOVED***
    if (err) ***REMOVED***
      handleFatalError(err);
      return stream;
    ***REMOVED***

    realRoot = res;
    readdirRec(opts.root, 0, function () ***REMOVED*** 
      // All errors are collected into the errors array
      if (errors.length > 0) ***REMOVED***
        allProcessed(errors, readdirResult); 
      ***REMOVED*** else ***REMOVED***
        allProcessed(null, readdirResult);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  return stream;
***REMOVED***

module.exports = readdir;
