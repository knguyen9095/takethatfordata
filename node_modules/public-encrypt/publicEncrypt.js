var parseKeys = require('parse-asn1');
var randomBytes = require('randombytes');
var createHash = require('create-hash');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var withPublic = require('./withPublic');
var crt = require('browserify-rsa');

var constants = ***REMOVED***
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_PKCS1_PADDIN: 1,
  RSA_NO_PADDING: 3
***REMOVED***;

module.exports = function publicEncrypt(public_key, msg, reverse) ***REMOVED***
  var padding;
  if (public_key.padding) ***REMOVED***
    padding = public_key.padding;
  ***REMOVED*** else if (reverse) ***REMOVED***
    padding = 1;
  ***REMOVED*** else ***REMOVED***
    padding = 4;
  ***REMOVED***
  var key = parseKeys(public_key);
  var paddedMsg;
  if (padding === 4) ***REMOVED***
    paddedMsg = oaep(key, msg);
  ***REMOVED*** else if (padding === 1) ***REMOVED***
    paddedMsg = pkcs1(key, msg, reverse);
  ***REMOVED*** else if (padding === 3) ***REMOVED***
    paddedMsg = new bn(msg);
    if (paddedMsg.cmp(key.modulus) >= 0) ***REMOVED***
      throw new Error('data too long for modulus');
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    throw new Error('unknown padding');
  ***REMOVED***
  if (reverse) ***REMOVED***
    return crt(paddedMsg, key);
  ***REMOVED*** else ***REMOVED***
    return withPublic(paddedMsg, key);
  ***REMOVED***
***REMOVED***;

function oaep(key, msg)***REMOVED***
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) ***REMOVED***
    throw new Error('message too long');
  ***REMOVED***
  var ps = new Buffer(k - mLen - hLen2 - 2);
  ps.fill(0);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
***REMOVED***
function pkcs1(key, msg, reverse)***REMOVED***
  var mLen = msg.length;
  var k = key.modulus.byteLength();
  if (mLen > k - 11) ***REMOVED***
    throw new Error('message too long');
  ***REMOVED***
  var ps;
  if (reverse) ***REMOVED***
    ps = new Buffer(k - mLen - 3);
    ps.fill(0xff);
  ***REMOVED*** else ***REMOVED***
    ps = nonZero(k - mLen - 3);
  ***REMOVED***
  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
***REMOVED***
function nonZero(len, crypto) ***REMOVED***
  var out = new Buffer(len);
  var i = 0;
  var cache = randomBytes(len*2);
  var cur = 0;
  var num;
  while (i < len) ***REMOVED***
    if (cur === cache.length) ***REMOVED***
      cache = randomBytes(len*2);
      cur = 0;
    ***REMOVED***
    num = cache[cur++];
    if (num) ***REMOVED***
      out[i++] = num;
    ***REMOVED***
  ***REMOVED***
  return out;
***REMOVED***