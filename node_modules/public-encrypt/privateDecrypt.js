var parseKeys = require('parse-asn1');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var crt = require('browserify-rsa');
var createHash = require('create-hash');
var withPublic = require('./withPublic');
module.exports = function privateDecrypt(private_key, enc, reverse) ***REMOVED***
  var padding;
  if (private_key.padding) ***REMOVED***
    padding = private_key.padding;
  ***REMOVED*** else if (reverse) ***REMOVED***
    padding = 1;
  ***REMOVED*** else ***REMOVED***
    padding = 4;
  ***REMOVED***
  
  var key = parseKeys(private_key);
  var k = key.modulus.byteLength();
  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) ***REMOVED***
    throw new Error('decryption error');
  ***REMOVED***
  var msg;
  if (reverse) ***REMOVED***
    msg = withPublic(new bn(enc), key);
  ***REMOVED*** else ***REMOVED***
    msg = crt(enc, key);
  ***REMOVED***
  var zBuffer = new Buffer(k - msg.length);
  zBuffer.fill(0);
  msg = Buffer.concat([zBuffer, msg], k);
  if (padding === 4) ***REMOVED***
    return oaep(key, msg);
  ***REMOVED*** else if (padding === 1) ***REMOVED***
    return pkcs1(key, msg, reverse);
  ***REMOVED*** else if (padding === 3) ***REMOVED***
    return msg;
  ***REMOVED*** else ***REMOVED***
    throw new Error('unknown padding');
  ***REMOVED***
***REMOVED***;

function oaep(key, msg)***REMOVED***
  var n = key.modulus;
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (msg[0] !== 0) ***REMOVED***
    throw new Error('decryption error');
  ***REMOVED***
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb =  msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
  if (compare(iHash, db.slice(0, hLen))) ***REMOVED***
    throw new Error('decryption error');
  ***REMOVED***
  var i = hLen;
  while (db[i] === 0) ***REMOVED***
    i++;
  ***REMOVED***
  if (db[i++] !== 1) ***REMOVED***
    throw new Error('decryption error');
  ***REMOVED***
  return db.slice(i);
***REMOVED***

function pkcs1(key, msg, reverse)***REMOVED***
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) ***REMOVED***
    if (i >= msg.length) ***REMOVED***
      status++;
      break;
    ***REMOVED***
  ***REMOVED***
  var ps = msg.slice(2, i - 1);
  var p2 = msg.slice(i - 1, i);

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse))***REMOVED***
    status++;
  ***REMOVED***
  if (ps.length < 8) ***REMOVED***
    status++;
  ***REMOVED***
  if (status) ***REMOVED***
    throw new Error('decryption error');
  ***REMOVED***
  return  msg.slice(i);
***REMOVED***
function compare(a, b)***REMOVED***
  a = new Buffer(a);
  b = new Buffer(b);
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) ***REMOVED***
    dif++;
    len = Math.min(a.length, b.length);
  ***REMOVED***
  var i = -1;
  while (++i < len) ***REMOVED***
    dif += (a[i] ^ b[i]);
  ***REMOVED***
  return dif;
***REMOVED***