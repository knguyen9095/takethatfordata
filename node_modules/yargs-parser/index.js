var camelCase = require('camelcase')
var path = require('path')
var tokenizeArgString = require('./lib/tokenize-arg-string')
var util = require('util')

function parse (args, opts) ***REMOVED***
  if (!opts) opts = ***REMOVED******REMOVED***
  // allow a string argument to be passed in rather
  // than an argv array.
  args = tokenizeArgString(args)
  // aliases might have transitive relationships, normalize this.
  var aliases = combineAliases(opts.alias || ***REMOVED******REMOVED***)
  var configuration = assign(***REMOVED***
    'short-option-groups': true,
    'camel-case-expansion': true,
    'dot-notation': true,
    'parse-numbers': true,
    'boolean-negation': true,
    'duplicate-arguments-array': true,
    'flatten-duplicate-arrays': true,
    'populate--': false
  ***REMOVED***, opts.configuration)
  var defaults = opts.default || ***REMOVED******REMOVED***
  var configObjects = opts.configObjects || []
  var envPrefix = opts.envPrefix
  var notFlagsOption = configuration['populate--']
  var notFlagsArgv = notFlagsOption ? '--' : '_'
  var newAliases = ***REMOVED******REMOVED***
  // allow a i18n handler to be passed in, default to a fake one (util.format).
  var __ = opts.__ || function (str) ***REMOVED***
    return util.format.apply(util, Array.prototype.slice.call(arguments))
  ***REMOVED***
  var error = null
  var flags = ***REMOVED***
    aliases: ***REMOVED******REMOVED***,
    arrays: ***REMOVED******REMOVED***,
    bools: ***REMOVED******REMOVED***,
    strings: ***REMOVED******REMOVED***,
    numbers: ***REMOVED******REMOVED***,
    counts: ***REMOVED******REMOVED***,
    normalize: ***REMOVED******REMOVED***,
    configs: ***REMOVED******REMOVED***,
    defaulted: ***REMOVED******REMOVED***,
    nargs: ***REMOVED******REMOVED***,
    coercions: ***REMOVED******REMOVED***
  ***REMOVED***
  var negative = /^-[0-9]+(\.[0-9]+)?/

  ;[].concat(opts.array).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.arrays[key] = true
  ***REMOVED***)

  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.bools[key] = true
  ***REMOVED***)

  ;[].concat(opts.string).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.strings[key] = true
  ***REMOVED***)

  ;[].concat(opts.number).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.numbers[key] = true
  ***REMOVED***)

  ;[].concat(opts.count).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.counts[key] = true
  ***REMOVED***)

  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.normalize[key] = true
  ***REMOVED***)

  Object.keys(opts.narg || ***REMOVED******REMOVED***).forEach(function (k) ***REMOVED***
    flags.nargs[k] = opts.narg[k]
  ***REMOVED***)

  Object.keys(opts.coerce || ***REMOVED******REMOVED***).forEach(function (k) ***REMOVED***
    flags.coercions[k] = opts.coerce[k]
  ***REMOVED***)

  if (Array.isArray(opts.config) || typeof opts.config === 'string') ***REMOVED***
    ;[].concat(opts.config).filter(Boolean).forEach(function (key) ***REMOVED***
      flags.configs[key] = true
    ***REMOVED***)
  ***REMOVED*** else ***REMOVED***
    Object.keys(opts.config || ***REMOVED******REMOVED***).forEach(function (k) ***REMOVED***
      flags.configs[k] = opts.config[k]
    ***REMOVED***)
  ***REMOVED***

  // create a lookup table that takes into account all
  // combinations of aliases: ***REMOVED***f: ['foo'], foo: ['f']***REMOVED***
  extendAliases(opts.key, aliases, opts.default, flags.arrays)

  // apply default values to all aliases.
  Object.keys(defaults).forEach(function (key) ***REMOVED***
    (flags.aliases[key] || []).forEach(function (alias) ***REMOVED***
      defaults[alias] = defaults[key]
    ***REMOVED***)
  ***REMOVED***)

  var argv = ***REMOVED*** _: [] ***REMOVED***

  Object.keys(flags.bools).forEach(function (key) ***REMOVED***
    setArg(key, !(key in defaults) ? false : defaults[key])
    setDefaulted(key)
  ***REMOVED***)

  var notFlags = []
  if (args.indexOf('--') !== -1) ***REMOVED***
    notFlags = args.slice(args.indexOf('--') + 1)
    args = args.slice(0, args.indexOf('--'))
  ***REMOVED***

  for (var i = 0; i < args.length; i++) ***REMOVED***
    var arg = args[i]
    var broken
    var key
    var letters
    var m
    var next
    var value

    // -- seperated by =
    if (arg.match(/^--.+=/) || (
      !configuration['short-option-groups'] && arg.match(/^-.+=/)
    )) ***REMOVED***
      // Using [\s\S] instead of . because js doesn't support the
      // 'dotall' regex modifier. See:
      // http://stackoverflow.com/a/1068308/13216
      m = arg.match(/^--?([^=]+)=([\s\S]*)$/)

      // nargs format = '--f=monkey washing cat'
      if (checkAllAliases(m[1], flags.nargs)) ***REMOVED***
        args.splice(i + 1, 0, m[2])
        i = eatNargs(i, m[1], args)
      // arrays format = '--f=a b c'
      ***REMOVED*** else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) ***REMOVED***
        args.splice(i + 1, 0, m[2])
        i = eatArray(i, m[1], args)
      ***REMOVED*** else ***REMOVED***
        setArg(m[1], m[2])
      ***REMOVED***
    ***REMOVED*** else if (arg.match(/^--no-.+/) && configuration['boolean-negation']) ***REMOVED***
      key = arg.match(/^--no-(.+)/)[1]
      setArg(key, false)

    // -- seperated by space.
    ***REMOVED*** else if (arg.match(/^--.+/) || (
      !configuration['short-option-groups'] && arg.match(/^-.+/)
    )) ***REMOVED***
      key = arg.match(/^--?(.+)/)[1]

      // nargs format = '--foo a b c'
      if (checkAllAliases(key, flags.nargs)) ***REMOVED***
        i = eatNargs(i, key, args)
      // array format = '--foo a b c'
      ***REMOVED*** else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) ***REMOVED***
        i = eatArray(i, key, args)
      ***REMOVED*** else ***REMOVED***
        next = args[i + 1]

        if (next !== undefined && (!next.match(/^-/) ||
          next.match(negative)) &&
          !checkAllAliases(key, flags.bools) &&
          !checkAllAliases(key, flags.counts)) ***REMOVED***
          setArg(key, next)
          i++
        ***REMOVED*** else if (/^(true|false)$/.test(next)) ***REMOVED***
          setArg(key, next)
          i++
        ***REMOVED*** else ***REMOVED***
          setArg(key, defaultForType(guessType(key, flags)))
        ***REMOVED***
      ***REMOVED***

    // dot-notation flag seperated by '='.
    ***REMOVED*** else if (arg.match(/^-.\..+=/)) ***REMOVED***
      m = arg.match(/^-([^=]+)=([\s\S]*)$/)
      setArg(m[1], m[2])

    // dot-notation flag seperated by space.
    ***REMOVED*** else if (arg.match(/^-.\..+/)) ***REMOVED***
      next = args[i + 1]
      key = arg.match(/^-(.\..+)/)[1]

      if (next !== undefined && !next.match(/^-/) &&
        !checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts)) ***REMOVED***
        setArg(key, next)
        i++
      ***REMOVED*** else ***REMOVED***
        setArg(key, defaultForType(guessType(key, flags)))
      ***REMOVED***
    ***REMOVED*** else if (arg.match(/^-[^-]+/) && !arg.match(negative)) ***REMOVED***
      letters = arg.slice(1, -1).split('')
      broken = false

      for (var j = 0; j < letters.length; j++) ***REMOVED***
        next = arg.slice(j + 2)

        if (letters[j + 1] && letters[j + 1] === '=') ***REMOVED***
          value = arg.slice(j + 3)
          key = letters[j]

          // nargs format = '-f=monkey washing cat'
          if (checkAllAliases(key, flags.nargs)) ***REMOVED***
            args.splice(i + 1, 0, value)
            i = eatNargs(i, key, args)
          // array format = '-f=a b c'
          ***REMOVED*** else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) ***REMOVED***
            args.splice(i + 1, 0, value)
            i = eatArray(i, key, args)
          ***REMOVED*** else ***REMOVED***
            setArg(key, value)
          ***REMOVED***

          broken = true
          break
        ***REMOVED***

        if (next === '-') ***REMOVED***
          setArg(letters[j], next)
          continue
        ***REMOVED***

        // current letter is an alphabetic character and next value is a number
        if (/[A-Za-z]/.test(letters[j]) &&
          /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ***REMOVED***
          setArg(letters[j], next)
          broken = true
          break
        ***REMOVED***

        if (letters[j + 1] && letters[j + 1].match(/\W/)) ***REMOVED***
          setArg(letters[j], next)
          broken = true
          break
        ***REMOVED*** else ***REMOVED***
          setArg(letters[j], defaultForType(guessType(letters[j], flags)))
        ***REMOVED***
      ***REMOVED***

      key = arg.slice(-1)[0]

      if (!broken && key !== '-') ***REMOVED***
        // nargs format = '-f a b c'
        if (checkAllAliases(key, flags.nargs)) ***REMOVED***
          i = eatNargs(i, key, args)
        // array format = '-f a b c'
        ***REMOVED*** else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) ***REMOVED***
          i = eatArray(i, key, args)
        ***REMOVED*** else ***REMOVED***
          next = args[i + 1]

          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
            next.match(negative)) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) ***REMOVED***
            setArg(key, next)
            i++
          ***REMOVED*** else if (/^(true|false)$/.test(next)) ***REMOVED***
            setArg(key, next)
            i++
          ***REMOVED*** else ***REMOVED***
            setArg(key, defaultForType(guessType(key, flags)))
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      argv._.push(
        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
      )
    ***REMOVED***
  ***REMOVED***

  // order of precedence:
  // 1. command line arg
  // 2. value from env var
  // 3. value from config file
  // 4. value from config objects
  // 5. configured default value
  applyEnvVars(argv, true) // special case: check env vars that point to config file
  applyEnvVars(argv, false)
  setConfig(argv)
  setConfigObjects()
  applyDefaultsAndAliases(argv, flags.aliases, defaults)
  applyCoercions(argv)

  // for any counts either not in args or without an explicit default, set to 0
  Object.keys(flags.counts).forEach(function (key) ***REMOVED***
    if (!hasKey(argv, key.split('.'))) setArg(key, 0)
  ***REMOVED***)

  // '--' defaults to undefined.
  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []
  notFlags.forEach(function (key) ***REMOVED***
    argv[notFlagsArgv].push(key)
  ***REMOVED***)

  // how many arguments should we consume, based
  // on the nargs option?
  function eatNargs (i, key, args) ***REMOVED***
    var toEat = checkAllAliases(key, flags.nargs)

    if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key))

    for (var ii = i + 1; ii < (toEat + i + 1); ii++) ***REMOVED***
      setArg(key, args[ii])
    ***REMOVED***

    return (i + toEat)
  ***REMOVED***

  // if an option is an array, eat all non-hyphenated arguments
  // following it... YUM!
  // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
  function eatArray (i, key, args) ***REMOVED***
    var start = i + 1
    var argsToSet = []
    var multipleArrayFlag = i > 0
    for (var ii = i + 1; ii < args.length; ii++) ***REMOVED***
      if (/^-/.test(args[ii]) && !negative.test(args[ii])) ***REMOVED***
        if (ii === start) ***REMOVED***
          setArg(key, defaultForType('array'))
        ***REMOVED***
        multipleArrayFlag = true
        break
      ***REMOVED***
      i = ii
      argsToSet.push(args[ii])
    ***REMOVED***
    if (multipleArrayFlag) ***REMOVED***
      setArg(key, argsToSet.map(function (arg) ***REMOVED***
        return processValue(key, arg)
      ***REMOVED***))
    ***REMOVED*** else ***REMOVED***
      argsToSet.forEach(function (arg) ***REMOVED***
        setArg(key, arg)
      ***REMOVED***)
    ***REMOVED***

    return i
  ***REMOVED***

  function setArg (key, val) ***REMOVED***
    unsetDefaulted(key)

    if (/-/.test(key) && !(flags.aliases[key] && flags.aliases[key].length) && configuration['camel-case-expansion']) ***REMOVED***
      var c = camelCase(key)
      flags.aliases[key] = [c]
      newAliases[c] = true
    ***REMOVED***

    var value = processValue(key, val)

    var splitKey = key.split('.')
    setKey(argv, splitKey, value)

    // handle populating aliases of the full key
    if (flags.aliases[key]) ***REMOVED***
      flags.aliases[key].forEach(function (x) ***REMOVED***
        x = x.split('.')
        setKey(argv, x, value)
      ***REMOVED***)
    ***REMOVED***

    // handle populating aliases of the first element of the dot-notation key
    if (splitKey.length > 1 && configuration['dot-notation']) ***REMOVED***
      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) ***REMOVED***
        x = x.split('.')

        // expand alias with nested objects in key
        var a = [].concat(splitKey)
        a.shift() // nuke the old key.
        x = x.concat(a)

        setKey(argv, x, value)
      ***REMOVED***)
    ***REMOVED***

    // Set normalize getter and setter when key is in 'normalize' but isn't an array
    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) ***REMOVED***
      var keys = [key].concat(flags.aliases[key] || [])
      keys.forEach(function (key) ***REMOVED***
        argv.__defineSetter__(key, function (v) ***REMOVED***
          val = path.normalize(v)
        ***REMOVED***)

        argv.__defineGetter__(key, function () ***REMOVED***
          return typeof val === 'string' ? path.normalize(val) : val
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED***

  function processValue (key, val) ***REMOVED***
    // handle parsing boolean arguments --foo=true --bar false.
    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) ***REMOVED***
      if (typeof val === 'string') val = val === 'true'
    ***REMOVED***

    var value = val
    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) ***REMOVED***
      if (isNumber(val)) value = Number(val)
      if (!isUndefined(val) && !isNumber(val) && checkAllAliases(key, flags.numbers)) value = NaN
    ***REMOVED***

    // increment a count given as arg (either no value or value parsed as boolean)
    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) ***REMOVED***
      value = increment
    ***REMOVED***

    // Set normalized value when key is in 'normalize' and in 'arrays'
    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) ***REMOVED***
      if (Array.isArray(val)) value = val.map(path.normalize)
      else value = path.normalize(val)
    ***REMOVED***
    return value
  ***REMOVED***

  // set args from config.json file, this should be
  // applied last so that defaults can be applied.
  function setConfig (argv) ***REMOVED***
    var configLookup = ***REMOVED******REMOVED***

    // expand defaults/aliases, in-case any happen to reference
    // the config.json file.
    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)

    Object.keys(flags.configs).forEach(function (configKey) ***REMOVED***
      var configPath = argv[configKey] || configLookup[configKey]
      if (configPath) ***REMOVED***
        try ***REMOVED***
          var config = null
          var resolvedConfigPath = path.resolve(process.cwd(), configPath)

          if (typeof flags.configs[configKey] === 'function') ***REMOVED***
            try ***REMOVED***
              config = flags.configs[configKey](resolvedConfigPath)
            ***REMOVED*** catch (e) ***REMOVED***
              config = e
            ***REMOVED***
            if (config instanceof Error) ***REMOVED***
              error = config
              return
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            config = require(resolvedConfigPath)
          ***REMOVED***

          setConfigObject(config)
        ***REMOVED*** catch (ex) ***REMOVED***
          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  // set args from config object.
  // it recursively checks nested objects.
  function setConfigObject (config, prev) ***REMOVED***
    Object.keys(config).forEach(function (key) ***REMOVED***
      var value = config[key]
      var fullKey = prev ? prev + '.' + key : key

      // if the value is an inner object and we have dot-notation
      // enabled, treat inner objects in config the same as
      // heavily nested dot notations (foo.bar.apple).
      if (typeof value === 'object' && !Array.isArray(value) && configuration['dot-notation']) ***REMOVED***
        // if the value is an object but not an array, check nested object
        setConfigObject(value, fullKey)
      ***REMOVED*** else ***REMOVED***
        // setting arguments via CLI takes precedence over
        // values within the config file.
        if (!hasKey(argv, fullKey.split('.')) || (flags.defaulted[fullKey])) ***REMOVED***
          setArg(fullKey, value)
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  // set all config objects passed in opts
  function setConfigObjects () ***REMOVED***
    if (typeof configObjects === 'undefined') return
    configObjects.forEach(function (configObject) ***REMOVED***
      setConfigObject(configObject)
    ***REMOVED***)
  ***REMOVED***

  function applyEnvVars (argv, configOnly) ***REMOVED***
    if (typeof envPrefix === 'undefined') return

    var prefix = typeof envPrefix === 'string' ? envPrefix : ''
    Object.keys(process.env).forEach(function (envVar) ***REMOVED***
      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) ***REMOVED***
        // get array of nested keys and convert them to camel case
        var keys = envVar.split('__').map(function (key, i) ***REMOVED***
          if (i === 0) ***REMOVED***
            key = key.substring(prefix.length)
          ***REMOVED***
          return camelCase(key)
        ***REMOVED***)

        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) ***REMOVED***
          setArg(keys.join('.'), process.env[envVar])
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  function applyCoercions (argv) ***REMOVED***
    var coerce
    Object.keys(argv).forEach(function (key) ***REMOVED***
      coerce = checkAllAliases(key, flags.coercions)
      if (typeof coerce === 'function') ***REMOVED***
        try ***REMOVED***
          argv[key] = coerce(argv[key])
        ***REMOVED*** catch (err) ***REMOVED***
          error = err
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  function applyDefaultsAndAliases (obj, aliases, defaults) ***REMOVED***
    Object.keys(defaults).forEach(function (key) ***REMOVED***
      if (!hasKey(obj, key.split('.'))) ***REMOVED***
        setKey(obj, key.split('.'), defaults[key])

        ;(aliases[key] || []).forEach(function (x) ***REMOVED***
          if (hasKey(obj, x.split('.'))) return
          setKey(obj, x.split('.'), defaults[key])
        ***REMOVED***)
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  function hasKey (obj, keys) ***REMOVED***
    var o = obj

    if (!configuration['dot-notation']) keys = [keys.join('.')]

    keys.slice(0, -1).forEach(function (key) ***REMOVED***
      o = (o[key] || ***REMOVED******REMOVED***)
    ***REMOVED***)

    var key = keys[keys.length - 1]

    if (typeof o !== 'object') return false
    else return key in o
  ***REMOVED***

  function setKey (obj, keys, value) ***REMOVED***
    var o = obj

    if (!configuration['dot-notation']) keys = [keys.join('.')]

    keys.slice(0, -1).forEach(function (key) ***REMOVED***
      if (o[key] === undefined) o[key] = ***REMOVED******REMOVED***
      o = o[key]
    ***REMOVED***)

    var key = keys[keys.length - 1]

    var isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)
    var isValueArray = Array.isArray(value)
    var duplicate = configuration['duplicate-arguments-array']

    if (value === increment) ***REMOVED***
      o[key] = increment(o[key])
    ***REMOVED*** else if (Array.isArray(o[key])) ***REMOVED***
      if (duplicate && isTypeArray && isValueArray) ***REMOVED***
        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : [o[key]].concat([value])
      ***REMOVED*** else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) ***REMOVED***
        o[key] = value
      ***REMOVED*** else ***REMOVED***
        o[key] = o[key].concat([value])
      ***REMOVED***
    ***REMOVED*** else if (o[key] === undefined && isTypeArray) ***REMOVED***
      o[key] = isValueArray ? value : [value]
    ***REMOVED*** else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) ***REMOVED***
      o[key] = [ o[key], value ]
    ***REMOVED*** else ***REMOVED***
      o[key] = value
    ***REMOVED***
  ***REMOVED***

  // extend the aliases list with inferred aliases.
  function extendAliases () ***REMOVED***
    Array.prototype.slice.call(arguments).forEach(function (obj) ***REMOVED***
      Object.keys(obj || ***REMOVED******REMOVED***).forEach(function (key) ***REMOVED***
        // short-circuit if we've already added a key
        // to the aliases array, for example it might
        // exist in both 'opts.default' and 'opts.key'.
        if (flags.aliases[key]) return

        flags.aliases[key] = [].concat(aliases[key] || [])
        // For "--option-name", also set argv.optionName
        flags.aliases[key].concat(key).forEach(function (x) ***REMOVED***
          if (/-/.test(x) && configuration['camel-case-expansion']) ***REMOVED***
            var c = camelCase(x)
            flags.aliases[key].push(c)
            newAliases[c] = true
          ***REMOVED***
        ***REMOVED***)
        flags.aliases[key].forEach(function (x) ***REMOVED***
          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) ***REMOVED***
            return x !== y
          ***REMOVED***))
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***

  // check if a flag is set for any of a key's aliases.
  function checkAllAliases (key, flag) ***REMOVED***
    var isSet = false
    var toCheck = [].concat(flags.aliases[key] || [], key)

    toCheck.forEach(function (key) ***REMOVED***
      if (flag[key]) isSet = flag[key]
    ***REMOVED***)

    return isSet
  ***REMOVED***

  function setDefaulted (key) ***REMOVED***
    [].concat(flags.aliases[key] || [], key).forEach(function (k) ***REMOVED***
      flags.defaulted[k] = true
    ***REMOVED***)
  ***REMOVED***

  function unsetDefaulted (key) ***REMOVED***
    [].concat(flags.aliases[key] || [], key).forEach(function (k) ***REMOVED***
      delete flags.defaulted[k]
    ***REMOVED***)
  ***REMOVED***

  // return a default value, given the type of a flag.,
  // e.g., key of type 'string' will default to '', rather than 'true'.
  function defaultForType (type) ***REMOVED***
    var def = ***REMOVED***
      boolean: true,
      string: '',
      number: undefined,
      array: []
    ***REMOVED***

    return def[type]
  ***REMOVED***

  // given a flag, enforce a default type.
  function guessType (key, flags) ***REMOVED***
    var type = 'boolean'

    if (checkAllAliases(key, flags.strings)) type = 'string'
    else if (checkAllAliases(key, flags.numbers)) type = 'number'
    else if (checkAllAliases(key, flags.arrays)) type = 'array'

    return type
  ***REMOVED***

  function isNumber (x) ***REMOVED***
    if (!configuration['parse-numbers']) return false
    if (typeof x === 'number') return true
    if (/^0x[0-9a-f]+$/i.test(x)) return true
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
  ***REMOVED***

  function isUndefined (num) ***REMOVED***
    return num === undefined
  ***REMOVED***

  return ***REMOVED***
    argv: argv,
    error: error,
    aliases: flags.aliases,
    newAliases: newAliases,
    configuration: configuration
  ***REMOVED***
***REMOVED***

// if any aliases reference each other, we should
// merge them together.
function combineAliases (aliases) ***REMOVED***
  var aliasArrays = []
  var change = true
  var combined = ***REMOVED******REMOVED***

  // turn alias lookup hash ***REMOVED***key: ['alias1', 'alias2']***REMOVED*** into
  // a simple array ['key', 'alias1', 'alias2']
  Object.keys(aliases).forEach(function (key) ***REMOVED***
    aliasArrays.push(
      [].concat(aliases[key], key)
    )
  ***REMOVED***)

  // combine arrays until zero changes are
  // made in an iteration.
  while (change) ***REMOVED***
    change = false
    for (var i = 0; i < aliasArrays.length; i++) ***REMOVED***
      for (var ii = i + 1; ii < aliasArrays.length; ii++) ***REMOVED***
        var intersect = aliasArrays[i].filter(function (v) ***REMOVED***
          return aliasArrays[ii].indexOf(v) !== -1
        ***REMOVED***)

        if (intersect.length) ***REMOVED***
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])
          aliasArrays.splice(ii, 1)
          change = true
          break
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // map arrays back to the hash-lookup (de-dupe while
  // we're at it).
  aliasArrays.forEach(function (aliasArray) ***REMOVED***
    aliasArray = aliasArray.filter(function (v, i, self) ***REMOVED***
      return self.indexOf(v) === i
    ***REMOVED***)
    combined[aliasArray.pop()] = aliasArray
  ***REMOVED***)

  return combined
***REMOVED***

function assign (defaults, configuration) ***REMOVED***
  var o = ***REMOVED******REMOVED***
  configuration = configuration || ***REMOVED******REMOVED***

  Object.keys(defaults).forEach(function (k) ***REMOVED***
    o[k] = defaults[k]
  ***REMOVED***)
  Object.keys(configuration).forEach(function (k) ***REMOVED***
    o[k] = configuration[k]
  ***REMOVED***)

  return o
***REMOVED***

// this function should only be called when a count is given as an arg
// it is NOT called to set a default value
// thus we can start the count at 1 instead of 0
function increment (orig) ***REMOVED***
  return orig !== undefined ? orig + 1 : 1
***REMOVED***

function Parser (args, opts) ***REMOVED***
  var result = parse(args.slice(), opts)

  return result.argv
***REMOVED***

// parse arguments and return detailed
// meta information, aliases, etc.
Parser.detailed = function (args, opts) ***REMOVED***
  return parse(args.slice(), opts)
***REMOVED***

module.exports = Parser
