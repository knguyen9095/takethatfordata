'use strict'

module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = require('pseudomap')
var util = require('util')

// A linked list to keep track of recently-used-ness
var Yallist = require('yallist')

// use symbols if possible, otherwise just _props
var hasSymbol = typeof Symbol === 'function'
var makeSymbol
if (hasSymbol) ***REMOVED***
  makeSymbol = function (key) ***REMOVED***
    return Symbol.for(key)
  ***REMOVED***
***REMOVED*** else ***REMOVED***
  makeSymbol = function (key) ***REMOVED***
    return '_' + key
  ***REMOVED***
***REMOVED***

var MAX = makeSymbol('max')
var LENGTH = makeSymbol('length')
var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
var ALLOW_STALE = makeSymbol('allowStale')
var MAX_AGE = makeSymbol('maxAge')
var DISPOSE = makeSymbol('dispose')
var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
var LRU_LIST = makeSymbol('lruList')
var CACHE = makeSymbol('cache')

function naiveLength () ***REMOVED*** return 1 ***REMOVED***

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) ***REMOVED***
  if (!(this instanceof LRUCache)) ***REMOVED***
    return new LRUCache(options)
  ***REMOVED***

  if (typeof options === 'number') ***REMOVED***
    options = ***REMOVED*** max: options ***REMOVED***
  ***REMOVED***

  if (!options) ***REMOVED***
    options = ***REMOVED******REMOVED***
  ***REMOVED***

  var max = this[MAX] = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) ***REMOVED***
    this[MAX] = Infinity
  ***REMOVED***

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') ***REMOVED***
    lc = naiveLength
  ***REMOVED***
  this[LENGTH_CALCULATOR] = lc

  this[ALLOW_STALE] = options.stale || false
  this[MAX_AGE] = options.maxAge || 0
  this[DISPOSE] = options.dispose
  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
  this.reset()
***REMOVED***

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', ***REMOVED***
  set: function (mL) ***REMOVED***
    if (!mL || !(typeof mL === 'number') || mL <= 0) ***REMOVED***
      mL = Infinity
    ***REMOVED***
    this[MAX] = mL
    trim(this)
  ***REMOVED***,
  get: function () ***REMOVED***
    return this[MAX]
  ***REMOVED***,
  enumerable: true
***REMOVED***)

Object.defineProperty(LRUCache.prototype, 'allowStale', ***REMOVED***
  set: function (allowStale) ***REMOVED***
    this[ALLOW_STALE] = !!allowStale
  ***REMOVED***,
  get: function () ***REMOVED***
    return this[ALLOW_STALE]
  ***REMOVED***,
  enumerable: true
***REMOVED***)

Object.defineProperty(LRUCache.prototype, 'maxAge', ***REMOVED***
  set: function (mA) ***REMOVED***
    if (!mA || !(typeof mA === 'number') || mA < 0) ***REMOVED***
      mA = 0
    ***REMOVED***
    this[MAX_AGE] = mA
    trim(this)
  ***REMOVED***,
  get: function () ***REMOVED***
    return this[MAX_AGE]
  ***REMOVED***,
  enumerable: true
***REMOVED***)

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', ***REMOVED***
  set: function (lC) ***REMOVED***
    if (typeof lC !== 'function') ***REMOVED***
      lC = naiveLength
    ***REMOVED***
    if (lC !== this[LENGTH_CALCULATOR]) ***REMOVED***
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(function (hit) ***REMOVED***
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      ***REMOVED***, this)
    ***REMOVED***
    trim(this)
  ***REMOVED***,
  get: function () ***REMOVED*** return this[LENGTH_CALCULATOR] ***REMOVED***,
  enumerable: true
***REMOVED***)

Object.defineProperty(LRUCache.prototype, 'length', ***REMOVED***
  get: function () ***REMOVED*** return this[LENGTH] ***REMOVED***,
  enumerable: true
***REMOVED***)

Object.defineProperty(LRUCache.prototype, 'itemCount', ***REMOVED***
  get: function () ***REMOVED*** return this[LRU_LIST].length ***REMOVED***,
  enumerable: true
***REMOVED***)

LRUCache.prototype.rforEach = function (fn, thisp) ***REMOVED***
  thisp = thisp || this
  for (var walker = this[LRU_LIST].tail; walker !== null;) ***REMOVED***
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  ***REMOVED***
***REMOVED***

function forEachStep (self, fn, node, thisp) ***REMOVED***
  var hit = node.value
  if (isStale(self, hit)) ***REMOVED***
    del(self, node)
    if (!self[ALLOW_STALE]) ***REMOVED***
      hit = undefined
    ***REMOVED***
  ***REMOVED***
  if (hit) ***REMOVED***
    fn.call(thisp, hit.value, hit.key, self)
  ***REMOVED***
***REMOVED***

LRUCache.prototype.forEach = function (fn, thisp) ***REMOVED***
  thisp = thisp || this
  for (var walker = this[LRU_LIST].head; walker !== null;) ***REMOVED***
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  ***REMOVED***
***REMOVED***

LRUCache.prototype.keys = function () ***REMOVED***
  return this[LRU_LIST].toArray().map(function (k) ***REMOVED***
    return k.key
  ***REMOVED***, this)
***REMOVED***

LRUCache.prototype.values = function () ***REMOVED***
  return this[LRU_LIST].toArray().map(function (k) ***REMOVED***
    return k.value
  ***REMOVED***, this)
***REMOVED***

LRUCache.prototype.reset = function () ***REMOVED***
  if (this[DISPOSE] &&
      this[LRU_LIST] &&
      this[LRU_LIST].length) ***REMOVED***
    this[LRU_LIST].forEach(function (hit) ***REMOVED***
      this[DISPOSE](hit.key, hit.value)
    ***REMOVED***, this)
  ***REMOVED***

  this[CACHE] = new Map() // hash of items by key
  this[LRU_LIST] = new Yallist() // list of items in order of use recency
  this[LENGTH] = 0 // length of items in the list
***REMOVED***

LRUCache.prototype.dump = function () ***REMOVED***
  return this[LRU_LIST].map(function (hit) ***REMOVED***
    if (!isStale(this, hit)) ***REMOVED***
      return ***REMOVED***
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***, this).toArray().filter(function (h) ***REMOVED***
    return h
  ***REMOVED***)
***REMOVED***

LRUCache.prototype.dumpLru = function () ***REMOVED***
  return this[LRU_LIST]
***REMOVED***

LRUCache.prototype.inspect = function (n, opts) ***REMOVED***
  var str = 'LRUCache ***REMOVED***'
  var extras = false

  var as = this[ALLOW_STALE]
  if (as) ***REMOVED***
    str += '\n  allowStale: true'
    extras = true
  ***REMOVED***

  var max = this[MAX]
  if (max && max !== Infinity) ***REMOVED***
    if (extras) ***REMOVED***
      str += ','
    ***REMOVED***
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  ***REMOVED***

  var maxAge = this[MAX_AGE]
  if (maxAge) ***REMOVED***
    if (extras) ***REMOVED***
      str += ','
    ***REMOVED***
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  ***REMOVED***

  var lc = this[LENGTH_CALCULATOR]
  if (lc && lc !== naiveLength) ***REMOVED***
    if (extras) ***REMOVED***
      str += ','
    ***REMOVED***
    str += '\n  length: ' + util.inspect(this[LENGTH], opts)
    extras = true
  ***REMOVED***

  var didFirst = false
  this[LRU_LIST].forEach(function (item) ***REMOVED***
    if (didFirst) ***REMOVED***
      str += ',\n  '
    ***REMOVED*** else ***REMOVED***
      if (extras) ***REMOVED***
        str += ',\n'
      ***REMOVED***
      didFirst = true
      str += '\n  '
    ***REMOVED***
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = ***REMOVED*** value: item.value ***REMOVED***
    if (item.maxAge !== maxAge) ***REMOVED***
      val.maxAge = item.maxAge
    ***REMOVED***
    if (lc !== naiveLength) ***REMOVED***
      val.length = item.length
    ***REMOVED***
    if (isStale(this, item)) ***REMOVED***
      val.stale = true
    ***REMOVED***

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  ***REMOVED***)

  if (didFirst || extras) ***REMOVED***
    str += '\n'
  ***REMOVED***
  str += '***REMOVED***'

  return str
***REMOVED***

LRUCache.prototype.set = function (key, value, maxAge) ***REMOVED***
  maxAge = maxAge || this[MAX_AGE]

  var now = maxAge ? Date.now() : 0
  var len = this[LENGTH_CALCULATOR](value, key)

  if (this[CACHE].has(key)) ***REMOVED***
    if (len > this[MAX]) ***REMOVED***
      del(this, this[CACHE].get(key))
      return false
    ***REMOVED***

    var node = this[CACHE].get(key)
    var item = node.value

    // dispose of the old one before overwriting
    // split out into 2 ifs for better coverage tracking
    if (this[DISPOSE]) ***REMOVED***
      if (!this[NO_DISPOSE_ON_SET]) ***REMOVED***
        this[DISPOSE](key, item.value)
      ***REMOVED***
    ***REMOVED***

    item.now = now
    item.maxAge = maxAge
    item.value = value
    this[LENGTH] += len - item.length
    item.length = len
    this.get(key)
    trim(this)
    return true
  ***REMOVED***

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this[MAX]) ***REMOVED***
    if (this[DISPOSE]) ***REMOVED***
      this[DISPOSE](key, value)
    ***REMOVED***
    return false
  ***REMOVED***

  this[LENGTH] += hit.length
  this[LRU_LIST].unshift(hit)
  this[CACHE].set(key, this[LRU_LIST].head)
  trim(this)
  return true
***REMOVED***

LRUCache.prototype.has = function (key) ***REMOVED***
  if (!this[CACHE].has(key)) return false
  var hit = this[CACHE].get(key).value
  if (isStale(this, hit)) ***REMOVED***
    return false
  ***REMOVED***
  return true
***REMOVED***

LRUCache.prototype.get = function (key) ***REMOVED***
  return get(this, key, true)
***REMOVED***

LRUCache.prototype.peek = function (key) ***REMOVED***
  return get(this, key, false)
***REMOVED***

LRUCache.prototype.pop = function () ***REMOVED***
  var node = this[LRU_LIST].tail
  if (!node) return null
  del(this, node)
  return node.value
***REMOVED***

LRUCache.prototype.del = function (key) ***REMOVED***
  del(this, this[CACHE].get(key))
***REMOVED***

LRUCache.prototype.load = function (arr) ***REMOVED***
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) ***REMOVED***
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) ***REMOVED***
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    ***REMOVED*** else ***REMOVED***
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) ***REMOVED***
        this.set(hit.k, hit.v, maxAge)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

LRUCache.prototype.prune = function () ***REMOVED***
  var self = this
  this[CACHE].forEach(function (value, key) ***REMOVED***
    get(self, key, false)
  ***REMOVED***)
***REMOVED***

function get (self, key, doUse) ***REMOVED***
  var node = self[CACHE].get(key)
  if (node) ***REMOVED***
    var hit = node.value
    if (isStale(self, hit)) ***REMOVED***
      del(self, node)
      if (!self[ALLOW_STALE]) hit = undefined
    ***REMOVED*** else ***REMOVED***
      if (doUse) ***REMOVED***
        self[LRU_LIST].unshiftNode(node)
      ***REMOVED***
    ***REMOVED***
    if (hit) hit = hit.value
  ***REMOVED***
  return hit
***REMOVED***

function isStale (self, hit) ***REMOVED***
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) ***REMOVED***
    return false
  ***REMOVED***
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) ***REMOVED***
    stale = diff > hit.maxAge
  ***REMOVED*** else ***REMOVED***
    stale = self[MAX_AGE] && (diff > self[MAX_AGE])
  ***REMOVED***
  return stale
***REMOVED***

function trim (self) ***REMOVED***
  if (self[LENGTH] > self[MAX]) ***REMOVED***
    for (var walker = self[LRU_LIST].tail;
         self[LENGTH] > self[MAX] && walker !== null;) ***REMOVED***
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function del (self, node) ***REMOVED***
  if (node) ***REMOVED***
    var hit = node.value
    if (self[DISPOSE]) ***REMOVED***
      self[DISPOSE](hit.key, hit.value)
    ***REMOVED***
    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  ***REMOVED***
***REMOVED***

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) ***REMOVED***
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
***REMOVED***
