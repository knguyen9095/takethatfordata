var NotAsync = ***REMOVED******REMOVED*** ;
var asyncExit = /^async[\t ]+(return|throw)/ ;
var asyncFunction = /^async[\t ]+function/ ;
var atomOrPropertyOrLabel = /^\s*[():;]/ ;
var removeComments = /([^\n])\/\*(\*(?!\/)|[^\n*])*\*\/([^\n])/g ;
var matchAsyncGet = /\s*(get|set)\s*\(/ ;

function hasLineTerminatorBeforeNext(st, since) ***REMOVED***
    return st.lineStart >= since;
***REMOVED***

function test(regex,st,noComment) ***REMOVED***
    var src = st.input.slice(st.start) ;
    if (noComment) ***REMOVED***
        src = src.replace(removeComments,"$1 $3") ;
  ***REMOVED***
    return regex.test(src);
***REMOVED***

/* Create a new parser derived from the specified parser, so that in the
 * event of an error we can back out and try again */
function subParse(parser, pos, extensions,parens) ***REMOVED***
    var p = new parser.constructor(parser.options, parser.input, pos);
    if (extensions)
        for (var k in extensions)
            p[k] = extensions[k] ;

    var src = parser ;
    var dest = p ;
    ['inFunction','inAsyncFunction','inAsync','inGenerator','inModule'].forEach(function(k)***REMOVED***
        if (k in src)
            dest[k] = src[k] ;
    ***REMOVED***) ;
    if (parens)
        p.options.preserveParens = true ;
    p.nextToken();
    return p;
***REMOVED***

//TODO: Implement option noAsyncGetters

function asyncAwaitPlugin (parser,options)***REMOVED***
    var es7check = function()***REMOVED******REMOVED*** ;

    parser.extend("initialContext",function(base)***REMOVED***
        return function()***REMOVED***
            if (this.options.ecmaVersion < 7) ***REMOVED***
                es7check = function(node) ***REMOVED***
                    parser.raise(node.start,"async/await keywords only available when ecmaVersion>=7") ;
                ***REMOVED*** ;
            ***REMOVED***
            this.reservedWords = new RegExp(this.reservedWords.toString().replace(/await|async/g,"").replace("|/","/").replace("/|","/").replace("||","|")) ;
            this.reservedWordsStrict = new RegExp(this.reservedWordsStrict.toString().replace(/await|async/g,"").replace("|/","/").replace("/|","/").replace("||","|")) ;
            this.reservedWordsStrictBind = new RegExp(this.reservedWordsStrictBind.toString().replace(/await|async/g,"").replace("|/","/").replace("/|","/").replace("||","|")) ;
            this.inAsyncFunction = options.inAsyncFunction ;
            if (options.awaitAnywhere && options.inAsyncFunction)
                parser.raise(node.start,"The options awaitAnywhere and inAsyncFunction are mutually exclusive") ;

            return base.apply(this,arguments);
        ***REMOVED***
    ***REMOVED***) ;

    parser.extend("shouldParseExportStatement",function(base)***REMOVED***
        return function()***REMOVED***
            if (this.type.label==='name' && this.value==='async' && test(asyncFunction,this)) ***REMOVED***
                return true ;
            ***REMOVED***
            return base.apply(this,arguments) ;
        ***REMOVED***
    ***REMOVED***) ;

    parser.extend("parseStatement",function(base)***REMOVED***
        return function (declaration, topLevel) ***REMOVED***
            var start = this.start;
            var startLoc = this.startLoc;
            if (this.type.label==='name') ***REMOVED***
                if (test(asyncFunction,this,true)) ***REMOVED***
                    var wasAsync = this.inAsyncFunction ;
                    try ***REMOVED***
                        this.inAsyncFunction = true ;
                        this.next() ;
                        var r = this.parseStatement(declaration, topLevel) ;
                        r.async = true ;
                        r.start = start;
                        r.loc && (r.loc.start = startLoc);
                        r.range && (r.range[0] = start);
                        return r ;
                    ***REMOVED*** finally ***REMOVED***
                        this.inAsyncFunction = wasAsync ;
                    ***REMOVED***
                ***REMOVED*** else if ((typeof options==="object" && options.asyncExits) && test(asyncExit,this)) ***REMOVED***
                    // NON-STANDARD EXTENSION iff. options.asyncExits is set, the
                    // extensions 'async return <expr>?' and 'async throw <expr>?'
                    // are enabled. In each case they are the standard ESTree nodes
                    // with the flag 'async:true'
                    this.next() ;
                    var r = this.parseStatement(declaration, topLevel) ;
                    r.async = true ;
                    r.start = start;
                    r.loc && (r.loc.start = startLoc);
                    r.range && (r.range[0] = start);
                   return r ;
                ***REMOVED***
            ***REMOVED***
            return base.apply(this,arguments);
        ***REMOVED***
    ***REMOVED***) ;

  parser.extend("parseIdent",function(base)***REMOVED***
        return function(liberal)***REMOVED***
                var id = base.apply(this,arguments);
                if (this.inAsyncFunction && id.name==='await') ***REMOVED***
                    if (arguments.length===0) ***REMOVED***
                        this.raise(id.start,"'await' is reserved within async functions") ;
                    ***REMOVED***
                ***REMOVED***
                return id ;
        ***REMOVED***
    ***REMOVED***) ;

  parser.extend("parseExprAtom",function(base)***REMOVED***
        return function(refShorthandDefaultPos)***REMOVED***
            var start = this.start ;
            var startLoc = this.startLoc;
            var rhs,r = base.apply(this,arguments);
            if (r.type==='Identifier') ***REMOVED***
                if (r.name==='async' && !hasLineTerminatorBeforeNext(this, r.end)) ***REMOVED***
                    // Is this really an async function?
                    var isAsync = this.inAsyncFunction ;
                    try ***REMOVED***
                        this.inAsyncFunction = true ;
                        var pp = this ;
                        var inBody = false ;

                        var parseHooks = ***REMOVED***
                            parseFunctionBody:function(node,isArrowFunction)***REMOVED***
                                try ***REMOVED***
                                    var wasInBody = inBody ;
                                    inBody = true ;
                                    return pp.parseFunctionBody.apply(this,arguments) ;
                                ***REMOVED*** finally ***REMOVED***
                                    inBody = wasInBody ;
                                ***REMOVED***
                            ***REMOVED***,
                            raise:function()***REMOVED***
                                try ***REMOVED***
                                    return pp.raise.apply(this,arguments) ;
                                ***REMOVED*** catch(ex) ***REMOVED***
                                    throw inBody?ex:NotAsync ;
                                ***REMOVED***
                            ***REMOVED***
                        ***REMOVED*** ;

                        rhs = subParse(this,this.start,parseHooks,true).parseExpression() ;
                        if (rhs.type==='SequenceExpression')
                            rhs = rhs.expressions[0] ;
                        if (rhs.type === 'CallExpression')
                            rhs = rhs.callee ;
                        if (rhs.type==='FunctionExpression' || rhs.type==='FunctionDeclaration' || rhs.type==='ArrowFunctionExpression') ***REMOVED***
                            // Because we don't know if the top level parser supprts preserveParens, we have to re-parse
                            // without it set
                            rhs = subParse(this,this.start,parseHooks).parseExpression() ;
                            if (rhs.type==='SequenceExpression')
                                rhs = rhs.expressions[0] ;
                            if (rhs.type === 'CallExpression')
                                rhs = rhs.callee ;
                            
                            rhs.async = true ;
                            rhs.start = start;
                            rhs.loc && (rhs.loc.start = startLoc);
                            rhs.range && (rhs.range[0] = start);
                            this.pos = rhs.end;
                            this.end = rhs.end ;
                            this.endLoc = rhs.endLoc ;
                            this.next();
                            es7check(rhs) ;
                            return rhs ;
                        ***REMOVED***
                    ***REMOVED*** catch (ex) ***REMOVED***
                        if (ex!==NotAsync)
                            throw ex ;
                    ***REMOVED***
                    finally ***REMOVED***
                        this.inAsyncFunction = isAsync ;
                    ***REMOVED***
                ***REMOVED***
                else if (r.name==='await') ***REMOVED***
                    var n = this.startNodeAt(r.start, r.loc && r.loc.start);
                    if (this.inAsyncFunction) ***REMOVED***
                        rhs = this.parseExprSubscripts() ;
                        n.operator = 'await' ;
                        n.argument = rhs ;
                        n = this.finishNodeAt(n,'AwaitExpression', rhs.end, rhs.loc && rhs.loc.end) ;
                        es7check(n) ;
                        return n ;
                    ***REMOVED***
                    // NON-STANDARD EXTENSION iff. options.awaitAnywhere is true,
                    // an 'AwaitExpression' is allowed anywhere the token 'await'
                    // could not be an identifier with the name 'await'.

                    // Look-ahead to see if this is really a property or label called async or await
                    if (this.input.slice(r.end).match(atomOrPropertyOrLabel)) ***REMOVED***
                        if (!options.awaitAnywhere && this.options.sourceType === 'module')
                            return this.raise(r.start,"'await' is reserved within modules") ;
                        return r ; // This is a valid property name or label
                    ***REMOVED***

                    if (typeof options==="object" && options.awaitAnywhere) ***REMOVED***
                        start = this.start ;
                        rhs = subParse(this,start-4).parseExprSubscripts() ;
                        if (rhs.end<=start) ***REMOVED***
                            rhs = subParse(this,start).parseExprSubscripts() ;
                            n.operator = 'await' ;
                            n.argument = rhs ;
                            n = this.finishNodeAt(n,'AwaitExpression', rhs.end, rhs.loc && rhs.loc.end) ;
                            this.pos = rhs.end;
                            this.end = rhs.end ;
                            this.endLoc = rhs.endLoc ;
                            this.next();
                            es7check(n) ;
                            return n ;
                        ***REMOVED***
                    ***REMOVED***

                    if (!options.awaitAnywhere && this.options.sourceType === 'module')
                        return this.raise(r.start,"'await' is reserved within modules") ;
                ***REMOVED***
            ***REMOVED***
            return r ;
        ***REMOVED***
    ***REMOVED***) ;

    parser.extend('finishNodeAt',function(base)***REMOVED***
            return function(node,type,pos,loc) ***REMOVED***
                if (node.__asyncValue) ***REMOVED***
                    delete node.__asyncValue ;
                    node.value.async = true ;
                ***REMOVED***
                return base.apply(this,arguments) ;
            ***REMOVED***
    ***REMOVED***) ;

    parser.extend('finishNode',function(base)***REMOVED***
            return function(node,type) ***REMOVED***
                if (node.__asyncValue) ***REMOVED***
                    delete node.__asyncValue ;
                    node.value.async = true ;
                ***REMOVED***
                return base.apply(this,arguments) ;
            ***REMOVED***
    ***REMOVED***) ;

    var allowedPropSpecifiers = ***REMOVED***
        get:true,
        set:true,
        async:true
    ***REMOVED***;
    
    parser.extend("parsePropertyName",function(base)***REMOVED***
        return function (prop) ***REMOVED***
            var prevName = prop.key && prop.key.name ;
            var key = base.apply(this,arguments) ;
            if (key.type === "Identifier" && (key.name === "async") && !hasLineTerminatorBeforeNext(this, key.end)) ***REMOVED***
                // Look-ahead to see if this is really a property or label called async or await
                if (!this.input.slice(key.end).match(atomOrPropertyOrLabel))***REMOVED***
                    // Cheese - eliminate the cases 'async get()***REMOVED******REMOVED***' and async set()***REMOVED******REMOVED***'
                    if (matchAsyncGet.test(this.input.slice(key.end))) ***REMOVED***
                        key = base.apply(this,arguments) ;
                        prop.__asyncValue = true ;
                    ***REMOVED*** else ***REMOVED***
                        es7check(prop) ;
                        if (prop.kind === 'set') 
                            this.raise(key.start,"'set <member>(value)' cannot be be async") ;
                        
                        key = base.apply(this,arguments) ;
                        if (key.type==='Identifier') ***REMOVED***
                            if (key.name==='set')
                                this.raise(key.start,"'set <member>(value)' cannot be be async") ;
                        ***REMOVED***
                        prop.__asyncValue = true ;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return key;
        ***REMOVED***;
    ***REMOVED***) ;

    parser.extend("parseClassMethod",function(base)***REMOVED***
        return function (classBody, method, isGenerator) ***REMOVED***
            var wasAsync ;
            if (method.__asyncValue) ***REMOVED***
                if (method.kind==='constructor')
                    this.raise(method.start,"class constructor() cannot be be async") ;
                wasAsync = this.inAsyncFunction ;
                this.inAsyncFunction = true ;
            ***REMOVED***
            var r = base.apply(this,arguments) ;
            this.inAsyncFunction = wasAsync ;
            return r ;
        ***REMOVED***
    ***REMOVED***) ;

    parser.extend("parseMethod",function(base)***REMOVED***
        return function (isGenerator) ***REMOVED***
            var wasAsync ;
            if (this.__currentProperty && this.__currentProperty.__asyncValue) ***REMOVED***
                wasAsync = this.inAsyncFunction ;
                this.inAsyncFunction = true ;
            ***REMOVED***
            var r = base.apply(this,arguments) ;
            this.inAsyncFunction = wasAsync ;
            return r ;
        ***REMOVED***
    ***REMOVED***) ;

    parser.extend("parsePropertyValue",function(base)***REMOVED***
        return function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) ***REMOVED***
            var prevProp = this.__currentProperty ; 
            this.__currentProperty = prop ;
            var wasAsync ;
            if (prop.__asyncValue) ***REMOVED***
                wasAsync = this.inAsyncFunction ;
                this.inAsyncFunction = true ;
            ***REMOVED***
            var r = base.apply(this,arguments) ;
            this.inAsyncFunction = wasAsync ;
            this.__currentProperty = prevProp ;
            return r ;
        ***REMOVED***
    ***REMOVED***) ;
***REMOVED***

module.exports = asyncAwaitPlugin ;
