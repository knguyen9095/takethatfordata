'use strict';

var acorn = require('acorn');
require('../')(acorn);
var estraverse = require('estraverse');
var xtend = require('xtend');
var assert = require('assert');

function find (type, ast, skip) ***REMOVED***
  skip = skip || 0;
  var skipped = 0;

  var found;

  estraverse.traverse(ast, ***REMOVED***
    enter: (node) => ***REMOVED***
      if (found) ***REMOVED***
        return estraverse.VisitorOption.Skip;
      ***REMOVED***
      if (node.type == type) ***REMOVED***
        if (skipped === skip) ***REMOVED***
          found = node;
          return estraverse.VisitorOption.Skip;
        ***REMOVED***
        skipped++;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  if (!found) ***REMOVED***
    throw new Error('did not find AwaitExpression (skipped ' + skipped + '/' + skip + ')');
  ***REMOVED***

  return found;
***REMOVED***

function extendOptions(pluginOptions, acornOptions) ***REMOVED***
  return xtend(***REMOVED***
    sourceType: 'module',
    ecmaVersion: 8,
    locations: true,
    ranges: true,
    plugins: ***REMOVED***asyncawait: pluginOptions || pluginOptions !== false***REMOVED***
  ***REMOVED***, acornOptions);
***REMOVED***

function parse(code, pluginOptions, acornOptions) ***REMOVED***
  if (Array.isArray(code)) ***REMOVED***
    code = code.join('\n');
  ***REMOVED***
  var options = extendOptions(pluginOptions, acornOptions);
  return acorn.parse(code, options);
***REMOVED***

describe('async', () => ***REMOVED***
  describe ('function declaration', () => ***REMOVED***
    var node;

    describe('-', () => ***REMOVED***
      beforeEach(() => ***REMOVED***
        node = find(
          'FunctionDeclaration',
          parse([
            'async function foo() ***REMOVED***',
            '  x = await bar()',
            '***REMOVED***'
          ])
        );
      ***REMOVED***);

      it('marks the node as async', () =>
        assert(node.async)
      );

      it('finds correct start position', () =>
        assert.strictEqual(node.start, 0)
      );

      it('finds correct end position', () =>
        assert.strictEqual(node.end, 42)
      );

      it('finds correct start line/column', () =>
        assert.deepEqual(node.loc.start, ***REMOVED***
          line: 1,
          column: 0
        ***REMOVED***)
      );

      it('finds correct end line/column', () =>
        assert.deepEqual(node.loc.end, ***REMOVED***
          line: 3,
          column: 1
        ***REMOVED***)
      );
    ***REMOVED***);

    var assertFindsIdentifierExpressionStatement = (ast) => ***REMOVED***
      node = find('ExpressionStatement', ast);
      assert.strictEqual(node.expression.type, 'Identifier');
      assert.strictEqual(node.expression.name, 'async');
      assert.deepEqual(node.expression.loc, ***REMOVED***
        start: ***REMOVED***
          line: 1,
          column: 0
        ***REMOVED***,
        end: ***REMOVED***
          line: 1,
          column: 5
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***;

    describe('linefeed after async (simple)', () => ***REMOVED***
      var ast;
      beforeEach(() => ***REMOVED***
        ast = parse([
          'async \t\t  ',
          'function foo() ***REMOVED***',
          '***REMOVED***'
        ]);
      ***REMOVED***);

      it('finds Identifier ExpressionStatement', () => ***REMOVED***
        assertFindsIdentifierExpressionStatement(ast);
      ***REMOVED***);

      it('does not mark FunctionDeclaration as async', () => ***REMOVED***
        node = find('FunctionDeclaration', ast);
        assert(!node.async, 'Expected node.async to be false');
      ***REMOVED***);
    ***REMOVED***);

    describe('linefeed after async (single line comment)', () => ***REMOVED***
      var ast;
      beforeEach(() => ***REMOVED***
        ast = parse([
          'async // flag enables async completion',
          'function foo() ***REMOVED***',
          '***REMOVED***'
        ]);
      ***REMOVED***);

      it('finds Identifier ExpressionStatement', () => ***REMOVED***
        assertFindsIdentifierExpressionStatement(ast);
      ***REMOVED***);

      it('does not mark FunctionDeclaration as async', () => ***REMOVED***
        node = find('FunctionDeclaration', ast);
        assert(!node.async, 'Expected node.async to be false');
      ***REMOVED***);
    ***REMOVED***);

    describe('linefeed after async (multiline comment) function', () => ***REMOVED***
      var ast;
      beforeEach(() => ***REMOVED***
        ast = parse([
          'async /* flag enables async completion',
          '         of the callback */function foo() ***REMOVED***',
          '***REMOVED***'
        ]);
      ***REMOVED***);

      it('finds Identifier ExpressionStatement', () => ***REMOVED***
        assertFindsIdentifierExpressionStatement(ast);
      ***REMOVED***);

      it('does not mark FunctionDeclaration as async', () => ***REMOVED***
        node = find('FunctionDeclaration', ast);
        assert(!node.async, 'Expected node.async to be false');
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);

  describe ('function expression', () => ***REMOVED***
    var node, code;

    describe('-', () => ***REMOVED***
      beforeEach(() => ***REMOVED***
        code = [
          'foo = async function () ***REMOVED***',
          '  x = await bar()',
          '***REMOVED***'
        ];
        node = find(
          'FunctionExpression',
          parse(code)
        );
      ***REMOVED***);

      it('marks the node as async', () =>
        assert(node.async)
      );

      it('finds correct start position', () =>
        assert.strictEqual(node.start, 6)
      );

      it('finds correct end position', () =>
        assert.strictEqual(node.end, code.join('\n').length)
      );

      it('finds correct start line/column', () =>
        assert.deepEqual(node.loc.start, ***REMOVED***
          line: 1,
          column: 6
        ***REMOVED***)
      );

      it('finds correct end line/column', () =>
        assert.deepEqual(node.loc.end, ***REMOVED***
          line: 3,
          column: 1
        ***REMOVED***)
      );
    ***REMOVED***);

    var assertFindsIdentifierAssignmentExpressionRHS = (ast) => ***REMOVED***
      node = find('AssignmentExpression', ast);
      assert.strictEqual(node.right.type, 'Identifier');
      assert.strictEqual(node.right.name, 'async');
      assert.deepEqual(node.right.loc, ***REMOVED***
        start: ***REMOVED***
          line: 1,
          column: 6
        ***REMOVED***,
        end: ***REMOVED***
          line: 1,
          column: 11
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***;

    describe('linefeed after async (simple)', () => ***REMOVED***
      var ast;
      beforeEach(() => ***REMOVED***
        ast = parse([
          'foo = async \t\t  ',
          ', function() ***REMOVED***',
          '***REMOVED***'
        ]);
      ***REMOVED***);

      it('finds Identifier ExpressionStatement', () => ***REMOVED***
        assertFindsIdentifierAssignmentExpressionRHS(ast);
      ***REMOVED***);

      it('does not mark FunctionExpression as async', () => ***REMOVED***
        node = find('FunctionExpression', ast);
        assert(!node.async, 'Expected node.async to be false');
      ***REMOVED***);
    ***REMOVED***);

    describe('linefeed after async (single line comment)', () => ***REMOVED***
      var ast;
      beforeEach(() => ***REMOVED***
        ast = parse([
          'foo = async // flag enables async completion',
          ', function() ***REMOVED***',
          '***REMOVED***'
        ]);
      ***REMOVED***);

      it('finds Identifier ExpressionStatement', () => ***REMOVED***
        assertFindsIdentifierAssignmentExpressionRHS(ast);
      ***REMOVED***);

      it('does not mark FunctionExpression as async', () => ***REMOVED***
        node = find('FunctionExpression', ast);
        assert(!node.async, 'Expected node.async to be false');
      ***REMOVED***);
    ***REMOVED***);

    describe('linefeed after async (multiline comment), function', () => ***REMOVED***
      var ast;
      beforeEach(() => ***REMOVED***
        ast = parse([
          'foo = async /* flag enables async completion',
          '         of the callback */, function() ***REMOVED***',
          '***REMOVED***'
        ]);
      ***REMOVED***);

      it('finds Identifier ExpressionStatement', () => ***REMOVED***
        assertFindsIdentifierAssignmentExpressionRHS(ast);
      ***REMOVED***);

      it('does not mark FunctionExpression as async', () => ***REMOVED***
        node = find('FunctionExpression', ast);
        assert(!node.async, 'Expected node.async to be false');
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);

  describe ('enhanced object literal', () => ***REMOVED***
    var node, code;

    describe('-', () => ***REMOVED***
      beforeEach(() => ***REMOVED***
        code = [
          'var x = ***REMOVED***',
          '  async foo() ***REMOVED******REMOVED***',
          '***REMOVED***;'
        ];
        node = find(
          // TODO: Is it really supposed to mark the Property async? Why not the FunctionExpression?
          'Property',
          parse(code)
        );
      ***REMOVED***);

      it('marks the node value as async', () =>
          assert(node.value.async)
      );

      it('does not mark the node as async', () =>
          assert(!node.async)
      );

      it('finds correct start position', () =>
          assert.strictEqual(node.start, 12)
      );

      it('finds correct end position', () =>
          assert.strictEqual(node.end, code[0].length + code[1].length + 1) // + 1 is due to newline char
      );

      it('finds correct start line/column', () =>
          assert.deepEqual(node.loc.start, ***REMOVED***
            line: 2,
            column: 2
          ***REMOVED***)
      );

      it('finds correct end line/column', () =>
          assert.deepEqual(node.loc.end, ***REMOVED***
            line: 2,
            column: 16
          ***REMOVED***)
      );
    ***REMOVED***);

    describe('linefeed after async (simple)', () => ***REMOVED***
      it('fails to parse', () => ***REMOVED***
        assert.throws(() => parse([
          'var x = ***REMOVED***',
          '  async \t\t  ',
          '  foo() ***REMOVED******REMOVED***',
          '***REMOVED***;'
        ]));
      ***REMOVED***);
    ***REMOVED***);

    describe('linefeed after async (single line comment)', () => ***REMOVED***
      it('fails to parse', () => ***REMOVED***
        assert.throws(() => parse([
          'var x = ***REMOVED***',
          '  async // flag enables async completion',
          '  foo() ***REMOVED******REMOVED***',
          '***REMOVED***;'
        ]));
      ***REMOVED***);
    ***REMOVED***);

    describe('linefeed after async (multiline comment) illegal decl', () => ***REMOVED***
      it('finds Identifier ExpressionStatement', () => ***REMOVED***
        assert.throws(() => parse([
          'var x = ***REMOVED***',
          '  async /* flag enables async completion',
          '         of the callback */ foo() ***REMOVED******REMOVED***',
          '***REMOVED***;'
        ]));
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);

  describe ('ArrowFunctionExpression', () => ***REMOVED***
    var node, code;

    describe('-', () => ***REMOVED***
      beforeEach(() => ***REMOVED***
        code = 'var x = async () => ***REMOVED******REMOVED***';
        node = find(
          'ArrowFunctionExpression',
          parse(code)
        );
      ***REMOVED***);

      it('marks the node as async', () =>
          assert(node.async)
      );

      it('finds correct start position', () =>
          assert.strictEqual(node.start, 8)
      );

      it('finds correct end position', () =>
          assert.strictEqual(node.end, code.length)
      );

      it('finds correct start line/column', () =>
          assert.deepEqual(node.loc.start, ***REMOVED***
            line: 1,
            column: 8
          ***REMOVED***)
      );

      it('finds correct end line/column', () =>
          assert.deepEqual(node.loc.end, ***REMOVED***
            line: 1,
            column: code.length
          ***REMOVED***)
      );
    ***REMOVED***);

    describe('linefeed after async (simple)', () => ***REMOVED***
      var ast;
      beforeEach(() => ***REMOVED***
        ast = parse([
          'var x = async \t\t  ',
          '()'
        ]);
      ***REMOVED***);

      it('fails to parse if linefeed preceeds arrow arguments', () => ***REMOVED***
        assert.throws(() => parse([
          'var x = async \t\t  ',
          '() => ***REMOVED******REMOVED***'
        ]));
      ***REMOVED***);

      it('finds CallExpression with "async" Identifier callee', () => ***REMOVED***
        node = find('CallExpression', ast);
        assert.strictEqual(node.callee.type, 'Identifier');
        assert.strictEqual(node.callee.name, 'async');
        assert.deepEqual(node.callee.loc, ***REMOVED***
          start: ***REMOVED***
            line: 1,
            column: 8
          ***REMOVED***,
          end: ***REMOVED***
            line: 1,
            column: 13
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);

    describe('linefeed after async (single line comment)', () => ***REMOVED***
      var ast;
      beforeEach(() => ***REMOVED***
        ast = parse([
          'var x = async // flag enables async completion',
          '()'
        ]);
      ***REMOVED***);

      it('fails to parse if linefeed preceeds arrow arguments', () => ***REMOVED***
        assert.throws(() => parse([
          'var x = async \t\t  ',
          '() => ***REMOVED******REMOVED***'
        ]));
      ***REMOVED***);

      it('finds CallExpression with "async" Identifier callee', () => ***REMOVED***
        node = find('CallExpression', ast);
        assert.strictEqual(node.callee.type, 'Identifier');
        assert.strictEqual(node.callee.name, 'async');
        assert.deepEqual(node.callee.loc, ***REMOVED***
          start: ***REMOVED***
            line: 1,
            column: 8
          ***REMOVED***,
          end: ***REMOVED***
            line: 1,
            column: 13
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);

    describe('linefeed after async (multiline comment) arrow decl', () => ***REMOVED***
      var ast;
      beforeEach(() => ***REMOVED***
        ast = parse([
          'var x = async /* flag enables async completion',
          '         of the callback */()'
        ]);
      ***REMOVED***);

      it('fails to parse if linefeed preceeds arrow arguments', () => ***REMOVED***
        assert.throws(() => parse([
          'var x = async /* flag enables async completion',
          '         of the callback */() => ***REMOVED******REMOVED***'
        ]));
      ***REMOVED***);

      it('finds CallExpression with "async" Identifier callee', () => ***REMOVED***
        node = find('CallExpression', ast);
        assert.strictEqual(node.callee.type, 'Identifier');
        assert.strictEqual(node.callee.name, 'async');
        assert.deepEqual(node.callee.loc, ***REMOVED***
          start: ***REMOVED***
            line: 1,
            column: 8
          ***REMOVED***,
          end: ***REMOVED***
            line: 1,
            column: 13
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***);

describe('await', () => ***REMOVED***
  describe('-', () => ***REMOVED***
    var node;

    beforeEach(() => ***REMOVED***
      node = find(
        'AwaitExpression',
        parse([
          'async function foo() ***REMOVED***',
          '  x = await bar()',
          '***REMOVED***'
        ])
      );
    ***REMOVED***);

    it('finds correct start position', () =>
      assert.strictEqual(node.start, 29)
    );

    it('finds correct end position', () =>
      assert.strictEqual(node.end, 40)
    );

    it('finds correct start line/column', () =>
      assert.deepEqual(node.loc.start, ***REMOVED***
        line: 2,
        column: 6
      ***REMOVED***)
    );

    it('finds correct end line/column', () =>
      assert.deepEqual(node.loc.end, ***REMOVED***
        line: 2,
        column: 17
      ***REMOVED***)
    );
  ***REMOVED***);

  describe('outside a function (awaitAnywhere)', () => ***REMOVED***
    var node;

    beforeEach(() => ***REMOVED***
      node = find(
        'AwaitExpression',
        parse(
          'x = await bar()',
          ***REMOVED***awaitAnywhere:true***REMOVED***
        )
      );
    ***REMOVED***);

    it('finds correct start position', () =>
      assert.strictEqual(node.start, 4)
    );

    it('finds correct start line/column', () =>
      assert.deepEqual(node.loc.start, ***REMOVED***
        line: 1,
        column: 4
      ***REMOVED***)
    );

    it('finds correct end position', () =>
      assert.strictEqual(node.end, 15)
    );

    it('finds correct end line/column', () =>
      assert.deepEqual(node.loc.end, ***REMOVED***
        line: 1,
        column: 15
      ***REMOVED***)
    );
  ***REMOVED***);
***REMOVED***);
