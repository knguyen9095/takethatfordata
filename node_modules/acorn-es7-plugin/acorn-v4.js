var asyncExit = /^async[\t ]+(return|throw)/ ;
var atomOrPropertyOrLabel = /^\s*[):;]/ ;
var removeComments = /([^\n])\/\*(\*(?!\/)|[^\n*])*\*\/([^\n])/g ;

function hasLineTerminatorBeforeNext(st, since) ***REMOVED***
    return st.lineStart >= since;
***REMOVED***

function test(regex,st,noComment) ***REMOVED***
    var src = st.input.slice(st.start) ;
    if (noComment) ***REMOVED***
        src = src.replace(removeComments,"$1 $3") ;
    ***REMOVED***
    return regex.test(src);
***REMOVED***

/* Create a new parser derived from the specified parser, so that in the
 * event of an error we can back out and try again */
function subParse(parser, pos, extensions) ***REMOVED***
    var p = new parser.constructor(parser.options, parser.input, pos);
    if (extensions)
        for (var k in extensions)
            p[k] = extensions[k] ;

    var src = parser ;
    var dest = p ;
    ['inFunction','inAsync','inGenerator','inModule'].forEach(function(k)***REMOVED***
        if (k in src)
            dest[k] = src[k] ;
    ***REMOVED***) ;
    p.nextToken();
    return p;
***REMOVED***

function asyncAwaitPlugin (parser,options)***REMOVED***
    if (!options || typeof options !== "object")
        options = ***REMOVED******REMOVED*** ;

    parser.extend("parse",function(base)***REMOVED***
        return function()***REMOVED***
            this.inAsync = options.inAsyncFunction ;
            if (options.awaitAnywhere && options.inAsyncFunction)
                parser.raise(node.start,"The options awaitAnywhere and inAsyncFunction are mutually exclusive") ;

            return base.apply(this,arguments);
        ***REMOVED***
    ***REMOVED***) ;

    parser.extend("parseStatement",function(base)***REMOVED***
        return function (declaration, topLevel) ***REMOVED***
            var start = this.start;
            var startLoc = this.startLoc;
            if (this.type.label==='name') ***REMOVED***
                if ((options.asyncExits) && test(asyncExit,this)) ***REMOVED***
                    // TODO: Ensure this function is itself nested in an async function or Method
                    this.next() ;

                    var r = this.parseStatement(declaration, topLevel) ;
                    r.async = true ;
                    r.start = start;
                    r.loc && (r.loc.start = startLoc);
                    r.range && (r.range[0] = start);
                    return r ;
                ***REMOVED***
            ***REMOVED***
            return base.apply(this,arguments);
        ***REMOVED***
    ***REMOVED***) ;

    parser.extend("parseIdent",function(base)***REMOVED***
        return function(liberal) ***REMOVED***
            if (this.options.sourceType==='module' && this.options.ecmaVersion >= 8 && options.awaitAnywhere)
                return base.call(this,true) ; // Force liberal mode if awaitAnywhere is set
            return base.apply(this,arguments) ;
        ***REMOVED***
    ***REMOVED***) ;

    parser.extend("parseExprAtom",function(base)***REMOVED***
        var NotAsync = ***REMOVED******REMOVED***;
        return function(refShorthandDefaultPos)***REMOVED***
            var start = this.start ;
            var startLoc = this.startLoc;

            var rhs,r = base.apply(this,arguments);

            if (r.type==='Identifier') ***REMOVED***
                if (r.name==='await' && !this.inAsync) ***REMOVED***
                    if (options.awaitAnywhere) ***REMOVED***
                        var n = this.startNodeAt(r.start, r.loc && r.loc.start);

                        start = this.start ;

                        var parseHooks = ***REMOVED***
                            raise:function()***REMOVED***
                                try ***REMOVED***
                                    return pp.raise.apply(this,arguments) ;
                                ***REMOVED*** catch(ex) ***REMOVED***
                                    throw /*inBody?ex:*/NotAsync ;
                                ***REMOVED***
                            ***REMOVED***
                        ***REMOVED*** ;

                        try ***REMOVED***
                            rhs = subParse(this,start-4,parseHooks).parseExprSubscripts() ;
                            if (rhs.end<=start) ***REMOVED***
                                rhs = subParse(this,start,parseHooks).parseExprSubscripts() ;
                                n.argument = rhs ;
                                n = this.finishNodeAt(n,'AwaitExpression', rhs.end, rhs.loc && rhs.loc.end) ;
                                this.pos = rhs.end;
                                this.end = rhs.end ;
                                this.endLoc = rhs.endLoc ;
                                this.next();
                                return n ;
                            ***REMOVED***
                        ***REMOVED*** catch (ex) ***REMOVED***
                            if (ex===NotAsync)
                                return r ;
                            throw ex ;
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return r ;
        ***REMOVED***
    ***REMOVED***) ;

    var allowedPropValues = ***REMOVED***
        undefined:true,
        get:true,
        set:true,
        static:true,
        async:true,
        constructor:true
    ***REMOVED***;
    parser.extend("parsePropertyName",function(base)***REMOVED***
        return function (prop) ***REMOVED***
            var prevName = prop.key && prop.key.name ;
            var key = base.apply(this,arguments) ;
            if (this.value==='get') ***REMOVED***
                prop.__maybeStaticAsyncGetter = true ;
            ***REMOVED***
            var next ;
            if (allowedPropValues[this.value])
                return key ;

            if (key.type === "Identifier" && (key.name === "async" || prevName === "async") && !hasLineTerminatorBeforeNext(this, key.end) 
                // Look-ahead to see if this is really a property or label called async or await
                && !this.input.slice(key.end).match(atomOrPropertyOrLabel)) ***REMOVED***
                if (prop.kind === 'set' || key.name === 'set') 
                    this.raise(key.start,"'set <member>(value)' cannot be be async") ;
                else ***REMOVED***
                    this.__isAsyncProp = true ;
                    key = base.apply(this,arguments) ;
                    if (key.type==='Identifier') ***REMOVED***
                        if (key.name==='set')
                            this.raise(key.start,"'set <member>(value)' cannot be be async") ;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                delete prop.__maybeStaticAsyncGetter ;
            ***REMOVED***
            return key;
        ***REMOVED***;
    ***REMOVED***) ;

    parser.extend("parseClassMethod",function(base)***REMOVED***
        return function (classBody, method, isGenerator) ***REMOVED***
            var r = base.apply(this,arguments) ;
            if (method.__maybeStaticAsyncGetter) ***REMOVED***
                delete method.__maybeStaticAsyncGetter ;
                if (method.key.name!=='get')
                    method.kind = "get" ;
            ***REMOVED***
            return r ;
        ***REMOVED***
    ***REMOVED***) ;


    parser.extend("parseFunctionBody",function(base)***REMOVED***
        return function (node, isArrowFunction) ***REMOVED***
            var wasAsync = this.inAsync ;
            if (this.__isAsyncProp) ***REMOVED***
                node.async = true ;
                this.inAsync = true ;
                delete this.__isAsyncProp ;
            ***REMOVED***
            var r = base.apply(this,arguments) ;
            this.inAsync = wasAsync ;
            return r ;
        ***REMOVED***
    ***REMOVED***) ;
***REMOVED***

module.exports = asyncAwaitPlugin ;
