'use strict';

var typeOf = require('kind-of');
var utils = module.exports;

/**
 * Returns true if the given value is a node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * console.log(utils.isNode(node)); //=> true
 * console.log(utils.isNode(***REMOVED******REMOVED***)); //=> false
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @returns ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.isNode = function(node) ***REMOVED***
  return typeOf(node) === 'object' && node.isNode === true;
***REMOVED***;

/**
 * Emit an empty string for the given `node`.
 *
 * ```js
 * // do nothing for beginning-of-string
 * snapdragon.compiler.set('bos', utils.noop);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @returns ***REMOVED***undefined***REMOVED***
 * @api public
 */

utils.noop = function(node) ***REMOVED***
  append(this, '', node);
***REMOVED***;

/**
 * Appdend `node.val` to `compiler.output`, exactly as it was created
 * by the parser.
 *
 * ```js
 * snapdragon.compiler.set('text', utils.identity);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @returns ***REMOVED***undefined***REMOVED***
 * @api public
 */

utils.identity = function(node) ***REMOVED***
  append(this, node.val, node);
***REMOVED***;

/**
 * Previously named `.emit`, this method appends the given `val`
 * to `compiler.output` for the given node. Useful when you know
 * what value should be appended advance, regardless of the actual
 * value of `node.val`.
 *
 * ```js
 * snapdragon.compiler
 *   .set('i', function(node) ***REMOVED***
 *     this.mapVisit(node);
 *   ***REMOVED***)
 *   .set('i.open', utils.append('<i>'))
 *   .set('i.close', utils.append('</i>'))
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @returns ***REMOVED***Function***REMOVED*** Returns a compiler middleware function.
 * @api public
 */

utils.append = function(val) ***REMOVED***
  return function(node) ***REMOVED***
    append(this, val, node);
  ***REMOVED***;
***REMOVED***;

/**
 * Used in compiler middleware, this onverts an AST node into
 * an empty `text` node and deletes `node.nodes` if it exists.
 * The advantage of this method is that, as opposed to completely
 * removing the node, indices will not need to be re-calculated
 * in sibling nodes, and nothing is appended to the output.
 *
 * ```js
 * utils.toNoop(node);
 * // convert `node.nodes` to the given value instead of deleting it
 * utils.toNoop(node, []);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***Array***REMOVED*** `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.
 * @api public
 */

utils.toNoop = function(node, nodes) ***REMOVED***
  if (nodes) ***REMOVED***
    node.nodes = nodes;
  ***REMOVED*** else ***REMOVED***
    delete node.nodes;
    node.type = 'text';
    node.val = '';
  ***REMOVED***
***REMOVED***;

/**
 * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon
 * automatically calls registered compilers, this allows you to pass a visitor
 * function.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) ***REMOVED***
 *   utils.visit(node, function(childNode) ***REMOVED***
 *     // do stuff with "childNode"
 *     return childNode;
 *   ***REMOVED***);
 * ***REMOVED***);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***Function***REMOVED*** `fn`
 * @return ***REMOVED***Object***REMOVED*** returns the node after recursively visiting all child nodes.
 * @api public
 */

utils.visit = function(node, fn) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(fn), 'expected a visitor function');
  fn(node);
  return node.nodes ? utils.mapVisit(node, fn) : node;
***REMOVED***;

/**
 * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by
 * [visit](#visit), use this method if you do not want `fn` to be called on
 * the first node.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) ***REMOVED***
 *   utils.mapVisit(node, function(childNode) ***REMOVED***
 *     // do stuff with "childNode"
 *     return childNode;
 *   ***REMOVED***);
 * ***REMOVED***);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @param ***REMOVED***Function***REMOVED*** `fn`
 * @return ***REMOVED***Object***REMOVED*** returns the node
 * @api public
 */

utils.mapVisit = function(node, fn) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isArray(node.nodes), 'expected node.nodes to be an array');
  assert(isFunction(fn), 'expected a visitor function');

  for (var i = 0; i < node.nodes.length; i++) ***REMOVED***
    utils.visit(node.nodes[i], fn);
  ***REMOVED***
  return node;
***REMOVED***;

/**
 * Unshift an `*.open` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) ***REMOVED***
 *   var match = this.match(/^***REMOVED***/);
 *   if (match) ***REMOVED***
 *     var parent = new Node(***REMOVED***type: 'brace'***REMOVED***);
 *     utils.addOpen(parent, Node);
 *     console.log(parent.nodes[0]):
 *     // ***REMOVED*** type: 'brace.open', val: '' ***REMOVED***;
 *
 *     // push the parent "brace" node onto the stack
 *     this.push(parent);
 *
 *     // return the parent node, so it's also added to the AST
 *     return brace;
 *   ***REMOVED***
 * ***REMOVED***);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***Function***REMOVED*** `Node` (required) Node constructor function from [snapdragon-node][].
 * @param ***REMOVED***Function***REMOVED*** `filter` Optionaly specify a filter function to exclude the node.
 * @return ***REMOVED***Object***REMOVED*** Returns the created opening node.
 * @api public
 */

utils.addOpen = function(node, Node, val, filter) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') ***REMOVED***
    filter = val;
    val = '';
  ***REMOVED***

  if (typeof filter === 'function' && !filter(node)) return;
  var open = new Node(***REMOVED*** type: node.type + '.open', val: val***REMOVED***);
  var unshift = node.unshift || node.unshiftNode;
  if (typeof unshift === 'function') ***REMOVED***
    unshift.call(node, open);
  ***REMOVED*** else ***REMOVED***
    utils.unshiftNode(node, open);
  ***REMOVED***
  return open;
***REMOVED***;

/**
 * Push a `*.close` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) ***REMOVED***
 *   var match = this.match(/^***REMOVED***/);
 *   if (match) ***REMOVED***
 *     var parent = this.parent();
 *     if (parent.type !== 'brace') ***REMOVED***
 *       throw new Error('missing opening: ' + '***REMOVED***');
 *     ***REMOVED***
 *
 *     utils.addClose(parent, Node);
 *     console.log(parent.nodes[parent.nodes.length - 1]):
 *     // ***REMOVED*** type: 'brace.close', val: '' ***REMOVED***;
 *
 *     // no need to return a node, since the parent
 *     // was already added to the AST
 *     return;
 *   ***REMOVED***
 * ***REMOVED***);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***Function***REMOVED*** `Node` (required) Node constructor function from [snapdragon-node][].
 * @param ***REMOVED***Function***REMOVED*** `filter` Optionaly specify a filter function to exclude the node.
 * @return ***REMOVED***Object***REMOVED*** Returns the created closing node.
 * @api public
 */

utils.addClose = function(node, Node, val, filter) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') ***REMOVED***
    filter = val;
    val = '';
  ***REMOVED***

  if (typeof filter === 'function' && !filter(node)) return;
  var close = new Node(***REMOVED*** type: node.type + '.close', val: val***REMOVED***);
  var push = node.push || node.pushNode;
  if (typeof push === 'function') ***REMOVED***
    push.call(node, close);
  ***REMOVED*** else ***REMOVED***
    utils.pushNode(node, close);
  ***REMOVED***
  return close;
***REMOVED***;

/**
 * Wraps the given `node` with `*.open` and `*.close` nodes.
 *
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***Function***REMOVED*** `Node` (required) Node constructor function from [snapdragon-node][].
 * @param ***REMOVED***Function***REMOVED*** `filter` Optionaly specify a filter function to exclude the node.
 * @return ***REMOVED***Object***REMOVED*** Returns the node
 * @api public
 */

utils.wrapNodes = function(node, Node, filter) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  utils.addOpen(node, Node, filter);
  utils.addClose(node, Node, filter);
  return node;
***REMOVED***;

/**
 * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var node = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * utils.pushNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param ***REMOVED***Object***REMOVED*** `parent`
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Object***REMOVED*** Returns the child node
 * @api public
 */

utils.pushNode = function(parent, node) ***REMOVED***
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.push(node);
  return node;
***REMOVED***;

/**
 * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var node = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * utils.unshiftNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param ***REMOVED***Object***REMOVED*** `parent`
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***undefined***REMOVED***
 * @api public
 */

utils.unshiftNode = function(parent, node) ***REMOVED***
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.unshift(node);
***REMOVED***;

/**
 * Pop the last `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * utils.pushNode(parent, new Node(***REMOVED***type: 'foo'***REMOVED***));
 * utils.pushNode(parent, new Node(***REMOVED***type: 'bar'***REMOVED***));
 * utils.pushNode(parent, new Node(***REMOVED***type: 'baz'***REMOVED***));
 * console.log(parent.nodes.length); //=> 3
 * utils.popNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param ***REMOVED***Object***REMOVED*** `parent`
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Number|Undefined***REMOVED*** Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.popNode = function(node) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.pop === 'function') ***REMOVED***
    return node.pop();
  ***REMOVED***
  return node.nodes && node.nodes.pop();
***REMOVED***;

/**
 * Shift the first `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * utils.pushNode(parent, new Node(***REMOVED***type: 'foo'***REMOVED***));
 * utils.pushNode(parent, new Node(***REMOVED***type: 'bar'***REMOVED***));
 * utils.pushNode(parent, new Node(***REMOVED***type: 'baz'***REMOVED***));
 * console.log(parent.nodes.length); //=> 3
 * utils.shiftNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param ***REMOVED***Object***REMOVED*** `parent`
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Number|Undefined***REMOVED*** Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.shiftNode = function(node) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.shift === 'function') ***REMOVED***
    return node.shift();
  ***REMOVED***
  return node.nodes && node.nodes.shift();
***REMOVED***;

/**
 * Remove the specified `node` from `parent.nodes`.
 *
 * ```js
 * var parent = new Node(***REMOVED***type: 'abc'***REMOVED***);
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * utils.pushNode(parent, foo);
 * utils.pushNode(parent, new Node(***REMOVED***type: 'bar'***REMOVED***));
 * utils.pushNode(parent, new Node(***REMOVED***type: 'baz'***REMOVED***));
 * console.log(parent.nodes.length); //=> 3
 * utils.removeNode(parent, foo);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param ***REMOVED***Object***REMOVED*** `parent`
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Object|undefined***REMOVED*** Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.
 * @api public
 */

utils.removeNode = function(parent, node) ***REMOVED***
  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!parent.nodes) ***REMOVED***
    return null;
  ***REMOVED***

  if (typeof parent.remove === 'function') ***REMOVED***
    return parent.remove(node);
  ***REMOVED***

  var idx = parent.nodes.indexOf(node);
  if (idx !== -1) ***REMOVED***
    return parent.nodes.splice(idx, 1);
  ***REMOVED***
***REMOVED***;

/**
 * Returns true if `node.type` matches the given `type`. Throws a
 * `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * console.log(utils.isType(node, 'foo')); // false
 * console.log(utils.isType(node, 'bar')); // true
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***String***REMOVED*** `type`
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.isType = function(node, type) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  switch (typeOf(type)) ***REMOVED***
    case 'array':
      var types = type.slice();
      for (var i = 0; i < types.length; i++) ***REMOVED***
        if (utils.isType(node, types[i])) ***REMOVED***
          return true;
        ***REMOVED***
      ***REMOVED***
      return false;
    case 'string':
      return node.type === type;
    case 'regexp':
      return type.test(node.type);
    default: ***REMOVED***
      throw new TypeError('expected "type" to be an array, string or regexp');
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Returns true if the given `node` has the given `type` in `node.nodes`.
 * Throws a `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node(***REMOVED***
 *   type: 'foo',
 *   nodes: [
 *     new Node(***REMOVED***type: 'bar'***REMOVED***),
 *     new Node(***REMOVED***type: 'baz'***REMOVED***)
 *   ]
 * ***REMOVED***);
 * console.log(utils.hasType(node, 'xyz')); // false
 * console.log(utils.hasType(node, 'baz')); // true
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***String***REMOVED*** `type`
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.hasType = function(node, type) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (!Array.isArray(node.nodes)) return false;
  for (var i = 0; i < node.nodes.length; i++) ***REMOVED***
    if (utils.isType(node.nodes[i], type)) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Returns the first node from `node.nodes` of the given `type`
 *
 * ```js
 * var node = new Node(***REMOVED***
 *   type: 'foo',
 *   nodes: [
 *     new Node(***REMOVED***type: 'text', val: 'abc'***REMOVED***),
 *     new Node(***REMOVED***type: 'text', val: 'xyz'***REMOVED***)
 *   ]
 * ***REMOVED***);
 *
 * var textNode = utils.firstOfType(node.nodes, 'text');
 * console.log(textNode.val);
 * //=> 'abc'
 * ```
 * @param ***REMOVED***Array***REMOVED*** `nodes`
 * @param ***REMOVED***String***REMOVED*** `type`
 * @return ***REMOVED***Object|undefined***REMOVED*** Returns the first matching node or undefined.
 * @api public
 */

utils.firstOfType = function(nodes, type) ***REMOVED***
  for (var i = 0; i < nodes.length; i++) ***REMOVED***
    var node = nodes[i];
    if (utils.isType(node, type)) ***REMOVED***
      return node;
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Returns the node at the specified index, or the first node of the
 * given `type` from `node.nodes`.
 *
 * ```js
 * var node = new Node(***REMOVED***
 *   type: 'foo',
 *   nodes: [
 *     new Node(***REMOVED***type: 'text', val: 'abc'***REMOVED***),
 *     new Node(***REMOVED***type: 'text', val: 'xyz'***REMOVED***)
 *   ]
 * ***REMOVED***);
 *
 * var nodeOne = utils.findNode(node.nodes, 'text');
 * console.log(nodeOne.val);
 * //=> 'abc'
 *
 * var nodeTwo = utils.findNode(node.nodes, 1);
 * console.log(nodeTwo.val);
 * //=> 'xyz'
 * ```
 *
 * @param ***REMOVED***Array***REMOVED*** `nodes`
 * @param ***REMOVED***String|Number***REMOVED*** `type` Node type or index.
 * @return ***REMOVED***Object***REMOVED*** Returns a node or undefined.
 * @api public
 */

utils.findNode = function(nodes, type) ***REMOVED***
  if (!Array.isArray(nodes)) ***REMOVED***
    return null;
  ***REMOVED***
  if (typeof type === 'number') ***REMOVED***
    return nodes[type];
  ***REMOVED***
  return utils.firstOfType(nodes, type);
***REMOVED***;

/**
 * Returns true if the given node is an "*.open" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node(***REMOVED***type: 'brace'***REMOVED***);
 * var open = new Node(***REMOVED***type: 'brace.open'***REMOVED***);
 * var close = new Node(***REMOVED***type: 'brace.close'***REMOVED***);
 *
 * console.log(utils.isOpen(brace)); // false
 * console.log(utils.isOpen(open)); // true
 * console.log(utils.isOpen(close)); // false
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.isOpen = function(node) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-5) === '.open';
***REMOVED***;

/**
 * Returns true if the given node is a "*.close" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node(***REMOVED***type: 'brace'***REMOVED***);
 * var open = new Node(***REMOVED***type: 'brace.open'***REMOVED***);
 * var close = new Node(***REMOVED***type: 'brace.close'***REMOVED***);
 *
 * console.log(utils.isClose(brace)); // false
 * console.log(utils.isClose(open)); // false
 * console.log(utils.isClose(close)); // true
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.isClose = function(node) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-6) === '.close';
***REMOVED***;

/**
 * Returns true if `node.nodes` **has** an `.open` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node(***REMOVED***
 *   type: 'brace',
 *   nodes: []
 * ***REMOVED***);
 *
 * var open = new Node(***REMOVED***type: 'brace.open'***REMOVED***);
 * console.log(utils.hasOpen(brace)); // false
 *
 * brace.pushNode(open);
 * console.log(utils.hasOpen(brace)); // true
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.hasOpen = function(node) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var first = node.first || node.nodes ? node.nodes[0] : null;
  if (utils.isNode(first)) ***REMOVED***
    return first.type === node.type + '.open';
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Returns true if `node.nodes` **has** a `.close` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node(***REMOVED***
 *   type: 'brace',
 *   nodes: []
 * ***REMOVED***);
 *
 * var close = new Node(***REMOVED***type: 'brace.close'***REMOVED***);
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(close);
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.hasClose = function(node) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
  if (utils.isNode(last)) ***REMOVED***
    return last.type === node.type + '.close';
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Returns true if `node.nodes` has both `.open` and `.close` nodes
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node(***REMOVED***
 *   type: 'brace',
 *   nodes: []
 * ***REMOVED***);
 *
 * var open = new Node(***REMOVED***type: 'brace.open'***REMOVED***);
 * var close = new Node(***REMOVED***type: 'brace.close'***REMOVED***);
 * console.log(utils.hasOpen(brace)); // false
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(open);
 * brace.pushNode(close);
 * console.log(utils.hasOpen(brace)); // true
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.hasOpenAndClose = function(node) ***REMOVED***
  return utils.hasOpen(node) && utils.hasClose(node);
***REMOVED***;

/**
 * Push the given `node` onto the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = ***REMOVED*** inside: ***REMOVED******REMOVED******REMOVED***;
 * var node = new Node(***REMOVED***type: 'brace'***REMOVED***);
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> ***REMOVED*** brace: [***REMOVED***type: 'brace'***REMOVED***] ***REMOVED***
 * ```
 * @param ***REMOVED***Object***REMOVED*** `state` The `compiler.state` object or custom state object.
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Array***REMOVED*** Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.addType = function(state, node) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.open$/, '');

  if (!state.hasOwnProperty('inside')) ***REMOVED***
    state.inside = ***REMOVED******REMOVED***;
  ***REMOVED***
  if (!state.inside.hasOwnProperty(type)) ***REMOVED***
    state.inside[type] = [];
  ***REMOVED***

  var arr = state.inside[type];
  arr.push(node);
  return arr;
***REMOVED***;

/**
 * Remove the given `node` from the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = ***REMOVED*** inside: ***REMOVED******REMOVED******REMOVED***;
 * var node = new Node(***REMOVED***type: 'brace'***REMOVED***);
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> ***REMOVED*** brace: [***REMOVED***type: 'brace'***REMOVED***] ***REMOVED***
 * utils.removeType(state, node);
 * //=> ***REMOVED*** brace: [] ***REMOVED***
 * ```
 * @param ***REMOVED***Object***REMOVED*** `state` The `compiler.state` object or custom state object.
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @return ***REMOVED***Array***REMOVED*** Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.removeType = function(state, node) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.close$/, '');

  if (state.inside.hasOwnProperty(type)) ***REMOVED***
    return state.inside[type].pop();
  ***REMOVED***
***REMOVED***;

/**
 * Returns true if `node.val` is an empty string, or `node.nodes` does
 * not contain any non-empty text nodes.
 *
 * ```js
 * var node = new Node(***REMOVED***type: 'text'***REMOVED***);
 * utils.isEmpty(node); //=> true
 * node.val = 'foo';
 * utils.isEmpty(node); //=> false
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***Function***REMOVED*** `fn`
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.isEmpty = function(node, fn) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!Array.isArray(node.nodes)) ***REMOVED***
    if (node.type !== 'text') ***REMOVED***
      return true;
    ***REMOVED***
    if (typeof fn === 'function') ***REMOVED***
      return fn(node, node.parent);
    ***REMOVED***
    return !utils.trim(node.val);
  ***REMOVED***

  for (var i = 0; i < node.nodes.length; i++) ***REMOVED***
    var child = node.nodes[i];
    if (utils.isOpen(child) || utils.isClose(child)) ***REMOVED***
      continue;
    ***REMOVED***
    if (!utils.isEmpty(child, fn)) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***;

/**
 * Returns true if the `state.inside` stack for the given type exists
 * and has one or more nodes on it.
 *
 * ```js
 * var state = ***REMOVED*** inside: ***REMOVED******REMOVED******REMOVED***;
 * var node = new Node(***REMOVED***type: 'brace'***REMOVED***);
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * utils.addType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> true
 * utils.removeType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * ```
 * @param ***REMOVED***Object***REMOVED*** `state`
 * @param ***REMOVED***String***REMOVED*** `type`
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.isInsideType = function(state, type) ***REMOVED***
  assert(isObject(state), 'expected state to be an object');
  assert(isString(type), 'expected type to be a string');

  if (!state.hasOwnProperty('inside')) ***REMOVED***
    return false;
  ***REMOVED***

  if (!state.inside.hasOwnProperty(type)) ***REMOVED***
    return false;
  ***REMOVED***

  return state.inside[type].length > 0;
***REMOVED***;

/**
 * Returns true if `node` is either a child or grand-child of the given `type`,
 * or `state.inside[type]` is a non-empty array.
 *
 * ```js
 * var state = ***REMOVED*** inside: ***REMOVED******REMOVED******REMOVED***;
 * var node = new Node(***REMOVED***type: 'brace'***REMOVED***);
 * var open = new Node(***REMOVED***type: 'brace.open'***REMOVED***);
 * console.log(utils.isInside(state, open, 'brace')); //=> false
 * utils.pushNode(node, open);
 * console.log(utils.isInside(state, open, 'brace')); //=> true
 * ```
 * @param ***REMOVED***Object***REMOVED*** `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.
 * @param ***REMOVED***Object***REMOVED*** `node` Instance of [snapdragon-node][]
 * @param ***REMOVED***String***REMOVED*** `type` The `node.type` to check for.
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

utils.isInside = function(state, node, type) ***REMOVED***
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  if (Array.isArray(type)) ***REMOVED***
    for (var i = 0; i < type.length; i++) ***REMOVED***
      if (utils.isInside(state, node, type[i])) ***REMOVED***
        return true;
      ***REMOVED***
    ***REMOVED***
    return false;
  ***REMOVED***

  var parent = node.parent;
  if (typeof type === 'string') ***REMOVED***
    return (parent && parent.type === type) || utils.isInsideType(state, type);
  ***REMOVED***

  if (typeOf(type) === 'regexp') ***REMOVED***
    if (parent && parent.type && type.test(parent.type)) ***REMOVED***
      return true;
    ***REMOVED***

    var keys = Object.keys(state.inside);
    var len = keys.length;
    var idx = -1;
    while (++idx < len) ***REMOVED***
      var key = keys[idx];
      var val = state.inside[key];

      if (Array.isArray(val) && val.length !== 0 && type.test(key)) ***REMOVED***
        return true;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Get the last `n` element from the given `array`. Used for getting
 * a node from `node.nodes.`
 *
 * @param ***REMOVED***Array***REMOVED*** `array`
 * @param ***REMOVED***Number***REMOVED*** `n`
 * @return ***REMOVED***undefined***REMOVED***
 * @api public
 */

utils.last = function(arr, n) ***REMOVED***
  return arr[arr.length - (n || 1)];
***REMOVED***;

/**
 * Cast the given `val` to an array.
 *
 * ```js
 * console.log(utils.arrayify(''));
 * //=> []
 * console.log(utils.arrayify('foo'));
 * //=> ['foo']
 * console.log(utils.arrayify(['foo']));
 * //=> ['foo']
 * ```
 * @param ***REMOVED***any***REMOVED*** `val`
 * @return ***REMOVED***Array***REMOVED***
 * @api public
 */

utils.arrayify = function(val) ***REMOVED***
  if (typeof val === 'string' && val !== '') ***REMOVED***
    return [val];
  ***REMOVED***
  if (!Array.isArray(val)) ***REMOVED***
    return [];
  ***REMOVED***
  return val;
***REMOVED***;

/**
 * Convert the given `val` to a string by joining with `,`. Useful
 * for creating a cheerio/CSS/DOM-style selector from a list of strings.
 *
 * @param ***REMOVED***any***REMOVED*** `val`
 * @return ***REMOVED***Array***REMOVED***
 * @api public
 */

utils.stringify = function(val) ***REMOVED***
  return utils.arrayify(val).join(',');
***REMOVED***;

/**
 * Ensure that the given value is a string and call `.trim()` on it,
 * or return an empty string.
 *
 * @param ***REMOVED***String***REMOVED*** `str`
 * @return ***REMOVED***String***REMOVED***
 * @api public
 */

utils.trim = function(str) ***REMOVED***
  return typeof str === 'string' ? str.trim() : '';
***REMOVED***;

/**
 * Return true if val is an object
 */

function isObject(val) ***REMOVED***
  return typeOf(val) === 'object';
***REMOVED***

/**
 * Return true if val is a string
 */

function isString(val) ***REMOVED***
  return typeof val === 'string';
***REMOVED***

/**
 * Return true if val is a function
 */

function isFunction(val) ***REMOVED***
  return typeof val === 'function';
***REMOVED***

/**
 * Return true if val is an array
 */

function isArray(val) ***REMOVED***
  return Array.isArray(val);
***REMOVED***

/**
 * Shim to ensure the `.append` methods work with any version of snapdragon
 */

function append(compiler, val, node) ***REMOVED***
  if (typeof compiler.append !== 'function') ***REMOVED***
    return compiler.emit(val, node);
  ***REMOVED***
  return compiler.append(val, node);
***REMOVED***

/**
 * Simplified assertion. Throws an error is `val` is falsey.
 */

function assert(val, message) ***REMOVED***
  if (!val) throw new Error(message);
***REMOVED***
