'use strict';

var async = require('async');
var crypto = require('crypto');
var fs = require('fs');
var GoogleAuth = require('google-auth-library');
var gcpMetadata = require('gcp-metadata');
var path = require('path');
var request = require('request');

class Auth ***REMOVED***
  constructor(config) ***REMOVED***
    this.authClientPromise = null;
    this.authClient = null;
    this.googleAuthClient = null;
    this.config = config || ***REMOVED******REMOVED***;
    this.credentials = null;
    this.environment = ***REMOVED******REMOVED***;
    this.projectId = this.config.projectId;
  ***REMOVED***

  authorizeRequest (reqOpts, callback) ***REMOVED***
    this.getToken((err, token) => ***REMOVED***
      if (err) ***REMOVED***
        callback(err);
        return;
      ***REMOVED***

      var authorizedReqOpts = Object.assign(***REMOVED******REMOVED***, reqOpts, ***REMOVED***
        headers: Object.assign(***REMOVED******REMOVED***, reqOpts.headers, ***REMOVED***
          Authorization: `Bearer $***REMOVED***token***REMOVED***`
        ***REMOVED***)
      ***REMOVED***);

      callback(null, authorizedReqOpts);
    ***REMOVED***);
  ***REMOVED***

  getAuthClient (callback) ***REMOVED***
    if (this.authClient) ***REMOVED***
      // This code works around an issue with context loss with async-listener.
      // Strictly speaking, this should not be necessary as the call to
      // authClientPromise.then(..) below would resolve to the same value.
      // However, async-listener defaults to resuming the `then` callbacks with
      // the context at the point of resolution rather than the context from the
      // point where the `then` callback was added. In this case, the promise
      // will be resolved on the very first incoming http request, and that
      // context will become sticky (will be restored by async-listener) around
      // the `then` callbacks for all subsequent requests.
      //
      // This breaks APM tools like Stackdriver Trace & others and tools like
      // long stack traces (they will provide an incorrect stack trace).
      //
      // NOTE: this doesn't solve the problem generally. Any request concurrent
      // to the first call to this function, before the promise resolves, will
      // still lose context. We don't have a better solution at the moment :(.
      return setImmediate(callback.bind(null, null, this.authClient));
    ***REMOVED***

    var createAuthClientPromise = (resolve, reject) => ***REMOVED***
      var googleAuthClient = this.googleAuthClient = new GoogleAuth();

      var config = this.config;
      var keyFile = config.keyFilename || config.keyFile;

      var addScope = (err, authClient, projectId) => ***REMOVED***
        if (err) ***REMOVED***
          reject(err);
          return;
        ***REMOVED***

        if (authClient.createScopedRequired && authClient.createScopedRequired()) ***REMOVED***
          if (!config.scopes || config.scopes.length === 0) ***REMOVED***
            var scopeError = new Error('Scopes are required for this request.');
            scopeError.code = 'MISSING_SCOPE';
            reject(scopeError);
            return;
          ***REMOVED***
        ***REMOVED***

        authClient.scopes = config.scopes;
        this.authClient = authClient;
        this.projectId = config.projectId || projectId || authClient.projectId;

        resolve(authClient);
      ***REMOVED***;

      if (config.credentials) ***REMOVED***
        googleAuthClient.fromJSON(config.credentials, addScope);
      ***REMOVED*** else if (keyFile) ***REMOVED***
        keyFile = path.resolve(process.cwd(), keyFile);

        fs.readFile(keyFile, (err, contents) => ***REMOVED***
          if (err) ***REMOVED***
            reject(err);
            return;
          ***REMOVED***

          try ***REMOVED***
            googleAuthClient.fromJSON(JSON.parse(contents), addScope);
          ***REMOVED*** catch(e) ***REMOVED***
            var authClient = new googleAuthClient.JWT();
            authClient.keyFile = keyFile;
            authClient.email = config.email;
            addScope(null, authClient);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        googleAuthClient.getApplicationDefault(addScope);
      ***REMOVED***
    ***REMOVED***;

    if (!this.authClientPromise) ***REMOVED***
      this.authClientPromise = new Promise(createAuthClientPromise);
    ***REMOVED***

    this.authClientPromise.then((authClient) => ***REMOVED***
      callback(null, authClient);
      // The return null is needed to avoid a spurious warning if the user is
      // using bluebird.
      // See: https://github.com/stephenplusplus/google-auto-auth/issues/28
      return null;
    ***REMOVED***).catch(callback);
  ***REMOVED***

  getCredentials (callback) ***REMOVED***
    if (this.credentials) ***REMOVED***
      setImmediate(() => ***REMOVED***
        callback(null, this.credentials);
      ***REMOVED***);
      return;
    ***REMOVED***

    this.getAuthClient((err) => ***REMOVED***
      if (err) ***REMOVED***
        callback(err);
        return;
      ***REMOVED***

      this.googleAuthClient.getCredentials((err, credentials) => ***REMOVED***
        if (err) ***REMOVED***
          callback(err);
          return;
        ***REMOVED***

        this.credentials = credentials;

        callback(null, credentials);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  getEnvironment (callback) ***REMOVED***
    async.parallel([
      cb => this.isAppEngine(cb),
      cb => this.isCloudFunction(cb),
      cb => this.isComputeEngine(cb),
      cb => this.isContainerEngine(cb)
    ], () => ***REMOVED***
      callback(null, this.environment);
    ***REMOVED***);
  ***REMOVED***

  getProjectId (callback) ***REMOVED***
    if (this.projectId) ***REMOVED***
      setImmediate(() => ***REMOVED***
        callback(null, this.projectId);
      ***REMOVED***);
      return;
    ***REMOVED***

    this.getAuthClient(err => ***REMOVED***
      if (err) ***REMOVED***
        callback(err);
        return;
      ***REMOVED***

      callback(null, this.projectId);
    ***REMOVED***);
  ***REMOVED***

  getToken (callback) ***REMOVED***
    this.getAuthClient((err, client) => ***REMOVED***
      if (err) ***REMOVED***
        callback(err);
        return;
      ***REMOVED***

      client.getAccessToken(callback);
    ***REMOVED***);
  ***REMOVED***

  isAppEngine (callback) ***REMOVED***
    setImmediate(() => ***REMOVED***
      var env = this.environment;

      if (typeof env.IS_APP_ENGINE === 'undefined') ***REMOVED***
        env.IS_APP_ENGINE = !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
      ***REMOVED***

      callback(null, env.IS_APP_ENGINE);
    ***REMOVED***);
  ***REMOVED***

  isCloudFunction (callback) ***REMOVED***
    setImmediate(() => ***REMOVED***
      var env = this.environment;

      if (typeof env.IS_CLOUD_FUNCTION === 'undefined') ***REMOVED***
        env.IS_CLOUD_FUNCTION = !!process.env.FUNCTION_NAME;
      ***REMOVED***

      callback(null, env.IS_CLOUD_FUNCTION);
    ***REMOVED***);
  ***REMOVED***

  isComputeEngine (callback) ***REMOVED***
    var env = this.environment;

    if (typeof env.IS_COMPUTE_ENGINE !== 'undefined') ***REMOVED***
      setImmediate(() => ***REMOVED***
        callback(null, env.IS_COMPUTE_ENGINE);
      ***REMOVED***);
      return;
    ***REMOVED***

    request('http://metadata.google.internal', (err, res) => ***REMOVED***
      env.IS_COMPUTE_ENGINE = !err && res.headers['metadata-flavor'] === 'Google';

      callback(null, env.IS_COMPUTE_ENGINE);
    ***REMOVED***);
  ***REMOVED***

  isContainerEngine (callback) ***REMOVED***
    var env = this.environment;

    if (typeof env.IS_CONTAINER_ENGINE !== 'undefined') ***REMOVED***
      setImmediate(() => ***REMOVED***
        callback(null, env.IS_CONTAINER_ENGINE);
      ***REMOVED***);
      return;
    ***REMOVED***

    gcpMetadata.instance('/attributes/cluster-name', err => ***REMOVED***
      env.IS_CONTAINER_ENGINE = !err;

      callback(null, env.IS_CONTAINER_ENGINE);
    ***REMOVED***);
  ***REMOVED***

  sign (data, callback) ***REMOVED***
    this.getCredentials((err, credentials) => ***REMOVED***
      if (err) ***REMOVED***
        callback(err);
        return;
      ***REMOVED***

      if (credentials.private_key) ***REMOVED***
        this._signWithPrivateKey(data, callback);
      ***REMOVED*** else ***REMOVED***
        this._signWithApi(data, callback);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  // `this.getCredentials()` will always have been run by this time
  _signWithApi (data, callback) ***REMOVED***
    if (!this.projectId) ***REMOVED***
      callback(new Error('Cannot sign data without a project ID.'));
      return;
    ***REMOVED***

    var client_email = this.credentials.client_email;

    if (!client_email) ***REMOVED***
      callback(new Error('Cannot sign data without `client_email`.'));
      return;
    ***REMOVED***

    var idString = `projects/$***REMOVED***this.projectId***REMOVED***/serviceAccounts/$***REMOVED***client_email***REMOVED***`;

    var reqOpts = ***REMOVED***
      method: 'POST',
      uri: `https://iam.googleapis.com/v1/$***REMOVED***idString***REMOVED***:signBlob`,
      json: ***REMOVED***
        bytesToSign: Buffer.from(data).toString('base64')
      ***REMOVED***
    ***REMOVED***;

    this.authorizeRequest(reqOpts, (err, authorizedReqOpts) => ***REMOVED***
      if (err) ***REMOVED***
        callback(err);
        return;
      ***REMOVED***

      request(authorizedReqOpts, function(err, resp, body) ***REMOVED***
        var response = resp.toJSON();

        if (!err && response.statusCode < 200 || response.statusCode >= 400) ***REMOVED***
          if (typeof response.body === 'object') ***REMOVED***
            var apiError = response.body.error;
            err = new Error(apiError.message);
            Object.assign(err, apiError);
          ***REMOVED*** else ***REMOVED***
            err = new Error(response.body);
            err.code = response.statusCode;
          ***REMOVED***
        ***REMOVED***

        callback(err, body && body.signature);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  // `this.getCredentials()` will always have been run by this time
  _signWithPrivateKey (data, callback) ***REMOVED***
    var sign = crypto.createSign('RSA-SHA256');
    sign.update(data);
    callback(null, sign.sign(this.credentials.private_key, 'base64'));
  ***REMOVED***
***REMOVED***

module.exports = config => ***REMOVED***
  return new Auth(config);
***REMOVED***;
