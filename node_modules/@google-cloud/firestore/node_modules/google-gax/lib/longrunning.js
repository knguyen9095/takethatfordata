/*
 * Copyright 2016, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var createBackoffSettings = require('./gax').createBackoffSettings;
var NormalApiCaller = require('./api_callable').NormalApiCaller;
var events = require('events');
var util = require('util');

/**
 * A callback to upack a google.protobuf.Any message.
 * @callback anyDecoder
 * @param ***REMOVED***google.protobuf.Any***REMOVED*** message - The message to unpacked.
 * @return ***REMOVED***Object***REMOVED*** - The unpacked message.
 */

/**
 * Describes the structure of a page-streaming call.
 *
 * @property ***REMOVED***OperationsClient***REMOVED*** operationsClient
 * @property ***REMOVED***anyDecoder***REMOVED*** responseDecoder
 * @property ***REMOVED***anyDecoder***REMOVED*** metadataDecoder
 *
 * @param ***REMOVED***OperationsClient***REMOVED*** operationsClient - The client used to poll or
 *   cancel an operation.
 * @param ***REMOVED***anyDecoder=***REMOVED*** responseDecoder - The decoder to unpack
 *   the response message.
 * @param ***REMOVED***anyDecoder=***REMOVED*** metadataDecoder - The decoder to unpack
 *   the metadata message.
 *
 * @constructor
 */
function LongrunningDescriptor(
  operationsClient,
  responseDecoder,
  metadataDecoder
) ***REMOVED***
  this.operationsClient = operationsClient;
  this.responseDecoder = responseDecoder;
  this.metadataDecoder = metadataDecoder;
***REMOVED***

LongrunningDescriptor.prototype.apiCaller = function() ***REMOVED***
  return new LongrunningApiCaller(this);
***REMOVED***;

exports.LongrunningDescriptor = LongrunningDescriptor;

/**
 * Creates an API caller that performs polling on a long running operation.
 *
 * @private
 * @constructor
 * @param ***REMOVED***LongrunningDescriptor***REMOVED*** longrunningDescriptor - Holds the
 * decoders used for unpacking responses and the operationsClient
 * used for polling the operation.
 */
function LongrunningApiCaller(longrunningDescriptor) ***REMOVED***
  NormalApiCaller.call(this);
  this.longrunningDescriptor = longrunningDescriptor;
***REMOVED***

util.inherits(LongrunningApiCaller, NormalApiCaller);

LongrunningApiCaller.prototype.call = function(
  apiCall,
  argument,
  settings,
  canceller
) ***REMOVED***
  var self = this;
  canceller.call(function(argument, callback) ***REMOVED***
    self._wrapOperation(apiCall, settings, argument, callback);
  ***REMOVED***, argument);
***REMOVED***;

LongrunningApiCaller.prototype._wrapOperation = function(
  apiCall,
  settings,
  argument,
  callback
) ***REMOVED***
  var backoffSettings = settings.longrunning;
  if (!backoffSettings) ***REMOVED***
    backoffSettings = createBackoffSettings(
      100,
      1.3,
      60000,
      null,
      null,
      null,
      null
    );
  ***REMOVED***

  var longrunningDescriptor = this.longrunningDescriptor;
  return apiCall(argument, function(err, rawResponse) ***REMOVED***
    if (err) ***REMOVED***
      callback(err, null, rawResponse);
      return;
    ***REMOVED***

    var operation = new Operation(
      rawResponse,
      longrunningDescriptor,
      backoffSettings,
      settings
    );

    callback(null, operation, rawResponse);
  ***REMOVED***);
***REMOVED***;

/**
 * Wrapper for a google.longrunnung.Operation.
 *
 * @constructor
 *
 * @param ***REMOVED***google.longrunning.Operation***REMOVED*** grpcOp - The operation to be wrapped.
 * @param ***REMOVED***LongrunningDescriptor***REMOVED*** longrunningDescriptor - This defines the
 * operations service client and unpacking mechanisms for the operation.
 * @param ***REMOVED***BackoffSettings***REMOVED*** backoffSettings - The backoff settings used in
 * in polling the operation.
 * @param ***REMOVED***CallOptions=***REMOVED*** callOptions - CallOptions used in making get operation
 * requests.
 */
function Operation(
  grpcOp,
  longrunningDescriptor,
  backoffSettings,
  callOptions
) ***REMOVED***
  events.EventEmitter.call(this);
  this.completeListeners = 0;
  this.hasActiveListeners = false;

  this.latestResponse = grpcOp;
  this.longrunningDescriptor = longrunningDescriptor;
  this.result = null;
  this.metadata = null;
  this.backoffSettings = backoffSettings;
  this._unpackResponse(grpcOp);
  this._listenForEvents();
  this._callOptions = callOptions;
***REMOVED***
util.inherits(Operation, events.EventEmitter);

/**
 * Begin listening for events on the operation. This method keeps track of how
 * many "complete" listeners are registered and removed, making sure polling is
 * handled automatically.
 *
 * As long as there is one active "complete" listener, the connection is open.
 * When there are no more listeners, the polling stops.
 *
 * @private
 */
Operation.prototype._listenForEvents = function() ***REMOVED***
  var self = this;

  this.on('newListener', function(event) ***REMOVED***
    if (event === 'complete') ***REMOVED***
      self.completeListeners++;

      if (!self.hasActiveListeners) ***REMOVED***
        self.hasActiveListeners = true;
        self.startPolling_();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  this.on('removeListener', function(event) ***REMOVED***
    if (event === 'complete' && --self.completeListeners === 0) ***REMOVED***
      self.hasActiveListeners = false;
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Cancels current polling api call and cancels the operation.
 *
 * @return ***REMOVED***Promise***REMOVED*** the promise of the OperationsClient#cancelOperation api
 * request.
 */
Operation.prototype.cancel = function() ***REMOVED***
  if (this.currentCallPromise_) ***REMOVED***
    this.currentCallPromise_.cancel();
  ***REMOVED***
  var operationsClient = this.longrunningDescriptor.operationsClient;
  return operationsClient.cancelOperation(***REMOVED***name: this.latestResponse.name***REMOVED***);
***REMOVED***;

/**
 * @callback GetOperationCallback
 * @param ***REMOVED***?Error***REMOVED*** error
 * @param ***REMOVED***?Object***REMOVED*** result
 * @param ***REMOVED***?Object***REMOVED*** metadata
 * @param ***REMOVED***?google.longrunning.Operation***REMOVED*** rawResponse
 */

/**
 * Get the updated status of the operation. If the Operation has previously
 * completed, this will use the status of the cached completed operation.
 *
 *   - callback(err): Operation failed
 *   - callback(null, result, metadata, rawResponse): Operation complete
 *   - callback(null, null, metadata, rawResponse): Operation incomplete
 *
 * @param ***REMOVED***getOperationCallback***REMOVED*** callback - Callback to handle the polled
 * operation result and metadata.
 * @return ***REMOVED***Promise|undefined***REMOVED*** - This returns a promise if a callback is not specified.
 * The promise resolves to an array where the first element is the unpacked
 * result, the second element is the metadata, and the third element is the raw
 * response of the api call. The promise rejects if the operation returns an
 * error.
 */
Operation.prototype.getOperation = function(callback) ***REMOVED***
  var self = this;
  var operationsClient = this.longrunningDescriptor.operationsClient;

  function promisifyResponse() ***REMOVED***
    if (!callback) ***REMOVED***
      var PromiseCtor = self._callOptions.promise;
      return new PromiseCtor(function(resolve, reject) ***REMOVED***
        if (self.latestResponse.error) ***REMOVED***
          var error = new Error(self.latestReponse.error.message);
          error.code = self.latestReponse.error.code;
          reject(error);
        ***REMOVED*** else ***REMOVED***
          resolve([self.result, self.metadata, self.latestResponse]);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
    return;
  ***REMOVED***

  if (this.latestResponse.done) ***REMOVED***
    this._unpackResponse(this.latestResponse, callback);
    return promisifyResponse();
  ***REMOVED***

  this.currentCallPromise_ = operationsClient.getOperation(
    ***REMOVED***name: this.latestResponse.name***REMOVED***,
    this._callOptions
  );

  var noCallbackPromise = this.currentCallPromise_.then(function(responses) ***REMOVED***
    self.latestResponse = responses[0];
    self._unpackResponse(responses[0], callback);
    return promisifyResponse();
  ***REMOVED***);

  if (!callback) ***REMOVED***
    return noCallbackPromise;
  ***REMOVED***
***REMOVED***;

Operation.prototype._unpackResponse = function(op, callback) ***REMOVED***
  var responseDecoder = this.longrunningDescriptor.responseDecoder;
  var metadataDecoder = this.longrunningDescriptor.metadataDecoder;
  var response;
  var metadata;

  if (op.done) ***REMOVED***
    if (op.result === 'error') ***REMOVED***
      var error = new Error(op.error.message);
      error.code = op.error.code;
      if (callback) ***REMOVED***
        callback(error);
      ***REMOVED***
      return;
    ***REMOVED***

    if (responseDecoder && op.response) ***REMOVED***
      response = responseDecoder(op.response.value);
      this.result = response;
    ***REMOVED***
  ***REMOVED***

  if (metadataDecoder && op.metadata) ***REMOVED***
    metadata = metadataDecoder(op.metadata.value);
    this.metadata = metadata;
  ***REMOVED***
  if (callback) ***REMOVED***
    callback(null, response, metadata, op);
  ***REMOVED***
***REMOVED***;

/**
 * Poll `getOperation` to check the operation's status. This runs a loop to ping
 * using the backoff strategy specified at initialization.
 *
 * Note: This method is automatically called once a "complete" event handler is
 * registered on the operation.
 *
 * @private
 */
Operation.prototype.startPolling_ = function() ***REMOVED***
  var self = this;

  var now = new Date();
  var delayMult = this.backoffSettings.retryDelayMultiplier;
  var maxDelay = this.backoffSettings.maxRetryDelayMillis;
  var delay = this.backoffSettings.initialRetryDelayMillis;
  var deadline = Infinity;
  if (this.backoffSettings.totalTimeoutMillis) ***REMOVED***
    deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;
  ***REMOVED***
  var previousMetadataBytes;
  if (this.latestResponse.metadata) ***REMOVED***
    previousMetadataBytes = this.latestResponse.metadata.value;
  ***REMOVED***

  function emit() ***REMOVED***
    self.emit.apply(self, Array.prototype.slice.call(arguments, 0));
  ***REMOVED***

  function retry() ***REMOVED***
    if (!self.hasActiveListeners) ***REMOVED***
      return;
    ***REMOVED***

    if (now.getTime() >= deadline) ***REMOVED***
      setImmediate(
        emit,
        'error',
        new Error(
          'Total timeout exceeded before ' + 'any response was received'
        )
      );
      return;
    ***REMOVED***

    self.getOperation(function(err, result, metadata, rawResponse) ***REMOVED***
      if (err) ***REMOVED***
        setImmediate(emit, 'error', err);
        return;
      ***REMOVED***

      if (!result) ***REMOVED***
        if (
          rawResponse.metadata &&
          (!previousMetadataBytes ||
            !rawResponse.metadata.value.equals(previousMetadataBytes))
        ) ***REMOVED***
          setImmediate(emit, 'progress', metadata, rawResponse);
          previousMetadataBytes = rawResponse.metadata.value;
        ***REMOVED***
        setTimeout(function() ***REMOVED***
          now = new Date();
          delay = Math.min(delay * delayMult, maxDelay);
          retry();
        ***REMOVED***, delay);
        return;
      ***REMOVED***

      setImmediate(emit, 'complete', result, metadata, rawResponse);
    ***REMOVED***);
  ***REMOVED***
  retry();
***REMOVED***;

/**
 * Wraps the `complete` and `error` events in a Promise.
 *
 * @return ***REMOVED***promise***REMOVED*** - Promise that resolves on operation completion and rejects
 * on operation error.
 */
Operation.prototype.promise = function() ***REMOVED***
  var self = this;
  var PromiseCtor = this._callOptions.promise;
  return new PromiseCtor(function(resolve, reject) ***REMOVED***
    self
      .on('error', reject)
      .on('complete', function(result, metadata, rawResponse) ***REMOVED***
        resolve([result, metadata, rawResponse]);
      ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Method used to create Operation objects.
 *
 * @constructor
 *
 * @param ***REMOVED***google.longrunning.Operation***REMOVED*** op - The operation to be wrapped.
 * @param ***REMOVED***LongrunningDescriptor***REMOVED*** longrunningDescriptor - This defines the
 * operations service client and unpacking mechanisms for the operation.
 * @param ***REMOVED***BackoffSettings***REMOVED*** backoffSettings - The backoff settings used in
 * in polling the operation.
 * @param ***REMOVED***CallOptions=***REMOVED*** callOptions - CallOptions used in making get operation
 * requests.
 */
exports.operation = function(
  op,
  longrunningDescriptor,
  backoffSettings,
  callOptions
) ***REMOVED***
  return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);
***REMOVED***;
