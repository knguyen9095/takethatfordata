/*
 * Copyright 2016, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Provides function wrappers that implement page streaming and retrying.
 */

'use strict';

var setTimeout = require('timers').setTimeout;
var util = require('util');

/**
 * @callback APICallback
 * @param ***REMOVED***?Error***REMOVED*** error
 * @param ***REMOVED***?Object***REMOVED*** response
 */

/**
 * @callback APIFunc
 * @param ***REMOVED***Object***REMOVED*** argument
 * @param ***REMOVED***grpc.Metadata***REMOVED*** metadata
 * @param ***REMOVED***Object***REMOVED*** options
 * @param ***REMOVED***APICallback***REMOVED*** callback
 */

/**
 * @callback APICall
 * @param ***REMOVED***Object***REMOVED*** argument
 * @param ***REMOVED***CallOptions***REMOVED*** callOptions
 * @param ***REMOVED***APICallback***REMOVED*** callback
 * @return ***REMOVED***Promise|Stream|undefined***REMOVED***
 */

/**
 * Canceller manages callback, API calls, and cancellation
 * of the API calls.
 * @param ***REMOVED***APICallback=***REMOVED*** callback
 *   The callback to be called asynchronously when the API call
 *   finishes.
 * @constructor
 * @property ***REMOVED***APICallback***REMOVED*** callback
 *   The callback function to be called.
 * @private
 */
function Canceller(callback) ***REMOVED***
  this.callback = callback;
  this.cancelFunc = null;
  this.completed = false;
***REMOVED***

/**
 * Cancels the ongoing promise.
 */
Canceller.prototype.cancel = function() ***REMOVED***
  if (this.completed) ***REMOVED***
    return;
  ***REMOVED***
  this.completed = true;
  if (this.cancelFunc) ***REMOVED***
    this.cancelFunc();
  ***REMOVED*** else ***REMOVED***
    this.callback(new Error('cancelled'));
  ***REMOVED***
***REMOVED***;

/**
 * Call calls the specified function. Result will be used to fulfill
 * the promise.
 *
 * @param ***REMOVED***function(Object, APICallback=)***REMOVED*** aFunc
 *   A function for an API call.
 * @param ***REMOVED***Object***REMOVED*** argument
 *   A request object.
 */
Canceller.prototype.call = function(aFunc, argument) ***REMOVED***
  if (this.completed) ***REMOVED***
    return;
  ***REMOVED***
  var self = this;
  var canceller = aFunc(argument, function() ***REMOVED***
    self.completed = true;
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift(self.callback);
    setImmediate.apply(null, args);
  ***REMOVED***);
  this.cancelFunc = function() ***REMOVED***
    canceller.cancel();
  ***REMOVED***;
***REMOVED***;

/**
 * PromiseCanceller is Canceller, but it holds a promise when
 * the API call finishes.
 * @param ***REMOVED***Function***REMOVED*** PromiseCtor - A constructor for a promise that implements
 * the ES6 specification of promise.
 * @constructor
 * @private
 */
function PromiseCanceller(PromiseCtor) ***REMOVED***
  var self = this;
  this.promise = new PromiseCtor(function(resolve, reject) ***REMOVED***
    Canceller.call(self, function(err) ***REMOVED***
      if (err) ***REMOVED***
        reject(err);
      ***REMOVED*** else ***REMOVED***
        resolve(Array.prototype.slice.call(arguments, 1));
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
  this.promise.cancel = function() ***REMOVED***
    self.cancel();
  ***REMOVED***;
***REMOVED***

util.inherits(PromiseCanceller, Canceller);

/**
 * Updates aFunc so that it gets called with the timeout as its final arg.
 *
 * This converts a function, aFunc, into another function with updated deadline.
 *
 * @private
 *
 * @param ***REMOVED***APIFunc***REMOVED*** aFunc - a function to be updated.
 * @param ***REMOVED***number***REMOVED*** timeout - to be added to the original function as it final
 *   positional arg.
 * @param ***REMOVED***Object***REMOVED*** otherArgs - the additional arguments to be passed to aFunc.
 * @param ***REMOVED***Object=***REMOVED*** abTests - the A/B testing key/value pairs.
 * @return ***REMOVED***function(Object, APICallback)***REMOVED***
 *  the function with other arguments and the timeout.
 */
function addTimeoutArg(aFunc, timeout, otherArgs, abTests) ***REMOVED***
  // TODO: this assumes the other arguments consist of metadata and options,
  // which is specific to gRPC calls. Remove the hidden dependency on gRPC.
  return function timeoutFunc(argument, callback) ***REMOVED***
    var now = new Date();
    var options = otherArgs.options || ***REMOVED******REMOVED***;
    options.deadline = new Date(now.getTime() + timeout);
    var metadata = otherArgs.metadataBuilder
      ? otherArgs.metadataBuilder(abTests, otherArgs.headers || ***REMOVED******REMOVED***)
      : null;
    return aFunc(argument, metadata, options, callback);
  ***REMOVED***;
***REMOVED***

/**
 * Creates a function equivalent to aFunc, but that retries on certain
 * exceptions.
 *
 * @private
 *
 * @param ***REMOVED***APIFunc***REMOVED*** aFunc - A function.
 * @param ***REMOVED***RetryOptions***REMOVED*** retry - Configures the exceptions upon which the
 *   function eshould retry, and the parameters to the exponential backoff retry
 *   algorithm.
 * @param ***REMOVED***Object***REMOVED*** otherArgs - the additional arguments to be passed to aFunc.
 * @return ***REMOVED***function(Object, APICallback)***REMOVED*** A function that will retry.
 */
function retryable(aFunc, retry, otherArgs) ***REMOVED***
  var delayMult = retry.backoffSettings.retryDelayMultiplier;
  var maxDelay = retry.backoffSettings.maxRetryDelayMillis;
  var timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;
  var maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;

  var delay = retry.backoffSettings.initialRetryDelayMillis;
  var timeout = retry.backoffSettings.initialRpcTimeoutMillis;

  /**
   * Equivalent to ``aFunc``, but retries upon transient failure.
   *
   * Retrying is done through an exponential backoff algorithm configured
   * by the options in ``retry``.
   * @param ***REMOVED***Object***REMOVED*** argument The request object.
   * @param ***REMOVED***APICallback***REMOVED*** callback The callback.
   * @return ***REMOVED***function()***REMOVED*** cancel function.
   */
  return function retryingFunc(argument, callback) ***REMOVED***
    var canceller;
    var timeoutId;
    var now = new Date();
    var deadline;
    if (retry.backoffSettings.totalTimeoutMillis) ***REMOVED***
      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;
    ***REMOVED***
    var retries = 0;
    var maxRetries = retry.backoffSettings.maxRetries;
    // TODO: define A/B testing values for retry behaviors.

    /** Repeat the API call as long as necessary. */
    function repeat() ***REMOVED***
      timeoutId = null;
      if (deadline && now.getTime() >= deadline) ***REMOVED***
        callback(
          new Error(
            'Retry total timeout exceeded before any' + 'response was received'
          )
        );
        return;
      ***REMOVED***

      if (retries && retries >= maxRetries) ***REMOVED***
        callback(
          new Error(
            'Exceeded maximum number of retries before any ' +
              'response was received'
          )
        );
        return;
      ***REMOVED***

      retries++;
      var toCall = addTimeoutArg(aFunc, timeout, otherArgs);
      canceller = toCall(argument, function(err) ***REMOVED***
        if (!err) ***REMOVED***
          var args = Array.prototype.slice.call(arguments, 1);
          args.unshift(null);
          callback.apply(null, args);
          return;
        ***REMOVED***
        canceller = null;
        if (retry.retryCodes.indexOf(err.code) < 0) ***REMOVED***
          err.note =
            'Exception occurred in retry method that was ' +
            'not classified as transient';
          callback(err);
        ***REMOVED*** else ***REMOVED***
          var toSleep = Math.random() * delay;
          timeoutId = setTimeout(function() ***REMOVED***
            now = new Date();
            delay = Math.min(delay * delayMult, maxDelay);
            timeout = Math.min(
              timeout * timeoutMult,
              maxTimeout,
              deadline - now.getTime()
            );
            repeat();
          ***REMOVED***, toSleep);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    if (maxRetries && deadline) ***REMOVED***
      callback(
        new Error(
          'Cannot set both totalTimeoutMillis and maxRetries ' +
            'in backoffSettings.'
        )
      );
    ***REMOVED*** else ***REMOVED***
      repeat();
    ***REMOVED***

    return ***REMOVED***
      cancel: function() ***REMOVED***
        if (timeoutId) ***REMOVED***
          clearTimeout(timeoutId);
        ***REMOVED***
        if (canceller) ***REMOVED***
          canceller.cancel();
        ***REMOVED*** else ***REMOVED***
          callback(new Error('cancelled'));
        ***REMOVED***
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***;
***REMOVED***

/**
 * Creates an API caller for normal methods.
 *
 * @private
 * @constructor
 */
function NormalApiCaller() ***REMOVED******REMOVED***

NormalApiCaller.prototype.init = function(settings, callback) ***REMOVED***
  if (callback) ***REMOVED***
    return new Canceller(callback);
  ***REMOVED***
  return new PromiseCanceller(settings.promise);
***REMOVED***;

NormalApiCaller.prototype.wrap = function(func) ***REMOVED***
  return func;
***REMOVED***;

NormalApiCaller.prototype.call = function(
  apiCall,
  argument,
  settings,
  canceller
) ***REMOVED***
  canceller.call(apiCall, argument);
***REMOVED***;

NormalApiCaller.prototype.fail = function(canceller, err) ***REMOVED***
  canceller.callback(err);
***REMOVED***;

NormalApiCaller.prototype.result = function(canceller) ***REMOVED***
  if (canceller.promise) ***REMOVED***
    return canceller.promise;
  ***REMOVED***
***REMOVED***;

exports.NormalApiCaller = NormalApiCaller;

/**
 * Converts an rpc call into an API call governed by the settings.
 *
 * In typical usage, `func` will be a promsie to a callable used to make an rpc
 * request. This will mostly likely be a bound method from a request stub used
 * to make an rpc call. It is not a direct function but a Promise instance,
 * because of its asynchronism (typically, obtaining the auth information).
 *
 * The result is a function which manages the API call with the given settings
 * and the options on the invocation.
 *
 * @param ***REMOVED***Promise.<APIFunc>***REMOVED*** funcWithAuth - is a promise to be used to make
 *   a bare rpc call. This is a Promise instead of a bare function because
 *   the rpc call will be involeved with asynchronous authentications.
 * @param ***REMOVED***CallSettings***REMOVED*** settings - provides the settings for this call
 * @param ***REMOVED***Object=***REMOVED*** optDescriptor - optionally specify the descriptor for
 *   the method call.
 * @return ***REMOVED***APICall***REMOVED*** func - a bound method on a request stub used
 *   to make an rpc call.
 */
exports.createApiCall = function createApiCall(
  funcWithAuth,
  settings,
  optDescriptor
) ***REMOVED***
  var apiCaller = optDescriptor
    ? optDescriptor.apiCaller(settings)
    : new NormalApiCaller();

  return function apiCallInner(request, callOptions, callback) ***REMOVED***
    var thisSettings = settings.merge(callOptions);

    var status = apiCaller.init(thisSettings, callback);
    funcWithAuth
      .then(function(func) ***REMOVED***
        func = apiCaller.wrap(func);
        var retry = thisSettings.retry;
        if (retry && retry.retryCodes && retry.retryCodes.length > 0) ***REMOVED***
          return retryable(func, thisSettings.retry, thisSettings.otherArgs);
        ***REMOVED***
        return addTimeoutArg(
          func,
          thisSettings.timeout,
          thisSettings.otherArgs
        );
      ***REMOVED***)
      .then(function(apiCall) ***REMOVED***
        apiCaller.call(apiCall, request, thisSettings, status);
      ***REMOVED***)
      .catch(function(err) ***REMOVED***
        apiCaller.fail(status, err);
      ***REMOVED***);
    return apiCaller.result(status);
  ***REMOVED***;
***REMOVED***;
