/*
 * Copyright 2016, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Provides behavior that supports request bundling.
 */

'use strict';

var _ = require('lodash');
var util = require('util');
var NormalApiCaller = require('./api_callable').NormalApiCaller;

/**
 * A function which does nothing. Used for an empty cancellation funciton.
 * @private
 */
function noop() ***REMOVED******REMOVED***

/**
 * Compute the identifier of the `obj`. The objects of the same ID
 * will be bundled together.
 *
 * @param ***REMOVED***Object***REMOVED*** obj - The request object.
 * @param ***REMOVED***String[]***REMOVED*** discriminatorFields - The array of field names.
 *   A field name may include '.' as a separator, which is used to
 *   indicate object traversal.
 * @return ***REMOVED***String|undefined***REMOVED*** - the identifier string, or undefined if any
 *   discriminator.
 *   fields do not exist.
 */
function computeBundleId(obj, discriminatorFields) ***REMOVED***
  var ids = [];
  var hasIds = false;
  for (var i = 0; i < discriminatorFields.length; ++i) ***REMOVED***
    var id = _.at(obj, discriminatorFields[i])[0];
    if (id === undefined) ***REMOVED***
      ids.push(null);
    ***REMOVED*** else ***REMOVED***
      hasIds = true;
      ids.push(id);
    ***REMOVED***
  ***REMOVED***
  if (!hasIds) ***REMOVED***
    return undefined;
  ***REMOVED***
  return JSON.stringify(ids);
***REMOVED***
exports.computeBundleId = computeBundleId;

/**
 * Creates a deep copy of the object with the consideration of subresponse
 * fields for bundling.
 *
 * @param ***REMOVED***Object***REMOVED*** obj - The source object.
 * @param ***REMOVED***Object?***REMOVED*** subresponseInfo - The information to copy the subset of
 *   the field for the response. Do nothing if it's null.
 * @param ***REMOVED***String***REMOVED*** subresponseInfo.field - The field name.
 * @param ***REMOVED***number***REMOVED*** subresponseInfo.start - The offset where the copying
 *   element should starts with.
 * @param ***REMOVED***number***REMOVED*** subresponseInfo.end - The ending index where the copying
 *   region of the elements ends.
 * @return ***REMOVED***Object***REMOVED*** The copied object.
 * @private
 */
function deepCopyForResponse(obj, subresponseInfo) ***REMOVED***
  var result;
  if (obj === null) ***REMOVED***
    return null;
  ***REMOVED***
  if (obj === undefined) ***REMOVED***
    return undefined;
  ***REMOVED***
  if (Array.isArray(obj)) ***REMOVED***
    result = [];
    obj.forEach(function(element) ***REMOVED***
      result.push(deepCopyForResponse(element, null));
    ***REMOVED***);
    return result;
  ***REMOVED***
  // Some objects (such as ByteBuffer) have copy method.
  if (obj.copy !== undefined) ***REMOVED***
    return obj.copy();
  ***REMOVED***
  // ArrayBuffer should be copied through slice().
  if (obj instanceof ArrayBuffer) ***REMOVED***
    return obj.slice();
  ***REMOVED***
  if (typeof obj === 'object') ***REMOVED***
    result = ***REMOVED******REMOVED***;
    Object.keys(obj).forEach(function(key) ***REMOVED***
      if (
        subresponseInfo &&
        key === subresponseInfo.field &&
        Array.isArray(obj[key])
      ) ***REMOVED***
        // Note that subresponses are not deep-copied. This is safe because
        // those subresponses are not shared among callbacks.
        result[key] = obj[key].slice(
          subresponseInfo.start,
          subresponseInfo.end
        );
      ***REMOVED*** else ***REMOVED***
        result[key] = deepCopyForResponse(obj[key], null);
      ***REMOVED***
    ***REMOVED***);
    return result;
  ***REMOVED***
  return obj;
***REMOVED***
exports.deepCopyForResponse = deepCopyForResponse;

/**
 * A task coordinates the execution of a single bundle.
 *
 * @param ***REMOVED***function***REMOVED*** apiCall - The function to conduct calling API.
 * @param ***REMOVED***Object***REMOVED*** bundlingRequest - The base request object to be used
 *   for the actual API call.
 * @param ***REMOVED***string***REMOVED*** bundledField - The name of the field in bundlingRequest
 *   to be bundled.
 * @param ***REMOVED***string=***REMOVED*** subresponseField - The name of the field in the response
 *   to be passed to the callback.
 * @constructor
 * @private
 */
function Task(apiCall, bundlingRequest, bundledField, subresponseField) ***REMOVED***
  this._apiCall = apiCall;
  this._request = bundlingRequest;
  this._bundledField = bundledField;
  this._subresponseField = subresponseField;
  this._data = [];
***REMOVED***

exports.Task = Task;

/**
 * Returns the number of elements in a task.
 * @return ***REMOVED***number***REMOVED*** The number of elements.
 */
Task.prototype.getElementCount = function() ***REMOVED***
  var count = 0;
  for (var i = 0; i < this._data.length; ++i) ***REMOVED***
    count += this._data[i].elements.length;
  ***REMOVED***
  return count;
***REMOVED***;

/**
 * Returns the total byte size of the elements in a task.
 * @return ***REMOVED***number***REMOVED*** The byte size.
 */
Task.prototype.getRequestByteSize = function() ***REMOVED***
  var size = 0;
  for (var i = 0; i < this._data.length; ++i) ***REMOVED***
    size += this._data[i].bytes;
  ***REMOVED***
  return size;
***REMOVED***;

/**
 * Invokes the actual API call with current elements.
 * @return ***REMOVED***string[]***REMOVED*** - the list of ids for invocations to be run.
 */
Task.prototype.run = function() ***REMOVED***
  if (this._data.length === 0) ***REMOVED***
    return [];
  ***REMOVED***
  var request = this._request;
  var elements = [];
  var ids = [];
  for (var i = 0; i < this._data.length; ++i) ***REMOVED***
    elements.push.apply(elements, this._data[i].elements);
    ids.push(this._data[i].callback.id);
  ***REMOVED***
  request[this._bundledField] = elements;

  var self = this;
  this.callCanceller = this._apiCall(request, function(err, response) ***REMOVED***
    var responses = [];
    if (err) ***REMOVED***
      self._data.forEach(function() ***REMOVED***
        responses.push(null);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      var subresponseInfo = null;
      if (self._subresponseField) ***REMOVED***
        subresponseInfo = ***REMOVED***
          field: self._subresponseField,
          start: 0,
        ***REMOVED***;
      ***REMOVED***
      self._data.forEach(function(data) ***REMOVED***
        if (subresponseInfo) ***REMOVED***
          subresponseInfo.end = subresponseInfo.start + data.elements.length;
        ***REMOVED***
        responses.push(deepCopyForResponse(response, subresponseInfo));
        if (subresponseInfo) ***REMOVED***
          subresponseInfo.start = subresponseInfo.end;
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
    for (var i = 0; i < self._data.length; ++i) ***REMOVED***
      if (self._data[i].cancelled) ***REMOVED***
        self._data[i].callback(new Error('cancelled'));
      ***REMOVED*** else ***REMOVED***
        self._data[i].callback(err, responses[i]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
  return ids;
***REMOVED***;

/**
 * Appends the list of elements into the task.
 * @param ***REMOVED***Object[]***REMOVED*** elements - the new list of elements.
 * @param ***REMOVED***number***REMOVED*** bytes - the byte size required to encode elements in the API.
 * @param ***REMOVED***APICallback***REMOVED*** callback - the callback of the method call.
 */
Task.prototype.extend = function(elements, bytes, callback) ***REMOVED***
  this._data.push(***REMOVED***
    elements: elements,
    bytes: bytes,
    callback: callback,
  ***REMOVED***);
***REMOVED***;

/**
 * Cancels a part of elements.
 * @param ***REMOVED***string***REMOVED*** id - The identifier of the part of elements.
 * @return ***REMOVED***boolean***REMOVED*** Whether the entire task will be canceled or not.
 */
Task.prototype.cancel = function(id) ***REMOVED***
  if (this.callCanceller) ***REMOVED***
    var allCancelled = true;
    this._data.forEach(function(d) ***REMOVED***
      if (d.callback.id === id) ***REMOVED***
        d.cancelled = true;
      ***REMOVED***
      if (!d.cancelled) ***REMOVED***
        allCancelled = false;
      ***REMOVED***
    ***REMOVED***);
    if (allCancelled) ***REMOVED***
      this.callCanceller.cancel();
    ***REMOVED***
    return allCancelled;
  ***REMOVED***
  for (var i = 0; i < this._data.length; ++i) ***REMOVED***
    if (this._data[i].callback.id === id) ***REMOVED***
      this._data[i].callback(new Error('cancelled'));
      this._data.splice(i, 1);
      break;
    ***REMOVED***
  ***REMOVED***
  return this._data.length === 0;
***REMOVED***;

/**
 * Organizes requests for an api service that requires to bundle them.
 *
 * @param ***REMOVED***BundleOptions***REMOVED*** bundleOptions - configures strategy this instance
 *   uses when executing bundled functions.
 * @param ***REMOVED***BundleDescriptor***REMOVED*** bundleDescriptor - the description of the bundling.
 * @constructor
 */
function BundleExecutor(bundleOptions, bundleDescriptor) ***REMOVED***
  this._options = bundleOptions;
  this._descriptor = bundleDescriptor;
  this._tasks = ***REMOVED******REMOVED***;
  this._timers = ***REMOVED******REMOVED***;
  this._invocations = ***REMOVED******REMOVED***;
  this._invocationId = 0;
***REMOVED***

exports.BundleExecutor = BundleExecutor;

/**
 * Schedule a method call.
 *
 * @param ***REMOVED***function***REMOVED*** apiCall - the function for an API call.
 * @param ***REMOVED***Object***REMOVED*** request - the request object to be bundled with others.
 * @param ***REMOVED***APICallback***REMOVED*** callback - the callback to be called when the method finished.
 * @return ***REMOVED***function()***REMOVED*** - the function to cancel the scheduled invocation.
 */
BundleExecutor.prototype.schedule = function(apiCall, request, callback) ***REMOVED***
  var bundleId = computeBundleId(
    request,
    this._descriptor.requestDiscriminatorFields
  );
  if (!callback) ***REMOVED***
    callback = noop;
  ***REMOVED***
  if (bundleId === undefined) ***REMOVED***
    console.warn(
      'The request does not have enough information for request bundling. ' +
        'Invoking immediately. Request: ' +
        JSON.stringify(request) +
        ' discriminator fields: ' +
        this._descriptor.requestDiscriminatorFields
    );
    return apiCall(request, callback);
  ***REMOVED***

  if (!(bundleId in this._tasks)) ***REMOVED***
    this._tasks[bundleId] = new Task(
      apiCall,
      request,
      this._descriptor.bundledField,
      this._descriptor.subresponseField
    );
  ***REMOVED***
  var task = this._tasks[bundleId];
  callback.id = String(this._invocationId++);
  this._invocations[callback.id] = bundleId;

  var bundledField = request[this._descriptor.bundledField];
  var elementCount = bundledField.length;
  var requestBytes = 0;
  var self = this;
  bundledField.forEach(function(obj) ***REMOVED***
    requestBytes += self._descriptor.byteLengthFunction(obj);
  ***REMOVED***);

  var countLimit = this._options.elementCountLimit || 0;
  var byteLimit = this._options.requestByteLimit || 0;

  if (
    (countLimit > 0 && elementCount >= countLimit) ||
    (byteLimit > 0 && requestBytes >= byteLimit)
  ) ***REMOVED***
    var message;
    if (countLimit > 0 && elementCount >= countLimit) ***REMOVED***
      message =
        'The number of elements ' +
        elementCount +
        ' exceeds the limit ' +
        this._options.elementCountLimit;
    ***REMOVED*** else ***REMOVED***
      message =
        'The required bytes ' +
        requestBytes +
        ' exceeds the limit ' +
        this._options.requestByteLimit;
    ***REMOVED***
    callback(new Error(message));
    return ***REMOVED***
      cancel: noop,
    ***REMOVED***;
  ***REMOVED***

  var existingCount = task.getElementCount();
  var existingBytes = task.getRequestByteSize();

  if (
    (countLimit > 0 && elementCount + existingCount >= countLimit) ||
    (byteLimit > 0 && requestBytes + existingBytes >= byteLimit)
  ) ***REMOVED***
    this._runNow(bundleId);
    this._tasks[bundleId] = new Task(
      apiCall,
      request,
      this._descriptor.bundledField,
      this._descriptor.subresponseField
    );
    task = this._tasks[bundleId];
  ***REMOVED***

  task.extend(bundledField, requestBytes, callback);
  var ret = ***REMOVED***
    cancel: function() ***REMOVED***
      self._cancel(callback.id);
    ***REMOVED***,
  ***REMOVED***;

  var countThreshold = this._options.elementCountThreshold || 0;
  var sizeThreshold = this._options.requestByteThreshold || 0;
  if (
    (countThreshold > 0 && task.getElementCount() >= countThreshold) ||
    (sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold)
  ) ***REMOVED***
    this._runNow(bundleId);
    return ret;
  ***REMOVED***

  if (!(bundleId in this._timers) && this._options.delayThreshold > 0) ***REMOVED***
    this._timers[bundleId] = setTimeout(function() ***REMOVED***
      delete self._timers[bundleId];
      self._runNow(bundleId);
    ***REMOVED***, self._options.delayThreshold);
  ***REMOVED***

  return ret;
***REMOVED***;

/**
 * Clears scheduled timeout if it exists.
 *
 * @param ***REMOVED***String***REMOVED*** bundleId - the id for the task whose timeout needs to be
 *   cleared.
 * @private
 */
BundleExecutor.prototype._maybeClearTimeout = function(bundleId) ***REMOVED***
  if (bundleId in this._timers) ***REMOVED***
    var timerId = this._timers[bundleId];
    delete this._timers[bundleId];
    clearTimeout(timerId);
  ***REMOVED***
***REMOVED***;

/**
 * Cancels an event.
 *
 * @param ***REMOVED***String***REMOVED*** id - The id for the event in the task.
 * @private
 */
BundleExecutor.prototype._cancel = function(id) ***REMOVED***
  if (!(id in this._invocations)) ***REMOVED***
    return;
  ***REMOVED***
  var bundleId = this._invocations[id];
  if (!(bundleId in this._tasks)) ***REMOVED***
    return;
  ***REMOVED***

  var task = this._tasks[bundleId];
  delete this._invocations[id];
  if (task.cancel(id)) ***REMOVED***
    this._maybeClearTimeout(bundleId);
    delete this._tasks[bundleId];
  ***REMOVED***
***REMOVED***;

/**
 * Invokes a task.
 *
 * @param ***REMOVED***String***REMOVED*** bundleId - The id for the task.
 * @private
 */
BundleExecutor.prototype._runNow = function(bundleId) ***REMOVED***
  if (!(bundleId in this._tasks)) ***REMOVED***
    console.warn('no such bundleid: ' + bundleId);
    return;
  ***REMOVED***
  this._maybeClearTimeout(bundleId);
  var task = this._tasks[bundleId];
  delete this._tasks[bundleId];

  var self = this;
  task.run().forEach(function(id) ***REMOVED***
    delete self._invocations[id];
  ***REMOVED***);
***REMOVED***;

/**
 * Creates an API caller that bundles requests.
 *
 * @private
 * @constructor
 * @param ***REMOVED***BundleExecutor***REMOVED*** bundler - bundles API calls.
 */
function Bundleable(bundler) ***REMOVED***
  this.bundler = bundler;
  NormalApiCaller.call(this);
***REMOVED***

util.inherits(Bundleable, NormalApiCaller);

Bundleable.prototype.call = function(apiCall, argument, settings, status) ***REMOVED***
  if (settings.isBundling) ***REMOVED***
    var self = this;
    status.call(function(argument, callback) ***REMOVED***
      self.bundler.schedule(apiCall, argument, callback);
    ***REMOVED***, argument);
  ***REMOVED*** else ***REMOVED***
    NormalApiCaller.prototype.call.call(
      this,
      apiCall,
      argument,
      settings,
      status
    );
  ***REMOVED***
***REMOVED***;

/**
 * Describes the structure of bundled call.
 *
 * requestDiscriminatorFields may include '.' as a separator, which is used to
 * indicate object traversal. This allows fields in nested objects to be used
 * to determine what request to bundle.
 *
 * @property ***REMOVED***String***REMOVED*** bundledField
 * @property ***REMOVED***String***REMOVED*** requestDiscriminatorFields
 * @property ***REMOVED***String***REMOVED*** subresponseField
 * @property ***REMOVED***Function***REMOVED*** byteLengthFunction
 *
 * @param ***REMOVED***String***REMOVED*** bundledField - the repeated field in the request message
 *   that will have its elements aggregated by bundling.
 * @param ***REMOVED***String***REMOVED*** requestDiscriminatorFields - a list of fields in the
 *   target request message class that are used to detemrine which request
 *   messages should be bundled together.
 * @param ***REMOVED***String***REMOVED*** subresponseField - an optional field, when present it
 *   indicates the field in the response message that should be used to
 *   demultiplex the response into multiple response messages.
 * @param ***REMOVED***Function***REMOVED*** byteLengthFunction - a function to obtain the byte
 *   length to be consumed for the bundled field messages. Because Node.JS
 *   protobuf.js/gRPC uses builtin Objects for the user-visible data and
 *   internally they are encoded/decoded in protobuf manner, this function
 *   is actually necessary to calculate the byte length.
 * @constructor
 */
function BundleDescriptor(
  bundledField,
  requestDiscriminatorFields,
  subresponseField,
  byteLengthFunction
) ***REMOVED***
  if (!byteLengthFunction && typeof subresponseField === 'function') ***REMOVED***
    byteLengthFunction = subresponseField;
    subresponseField = null;
  ***REMOVED***
  this.bundledField = bundledField;
  this.requestDiscriminatorFields = requestDiscriminatorFields;
  this.subresponseField = subresponseField;
  this.byteLengthFunction = byteLengthFunction;
***REMOVED***
exports.BundleDescriptor = BundleDescriptor;

/**
 * Returns a new API caller.
 * @private
 * @param ***REMOVED***CallSettings***REMOVED*** settings - the current settings.
 * @return ***REMOVED***Bundleable***REMOVED*** - the new bundling API caller.
 */
BundleDescriptor.prototype.apiCaller = function(settings) ***REMOVED***
  return new Bundleable(new BundleExecutor(settings.bundleOptions, this));
***REMOVED***;
