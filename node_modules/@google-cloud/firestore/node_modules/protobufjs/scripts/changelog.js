"use strict";

var path = require("path"),
    fs   = require("fs");

var gitSemverTags = require("git-semver-tags"),
    gitRawCommits = require("git-raw-commits"),
    minimist      = require("minimist");

var basedir = path.join(__dirname, "..");
var pkg = require(basedir + "/package.json");

var argv = minimist(process.argv, ***REMOVED***
    alias: ***REMOVED***
        tag    : "t",
        write  : "w"
    ***REMOVED***,
    string: [ "tag" ],
    boolean: [ "write" ],
    default: ***REMOVED***
        tag: null,
        write: false
    ***REMOVED***
***REMOVED***);

// categories to be used in the future and regexes for lazy / older subjects
var validCategories = ***REMOVED***
    "Breaking": null,
    "Fixed": /fix|properly|prevent|correctly/i,
    "New": /added|initial/i,
    "CLI": /pbjs|pbts|CLI/,
    "Docs": /README/i,
    "Other": null
***REMOVED***;
var breakingFallback = /removed|stripped|dropped/i;

var repo = "https://github.com/dcodeIO/protobuf.js";

gitSemverTags(function(err, tags) ***REMOVED***
    if (err)
        throw err;

    var categories = ***REMOVED******REMOVED***;
    Object.keys(validCategories).forEach(function(category) ***REMOVED***
        categories[category] = [];
    ***REMOVED***);
    var output = [];

    var from = tags[0];
    var to = "HEAD";
    var tag;
    if (argv.tag) ***REMOVED***
        var idx = tags.indexOf(argv.tag);
        if (idx < 0)
            throw Error("no such tag: " + argv.tag);
        from = tags[idx + 1];
        tag = to = tags[idx];
    ***REMOVED*** else
        tag = pkg.version;

    var commits = gitRawCommits(***REMOVED***
        from: from,
        to: to,
        merges: false,
        format: "%B%n#%H"
    ***REMOVED***);

    commits.on("error", function(err) ***REMOVED***
        throw err;
    ***REMOVED***);

    commits.on("data", function(chunk) ***REMOVED***
        var message = chunk.toString("utf8").trim();
        var match = /#([0-9a-f]***REMOVED***40***REMOVED***)$/.exec(message);
        var hash;
        if (match) ***REMOVED***
            message = message.substring(0, message.length - match[1].length).trim();
            hash = match[1];
        ***REMOVED***
        message.split(";").forEach(function(message) ***REMOVED***
            if (/^(Merge pull request |Post-merge)/.test(message))
                return;
            var match = /^(\w+):/i.exec(message = message.trim());
            var category;
            if (match && match[1] in validCategories) ***REMOVED***
                category = match[1];
                message = message.substring(match[1].length + 1).trim();
            ***REMOVED*** else ***REMOVED***
                var keys = Object.keys(validCategories);
                for (var i = 0; i < keys.length; ++i) ***REMOVED***
                    var re = validCategories[keys[i]];
                    if (re && re.test(message)) ***REMOVED***
                        category = keys[i];
                        break;
                    ***REMOVED***
                ***REMOVED***
                message = message.replace(/^(\w+):/i, "").trim();
            ***REMOVED***
            if (!category) ***REMOVED***
                if (breakingFallback.test(message))
                    category = "Breaking";
                else
                    category = "Other";
            ***REMOVED***
            var nl = message.indexOf("\n");
            if (nl > -1)
                message = message.substring(0, nl).trim();
            if (!hash || message.length < 12)
                return;
            message = message.replace(/\[ci skip\]/, "").trim();
            categories[category].push(***REMOVED***
                text: message,
                hash: hash
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***);

    commits.on("end", function() ***REMOVED***
        output.push("# [" + tag + "](" + repo + "/releases/tag/" + tag + ")\n");
        Object.keys(categories).forEach(function(category) ***REMOVED***
            var messages = categories[category];
            if (!messages.length)
                return;
            output.push("\n## " + category + "\n");
            messages.forEach(function(message) ***REMOVED***
                var text = message.text.replace(/#(\d+)/g, "[#$1](" + repo + "/issues/$1)");
                output.push("[:hash:](" + repo + "/commit/" + message.hash + ") " + text + "<br />\n");
            ***REMOVED***);
        ***REMOVED***);
        var current;
        try ***REMOVED***
            current = fs.readFileSync(basedir + "/CHANGELOG.md").toString("utf8");
        ***REMOVED*** catch (e) ***REMOVED***
            current = "";
        ***REMOVED***
        var re = new RegExp("^# \\[" + tag + "\\]");
        if (re.test(current)) ***REMOVED*** // regenerated, replace
            var pos = current.indexOf("# [", 1);
            if (pos > -1)
                current = current.substring(pos).trim();
            else
                current = "";
        ***REMOVED***
        var contents = output.join("") + "\n" + current;
        if (argv.write)
            fs.writeFileSync(basedir + "/CHANGELOG.md", contents, "utf8");
        else
            process.stdout.write(contents);
    ***REMOVED***);
***REMOVED***);
