"use strict";
var child_process = require("child_process"),
    path     = require("path"),
    fs       = require("fs"),
    pkg      = require("./package.json"),
    util     = require("./util");

util.setup();

var minimist = require("minimist"),
    chalk    = require("chalk"),
    glob     = require("glob"),
    tmp      = require("tmp");

/**
 * Runs pbts programmatically.
 * @param ***REMOVED***string[]***REMOVED*** args Command line arguments
 * @param ***REMOVED***function(?Error, string=)***REMOVED*** [callback] Optional completion callback
 * @returns ***REMOVED***number|undefined***REMOVED*** Exit code, if known
 */
exports.main = function(args, callback) ***REMOVED***
    var argv = minimist(args, ***REMOVED***
        alias: ***REMOVED***
            name: "n",
            out : "o",
            main: "m",
            global: "g"
        ***REMOVED***,
        string: [ "name", "out", "global" ],
        boolean: [ "comments", "main" ],
        default: ***REMOVED***
            comments: true,
            main: false
        ***REMOVED***
    ***REMOVED***);

    var files  = argv._;

    if (!files.length) ***REMOVED***
        if (callback)
            callback(Error("usage")); // eslint-disable-line callback-return
        else
            process.stderr.write([
                "protobuf.js v" + pkg.version + " CLI for TypeScript",
                "",
                chalk.bold.white("Generates TypeScript definitions from annotated JavaScript files."),
                "",
                "  -o, --out       Saves to a file instead of writing to stdout.",
                "",
                "  -g, --global    Name of the global object in browser environments, if any.",
                "",
                "  --no-comments   Does not output any JSDoc comments.",
                "",
                chalk.bold.gray("  Internal flags:"),
                "",
                "  -n, --name      Wraps everything in a module of the specified name.",
                "",
                "  -m, --main      Whether building the main library without any imports.",
                "",
                "usage: " + chalk.bold.green("pbts") + " [options] file1.js file2.js ..." + chalk.bold.gray("  (or)  ") + "other | " + chalk.bold.green("pbts") + " [options] -",
                ""
            ].join("\n"));
        return 1;
    ***REMOVED***

    // Resolve glob expressions
    for (var i = 0; i < files.length;) ***REMOVED***
        if (glob.hasMagic(files[i])) ***REMOVED***
            var matches = glob.sync(files[i]);
            Array.prototype.splice.apply(files, [i, 1].concat(matches));
            i += matches.length;
        ***REMOVED*** else
            ++i;
    ***REMOVED***

    var cleanup = [];

    // Read from stdin (to a temporary file)
    if (files.length === 1 && files[0] === "-") ***REMOVED***
        var data = [];
        process.stdin.on("data", function(chunk) ***REMOVED***
            data.push(chunk);
        ***REMOVED***);
        process.stdin.on("end", function() ***REMOVED***
            files[0] = tmp.tmpNameSync() + ".js";
            fs.writeFileSync(files[0], Buffer.concat(data));
            cleanup.push(files[0]);
            callJsdoc();
        ***REMOVED***);

    // Load from disk
    ***REMOVED*** else ***REMOVED***
        callJsdoc();
    ***REMOVED***

    function callJsdoc() ***REMOVED***

        // There is no proper API for jsdoc, so this executes the CLI and pipes the output
        var basedir = path.join(__dirname, ".");
        var moduleName = argv.name || "null";
        var cmd = "node \"" + require.resolve("jsdoc/jsdoc.js") + "\" -c \"" + path.join(basedir, "lib", "tsd-jsdoc.json") + "\" -q \"module=" + encodeURIComponent(moduleName) + "&comments=" + Boolean(argv.comments) + "\" " + files.map(function(file) ***REMOVED*** return "\"" + file + "\""; ***REMOVED***).join(" ");
        var child = child_process.exec(cmd, ***REMOVED***
            cwd: process.cwd(),
            argv0: "node",
            stdio: "pipe",
            maxBuffer: 1 << 24 // 16mb
        ***REMOVED***);
        var out = [];
        var ended = false;
        var closed = false;
        child.stdout.on("data", function(data) ***REMOVED***
            out.push(data);
        ***REMOVED***);
        child.stdout.on("end", function() ***REMOVED***
            if (closed) finish();
            else ended = true;
        ***REMOVED***);
        child.stderr.pipe(process.stderr);
        child.on("close", function(code) ***REMOVED***
            // clean up temporary files, no matter what
            try ***REMOVED*** cleanup.forEach(fs.unlinkSync); ***REMOVED*** catch(e) ***REMOVED***/**/***REMOVED*** cleanup = [];

            if (code) ***REMOVED***
                out = out.join("").replace(/\s*JSDoc \d+\.\d+\.\d+ [^$]+/, "");
                process.stderr.write(out);
                var err = Error("code " + code);
                if (callback)
                    return callback(err);
                throw err;
            ***REMOVED***

            if (ended) return finish();
            closed = true;
            return undefined;
        ***REMOVED***);

        function finish() ***REMOVED***
            var output = [];
            if (argv.global)
                output.push(
                    "export as namespace " + argv.global + ";",
                    ""
                );
            if (!argv.main)
                output.push(
                    "import * as $protobuf from \"protobufjs\";",
                    ""
                );
            output = output.join("\n") + "\n" + out.join("");

            try ***REMOVED***
                if (argv.out)
                    fs.writeFileSync(argv.out, output, ***REMOVED*** encoding: "utf8" ***REMOVED***);
                else if (!callback)
                    process.stdout.write(output, "utf8");
                return callback
                    ? callback(null, output)
                    : undefined;
            ***REMOVED*** catch (err) ***REMOVED***
                if (callback)
                    return callback(err);
                throw err;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return undefined;
***REMOVED***;
