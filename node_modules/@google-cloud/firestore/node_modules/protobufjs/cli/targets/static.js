"use strict";
module.exports = static_target;

var protobuf   = require("../.."),
    UglifyJS   = require("uglify-js"),
    espree     = require("espree"),
    escodegen  = require("escodegen"),
    estraverse = require("estraverse");

var Type      = protobuf.Type,
    Service   = protobuf.Service,
    Enum      = protobuf.Enum,
    Namespace = protobuf.Namespace,
    util      = protobuf.util;

var out = [];
var indent = 0;
var config = ***REMOVED******REMOVED***;

static_target.description = "Static code without reflection (non-functional on its own)";

function static_target(root, options, callback) ***REMOVED***
    config = options;
    try ***REMOVED***
        var aliases = [];
        if (config.decode)
            aliases.push("Reader");
        if (config.encode)
            aliases.push("Writer");
        aliases.push("util");
        if (aliases.length) ***REMOVED***
            if (config.comments)
                push("// Common aliases");
            push((config.es6 ? "const " : "var ") + aliases.map(function(name) ***REMOVED*** return "$" + name + " = $protobuf." + name; ***REMOVED***).join(", ") + ";");
            push("");
        ***REMOVED***
        if (config.comments) ***REMOVED***
            if (root.comment) ***REMOVED***
                pushComment("@fileoverview " + root.comment);
                push("");
            ***REMOVED***
            push("// Exported root namespace");
        ***REMOVED***
        var rootProp = util.safeProp(config.root || "default");
        push((config.es6 ? "const" : "var") + " $root = $protobuf.roots" + rootProp + " || ($protobuf.roots" + rootProp + " = ***REMOVED******REMOVED***);");
        buildNamespace(null, root);
        return callback(null, out.join("\n"));
    ***REMOVED*** catch (err) ***REMOVED***
        return callback(err);
    ***REMOVED*** finally ***REMOVED***
        out = [];
        indent = 0;
        config = ***REMOVED******REMOVED***;
    ***REMOVED***
***REMOVED***

function push(line) ***REMOVED***
    if (line === "")
        return out.push("");
    var ind = "";
    for (var i = 0; i < indent; ++i)
        ind += "    ";
    return out.push(ind + line);
***REMOVED***

function pushComment(lines) ***REMOVED***
    if (!config.comments)
        return;
    var split = [];
    for (var i = 0; i < lines.length; ++i)
        if (lines[i] != null && lines[i].substring(0, 8) !== "@exclude")
            Array.prototype.push.apply(split, lines[i].split(/\r?\n/g));
    push("/**");
    split.forEach(function(line) ***REMOVED***
        if (line === null)
            return;
        push(" * " + line.replace(/\*\//g, "* /"));
    ***REMOVED***);
    push(" */");
***REMOVED***

function exportName(object, asInterface) ***REMOVED***
    if (asInterface) ***REMOVED***
        if (object.__interfaceName)
            return object.__interfaceName;
    ***REMOVED*** else if (object.__exportName)
        return object.__exportName;
    var parts = object.fullName.substring(1).split("."),
        i = 0;
    while (i < parts.length)
        parts[i] = escapeName(parts[i++]);
    if (asInterface)
        parts[i - 1] = "I" + parts[i - 1];
    return object[asInterface ? "__interfaceName" : "__exportName"] = parts.join(".");
***REMOVED***

function escapeName(name) ***REMOVED***
    if (!name)
        return "$root";
    return util.isReserved(name) ? name + "_" : name;
***REMOVED***

function aOrAn(name) ***REMOVED***
    return ((/^[hH](?:ou|on|ei)/.test(name) || /^[aeiouAEIOU][a-z]/.test(name)) && !/^us/i.test(name)
        ? "an "
        : "a ") + name;
***REMOVED***

function buildNamespace(ref, ns) ***REMOVED***
    if (!ns)
        return;
    if (ns.name !== "") ***REMOVED***
        push("");
        if (!ref && config.es6)
            push("export const " + escapeName(ns.name) + " = " + escapeName(ref) + "." + escapeName(ns.name) + " = (() => ***REMOVED***");
        else
            push(escapeName(ref) + "." + escapeName(ns.name) + " = (function() ***REMOVED***");
        ++indent;
    ***REMOVED***

    if (ns instanceof Type) ***REMOVED***
        buildType(undefined, ns);
    ***REMOVED*** else if (ns instanceof Service)
        buildService(undefined, ns);
    else if (ns.name !== "") ***REMOVED***
        push("");
        pushComment([
            ns.comment || "Namespace " + ns.name + ".",
            ns.parent instanceof protobuf.Root ? "@exports " + escapeName(ns.name) : "@memberof " + exportName(ns.parent),
            "@namespace"
        ]);
        push((config.es6 ? "const" : "var") + " " + escapeName(ns.name) + " = ***REMOVED******REMOVED***;");
    ***REMOVED***

    ns.nestedArray.forEach(function(nested) ***REMOVED***
        if (nested instanceof Enum)
            buildEnum(ns.name, nested);
        else if (nested instanceof Namespace)
            buildNamespace(ns.name, nested);
    ***REMOVED***);
    if (ns.name !== "") ***REMOVED***
        push("");
        push("return " + escapeName(ns.name) + ";");
        --indent;
        push("***REMOVED***)();");
    ***REMOVED***
***REMOVED***

var reduceableBlockStatements = ***REMOVED***
    IfStatement: true,
    ForStatement: true,
    WhileStatement: true
***REMOVED***;

var shortVars = ***REMOVED***
    "r": "reader",
    "w": "writer",
    "m": "message",
    "t": "tag",
    "l": "length",
    "c": "end", "c2": "end2",
    "k": "key",
    "ks": "keys", "ks2": "keys2",
    "e": "error",
    "f": "impl",
    "o": "options",
    "d": "object",
    "n": "long",
    "p": "properties"
***REMOVED***;

function beautifyCode(code) ***REMOVED***
    // Add semicolons
    code = UglifyJS.minify(code, ***REMOVED***
        fromString: true,
        compress: false,
        mangle: false,
        output: ***REMOVED***
            beautify: true
        ***REMOVED***
    ***REMOVED***).code;
    // Properly beautify
    var ast = espree.parse(code);
    estraverse.replace(ast, ***REMOVED***
        enter: function(node, parent) ***REMOVED***
            // rename short vars
            if (node.type === "Identifier" && (parent.property !== node || parent.computed) && shortVars[node.name])
                return ***REMOVED***
                    "type": "Identifier",
                    "name": shortVars[node.name]
                ***REMOVED***;
            // replace var with let if es6
            if (config.es6 && node.type === "VariableDeclaration" && node.kind === "var") ***REMOVED***
                node.kind = "let";
                return undefined;
            ***REMOVED***
            // remove braces around block statements with a single child
            if (node.type === "BlockStatement" && reduceableBlockStatements[parent.type] && node.body.length === 1)
                return node.body[0];
            return undefined;
        ***REMOVED***
    ***REMOVED***);
    code = escodegen.generate(ast, ***REMOVED***
        format: ***REMOVED***
            newline: "\n",
            quotes: "double"
        ***REMOVED***
    ***REMOVED***);
    // Add id, wireType comments
    if (config.comments)
        code = code.replace(/\.uint32\((\d+)\)/g, function($0, $1) ***REMOVED***
            var id = $1 >>> 3,
                wireType = $1 & 7;
            return ".uint32(/* id " + id + ", wireType " + wireType + " =*/" + $1 + ")";
        ***REMOVED***);
    return code;
***REMOVED***

var renameVars = ***REMOVED***
    "Writer": "$Writer",
    "Reader": "$Reader",
    "util": "$util"
***REMOVED***;

function buildFunction(type, functionName, gen, scope) ***REMOVED***
    var code = gen.toString(functionName)
        .replace(/((?!\.)types\[\d+])(\.values)/g, "$1"); // enums: use types[N] instead of reflected types[N].values

    var ast = espree.parse(code);
    /* eslint-disable no-extra-parens */
    estraverse.replace(ast, ***REMOVED***
        enter: function(node, parent) ***REMOVED***
            // rename vars
            if (
                node.type === "Identifier" && renameVars[node.name]
                && (
                    (parent.type === "MemberExpression" && parent.object === node)
                 || (parent.type === "BinaryExpression" && parent.right === node)
                )
            )
                return ***REMOVED***
                    "type": "Identifier",
                    "name": renameVars[node.name]
                ***REMOVED***;
            // replace this.ctor with the actual ctor
            if (
                node.type === "MemberExpression"
             && node.object.type === "ThisExpression"
             && node.property.type === "Identifier" && node.property.name === "ctor"
            )
                return ***REMOVED***
                    "type": "Identifier",
                    "name": "$root" + type.fullName
                ***REMOVED***;
            // replace types[N] with the field's actual type
            if (
                node.type === "MemberExpression"
             && node.object.type === "Identifier" && node.object.name === "types"
             && node.property.type === "Literal"
            )
                return ***REMOVED***
                    "type": "Identifier",
                    "name": "$root" + type.fieldsArray[node.property.value].resolvedType.fullName
                ***REMOVED***;
            return undefined;
        ***REMOVED***
    ***REMOVED***);
    /* eslint-enable no-extra-parens */
    code = escodegen.generate(ast, ***REMOVED***
        format: ***REMOVED***
            newline: "\n",
            quotes: "double"
        ***REMOVED***
    ***REMOVED***);

    if (config.beautify)
        code = beautifyCode(code);

    code = code.replace(/ ***REMOVED***4***REMOVED***/g, "\t");

    var hasScope = scope && Object.keys(scope).length,
        isCtor = functionName === type.name;

    if (hasScope) // remove unused scope vars
        Object.keys(scope).forEach(function(key) ***REMOVED***
            if (!new RegExp("\\b(" + key + ")\\b", "g").test(code))
                delete scope[key];
        ***REMOVED***);

    var lines = code.split(/\n/g);
    if (isCtor) // constructor
        push(lines[0]);
    else if (hasScope) // enclose in an iife
        push(escapeName(type.name) + "." + escapeName(functionName) + " = (function(" + Object.keys(scope).map(escapeName).join(", ") + ") ***REMOVED*** return " + lines[0]);
    else
        push(escapeName(type.name) + "." + escapeName(functionName) + " = " + lines[0]);
    lines.slice(1, lines.length - 1).forEach(function(line) ***REMOVED***
        var prev = indent;
        var i = 0;
        while (line.charAt(i++) === "\t")
            ++indent;
        push(line.trim());
        indent = prev;
    ***REMOVED***);
    if (isCtor)
        push("***REMOVED***");
    else if (hasScope)
        push("***REMOVED***;***REMOVED***)(" + Object.keys(scope).map(function(key) ***REMOVED*** return scope[key]; ***REMOVED***).join(", ") + ");");
    else
        push("***REMOVED***;");
***REMOVED***

function toJsType(field) ***REMOVED***
    var type;

    switch (field.type) ***REMOVED***
        case "double":
        case "float":
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
            type = "number";
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
            type = config.forceLong ? "Long" : config.forceNumber ? "number" : "number|Long";
            break;
        case "bool":
            type = "boolean";
            break;
        case "string":
            type = "string";
            break;
        case "bytes":
            type = "Uint8Array";
            break;
        default:
            if (field.resolve().resolvedType)
                type = exportName(field.resolvedType, !(field.resolvedType instanceof protobuf.Enum || config.forceMessage));
            else
                type = "*"; // should not happen
            break;
    ***REMOVED***
    if (field.map)
        return "Object.<string," + type + ">";
    if (field.repeated)
        return "Array.<" + type + ">";
    return type;
***REMOVED***

function buildType(ref, type) ***REMOVED***

    if (config.comments) ***REMOVED***
        var typeDef = [
            "Properties of " + aOrAn(type.name) + ".",
            type.parent instanceof protobuf.Root ? "@exports " + escapeName("I" + type.name) : "@memberof " + exportName(type.parent),
            "@interface " + escapeName("I" + type.name)
        ];
        type.fieldsArray.forEach(function(field) ***REMOVED***
            var prop = util.safeProp(field.name); // either .name or ["name"]
            prop = prop.substring(1, prop.charAt(0) === "[" ? prop.length - 1 : prop.length);
            var jsType = toJsType(field);
            if (field.optional)
                jsType = jsType + "|null";
            typeDef.push("@property ***REMOVED***" + jsType + "***REMOVED*** " + (field.optional ? "[" + prop + "]" : prop) + " " + (field.comment || type.name + " " + field.name));
        ***REMOVED***);
        push("");
        pushComment(typeDef);
    ***REMOVED***

    // constructor
    push("");
    pushComment([
        "Constructs a new " + type.name + ".",
        type.parent instanceof protobuf.Root ? "@exports " + escapeName(type.name) : "@memberof " + exportName(type.parent),
        "@classdesc " + (type.comment || "Represents " + aOrAn(type.name) + "."),
        config.comments ? "@implements " + escapeName("I" + type.name) : null,
        "@constructor",
        "@param ***REMOVED***" + exportName(type, true) + "=***REMOVED*** [" + (config.beautify ? "properties" : "p") + "] Properties to set"
    ]);
    buildFunction(type, type.name, Type.generateConstructor(type));

    // default values
    var firstField = true;
    type.fieldsArray.forEach(function(field) ***REMOVED***
        field.resolve();
        var prop = util.safeProp(field.name);
        if (config.comments) ***REMOVED***
            push("");
            var jsType = toJsType(field);
            if (field.optional && !field.map && !field.repeated && field.resolvedType instanceof Type)
                jsType = jsType + "|null|undefined";
            pushComment([
                field.comment || type.name + " " + field.name + ".",
                "@member ***REMOVED***" + jsType + "***REMOVED*** " + field.name,
                "@memberof " + exportName(type),
                "@instance"
            ]);
        ***REMOVED*** else if (firstField) ***REMOVED***
            push("");
            firstField = false;
        ***REMOVED***
        if (field.repeated)
            push(escapeName(type.name) + ".prototype" + prop + " = $util.emptyArray;"); // overwritten in constructor
        else if (field.map)
            push(escapeName(type.name) + ".prototype" + prop + " = $util.emptyObject;"); // overwritten in constructor
        else if (field.long)
            push(escapeName(type.name) + ".prototype" + prop + " = $util.Long ? $util.Long.fromBits("
                    + JSON.stringify(field.typeDefault.low) + ","
                    + JSON.stringify(field.typeDefault.high) + ","
                    + JSON.stringify(field.typeDefault.unsigned)
                + ") : " + field.typeDefault.toNumber(field.type.charAt(0) === "u") + ";");
        else if (field.bytes) ***REMOVED***
            push(escapeName(type.name) + ".prototype" + prop + " = $util.newBuffer(" + JSON.stringify(Array.prototype.slice.call(field.typeDefault)) + ");");
        ***REMOVED*** else
            push(escapeName(type.name) + ".prototype" + prop + " = " + JSON.stringify(field.typeDefault) + ";");
    ***REMOVED***);

    // virtual oneof fields
    var firstOneOf = true;
    type.oneofsArray.forEach(function(oneof) ***REMOVED***
        if (firstOneOf) ***REMOVED***
            firstOneOf = false;
            push("");
            if (config.comments)
                push("// OneOf field names bound to virtual getters and setters");
            push((config.es6 ? "let" : "var") + " $oneOfFields;");
        ***REMOVED***
        oneof.resolve();
        push("");
        pushComment([
            oneof.comment || type.name + " " + oneof.name + ".",
            "@member ***REMOVED***" + oneof.oneof.map(JSON.stringify).join("|") + "|undefined***REMOVED*** " + escapeName(oneof.name),
            "@memberof " + exportName(type),
            "@instance"
        ]);
        push("Object.defineProperty(" + escapeName(type.name) + ".prototype, " + JSON.stringify(oneof.name) +", ***REMOVED***");
        ++indent;
            push("get: $util.oneOfGetter($oneOfFields = [" + oneof.oneof.map(JSON.stringify).join(", ") + "]),");
            push("set: $util.oneOfSetter($oneOfFields)");
        --indent;
        push("***REMOVED***);");
    ***REMOVED***);

    if (config.create) ***REMOVED***
        push("");
        pushComment([
            "Creates a new " + type.name + " instance using the specified properties.",
            "@function create",
            "@memberof " + exportName(type),
            "@static",
            "@param ***REMOVED***" + exportName(type, true) + "=***REMOVED*** [properties] Properties to set",
            "@returns ***REMOVED***" + exportName(type) + "***REMOVED*** " + type.name + " instance"
        ]);
        push(escapeName(type.name) + ".create = function create(properties) ***REMOVED***");
            ++indent;
            push("return new " + escapeName(type.name) + "(properties);");
            --indent;
        push("***REMOVED***;");
    ***REMOVED***

    if (config.encode) ***REMOVED***
        push("");
        pushComment([
            "Encodes the specified " + type.name + " message. Does not implicitly ***REMOVED***@link " + exportName(type) + ".verify|verify***REMOVED*** messages.",
            "@function encode",
            "@memberof " + exportName(type),
            "@static",
            "@param ***REMOVED***" + exportName(type, !config.forceMessage) + "***REMOVED*** " + (config.beautify ? "message" : "m") + " " + type.name + " message or plain object to encode",
            "@param ***REMOVED***$protobuf.Writer***REMOVED*** [" + (config.beautify ? "writer" : "w") + "] Writer to encode to",
            "@returns ***REMOVED***$protobuf.Writer***REMOVED*** Writer"
        ]);
        buildFunction(type, "encode", protobuf.encoder(type));

        if (config.delimited) ***REMOVED***
            push("");
            pushComment([
                "Encodes the specified " + type.name + " message, length delimited. Does not implicitly ***REMOVED***@link " + exportName(type) + ".verify|verify***REMOVED*** messages.",
                "@function encodeDelimited",
                "@memberof " + exportName(type),
                "@static",
                "@param ***REMOVED***" + exportName(type, !config.forceMessage) + "***REMOVED*** message " + type.name + " message or plain object to encode",
                "@param ***REMOVED***$protobuf.Writer***REMOVED*** [writer] Writer to encode to",
                "@returns ***REMOVED***$protobuf.Writer***REMOVED*** Writer"
            ]);
            push(escapeName(type.name) + ".encodeDelimited = function encodeDelimited(message, writer) ***REMOVED***");
            ++indent;
            push("return this.encode(message, writer).ldelim();");
            --indent;
            push("***REMOVED***;");
        ***REMOVED***
    ***REMOVED***

    if (config.decode) ***REMOVED***
        push("");
        pushComment([
            "Decodes " + aOrAn(type.name) + " message from the specified reader or buffer.",
            "@function decode",
            "@memberof " + exportName(type),
            "@static",
            "@param ***REMOVED***$protobuf.Reader|Uint8Array***REMOVED*** " + (config.beautify ? "reader" : "r") + " Reader or buffer to decode from",
            "@param ***REMOVED***number***REMOVED*** [" + (config.beautify ? "length" : "l") + "] Message length if known beforehand",
            "@returns ***REMOVED***" + exportName(type) + "***REMOVED*** " + type.name,
            "@throws ***REMOVED***Error***REMOVED*** If the payload is not a reader or valid buffer",
            "@throws ***REMOVED***$protobuf.util.ProtocolError***REMOVED*** If required fields are missing"
        ]);
        buildFunction(type, "decode", protobuf.decoder(type));

        if (config.delimited) ***REMOVED***
            push("");
            pushComment([
                "Decodes " + aOrAn(type.name) + " message from the specified reader or buffer, length delimited.",
                "@function decodeDelimited",
                "@memberof " + exportName(type),
                "@static",
                "@param ***REMOVED***$protobuf.Reader|Uint8Array***REMOVED*** reader Reader or buffer to decode from",
                "@returns ***REMOVED***" + exportName(type) + "***REMOVED*** " + type.name,
                "@throws ***REMOVED***Error***REMOVED*** If the payload is not a reader or valid buffer",
                "@throws ***REMOVED***$protobuf.util.ProtocolError***REMOVED*** If required fields are missing"
            ]);
            push(escapeName(type.name) + ".decodeDelimited = function decodeDelimited(reader) ***REMOVED***");
            ++indent;
                push("if (!(reader instanceof $Reader))");
                ++indent;
                    push("reader = new $Reader(reader);");
                --indent;
                push("return this.decode(reader, reader.uint32());");
            --indent;
            push("***REMOVED***;");
        ***REMOVED***
    ***REMOVED***

    if (config.verify) ***REMOVED***
        push("");
        pushComment([
            "Verifies " + aOrAn(type.name) + " message.",
            "@function verify",
            "@memberof " + exportName(type),
            "@static",
            "@param ***REMOVED***Object.<string,*>***REMOVED*** " + (config.beautify ? "message" : "m") + " Plain object to verify",
            "@returns ***REMOVED***string|null***REMOVED*** `null` if valid, otherwise the reason why it is not"
        ]);
        buildFunction(type, "verify", protobuf.verifier(type));
    ***REMOVED***

    if (config.convert) ***REMOVED***
        push("");
        pushComment([
            "Creates " + aOrAn(type.name) + " message from a plain object. Also converts values to their respective internal types.",
            "@function fromObject",
            "@memberof " + exportName(type),
            "@static",
            "@param ***REMOVED***Object.<string,*>***REMOVED*** " + (config.beautify ? "object" : "d") + " Plain object",
            "@returns ***REMOVED***" + exportName(type) + "***REMOVED*** " + type.name
        ]);
        buildFunction(type, "fromObject", protobuf.converter.fromObject(type));

        push("");
        pushComment([
            "Creates a plain object from " + aOrAn(type.name) + " message. Also converts values to other types if specified.",
            "@function toObject",
            "@memberof " + exportName(type),
            "@static",
            "@param ***REMOVED***" + exportName(type) + "***REMOVED*** " + (config.beautify ? "message" : "m") + " " + type.name,
            "@param ***REMOVED***$protobuf.IConversionOptions***REMOVED*** [" + (config.beautify ? "options" : "o") + "] Conversion options",
            "@returns ***REMOVED***Object.<string,*>***REMOVED*** Plain object"
        ]);
        buildFunction(type, "toObject", protobuf.converter.toObject(type));

        push("");
        pushComment([
            "Converts this " + type.name + " to JSON.",
            "@function toJSON",
            "@memberof " + exportName(type),
            "@instance",
            "@returns ***REMOVED***Object.<string,*>***REMOVED*** JSON object"
        ]);
        push(escapeName(type.name) + ".prototype.toJSON = function toJSON() ***REMOVED***");
        ++indent;
            push("return this.constructor.toObject(this, $protobuf.util.toJSONOptions);");
        --indent;
        push("***REMOVED***;");
    ***REMOVED***
***REMOVED***

function buildService(ref, service) ***REMOVED***

    push("");
    pushComment([
        "Constructs a new " + service.name + " service.",
        service.parent instanceof protobuf.Root ? "@exports " + escapeName(service.name) : "@memberof " + exportName(service.parent),
        "@classdesc " + (service.comment || "Represents " + aOrAn(service.name)),
        "@extends $protobuf.rpc.Service",
        "@constructor",
        "@param ***REMOVED***$protobuf.RPCImpl***REMOVED*** rpcImpl RPC implementation",
        "@param ***REMOVED***boolean***REMOVED*** [requestDelimited=false] Whether requests are length-delimited",
        "@param ***REMOVED***boolean***REMOVED*** [responseDelimited=false] Whether responses are length-delimited"
    ]);
    push("function " + escapeName(service.name) + "(rpcImpl, requestDelimited, responseDelimited) ***REMOVED***");
    ++indent;
    push("$protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);");
    --indent;
    push("***REMOVED***");
    push("");
    push("(" + escapeName(service.name) + ".prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = " + escapeName(service.name) + ";");

    if (config.create) ***REMOVED***
        push("");
        pushComment([
            "Creates new " + service.name + " service using the specified rpc implementation.",
            "@function create",
            "@memberof " + exportName(service),
            "@static",
            "@param ***REMOVED***$protobuf.RPCImpl***REMOVED*** rpcImpl RPC implementation",
            "@param ***REMOVED***boolean***REMOVED*** [requestDelimited=false] Whether requests are length-delimited",
            "@param ***REMOVED***boolean***REMOVED*** [responseDelimited=false] Whether responses are length-delimited",
            "@returns ***REMOVED***" + escapeName(service.name) + "***REMOVED*** RPC service. Useful where requests and/or responses are streamed."
        ]);
        push(escapeName(service.name) + ".create = function create(rpcImpl, requestDelimited, responseDelimited) ***REMOVED***");
            ++indent;
            push("return new this(rpcImpl, requestDelimited, responseDelimited);");
            --indent;
        push("***REMOVED***;");
    ***REMOVED***

    service.methodsArray.forEach(function(method) ***REMOVED***
        method.resolve();
        var lcName = protobuf.util.lcFirst(method.name),
            cbName = escapeName(method.name + "Callback");
        push("");
        pushComment([
            "Callback as used by ***REMOVED***@link " + exportName(service) + "#" + escapeName(lcName) + "***REMOVED***.",
            // This is a more specialized version of protobuf.rpc.ServiceCallback
            "@memberof " + exportName(service),
            "@typedef " + cbName,
            "@type ***REMOVED***function***REMOVED***",
            "@param ***REMOVED***Error|null***REMOVED*** error Error, if any",
            "@param ***REMOVED***" + exportName(method.resolvedResponseType) + "***REMOVED*** [response] " + method.resolvedResponseType.name
        ]);
        push("");
        pushComment([
            method.comment || "Calls " + method.name + ".",
            "@function " + lcName,
            "@memberof " + exportName(service),
            "@instance",
            "@param ***REMOVED***" + exportName(method.resolvedRequestType, !config.forceMessage) + "***REMOVED*** request " + method.resolvedRequestType.name + " message or plain object",
            "@param ***REMOVED***" + exportName(service) + "." + cbName + "***REMOVED*** callback Node-style callback called with the error, if any, and " + method.resolvedResponseType.name,
            "@returns ***REMOVED***undefined***REMOVED***",
            "@variation 1"
        ]);
        push(escapeName(service.name) + ".prototype" + util.safeProp(lcName) + " = function " + escapeName(lcName) + "(request, callback) ***REMOVED***");
            ++indent;
            push("return this.rpcCall(" + escapeName(lcName) + ", $root." + exportName(method.resolvedRequestType) + ", $root." + exportName(method.resolvedResponseType) + ", request, callback);");
            --indent;
        push("***REMOVED***;");
        if (config.comments)
            push("");
        pushComment([
            method.comment || "Calls " + method.name + ".",
            "@function " + lcName,
            "@memberof " + exportName(service),
            "@instance",
            "@param ***REMOVED***" + exportName(method.resolvedRequestType, !config.forceMessage) + "***REMOVED*** request " + method.resolvedRequestType.name + " message or plain object",
            "@returns ***REMOVED***Promise<" + exportName(method.resolvedResponseType) + ">***REMOVED*** Promise",
            "@variation 2"
        ]);
    ***REMOVED***);
***REMOVED***

function buildEnum(ref, enm) ***REMOVED***

    push("");
    var comment = [
        enm.comment || enm.name + " enum.",
        enm.parent instanceof protobuf.Root ? "@exports " + escapeName(enm.name) : "@name " + exportName(enm),
        config.forceEnumString ? "@enum ***REMOVED***number***REMOVED***" : "@enum ***REMOVED***string***REMOVED***",
    ];
    Object.keys(enm.values).forEach(function(key) ***REMOVED***
        var val = config.forceEnumString ? key : enm.values[key];
        comment.push((config.forceEnumString ? "@property ***REMOVED***string***REMOVED*** " : "@property ***REMOVED***number***REMOVED*** ") + key + "=" + val + " " + (enm.comments[key] || key + " value"));
    ***REMOVED***);
    pushComment(comment);
    push(escapeName(ref) + "." + escapeName(enm.name) + " = (function() ***REMOVED***");
    ++indent;
        push((config.es6 ? "const" : "var") + " valuesById = ***REMOVED******REMOVED***, values = Object.create(valuesById);");
        var aliased = [];
        Object.keys(enm.values).forEach(function(key) ***REMOVED***
            var valueId = enm.values[key];
            var val = config.forceEnumString ? JSON.stringify(key) : valueId;
            if (aliased.indexOf(valueId) > -1)
                push("values[" + JSON.stringify(key) + "] = " + val + ";");
            else ***REMOVED***
                push("values[valuesById[" + valueId + "] = " + JSON.stringify(key) + "] = " + val + ";");
                aliased.push(valueId);
            ***REMOVED***
        ***REMOVED***);
        push("return values;");
    --indent;
    push("***REMOVED***)();");
***REMOVED***
