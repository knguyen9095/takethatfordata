"use strict";
module.exports = proto_target;

proto_target.private = true;

var protobuf = require("../..");

var Namespace  = protobuf.Namespace,
    Enum       = protobuf.Enum,
    Type       = protobuf.Type,
    Field      = protobuf.Field,
    OneOf      = protobuf.OneOf,
    Service    = protobuf.Service,
    Method     = protobuf.Method,
    types      = protobuf.types,
    util       = protobuf.util;

function underScore(str) ***REMOVED***
    return str.substring(0,1)
         + str.substring(1)
               .replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) ***REMOVED*** return "_" + $1.toLowerCase(); ***REMOVED***);
***REMOVED***

var out = [];
var indent = 0;
var first = false;
var syntax = 3;

function proto_target(root, options, callback) ***REMOVED***
    if (options) ***REMOVED***
        switch (options.syntax) ***REMOVED***
            case undefined:
            case "proto3":
            case "3":
                syntax = 3;
                break;
            case "proto2":
            case "2":
                syntax = 2;
                break;
            default:
                return callback(Error("invalid syntax: " + options.syntax));
        ***REMOVED***
    ***REMOVED***
    indent = 0;
    first = false;
    try ***REMOVED***
        buildRoot(root);
        return callback(null, out.join("\n"));
    ***REMOVED*** catch (err) ***REMOVED***
        return callback(err);
    ***REMOVED*** finally ***REMOVED***
        out = [];
        syntax = 3;
    ***REMOVED***
***REMOVED***

function push(line) ***REMOVED***
    if (line === "")
        out.push("");
    else ***REMOVED***
        var ind = "";
        for (var i = 0; i < indent; ++i)
            ind += "    ";
        out.push(ind + line);
    ***REMOVED***
***REMOVED***

function escape(str) ***REMOVED***
    return str.replace(/[\\"']/g, "\\$&")
              .replace(/\r/g, "\\r")
              .replace(/\n/g, "\\n")
              .replace(/\u0000/g, "\\0");
***REMOVED***

function value(v) ***REMOVED***
    switch (typeof v) ***REMOVED***
        case "boolean":
            return v ? "true" : "false";
        case "number":
            return v.toString();
        default:
            return "\"" + escape(String(v)) + "\"";
    ***REMOVED***
***REMOVED***

function buildRoot(root) ***REMOVED***
    root.resolveAll();
    var pkg = [];
    var ptr = root;
    var repeat = true;
    do ***REMOVED***
        var nested = ptr.nestedArray;
        if (nested.length === 1 && nested[0] instanceof Namespace && !(nested[0] instanceof Type || nested[0] instanceof Service)) ***REMOVED***
            ptr = nested[0];
            if (ptr !== root)
                pkg.push(ptr.name);
        ***REMOVED*** else
            repeat = false;
    ***REMOVED*** while (repeat);
    out.push("syntax = \"proto" + syntax + "\";");
    if (pkg.length)
        out.push("", "package " + pkg.join(".") + ";");

    buildOptions(ptr);
    ptr.nestedArray.forEach(build);
***REMOVED***

function build(object) ***REMOVED***
    if (object instanceof Enum)
        buildEnum(object);
    else if (object instanceof Type)
        buildType(object);
    else if (object instanceof Field)
        buildField(object);
    else if (object instanceof OneOf)
        buildOneOf(object);
    else if (object instanceof Service)
        buildService(object);
    else if (object instanceof Method)
        buildMethod(object);
    else
        buildNamespace(object);
***REMOVED***

function buildNamespace(namespace) ***REMOVED*** // just a namespace, not a type etc.
    push("");
    push("message " + namespace.name + " ***REMOVED***");
    ++indent;
    buildOptions(namespace);
    consolidateExtends(namespace.nestedArray).remaining.forEach(build);
    --indent;
    push("***REMOVED***");
***REMOVED***

function buildEnum(enm) ***REMOVED***
    push("");
    push("enum " + enm.name + " ***REMOVED***");
    buildOptions(enm);
    ++indent; first = true;
    Object.keys(enm.values).forEach(function(name) ***REMOVED***
        var val = enm.values[name];
        if (first) ***REMOVED***
            push("");
            first = false;
        ***REMOVED***
        push(name + " = " + val + ";");
    ***REMOVED***);
    --indent; first = false;
    push("***REMOVED***");
***REMOVED***

function buildRanges(keyword, ranges) ***REMOVED***
    if (ranges && ranges.length) ***REMOVED***
        var parts = [];
        ranges.forEach(function(range) ***REMOVED***
            if (typeof range === "string")
                parts.push("\"" + escape(range) + "\"");
            else if (range[0] === range[1])
                parts.push(range[0]);
            else
                parts.push(range[0] + " to " + (range[1] === 0x1FFFFFFF ? "max" : range[1]));
        ***REMOVED***);
        push("");
        push(keyword + " " + parts.join(", ") + ";");
    ***REMOVED***
***REMOVED***

function buildType(type) ***REMOVED***
    if (type.group)
        return; // built with the sister-field
    push("");
    push("message " + type.name + " ***REMOVED***");
    ++indent;
    buildOptions(type);
    type.oneofsArray.forEach(build);
    first = true;
    type.fieldsArray.forEach(build);
    consolidateExtends(type.nestedArray).remaining.forEach(build);
    buildRanges("extensions", type.extensions);
    buildRanges("reserved", type.reserved);
    --indent;
    push("***REMOVED***");
***REMOVED***

function buildField(field, passExtend) ***REMOVED***
    if (field.partOf || field.declaringField || field.extend !== undefined && !passExtend)
        return;
    if (first) ***REMOVED***
        first = false;
        push("");
    ***REMOVED***
    if (field.resolvedType && field.resolvedType.group) ***REMOVED***
        buildGroup(field);
        return;
    ***REMOVED***
    var sb = [];
    if (field.map)
        sb.push("map<" + field.keyType + ", " + field.type + ">");
    else if (field.repeated)
        sb.push("repeated", field.type);
    else if (syntax === 2 || field.parent.group)
        sb.push(field.required ? "required" : "optional", field.type);
    else
        sb.push(field.type);
    sb.push(underScore(field.name), "=", field.id);
    var opts = buildFieldOptions(field);
    if (opts)
        sb.push(opts);
    push(sb.join(" ") + ";");
***REMOVED***

function buildGroup(field) ***REMOVED***
    push(field.rule + " group " + field.resolvedType.name + " = " + field.id + " ***REMOVED***");
    ++indent;
    buildOptions(field.resolvedType);
    first = true;
    field.resolvedType.fieldsArray.forEach(function(field) ***REMOVED***
        buildField(field);
    ***REMOVED***);
    --indent;
    push("***REMOVED***");
***REMOVED***

function buildFieldOptions(field) ***REMOVED***
    var keys;
    if (!field.options || !(keys = Object.keys(field.options)).length)
        return null;
    var sb = [];
    keys.forEach(function(key) ***REMOVED***
        var val = field.options[key];
        var wireType = types.packed[field.resolvedType instanceof Enum ? "int32" : field.type];
        switch (key) ***REMOVED***
            case "packed":
                val = Boolean(val);
                // skip when not packable or syntax default
                if (wireType === undefined || syntax === 3 === val)
                    return;
                break;
            case "default":
                if (syntax === 3)
                    return;
                // skip default (resolved) default values
                if (field.long && !util.longNeq(field.defaultValue, types.defaults[field.type]) || !field.long && field.defaultValue === types.defaults[field.type])
                    return;
                // enum defaults specified as strings are type references and not enclosed in quotes
                if (field.resolvedType instanceof Enum)
                    break;
                // otherwise fallthrough
            default:
                val = value(val);
                break;
        ***REMOVED***
        sb.push(key + "=" + val);
    ***REMOVED***);
    return sb.length
        ? "[" + sb.join(", ") + "]"
        : null;
***REMOVED***

function consolidateExtends(nested) ***REMOVED***
    var ext = ***REMOVED******REMOVED***;
    nested = nested.filter(function(obj) ***REMOVED***
        if (!(obj instanceof Field) || obj.extend === undefined)
            return true;
        (ext[obj.extend] || (ext[obj.extend] = [])).push(obj);
        return false;
    ***REMOVED***);
    Object.keys(ext).forEach(function(extend) ***REMOVED***
        push("");
        push("extend " + extend + " ***REMOVED***");
        ++indent; first = true;
        ext[extend].forEach(function(field) ***REMOVED***
            buildField(field, true);
        ***REMOVED***);
        --indent;
        push("***REMOVED***");
    ***REMOVED***);
    return ***REMOVED***
        remaining: nested
    ***REMOVED***;
***REMOVED***

function buildOneOf(oneof) ***REMOVED***
    push("");
    push("oneof " + underScore(oneof.name) + " ***REMOVED***");
    ++indent; first = true;
    oneof.oneof.forEach(function(fieldName) ***REMOVED***
        var field = oneof.parent.get(fieldName);
        if (first) ***REMOVED***
            first = false;
            push("");
        ***REMOVED***
        var opts = buildFieldOptions(field);
        push(field.type + " " + underScore(field.name) + " = " + field.id + (opts ? " " + opts : "") + ";");
    ***REMOVED***);
    --indent;
    push("***REMOVED***");
***REMOVED***

function buildService(service) ***REMOVED***
    push("service " + service.name + " ***REMOVED***");
    ++indent;
    service.methodsArray.forEach(build);
    consolidateExtends(service.nestedArray).remaining.forEach(build);
    --indent;
    push("***REMOVED***");
***REMOVED***

function buildMethod(method) ***REMOVED***
    push(method.type + " " + method.name + " (" + (method.requestStream ? "stream " : "") + method.requestType + ") returns (" + (method.responseStream ? "stream " : "") + method.responseType + ");");
***REMOVED***

function buildOptions(object) ***REMOVED***
    if (!object.options)
        return;
    first = true;
    Object.keys(object.options).forEach(function(key) ***REMOVED***
        if (first) ***REMOVED***
            first = false;
            push("");
        ***REMOVED***
        var val = object.options[key];
        push("option " + key + " = " + JSON.stringify(val) + ";");
    ***REMOVED***);
***REMOVED***
