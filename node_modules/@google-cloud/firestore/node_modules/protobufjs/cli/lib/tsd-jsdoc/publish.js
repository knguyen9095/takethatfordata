"use strict";

var fs = require("fs");

// output stream
var out = null;

// documentation data
var data = null;

// already handled objects, by name
var seen = ***REMOVED******REMOVED***;

// indentation level
var indent = 0;

// whether indent has been written for the current line yet
var indentWritten = false;

// provided options
var options = ***REMOVED******REMOVED***;

// queued interfaces
var queuedInterfaces = [];

// whether writing the first line
var firstLine = true;

// JSDoc hook
exports.publish = function publish(taffy, opts) ***REMOVED***
    options = opts || ***REMOVED******REMOVED***;

    // query overrides options
    if (options.query)
        Object.keys(options.query).forEach(function(key) ***REMOVED***
            if (key !== "query")
                switch (options[key] = options.query[key]) ***REMOVED***
                    case "true":
                        options[key] = true;
                        break;
                    case "false":
                        options[key] = false;
                        break;
                    case "null":
                        options[key] = null;
                        break;
                ***REMOVED***
        ***REMOVED***);

    // remove undocumented
    taffy(***REMOVED*** undocumented: true ***REMOVED***).remove();
    taffy(***REMOVED*** ignore: true ***REMOVED***).remove();
    taffy(***REMOVED*** inherited: true ***REMOVED***).remove();

    // remove private
    if (!options.private)
        taffy(***REMOVED*** access: "private" ***REMOVED***).remove();

    // setup output
    out = options.destination
        ? fs.createWriteStream(options.destination)
        : process.stdout;

    try ***REMOVED***
        // setup environment
        data = taffy().get();
        indent = 0;
        indentWritten = false;
        firstLine = true;

        // wrap everything in a module if configured
        if (options.module) ***REMOVED***
            writeln("export = ", options.module, ";");
            writeln();
            writeln("declare namespace ", options.module, " ***REMOVED***");
            writeln();
            ++indent;
        ***REMOVED***

        // handle all
        getChildrenOf(undefined).forEach(function(child) ***REMOVED***
            handleElement(child, null);
        ***REMOVED***);

        // process queued
        while (queuedInterfaces.length) ***REMOVED***
            var element = queuedInterfaces.shift();
            begin(element);
            writeInterface(element);
            writeln(";");
        ***REMOVED***

        // end wrap
        if (options.module) ***REMOVED***
            --indent;
            writeln("***REMOVED***");
        ***REMOVED***

        // close file output
        if (out !== process.stdout)
            out.end();

    ***REMOVED*** finally ***REMOVED***
        // gc environment objects
        out = data = null;
        seen = options = ***REMOVED******REMOVED***;
        queuedInterfaces = [];
    ***REMOVED***
***REMOVED***;

//
// Utility
//

// writes one or multiple strings
function write() ***REMOVED***
    var s = Array.prototype.slice.call(arguments).join("");
    if (!indentWritten) ***REMOVED***
        for (var i = 0; i < indent; ++i)
            s = "    " + s;
        indentWritten = true;
    ***REMOVED***
    out.write(s);
    firstLine = false;
***REMOVED***

// writes zero or multiple strings, followed by a new line
function writeln() ***REMOVED***
    var s = Array.prototype.slice.call(arguments).join("");
    if (s.length)
        write(s, "\n");
    else if (!firstLine)
        out.write("\n");
    indentWritten = false;
***REMOVED***

var keepTags = [
    "param",
    "returns",
    "throws",
    "see"
];

// parses a comment into text and tags
function parseComment(comment) ***REMOVED***
    var lines = comment.replace(/^ *\/\*\* *|^ *\*\/| *\*\/ *$|^ *\* */mg, "").trim().split(/\r?\n|\r/g); // property.description has just "\r" ?!
    var desc;
    var text = [];
    var tags = null;
    for (var i = 0; i < lines.length; ++i) ***REMOVED***
        var match = /^@(\w+)\b/.exec(lines[i]);
        if (match) ***REMOVED***
            if (!tags) ***REMOVED***
                tags = [];
                desc = text;
            ***REMOVED***
            text = [];
            tags.push(***REMOVED*** name: match[1], text: text ***REMOVED***);
            lines[i] = lines[i].substring(match[1].length + 1).trim();
        ***REMOVED***
        if (lines[i].length || text.length)
            text.push(lines[i]);
    ***REMOVED***
    return ***REMOVED***
        text: desc || text,
        tags: tags || []
    ***REMOVED***;
***REMOVED***

// writes a comment
function writeComment(comment, otherwiseNewline) ***REMOVED***
    if (!comment || options.comments === false) ***REMOVED***
        if (otherwiseNewline)
            writeln();
        return;
    ***REMOVED***
    if (typeof comment !== "object")
        comment = parseComment(comment);
    comment.tags = comment.tags.filter(function(tag) ***REMOVED***
        return keepTags.indexOf(tag.name) > -1 && (tag.name !== "returns" || tag.text[0] !== "***REMOVED***undefined***REMOVED***");
    ***REMOVED***);
    writeln();
    if (!comment.tags.length && comment.text.length < 2) ***REMOVED***
        writeln("/** " + comment.text[0] + " */");
        return;
    ***REMOVED***
    writeln("/**");
    comment.text.forEach(function(line) ***REMOVED***
        if (line.length)
            writeln(" * ", line);
        else
            writeln(" *");
    ***REMOVED***);
    comment.tags.forEach(function(tag) ***REMOVED***
        var started = false;
        if (tag.text.length) ***REMOVED***
            tag.text.forEach(function(line, i) ***REMOVED***
                if (i > 0)
                    write(" * ");
                else if (tag.name !== "throws")
                    line = line.replace(/^\***REMOVED***[^\s]****REMOVED*** ?/, "");
                if (!line.length)
                    return;
                if (!started) ***REMOVED***
                    write(" * @", tag.name, " ");
                    started = true;
                ***REMOVED***
                writeln(line);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***);
    writeln(" */");
***REMOVED***

// recursively replaces all occurencies of re's match
function replaceRecursive(name, re, fn) ***REMOVED***
    var found;

    function replacer() ***REMOVED***
        found = true;
        return fn.apply(null, arguments);
    ***REMOVED***

    do ***REMOVED***
        found = false;
        name = name.replace(re, replacer);
    ***REMOVED*** while (found);
    return name;
***REMOVED***

// tests if an element is considered to be a class or class-like
function isClassLike(element) ***REMOVED***
    return isClass(element) || isInterface(element);
***REMOVED***

// tests if an element is considered to be a class
function isClass(element) ***REMOVED***
    return element && element.kind === "class";
***REMOVED***

// tests if an element is considered to be an interface
function isInterface(element) ***REMOVED***
    return element && (element.kind === "interface" || element.kind === "mixin");
***REMOVED***

// tests if an element is considered to be a namespace
function isNamespace(element) ***REMOVED***
    return element && (element.kind === "namespace" || element.kind === "module");
***REMOVED***

// gets all children of the specified parent
function getChildrenOf(parent) ***REMOVED***
    var memberof = parent ? parent.longname : undefined;
    return data.filter(function(element) ***REMOVED***
        return element.memberof === memberof;
    ***REMOVED***);
***REMOVED***

// gets the literal type of an element
function getTypeOf(element) ***REMOVED***
    if (element.tsType)
        return element.tsType.replace(/\r?\n|\r/g, "\n");
    var name = "any";
    var type = element.type;
    if (type && type.names && type.names.length) ***REMOVED***
        if (type.names.length === 1)
            name = element.type.names[0].trim();
        else
            name = "(" + element.type.names.join("|") + ")";
    ***REMOVED*** else
        return name;

    // Replace catchalls with any
    name = name.replace(/\*|\bmixed\b/g, "any");

    // Ensure upper case Object for map expressions below
    name = name.replace(/\bobject\b/g, "Object");

    // Correct Something.<Something> to Something<Something>
    name = replaceRecursive(name, /\b(?!Object|Array)([\w$]+)\.<([^>]*)>/gi, function($0, $1, $2) ***REMOVED***
        return $1 + "<" + $2 + ">";
    ***REMOVED***);

    // Replace Array.<string> with string[]
    name = replaceRecursive(name, /\bArray\.?<([^>]*)>/gi, function($0, $1) ***REMOVED***
        return $1 + "[]";
    ***REMOVED***);

    // Replace Object.<string,number> with ***REMOVED*** [k: string]: number ***REMOVED***
    name = replaceRecursive(name, /\bObject\.?<([^,]*), *([^>]*)>/gi, function($0, $1, $2) ***REMOVED***
        return "***REMOVED*** [k: " + $1 + "]: " + $2 + " ***REMOVED***";
    ***REMOVED***);

    // Replace functions (there are no signatures) with Function
    name = name.replace(/\bfunction(?:\(\))?\b/g, "Function");

    // Convert plain Object back to just object
    name = name.replace(/\b(Object\b(?!\.))/g, function($0, $1) ***REMOVED***
        return $1.toLowerCase();
    ***REMOVED***);

    return name;
***REMOVED***

// begins writing the definition of the specified element
function begin(element, is_interface) ***REMOVED***
    if (!seen[element.longname]) ***REMOVED***
        if (isClass(element)) ***REMOVED***
            var comment = parseComment(element.comment);
            var classdesc = comment.tags.find(function(tag) ***REMOVED*** return tag.name === "classdesc"; ***REMOVED***);
            if (classdesc) ***REMOVED***
                comment.text = classdesc.text;
                comment.tags = [];
            ***REMOVED***
            writeComment(comment, true);
        ***REMOVED*** else
            writeComment(element.comment, is_interface || isClassLike(element) || isNamespace(element) || element.isEnum || element.scope === "global");
        seen[element.longname] = element;
    ***REMOVED*** else
        writeln();
    if (element.scope !== "global" || options.module)
        return;
    write("export ");
***REMOVED***

// writes the function signature describing element
function writeFunctionSignature(element, isConstructor, isTypeDef) ***REMOVED***
    write("(");

    var params = ***REMOVED******REMOVED***;

    // this type
    if (element.this)
        params["this"] = ***REMOVED***
            type: element.this.replace(/^***REMOVED***|***REMOVED***$/g, ""),
            optional: false
        ***REMOVED***;

    // parameter types
    if (element.params)
        element.params.forEach(function(param) ***REMOVED***
            var path = param.name.split(/\./g);
            if (path.length === 1)
                params[param.name] = ***REMOVED***
                    type: getTypeOf(param),
                    variable: param.variable === true,
                    optional: param.optional === true,
                    defaultValue: param.defaultvalue // Not used yet (TODO)
                ***REMOVED***;
            else // Property syntax (TODO)
                params[path[0]].type = "***REMOVED*** [k: string]: any ***REMOVED***";
        ***REMOVED***);

    var paramNames = Object.keys(params);
    paramNames.forEach(function(name, i) ***REMOVED***
        var param = params[name];
        var type = param.type;
        if (param.variable) ***REMOVED***
            name = "..." + name;
            type = param.type.charAt(0) === "(" ? "any[]" : param.type + "[]";
        ***REMOVED***
        write(name, !param.variable && param.optional ? "?: " : ": ", type);
        if (i < paramNames.length - 1)
            write(", ");
    ***REMOVED***);

    write(")");

    // return type
    if (!isConstructor) ***REMOVED***
        write(isTypeDef ? " => " : ": ");
        var typeName;
        if (element.returns && element.returns.length && (typeName = getTypeOf(element.returns[0])) !== "undefined")
            write(typeName);
        else
            write("void");
    ***REMOVED***
***REMOVED***

// writes (a typedef as) an interface
function writeInterface(element) ***REMOVED***
    write("interface ", element.name);
    writeInterfaceBody(element);
    writeln();
***REMOVED***

function writeInterfaceBody(element) ***REMOVED***
    writeln("***REMOVED***");
    ++indent;
    if (element.tsType)
        writeln(element.tsType.replace(/\r?\n|\r/g, "\n"));
    else if (element.properties && element.properties.length)
        element.properties.forEach(writeProperty);
    --indent;
    write("***REMOVED***");
***REMOVED***

function writeProperty(property, declare) ***REMOVED***
    writeComment(property.description);
    if (declare)
        write("let ");
    write(property.name);
    if (property.optional)
        write("?");
    writeln(": ", getTypeOf(property), ";");
***REMOVED***

//
// Handlers
//

// handles a single element of any understood type
function handleElement(element, parent) ***REMOVED***
    if (element.scope === "inner")
        return false;

    if (element.optional !== true && element.type && element.type.names && element.type.names.length) ***REMOVED***
        for (var i = 0; i < element.type.names.length; i++) ***REMOVED***
            if (element.type.names[i].toLowerCase() === "undefined") ***REMOVED***
                // This element is actually optional. Set optional to true and
                // remove the 'undefined' type
                element.optional = true;
                element.type.names.splice(i, 1);
                i--;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    if (seen[element.longname])
        return true;
    if (isClassLike(element))
        handleClass(element, parent);
    else switch (element.kind) ***REMOVED***
        case "module":
        case "namespace":
            handleNamespace(element, parent);
            break;
        case "constant":
        case "member":
            handleMember(element, parent);
            break;
        case "function":
            handleFunction(element, parent);
            break;
        case "typedef":
            handleTypeDef(element, parent);
            break;
        case "package":
            break;
    ***REMOVED***
    seen[element.longname] = element;
    return true;
***REMOVED***

// handles (just) a namespace
function handleNamespace(element/*, parent*/) ***REMOVED***
    var children = getChildrenOf(element);
    if (!children.length)
        return;
    var first = true;
    if (element.properties)
        element.properties.forEach(function(property) ***REMOVED***
            if (!/^[$\w]+$/.test(property.name)) // incompatible in namespace
                return;
            if (first) ***REMOVED***
                begin(element);
                writeln("namespace ", element.name, " ***REMOVED***");
                ++indent;
                first = false;
            ***REMOVED***
            writeProperty(property, true);
        ***REMOVED***);
    children.forEach(function(child) ***REMOVED***
        if (child.scope === "inner" || seen[child.longname])
            return;
        if (first) ***REMOVED***
            begin(element);
            writeln("namespace ", element.name, " ***REMOVED***");
            ++indent;
            first = false;
        ***REMOVED***
        handleElement(child, element);
    ***REMOVED***);
    if (!first) ***REMOVED***
        --indent;
        writeln("***REMOVED***");
    ***REMOVED***
***REMOVED***

// a filter function to remove any module references
function notAModuleReference(ref) ***REMOVED***
    return ref.indexOf("module:") === -1;
***REMOVED***

// handles a class or class-like
function handleClass(element, parent) ***REMOVED***
    var is_interface = isInterface(element);
    begin(element, is_interface);
    if (is_interface)
        write("interface ");
    else ***REMOVED***
        if (element.virtual)
            write("abstract ");
        write("class ");
    ***REMOVED***
    write(element.name);
    if (element.templates && element.templates.length)
        write("<", element.templates.join(", "), ">");
    write(" ");

    // extended classes
    if (element.augments) ***REMOVED***
        var augments = element.augments.filter(notAModuleReference);
        if (augments.length)
            write("extends ", augments[0], " ");
    ***REMOVED***

    // implemented interfaces
    var impls = [];
    if (element.implements)
        Array.prototype.push.apply(impls, element.implements);
    if (element.mixes)
        Array.prototype.push.apply(impls, element.mixes);
    impls = impls.filter(notAModuleReference);
    if (impls.length)
        write("implements ", impls.join(", "), " ");

    writeln("***REMOVED***");
    ++indent;

    if (element.tsType)
        writeln(element.tsType.replace(/\r?\n|\r/g, "\n"));

    // constructor
    if (!is_interface && !element.virtual)
        handleFunction(element, parent, true);

    // properties
    if (is_interface && element.properties)
        element.properties.forEach(function(property) ***REMOVED***
            writeProperty(property);
        ***REMOVED***);

    // class-compatible members
    var incompatible = [];
    getChildrenOf(element).forEach(function(child) ***REMOVED***
        if (isClassLike(child) || child.kind === "module" || child.kind === "typedef" || child.isEnum) ***REMOVED***
            incompatible.push(child);
            return;
        ***REMOVED***
        handleElement(child, element);
    ***REMOVED***);

    --indent;
    writeln("***REMOVED***");

    // class-incompatible members
    if (incompatible.length) ***REMOVED***
        writeln();
        if (element.scope === "global" && !options.module)
            write("export ");
        writeln("namespace ", element.name, " ***REMOVED***");
        ++indent;
        incompatible.forEach(function(child) ***REMOVED***
            handleElement(child, element);
        ***REMOVED***);
        --indent;
        writeln("***REMOVED***");
    ***REMOVED***
***REMOVED***

// handles a namespace or class member
function handleMember(element, parent) ***REMOVED***
    begin(element);

    if (element.isEnum) ***REMOVED***
        var stringEnum = false;
        element.properties.forEach(function(property) ***REMOVED***
            if (isNaN(property.defaultvalue)) ***REMOVED***
                stringEnum = true;
            ***REMOVED***
        ***REMOVED***);
        if (stringEnum) ***REMOVED***
            writeln("type ", element.name, " =");
            ++indent;
            element.properties.forEach(function(property, i) ***REMOVED***
                write(i === 0 ? "" : "| ", JSON.stringify(property.defaultvalue));
            ***REMOVED***);
            --indent;
            writeln(";");
        ***REMOVED*** else ***REMOVED***
            writeln("enum ", element.name, " ***REMOVED***");
            ++indent;
            element.properties.forEach(function(property, i) ***REMOVED***
                write(property.name);
                if (property.defaultvalue !== undefined)
                    write(" = ", JSON.stringify(property.defaultvalue));
                if (i < element.properties.length - 1)
                    writeln(",");
                else
                    writeln();
            ***REMOVED***);
            --indent;
            writeln("***REMOVED***");
        ***REMOVED***

    ***REMOVED*** else ***REMOVED***

        var inClass = isClassLike(parent);
        if (inClass) ***REMOVED***
            write(element.access || "public", " ");
            if (element.scope === "static")
                write("static ");
            if (element.readonly)
                write("readonly ");
        ***REMOVED*** else
            write(element.kind === "constant" ? "const " : "let ");

        write(element.name);
        if (element.optional)
            write("?");
        write(": ");

        if (element.type && element.type.names && /^Object\b/i.test(element.type.names[0]) && element.properties) ***REMOVED***
            writeln("***REMOVED***");
            ++indent;
            element.properties.forEach(function(property, i) ***REMOVED***
                writeln(JSON.stringify(property.name), ": ", getTypeOf(property), i < element.properties.length - 1 ? "," : "");
            ***REMOVED***);
            --indent;
            writeln("***REMOVED***;");
        ***REMOVED*** else
            writeln(getTypeOf(element), ";");
    ***REMOVED***
***REMOVED***

// handles a function or method
function handleFunction(element, parent, isConstructor) ***REMOVED***
    var insideClass = true;
    if (isConstructor) ***REMOVED***
        writeComment(element.comment);
        write("constructor");
    ***REMOVED*** else ***REMOVED***
        begin(element);
        insideClass = isClassLike(parent);
        if (insideClass) ***REMOVED***
            write(element.access || "public", " ");
            if (element.scope === "static")
                write("static ");
        ***REMOVED*** else
            write("function ");
        write(element.name);
        if (element.templates && element.templates.length)
            write("<", element.templates.join(", "), ">");
    ***REMOVED***
    writeFunctionSignature(element, isConstructor, false);
    writeln(";");
    if (!insideClass)
        handleNamespace(element);
***REMOVED***

// handles a type definition (not a real type)
function handleTypeDef(element, parent) ***REMOVED***
    if (isInterface(element)) ***REMOVED***
        if (isClassLike(parent))
            queuedInterfaces.push(element);
        else ***REMOVED***
            begin(element);
            writeInterface(element);
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        writeComment(element.comment, true);
        write("type ", element.name);
        if (element.templates && element.templates.length)
            write("<", element.templates.join(", "), ">");
        write(" = ");
        if (element.tsType)
            write(element.tsType.replace(/\r?\n|\r/g, "\n"));
        else ***REMOVED***
            var type = getTypeOf(element);
            if (element.type && element.type.names.length === 1 && element.type.names[0] === "function")
                writeFunctionSignature(element, false, true);
            else if (type === "object") ***REMOVED***
                if (element.properties && element.properties.length)
                    writeInterfaceBody(element);
                else
                    write("***REMOVED******REMOVED***");
            ***REMOVED*** else
                write(type);
        ***REMOVED***
        writeln(";");
    ***REMOVED***
***REMOVED***
