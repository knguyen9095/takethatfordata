"use strict";

/**
 * Wrappers for common types.
 * @type ***REMOVED***Object.<string,IWrapper>***REMOVED***
 * @const
 */
var wrappers = exports;

var Message = require("./message");

/**
 * From object converter part of an ***REMOVED***@link IWrapper***REMOVED***.
 * @typedef WrapperFromObjectConverter
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***Object.<string,*>***REMOVED*** object Plain object
 * @returns ***REMOVED***Message<***REMOVED******REMOVED***>***REMOVED*** Message instance
 * @this Type
 */

/**
 * To object converter part of an ***REMOVED***@link IWrapper***REMOVED***.
 * @typedef WrapperToObjectConverter
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***Message<***REMOVED******REMOVED***>***REMOVED*** message Message instance
 * @param ***REMOVED***IConversionOptions***REMOVED*** [options] Conversion options
 * @returns ***REMOVED***Object.<string,*>***REMOVED*** Plain object
 * @this Type
 */

/**
 * Common type wrapper part of ***REMOVED***@link wrappers***REMOVED***.
 * @interface IWrapper
 * @property ***REMOVED***WrapperFromObjectConverter***REMOVED*** [fromObject] From object converter
 * @property ***REMOVED***WrapperToObjectConverter***REMOVED*** [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = ***REMOVED***

    fromObject: function(object) ***REMOVED***

        // unwrap value type if mapped
        if (object && object["@type"]) ***REMOVED***
            var type = this.lookup(object["@type"]);
            /* istanbul ignore else */
            if (type) ***REMOVED***
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                return this.create(***REMOVED***
                    type_url: "/" + type_url,
                    value: type.encode(type.fromObject(object)).finish()
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return this.fromObject(object);
    ***REMOVED***,

    toObject: function(message, options) ***REMOVED***

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) ***REMOVED***
            // Only use fully qualified type name after the last '/'
            var name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        ***REMOVED***

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) ***REMOVED***
            var object = message.$type.toObject(message, options);
            object["@type"] = message.$type.fullName;
            return object;
        ***REMOVED***

        return this.toObject(message, options);
    ***REMOVED***
***REMOVED***;
