"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require("./util/minimal");

var roots = require("./roots");

var Type, // cyclic
    Enum;

util.codegen = require("@protobufjs/codegen");
util.fetch   = require("@protobufjs/fetch");
util.path    = require("@protobufjs/path");

/**
 * Node's fs module if available.
 * @type ***REMOVED***Object.<string,*>***REMOVED***
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param ***REMOVED***Object.<string,*>***REMOVED*** object Object to convert
 * @returns ***REMOVED***Array.<*>***REMOVED*** Converted array
 */
util.toArray = function toArray(object) ***REMOVED***
    if (object) ***REMOVED***
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    ***REMOVED***
    return [];
***REMOVED***;

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param ***REMOVED***Array.<*>***REMOVED*** array Array to convert
 * @returns ***REMOVED***Object.<string,*>***REMOVED*** Converted object
 */
util.toObject = function toObject(array) ***REMOVED***
    var object = ***REMOVED******REMOVED***,
        index  = 0;
    while (index < array.length) ***REMOVED***
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    ***REMOVED***
    return object;
***REMOVED***;

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param ***REMOVED***string***REMOVED*** name Name to test
 * @returns ***REMOVED***boolean***REMOVED*** `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) ***REMOVED***
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
***REMOVED***;

/**
 * Returns a safe property accessor for the specified property name.
 * @param ***REMOVED***string***REMOVED*** prop Property name
 * @returns ***REMOVED***string***REMOVED*** Safe accessor
 */
util.safeProp = function safeProp(prop) ***REMOVED***
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
***REMOVED***;

/**
 * Converts the first character of a string to upper case.
 * @param ***REMOVED***string***REMOVED*** str String to convert
 * @returns ***REMOVED***string***REMOVED*** Converted string
 */
util.ucFirst = function ucFirst(str) ***REMOVED***
    return str.charAt(0).toUpperCase() + str.substring(1);
***REMOVED***;

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param ***REMOVED***string***REMOVED*** str String to convert
 * @returns ***REMOVED***string***REMOVED*** Converted string
 */
util.camelCase = function camelCase(str) ***REMOVED***
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) ***REMOVED*** return $1.toUpperCase(); ***REMOVED***);
***REMOVED***;

/**
 * Compares reflected fields by id.
 * @param ***REMOVED***Field***REMOVED*** a First field
 * @param ***REMOVED***Field***REMOVED*** b Second field
 * @returns ***REMOVED***number***REMOVED*** Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) ***REMOVED***
    return a.id - b.id;
***REMOVED***;

/**
 * Decorator helper for types (TypeScript).
 * @param ***REMOVED***Constructor<T>***REMOVED*** ctor Constructor function
 * @param ***REMOVED***string***REMOVED*** [typeName] Type name, defaults to the constructor's name
 * @returns ***REMOVED***Type***REMOVED*** Reflected type
 * @template T extends Message<T>
 * @property ***REMOVED***Root***REMOVED*** root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) ***REMOVED***

    /* istanbul ignore if */
    if (ctor.$type) ***REMOVED***
        if (typeName && ctor.$type.name !== typeName) ***REMOVED***
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        ***REMOVED***
        return ctor.$type;
    ***REMOVED***

    /* istanbul ignore next */
    if (!Type)
        Type = require("./type");

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", ***REMOVED*** value: type, enumerable: false ***REMOVED***);
    Object.defineProperty(ctor.prototype, "$type", ***REMOVED*** value: type, enumerable: false ***REMOVED***);
    return type;
***REMOVED***;

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param ***REMOVED***Object***REMOVED*** object Enum object
 * @returns ***REMOVED***Enum***REMOVED*** Reflected enum
 */
util.decorateEnum = function decorateEnum(object) ***REMOVED***

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require("./enum");

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", ***REMOVED*** value: enm, enumerable: false ***REMOVED***);
    return enm;
***REMOVED***;

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type ***REMOVED***Root***REMOVED***
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", ***REMOVED***
    get: function() ***REMOVED***
        return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
    ***REMOVED***
***REMOVED***);
