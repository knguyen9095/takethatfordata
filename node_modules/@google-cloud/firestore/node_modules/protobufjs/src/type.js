"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require("./namespace");
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require("./enum"),
    OneOf     = require("./oneof"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    Service   = require("./service"),
    Message   = require("./message"),
    Reader    = require("./reader"),
    Writer    = require("./writer"),
    util      = require("./util"),
    encoder   = require("./encoder"),
    decoder   = require("./decoder"),
    verifier  = require("./verifier"),
    converter = require("./converter"),
    wrappers  = require("./wrappers");

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param ***REMOVED***string***REMOVED*** name Message name
 * @param ***REMOVED***Object.<string,*>***REMOVED*** [options] Declared options
 */
function Type(name, options) ***REMOVED***
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type ***REMOVED***Object.<string,Field>***REMOVED***
     */
    this.fields = ***REMOVED******REMOVED***;  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type ***REMOVED***Object.<string,OneOf>***REMOVED***
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type ***REMOVED***number[][]***REMOVED***
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type ***REMOVED***Array.<number[]|string>***REMOVED***
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type ***REMOVED***boolean|undefined***REMOVED***
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type ***REMOVED***Object.<number,Field>|null***REMOVED***
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type ***REMOVED***Field[]|null***REMOVED***
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type ***REMOVED***OneOf[]|null***REMOVED***
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type ***REMOVED***Constructor<***REMOVED******REMOVED***>***REMOVED***
     * @private
     */
    this._ctor = null;
***REMOVED***

Object.defineProperties(Type.prototype, ***REMOVED***

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type ***REMOVED***Object.<number,Field>***REMOVED***
     * @readonly
     */
    fieldsById: ***REMOVED***
        get: function() ***REMOVED***

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = ***REMOVED******REMOVED***;
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) ***REMOVED***
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            ***REMOVED***
            return this._fieldsById;
        ***REMOVED***
    ***REMOVED***,

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type ***REMOVED***Field[]***REMOVED***
     * @readonly
     */
    fieldsArray: ***REMOVED***
        get: function() ***REMOVED***
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        ***REMOVED***
    ***REMOVED***,

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type ***REMOVED***OneOf[]***REMOVED***
     * @readonly
     */
    oneofsArray: ***REMOVED***
        get: function() ***REMOVED***
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        ***REMOVED***
    ***REMOVED***,

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend ***REMOVED***@link Message***REMOVED*** yet, its prototype will be setup accordingly and static methods will be populated. If it already extends ***REMOVED***@link Message***REMOVED***, it will just replace the internal constructor.
     * @name Type#ctor
     * @type ***REMOVED***Constructor<***REMOVED******REMOVED***>***REMOVED***
     */
    ctor: ***REMOVED***
        get: function() ***REMOVED***
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        ***REMOVED***,
        set: function(ctor) ***REMOVED***

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) ***REMOVED***
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            ***REMOVED***

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = ***REMOVED******REMOVED***;
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = ***REMOVED***
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                ***REMOVED***;
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        ***REMOVED***
    ***REMOVED***
***REMOVED***);

/**
 * Generates a constructor function for the specified type.
 * @param ***REMOVED***Type***REMOVED*** mtype Message type
 * @returns ***REMOVED***Codegen***REMOVED*** Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) ***REMOVED***
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s=***REMOVED******REMOVED***", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
***REMOVED***;

function clearCache(type) ***REMOVED***
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
***REMOVED***

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property ***REMOVED***Object.<string,IOneOf>***REMOVED*** [oneofs] Oneof descriptors
 * @property ***REMOVED***Object.<string,IField>***REMOVED*** fields Field descriptors
 * @property ***REMOVED***number[][]***REMOVED*** [extensions] Extension ranges
 * @property ***REMOVED***number[][]***REMOVED*** [reserved] Reserved ranges
 * @property ***REMOVED***boolean***REMOVED*** [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param ***REMOVED***string***REMOVED*** name Message name
 * @param ***REMOVED***IType***REMOVED*** json Message type descriptor
 * @returns ***REMOVED***Type***REMOVED*** Created message type
 */
Type.fromJSON = function fromJSON(name, json) ***REMOVED***
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) ***REMOVED***
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        ***REMOVED***
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    return type;
***REMOVED***;

/**
 * Converts this message type to a message type descriptor.
 * @returns ***REMOVED***IType***REMOVED*** Message type descriptor
 */
Type.prototype.toJSON = function toJSON() ***REMOVED***
    var inherited = Namespace.prototype.toJSON.call(this);
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) ***REMOVED*** return !obj.declaringField; ***REMOVED***)) || ***REMOVED******REMOVED***,
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined
    ]);
***REMOVED***;

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() ***REMOVED***
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
***REMOVED***;

/**
 * @override
 */
Type.prototype.get = function get(name) ***REMOVED***
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
***REMOVED***;

/**
 * Adds a nested object to this type.
 * @param ***REMOVED***ReflectionObject***REMOVED*** object Nested object to add
 * @returns ***REMOVED***Type***REMOVED*** `this`
 * @throws ***REMOVED***TypeError***REMOVED*** If arguments are invalid
 * @throws ***REMOVED***Error***REMOVED*** If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) ***REMOVED***

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) ***REMOVED***
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    ***REMOVED***
    if (object instanceof OneOf) ***REMOVED***
        if (!this.oneofs)
            this.oneofs = ***REMOVED******REMOVED***;
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    ***REMOVED***
    return Namespace.prototype.add.call(this, object);
***REMOVED***;

/**
 * Removes a nested object from this type.
 * @param ***REMOVED***ReflectionObject***REMOVED*** object Nested object to remove
 * @returns ***REMOVED***Type***REMOVED*** `this`
 * @throws ***REMOVED***TypeError***REMOVED*** If arguments are invalid
 * @throws ***REMOVED***Error***REMOVED*** If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) ***REMOVED***
    if (object instanceof Field && object.extend === undefined) ***REMOVED***
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    ***REMOVED***
    if (object instanceof OneOf) ***REMOVED***

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    ***REMOVED***
    return Namespace.prototype.remove.call(this, object);
***REMOVED***;

/**
 * Tests if the specified id is reserved.
 * @param ***REMOVED***number***REMOVED*** id Id to test
 * @returns ***REMOVED***boolean***REMOVED*** `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) ***REMOVED***
    return Namespace.isReservedId(this.reserved, id);
***REMOVED***;

/**
 * Tests if the specified name is reserved.
 * @param ***REMOVED***string***REMOVED*** name Name to test
 * @returns ***REMOVED***boolean***REMOVED*** `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) ***REMOVED***
    return Namespace.isReservedName(this.reserved, name);
***REMOVED***;

/**
 * Creates a new message of this type using the specified properties.
 * @param ***REMOVED***Object.<string,*>***REMOVED*** [properties] Properties to set
 * @returns ***REMOVED***Message<***REMOVED******REMOVED***>***REMOVED*** Message instance
 */
Type.prototype.create = function create(properties) ***REMOVED***
    return new this.ctor(properties);
***REMOVED***;

/**
 * Sets up ***REMOVED***@link Type#encode|encode***REMOVED***, ***REMOVED***@link Type#decode|decode***REMOVED*** and ***REMOVED***@link Type#verify|verify***REMOVED***.
 * @returns ***REMOVED***Type***REMOVED*** `this`
 */
Type.prototype.setup = function setup() ***REMOVED***
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)(***REMOVED***
        Writer : Writer,
        types  : types,
        util   : util
    ***REMOVED***);
    this.decode = decoder(this)(***REMOVED***
        Reader : Reader,
        types  : types,
        util   : util
    ***REMOVED***);
    this.verify = verifier(this)(***REMOVED***
        types : types,
        util  : util
    ***REMOVED***);
    this.fromObject = converter.fromObject(this)(***REMOVED***
        types : types,
        util  : util
    ***REMOVED***);
    this.toObject = converter.toObject(this)(***REMOVED***
        types : types,
        util  : util
    ***REMOVED***);

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) ***REMOVED***
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) ***REMOVED***
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // ***REMOVED***
        // if (wrapper.toObject) ***REMOVED***
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // ***REMOVED***
    ***REMOVED***

    return this;
***REMOVED***;

/**
 * Encodes a message of this type. Does not implicitly ***REMOVED***@link Type#verify|verify***REMOVED*** messages.
 * @param ***REMOVED***Message<***REMOVED******REMOVED***>|Object.<string,*>***REMOVED*** message Message instance or plain object
 * @param ***REMOVED***Writer***REMOVED*** [writer] Writer to encode to
 * @returns ***REMOVED***Writer***REMOVED*** writer
 */
Type.prototype.encode = function encode_setup(message, writer) ***REMOVED***
    return this.setup().encode(message, writer); // overrides this method
***REMOVED***;

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly ***REMOVED***@link Type#verify|verify***REMOVED*** messages.
 * @param ***REMOVED***Message<***REMOVED******REMOVED***>|Object.<string,*>***REMOVED*** message Message instance or plain object
 * @param ***REMOVED***Writer***REMOVED*** [writer] Writer to encode to
 * @returns ***REMOVED***Writer***REMOVED*** writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) ***REMOVED***
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
***REMOVED***;

/**
 * Decodes a message of this type.
 * @param ***REMOVED***Reader|Uint8Array***REMOVED*** reader Reader or buffer to decode from
 * @param ***REMOVED***number***REMOVED*** [length] Length of the message, if known beforehand
 * @returns ***REMOVED***Message<***REMOVED******REMOVED***>***REMOVED*** Decoded message
 * @throws ***REMOVED***Error***REMOVED*** If the payload is not a reader or valid buffer
 * @throws ***REMOVED***util.ProtocolError<***REMOVED******REMOVED***>***REMOVED*** If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) ***REMOVED***
    return this.setup().decode(reader, length); // overrides this method
***REMOVED***;

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param ***REMOVED***Reader|Uint8Array***REMOVED*** reader Reader or buffer to decode from
 * @returns ***REMOVED***Message<***REMOVED******REMOVED***>***REMOVED*** Decoded message
 * @throws ***REMOVED***Error***REMOVED*** If the payload is not a reader or valid buffer
 * @throws ***REMOVED***util.ProtocolError***REMOVED*** If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) ***REMOVED***
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
***REMOVED***;

/**
 * Verifies that field values are valid and that required fields are present.
 * @param ***REMOVED***Object.<string,*>***REMOVED*** message Plain object to verify
 * @returns ***REMOVED***null|string***REMOVED*** `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) ***REMOVED***
    return this.setup().verify(message); // overrides this method
***REMOVED***;

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param ***REMOVED***Object.<string,*>***REMOVED*** object Plain object to convert
 * @returns ***REMOVED***Message<***REMOVED******REMOVED***>***REMOVED*** Message instance
 */
Type.prototype.fromObject = function fromObject(object) ***REMOVED***
    return this.setup().fromObject(object);
***REMOVED***;

/**
 * Conversion options as used by ***REMOVED***@link Type#toObject***REMOVED*** and ***REMOVED***@link Message.toObject***REMOVED***.
 * @interface IConversionOptions
 * @property ***REMOVED***Function***REMOVED*** [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a ***REMOVED***@link Long***REMOVED*** with a long library.
 * @property ***REMOVED***Function***REMOVED*** [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property ***REMOVED***Function***REMOVED*** [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property ***REMOVED***boolean***REMOVED*** [defaults=false] Also sets default values on the resulting object
 * @property ***REMOVED***boolean***REMOVED*** [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property ***REMOVED***boolean***REMOVED*** [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property ***REMOVED***boolean***REMOVED*** [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property ***REMOVED***boolean***REMOVED*** [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param ***REMOVED***Message<***REMOVED******REMOVED***>***REMOVED*** message Message instance
 * @param ***REMOVED***IConversionOptions***REMOVED*** [options] Conversion options
 * @returns ***REMOVED***Object.<string,*>***REMOVED*** Plain object
 */
Type.prototype.toObject = function toObject(message, options) ***REMOVED***
    return this.setup().toObject(message, options);
***REMOVED***;

/**
 * Decorator function as returned by ***REMOVED***@link Type.d***REMOVED*** (TypeScript).
 * @typedef TypeDecorator
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***Constructor<T>***REMOVED*** target Target constructor
 * @returns ***REMOVED***undefined***REMOVED***
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param ***REMOVED***string***REMOVED*** [typeName] Type name, defaults to the constructor's name
 * @returns ***REMOVED***TypeDecorator<T>***REMOVED*** Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) ***REMOVED***
    return function typeDecorator(target) ***REMOVED***
        util.decorateType(target, typeName);
    ***REMOVED***;
***REMOVED***;
