"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require("./util");

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param ***REMOVED***string***REMOVED*** name Object name
 * @param ***REMOVED***Object.<string,*>***REMOVED*** [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) ***REMOVED***

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type ***REMOVED***Object.<string,*>|undefined***REMOVED***
     */
    this.options = options; // toJSON

    /**
     * Unique name within its namespace.
     * @type ***REMOVED***string***REMOVED***
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type ***REMOVED***Namespace|null***REMOVED***
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type ***REMOVED***string|null***REMOVED***
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type ***REMOVED***string|null***REMOVED***
     */
    this.filename = null;
***REMOVED***

Object.defineProperties(ReflectionObject.prototype, ***REMOVED***

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type ***REMOVED***Root***REMOVED***
     * @readonly
     */
    root: ***REMOVED***
        get: function() ***REMOVED***
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        ***REMOVED***
    ***REMOVED***,

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type ***REMOVED***string***REMOVED***
     * @readonly
     */
    fullName: ***REMOVED***
        get: function() ***REMOVED***
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) ***REMOVED***
                path.unshift(ptr.name);
                ptr = ptr.parent;
            ***REMOVED***
            return path.join(".");
        ***REMOVED***
    ***REMOVED***
***REMOVED***);

/**
 * Converts this reflection object to its descriptor representation.
 * @returns ***REMOVED***Object.<string,*>***REMOVED*** Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() ***REMOVED***
    throw Error(); // not implemented, shouldn't happen
***REMOVED***;

/**
 * Called when this object is added to a parent.
 * @param ***REMOVED***ReflectionObject***REMOVED*** parent Parent added to
 * @returns ***REMOVED***undefined***REMOVED***
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) ***REMOVED***
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
***REMOVED***;

/**
 * Called when this object is removed from a parent.
 * @param ***REMOVED***ReflectionObject***REMOVED*** parent Parent removed from
 * @returns ***REMOVED***undefined***REMOVED***
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) ***REMOVED***
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
***REMOVED***;

/**
 * Resolves this objects type references.
 * @returns ***REMOVED***ReflectionObject***REMOVED*** `this`
 */
ReflectionObject.prototype.resolve = function resolve() ***REMOVED***
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
***REMOVED***;

/**
 * Gets an option value.
 * @param ***REMOVED***string***REMOVED*** name Option name
 * @returns ***REMOVED*******REMOVED*** Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) ***REMOVED***
    if (this.options)
        return this.options[name];
    return undefined;
***REMOVED***;

/**
 * Sets an option.
 * @param ***REMOVED***string***REMOVED*** name Option name
 * @param ***REMOVED*******REMOVED*** value Option value
 * @param ***REMOVED***boolean***REMOVED*** [ifNotSet] Sets the option only if it isn't currently set
 * @returns ***REMOVED***ReflectionObject***REMOVED*** `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) ***REMOVED***
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = ***REMOVED******REMOVED***))[name] = value;
    return this;
***REMOVED***;

/**
 * Sets multiple options.
 * @param ***REMOVED***Object.<string,*>***REMOVED*** options Options to set
 * @param ***REMOVED***boolean***REMOVED*** [ifNotSet] Sets an option only if it isn't currently set
 * @returns ***REMOVED***ReflectionObject***REMOVED*** `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) ***REMOVED***
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
***REMOVED***;

/**
 * Converts this instance to its string representation.
 * @returns ***REMOVED***string***REMOVED*** Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() ***REMOVED***
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
***REMOVED***;

ReflectionObject._configure = function(Root_) ***REMOVED***
    Root = Root_;
***REMOVED***;
