"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by ***REMOVED***@link rpc.ServiceMethod|ServiceMethod***REMOVED***.
 *
 * Differs from ***REMOVED***@link RPCImplCallback***REMOVED*** in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***Error|null***REMOVED*** error Error, if any
 * @param ***REMOVED***TRes***REMOVED*** [response] Response message
 * @returns ***REMOVED***undefined***REMOVED***
 */

/**
 * A service method part of a ***REMOVED***@link rpc.Service***REMOVED*** as created by ***REMOVED***@link Service.create***REMOVED***.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***TReq|Properties<TReq>***REMOVED*** request Request message or plain object
 * @param ***REMOVED***rpc.ServiceMethodCallback<TRes>***REMOVED*** [callback] Node-style callback called with the error, if any, and the response message
 * @returns ***REMOVED***Promise<Message<TRes>>***REMOVED*** Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by ***REMOVED***@link Service#create***REMOVED***.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param ***REMOVED***RPCImpl***REMOVED*** rpcImpl RPC implementation
 * @param ***REMOVED***boolean***REMOVED*** [requestDelimited=false] Whether requests are length-delimited
 * @param ***REMOVED***boolean***REMOVED*** [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) ***REMOVED***

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type ***REMOVED***RPCImpl|null***REMOVED***
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.responseDelimited = Boolean(responseDelimited);
***REMOVED***

/**
 * Calls a service method through ***REMOVED***@link rpc.Service#rpcImpl|rpcImpl***REMOVED***.
 * @param ***REMOVED***Method|rpc.ServiceMethod<TReq,TRes>***REMOVED*** method Reflected or static method
 * @param ***REMOVED***Constructor<TReq>***REMOVED*** requestCtor Request constructor
 * @param ***REMOVED***Constructor<TRes>***REMOVED*** responseCtor Response constructor
 * @param ***REMOVED***TReq|Properties<TReq>***REMOVED*** request Request message or plain object
 * @param ***REMOVED***rpc.ServiceMethodCallback<TRes>***REMOVED*** callback Service callback
 * @returns ***REMOVED***undefined***REMOVED***
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) ***REMOVED***

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) ***REMOVED***
        setTimeout(function() ***REMOVED*** callback(Error("already ended")); ***REMOVED***, 0);
        return undefined;
    ***REMOVED***

    try ***REMOVED***
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) ***REMOVED***

                if (err) ***REMOVED***
                    self.emit("error", err, method);
                    return callback(err);
                ***REMOVED***

                if (response === null) ***REMOVED***
                    self.end(/* endedByRPC */ true);
                    return undefined;
                ***REMOVED***

                if (!(response instanceof responseCtor)) ***REMOVED***
                    try ***REMOVED***
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    ***REMOVED*** catch (err) ***REMOVED***
                        self.emit("error", err, method);
                        return callback(err);
                    ***REMOVED***
                ***REMOVED***

                self.emit("data", response, method);
                return callback(null, response);
            ***REMOVED***
        );
    ***REMOVED*** catch (err) ***REMOVED***
        self.emit("error", err, method);
        setTimeout(function() ***REMOVED*** callback(err); ***REMOVED***, 0);
        return undefined;
    ***REMOVED***
***REMOVED***;

/**
 * Ends this service and emits the `end` event.
 * @param ***REMOVED***boolean***REMOVED*** [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns ***REMOVED***rpc.Service***REMOVED*** `this`
 */
Service.prototype.end = function end(endedByRPC) ***REMOVED***
    if (this.rpcImpl) ***REMOVED***
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    ***REMOVED***
    return this;
***REMOVED***;
