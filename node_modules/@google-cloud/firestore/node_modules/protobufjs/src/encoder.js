"use strict";
module.exports = encoder;

var Enum     = require("./enum"),
    types    = require("./types"),
    util     = require("./util");

/**
 * Generates a partial message type encoder.
 * @param ***REMOVED***Codegen***REMOVED*** gen Codegen instance
 * @param ***REMOVED***Field***REMOVED*** field Reflected field
 * @param ***REMOVED***number***REMOVED*** fieldIndex Field index
 * @param ***REMOVED***string***REMOVED*** ref Variable reference
 * @returns ***REMOVED***Codegen***REMOVED*** Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) ***REMOVED***
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
***REMOVED***

/**
 * Generates an encoder specific to the specified message type.
 * @param ***REMOVED***Type***REMOVED*** mtype Message type
 * @returns ***REMOVED***Codegen***REMOVED*** Codegen instance
 */
function encoder(mtype) ***REMOVED***
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) ***REMOVED***
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) ***REMOVED***
            gen
    ("if(%s!=null&&m.hasOwnProperty(%j))***REMOVED***", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i)***REMOVED***", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("***REMOVED***")
    ("***REMOVED***");

            // Repeated fields
        ***REMOVED*** else if (field.repeated) ***REMOVED*** gen
    ("if(%s!=null&&%s.length)***REMOVED***", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) ***REMOVED*** gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            ***REMOVED*** else ***REMOVED*** gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            ***REMOVED*** gen
    ("***REMOVED***");

        // Non-repeated
        ***REMOVED*** else ***REMOVED***
            if (field.optional) gen
    ("if(%s!=null&&m.hasOwnProperty(%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        ***REMOVED***
    ***REMOVED***

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
***REMOVED***