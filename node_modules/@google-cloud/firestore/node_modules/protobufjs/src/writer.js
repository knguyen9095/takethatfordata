"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param ***REMOVED***function(*, Uint8Array, number)***REMOVED*** fn Function to call
 * @param ***REMOVED***number***REMOVED*** len Value byte length
 * @param ***REMOVED*******REMOVED*** val Value to write
 * @ignore
 */
function Op(fn, len, val) ***REMOVED***

    /**
     * Function to call.
     * @type ***REMOVED***function(Uint8Array, number, *)***REMOVED***
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type ***REMOVED***number***REMOVED***
     */
    this.len = len;

    /**
     * Next operation.
     * @type ***REMOVED***Writer.Op|undefined***REMOVED***
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type ***REMOVED*******REMOVED***
     */
    this.val = val; // type varies
***REMOVED***

/* istanbul ignore next */
function noop() ***REMOVED******REMOVED*** // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param ***REMOVED***Writer***REMOVED*** writer Writer to copy state from
 * @ignore
 */
function State(writer) ***REMOVED***

    /**
     * Current head.
     * @type ***REMOVED***Writer.Op***REMOVED***
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type ***REMOVED***Writer.Op***REMOVED***
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type ***REMOVED***number***REMOVED***
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type ***REMOVED***State|null***REMOVED***
     */
    this.next = writer.states;
***REMOVED***

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() ***REMOVED***

    /**
     * Current length.
     * @type ***REMOVED***number***REMOVED***
     */
    this.len = 0;

    /**
     * Operations head.
     * @type ***REMOVED***Object***REMOVED***
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type ***REMOVED***Object***REMOVED***
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type ***REMOVED***Object|null***REMOVED***
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
***REMOVED***

/**
 * Creates a new writer.
 * @function
 * @returns ***REMOVED***BufferWriter|Writer***REMOVED*** A ***REMOVED***@link BufferWriter***REMOVED*** when Buffers are supported, otherwise a ***REMOVED***@link Writer***REMOVED***
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() ***REMOVED***
        return (Writer.create = function create_buffer() ***REMOVED***
            return new BufferWriter();
        ***REMOVED***)();
    ***REMOVED***
    /* istanbul ignore next */
    : function create_array() ***REMOVED***
        return new Writer();
    ***REMOVED***;

/**
 * Allocates a buffer of the specified size.
 * @param ***REMOVED***number***REMOVED*** size Buffer size
 * @returns ***REMOVED***Uint8Array***REMOVED*** Buffer
 */
Writer.alloc = function alloc(size) ***REMOVED***
    return new util.Array(size);
***REMOVED***;

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param ***REMOVED***function(Uint8Array, number, *)***REMOVED*** fn Function to call
 * @param ***REMOVED***number***REMOVED*** len Value byte length
 * @param ***REMOVED***number***REMOVED*** val Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) ***REMOVED***
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
***REMOVED***;

function writeByte(val, buf, pos) ***REMOVED***
    buf[pos] = val & 255;
***REMOVED***

function writeVarint32(val, buf, pos) ***REMOVED***
    while (val > 127) ***REMOVED***
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    ***REMOVED***
    buf[pos] = val;
***REMOVED***

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param ***REMOVED***number***REMOVED*** len Value byte length
 * @param ***REMOVED***number***REMOVED*** val Value to write
 * @ignore
 */
function VarintOp(len, val) ***REMOVED***
    this.len = len;
    this.next = undefined;
    this.val = val;
***REMOVED***

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param ***REMOVED***number***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.uint32 = function write_uint32(value) ***REMOVED***
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
***REMOVED***;

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param ***REMOVED***number***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.int32 = function write_int32(value) ***REMOVED***
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
***REMOVED***;

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param ***REMOVED***number***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.sint32 = function write_sint32(value) ***REMOVED***
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
***REMOVED***;

function writeVarint64(val, buf, pos) ***REMOVED***
    while (val.hi) ***REMOVED***
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    ***REMOVED***
    while (val.lo > 127) ***REMOVED***
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    ***REMOVED***
    buf[pos++] = val.lo;
***REMOVED***

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param ***REMOVED***Long|number|string***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 * @throws ***REMOVED***TypeError***REMOVED*** If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) ***REMOVED***
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
***REMOVED***;

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param ***REMOVED***Long|number|string***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 * @throws ***REMOVED***TypeError***REMOVED*** If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param ***REMOVED***Long|number|string***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 * @throws ***REMOVED***TypeError***REMOVED*** If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) ***REMOVED***
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
***REMOVED***;

/**
 * Writes a boolish value as a varint.
 * @param ***REMOVED***boolean***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.bool = function write_bool(value) ***REMOVED***
    return this._push(writeByte, 1, value ? 1 : 0);
***REMOVED***;

function writeFixed32(val, buf, pos) ***REMOVED***
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
***REMOVED***

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param ***REMOVED***number***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) ***REMOVED***
    return this._push(writeFixed32, 4, value >>> 0);
***REMOVED***;

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param ***REMOVED***number***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param ***REMOVED***Long|number|string***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 * @throws ***REMOVED***TypeError***REMOVED*** If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) ***REMOVED***
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
***REMOVED***;

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param ***REMOVED***Long|number|string***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 * @throws ***REMOVED***TypeError***REMOVED*** If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param ***REMOVED***number***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.float = function write_float(value) ***REMOVED***
    return this._push(util.float.writeFloatLE, 4, value);
***REMOVED***;

/**
 * Writes a double (64 bit float).
 * @function
 * @param ***REMOVED***number***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.double = function write_double(value) ***REMOVED***
    return this._push(util.float.writeDoubleLE, 8, value);
***REMOVED***;

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) ***REMOVED***
        buf.set(val, pos); // also works for plain array values
    ***REMOVED***
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) ***REMOVED***
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    ***REMOVED***;

/**
 * Writes a sequence of bytes.
 * @param ***REMOVED***Uint8Array|string***REMOVED*** value Buffer or base64 encoded string to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.bytes = function write_bytes(value) ***REMOVED***
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) ***REMOVED***
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    ***REMOVED***
    return this.uint32(len)._push(writeBytes, len, value);
***REMOVED***;

/**
 * Writes a string.
 * @param ***REMOVED***string***REMOVED*** value Value to write
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.string = function write_string(value) ***REMOVED***
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
***REMOVED***;

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling ***REMOVED***@link Writer#reset|reset***REMOVED*** or ***REMOVED***@link Writer#ldelim|ldelim***REMOVED*** resets the writer to the previous state.
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.fork = function fork() ***REMOVED***
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
***REMOVED***;

/**
 * Resets this instance to the last state.
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.reset = function reset() ***REMOVED***
    if (this.states) ***REMOVED***
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    ***REMOVED*** else ***REMOVED***
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    ***REMOVED***
    return this;
***REMOVED***;

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns ***REMOVED***Writer***REMOVED*** `this`
 */
Writer.prototype.ldelim = function ldelim() ***REMOVED***
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) ***REMOVED***
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    ***REMOVED***
    return this;
***REMOVED***;

/**
 * Finishes the write operation.
 * @returns ***REMOVED***Uint8Array***REMOVED*** Finished buffer
 */
Writer.prototype.finish = function finish() ***REMOVED***
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) ***REMOVED***
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    ***REMOVED***
    // this.head = this.tail = null;
    return buf;
***REMOVED***;

Writer._configure = function(BufferWriter_) ***REMOVED***
    BufferWriter = BufferWriter_;
***REMOVED***;
