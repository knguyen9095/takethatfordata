"use strict";
module.exports = tokenize;

var delimRe        = /[\s***REMOVED******REMOVED***=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = ***REMOVED***
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
***REMOVED***;

/**
 * Unescapes a string.
 * @param ***REMOVED***string***REMOVED*** str String to unescape
 * @returns ***REMOVED***string***REMOVED*** Unescaped string
 * @property ***REMOVED***Object.<string,string>***REMOVED*** map Special characters map
 * @memberof tokenize
 */
function unescape(str) ***REMOVED***
    return str.replace(unescapeRe, function($0, $1) ***REMOVED***
        switch ($1) ***REMOVED***
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type ***REMOVED***function***REMOVED***
 * @returns ***REMOVED***string|null***REMOVED*** Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type ***REMOVED***function***REMOVED***
 * @returns ***REMOVED***string|null***REMOVED*** Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** token Token
 * @returns ***REMOVED***undefined***REMOVED***
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** expected Expected token
 * @param ***REMOVED***boolean***REMOVED*** [optional=false] If optional
 * @returns ***REMOVED***boolean***REMOVED*** Whether the token matched
 * @throws ***REMOVED***Error***REMOVED*** If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***number***REMOVED*** [line] Line number
 * @returns ***REMOVED***string|null***REMOVED*** Comment text or `null` if none
 */

/**
 * Handle object returned from ***REMOVED***@link tokenize***REMOVED***.
 * @interface ITokenizerHandle
 * @property ***REMOVED***TokenizerHandleNext***REMOVED*** next Gets the next token and advances (`null` on eof)
 * @property ***REMOVED***TokenizerHandlePeek***REMOVED*** peek Peeks for the next token (`null` on eof)
 * @property ***REMOVED***TokenizerHandlePush***REMOVED*** push Pushes a token back to the stack
 * @property ***REMOVED***TokenizerHandleSkip***REMOVED*** skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property ***REMOVED***TokenizerHandleCmnt***REMOVED*** cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property ***REMOVED***number***REMOVED*** line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param ***REMOVED***string***REMOVED*** source Source contents
 * @returns ***REMOVED***ITokenizerHandle***REMOVED*** Tokenizer handle
 */
function tokenize(source) ***REMOVED***
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param ***REMOVED***string***REMOVED*** subject Subject
     * @returns ***REMOVED***Error***REMOVED*** Error created
     * @inner
     */
    function illegal(subject) ***REMOVED***
        return Error("illegal " + subject + " (line " + line + ")");
    ***REMOVED***

    /**
     * Reads a string till its end.
     * @returns ***REMOVED***string***REMOVED*** String read
     * @inner
     */
    function readString() ***REMOVED***
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    ***REMOVED***

    /**
     * Gets the character at `pos` within the source.
     * @param ***REMOVED***number***REMOVED*** pos Position
     * @returns ***REMOVED***string***REMOVED*** Character
     * @inner
     */
    function charAt(pos) ***REMOVED***
        return source.charAt(pos);
    ***REMOVED***

    /**
     * Sets the current comment text.
     * @param ***REMOVED***number***REMOVED*** start Start offset
     * @param ***REMOVED***number***REMOVED*** end End offset
     * @returns ***REMOVED***undefined***REMOVED***
     * @inner
     */
    function setComment(start, end) ***REMOVED***
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        var offset = start - 3, // "///" or "/**"
            c;
        do ***REMOVED***
            if (--offset < 0 || (c = source.charAt(offset)) === "\n") ***REMOVED***
                commentLineEmpty = true;
                break;
            ***REMOVED***
        ***REMOVED*** while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i].replace(setCommentRe, "").trim();
        commentText = lines
            .join("\n")
            .trim();
    ***REMOVED***

    /**
     * Obtains the next token.
     * @returns ***REMOVED***string|null***REMOVED*** Next token or `null` on eof
     * @inner
     */
    function next() ***REMOVED***
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc;
        do ***REMOVED***
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) ***REMOVED***
                if (curr === "\n")
                    ++line;
                if (++offset === length)
                    return null;
            ***REMOVED***
            if (charAt(offset) === "/") ***REMOVED***
                if (++offset === length)
                    throw illegal("comment");
                if (charAt(offset) === "/") ***REMOVED*** // Line
                    isDoc = charAt(start = offset + 1) === "/";
                    while (charAt(++offset) !== "\n")
                        if (offset === length)
                            return null;
                    ++offset;
                    if (isDoc) /// Comment
                        setComment(start, offset - 1);
                    ++line;
                    repeat = true;
                ***REMOVED*** else if ((curr = charAt(offset)) === "*") ***REMOVED*** /* Block */
                    isDoc = charAt(start = offset + 1) === "*";
                    do ***REMOVED***
                        if (curr === "\n")
                            ++line;
                        if (++offset === length)
                            throw illegal("comment");
                        prev = curr;
                        curr = charAt(offset);
                    ***REMOVED*** while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) /** Comment */
                        setComment(start, offset - 2);
                    repeat = true;
                ***REMOVED*** else
                    return "/";
            ***REMOVED***
        ***REMOVED*** while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    ***REMOVED***

    /**
     * Pushes a token back to the stack.
     * @param ***REMOVED***string***REMOVED*** token Token
     * @returns ***REMOVED***undefined***REMOVED***
     * @inner
     */
    function push(token) ***REMOVED***
        stack.push(token);
    ***REMOVED***

    /**
     * Peeks for the next token.
     * @returns ***REMOVED***string|null***REMOVED*** Token or `null` on eof
     * @inner
     */
    function peek() ***REMOVED***
        if (!stack.length) ***REMOVED***
            var token = next();
            if (token === null)
                return null;
            push(token);
        ***REMOVED***
        return stack[0];
    ***REMOVED***

    /**
     * Skips a token.
     * @param ***REMOVED***string***REMOVED*** expected Expected token
     * @param ***REMOVED***boolean***REMOVED*** [optional=false] Whether the token is optional
     * @returns ***REMOVED***boolean***REMOVED*** `true` when skipped, `false` if not
     * @throws ***REMOVED***Error***REMOVED*** When a required token is not present
     * @inner
     */
    function skip(expected, optional) ***REMOVED***
        var actual = peek(),
            equals = actual === expected;
        if (equals) ***REMOVED***
            next();
            return true;
        ***REMOVED***
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    ***REMOVED***

    /**
     * Gets a comment.
     * @param ***REMOVED***number***REMOVED*** [trailingLine] Line number if looking for a trailing comment
     * @returns ***REMOVED***string|null***REMOVED*** Comment text
     * @inner
     */
    function cmnt(trailingLine) ***REMOVED***
        var ret = null;
        if (trailingLine === undefined) ***REMOVED***
            if (commentLine === line - 1 && (commentType === "*" || commentLineEmpty))
                ret = commentText;
        ***REMOVED*** else ***REMOVED***
            /* istanbul ignore else */
            if (commentLine < trailingLine)
                peek();
            if (commentLine === trailingLine && !commentLineEmpty && commentType === "/")
                ret = commentText;
        ***REMOVED***
        return ret;
    ***REMOVED***

    return Object.defineProperty(***REMOVED***
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    ***REMOVED***, "line", ***REMOVED***
        get: function() ***REMOVED*** return line; ***REMOVED***
    ***REMOVED***);
    /* eslint-enable callback-return */
***REMOVED***
