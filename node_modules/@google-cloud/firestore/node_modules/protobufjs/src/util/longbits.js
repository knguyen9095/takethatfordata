"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param ***REMOVED***number***REMOVED*** lo Low 32 bits, unsigned
 * @param ***REMOVED***number***REMOVED*** hi High 32 bits, unsigned
 */
function LongBits(lo, hi) ***REMOVED***

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type ***REMOVED***number***REMOVED***
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type ***REMOVED***number***REMOVED***
     */
    this.hi = hi >>> 0;
***REMOVED***

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type ***REMOVED***util.LongBits***REMOVED***
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() ***REMOVED*** return 0; ***REMOVED***;
zero.zzEncode = zero.zzDecode = function() ***REMOVED*** return this; ***REMOVED***;
zero.length = function() ***REMOVED*** return 1; ***REMOVED***;

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type ***REMOVED***string***REMOVED***
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param ***REMOVED***number***REMOVED*** value Value
 * @returns ***REMOVED***util.LongBits***REMOVED*** Instance
 */
LongBits.fromNumber = function fromNumber(value) ***REMOVED***
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) ***REMOVED***
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) ***REMOVED***
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        ***REMOVED***
    ***REMOVED***
    return new LongBits(lo, hi);
***REMOVED***;

/**
 * Constructs new long bits from a number, long or string.
 * @param ***REMOVED***Long|number|string***REMOVED*** value Value
 * @returns ***REMOVED***util.LongBits***REMOVED*** Instance
 */
LongBits.from = function from(value) ***REMOVED***
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) ***REMOVED***
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    ***REMOVED***
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
***REMOVED***;

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param ***REMOVED***boolean***REMOVED*** [unsigned=false] Whether unsigned or not
 * @returns ***REMOVED***number***REMOVED*** Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) ***REMOVED***
    if (!unsigned && this.hi >>> 31) ***REMOVED***
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    ***REMOVED***
    return this.lo + this.hi * 4294967296;
***REMOVED***;

/**
 * Converts this long bits to a long.
 * @param ***REMOVED***boolean***REMOVED*** [unsigned=false] Whether unsigned or not
 * @returns ***REMOVED***Long***REMOVED*** Long
 */
LongBits.prototype.toLong = function toLong(unsigned) ***REMOVED***
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : ***REMOVED*** low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) ***REMOVED***;
***REMOVED***;

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param ***REMOVED***string***REMOVED*** hash Hash
 * @returns ***REMOVED***util.LongBits***REMOVED*** Bits
 */
LongBits.fromHash = function fromHash(hash) ***REMOVED***
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
***REMOVED***;

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns ***REMOVED***string***REMOVED*** Hash
 */
LongBits.prototype.toHash = function toHash() ***REMOVED***
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
***REMOVED***;

/**
 * Zig-zag encodes this long bits.
 * @returns ***REMOVED***util.LongBits***REMOVED*** `this`
 */
LongBits.prototype.zzEncode = function zzEncode() ***REMOVED***
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
***REMOVED***;

/**
 * Zig-zag decodes this long bits.
 * @returns ***REMOVED***util.LongBits***REMOVED*** `this`
 */
LongBits.prototype.zzDecode = function zzDecode() ***REMOVED***
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
***REMOVED***;

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns ***REMOVED***number***REMOVED*** Length
 */
LongBits.prototype.length = function length() ***REMOVED***
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
***REMOVED***;
