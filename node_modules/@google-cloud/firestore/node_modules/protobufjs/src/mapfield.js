"use strict";
module.exports = MapField;

// extends Field
var Field = require("./field");
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require("./types"),
    util    = require("./util");

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param ***REMOVED***string***REMOVED*** name Unique name within its namespace
 * @param ***REMOVED***number***REMOVED*** id Unique id within its namespace
 * @param ***REMOVED***string***REMOVED*** keyType Key type
 * @param ***REMOVED***string***REMOVED*** type Value type
 * @param ***REMOVED***Object.<string,*>***REMOVED*** [options] Declared options
 */
function MapField(name, id, keyType, type, options) ***REMOVED***
    Field.call(this, name, id, type, options);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type ***REMOVED***string***REMOVED***
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type ***REMOVED***ReflectionObject|null***REMOVED***
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
***REMOVED***

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends ***REMOVED***IField***REMOVED***
 * @property ***REMOVED***string***REMOVED*** keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property ***REMOVED***string***REMOVED*** extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param ***REMOVED***string***REMOVED*** name Field name
 * @param ***REMOVED***IMapField***REMOVED*** json Map field descriptor
 * @returns ***REMOVED***MapField***REMOVED*** Created map field
 * @throws ***REMOVED***TypeError***REMOVED*** If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) ***REMOVED***
    return new MapField(name, json.id, json.keyType, json.type, json.options);
***REMOVED***;

/**
 * Converts this map field to a map field descriptor.
 * @returns ***REMOVED***IMapField***REMOVED*** Map field descriptor
 */
MapField.prototype.toJSON = function toJSON() ***REMOVED***
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options
    ]);
***REMOVED***;

/**
 * @override
 */
MapField.prototype.resolve = function resolve() ***REMOVED***
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
***REMOVED***;

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param ***REMOVED***number***REMOVED*** fieldId Field id
 * @param ***REMOVED***"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"***REMOVED*** fieldKeyType Field key type
 * @param ***REMOVED***"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<***REMOVED******REMOVED***>***REMOVED*** fieldValueType Field value type
 * @returns ***REMOVED***FieldDecorator***REMOVED*** Decorator function
 * @template T extends ***REMOVED*** [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<***REMOVED******REMOVED***> ***REMOVED***
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) ***REMOVED***

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) ***REMOVED***
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    ***REMOVED***;
***REMOVED***;
