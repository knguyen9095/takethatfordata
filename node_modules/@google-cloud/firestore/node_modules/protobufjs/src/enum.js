"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require("./namespace"),
    util = require("./util");

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param ***REMOVED***string***REMOVED*** name Unique name within its namespace
 * @param ***REMOVED***Object.<string,number>***REMOVED*** [values] Enum values as an object, by name
 * @param ***REMOVED***Object.<string,*>***REMOVED*** [options] Declared options
 */
function Enum(name, values, options) ***REMOVED***
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type ***REMOVED***Object.<number,string>***REMOVED***
     */
    this.valuesById = ***REMOVED******REMOVED***;

    /**
     * Enum values by name.
     * @type ***REMOVED***Object.<string,number>***REMOVED***
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Value comment texts, if any.
     * @type ***REMOVED***Object.<string,string>***REMOVED***
     */
    this.comments = ***REMOVED******REMOVED***;

    /**
     * Reserved ranges, if any.
     * @type ***REMOVED***Array.<number[]|string>***REMOVED***
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
***REMOVED***

/**
 * Enum descriptor.
 * @interface IEnum
 * @property ***REMOVED***Object.<string,number>***REMOVED*** values Enum values
 * @property ***REMOVED***Object.<string,*>***REMOVED*** [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param ***REMOVED***string***REMOVED*** name Enum name
 * @param ***REMOVED***IEnum***REMOVED*** json Enum descriptor
 * @returns ***REMOVED***Enum***REMOVED*** Created enum
 * @throws ***REMOVED***TypeError***REMOVED*** If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) ***REMOVED***
    var enm = new Enum(name, json.values, json.options);
    enm.reserved = json.reserved;
    return enm;
***REMOVED***;

/**
 * Converts this enum to an enum descriptor.
 * @returns ***REMOVED***IEnum***REMOVED*** Enum descriptor
 */
Enum.prototype.toJSON = function toJSON() ***REMOVED***
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined
    ]);
***REMOVED***;

/**
 * Adds a value to this enum.
 * @param ***REMOVED***string***REMOVED*** name Value name
 * @param ***REMOVED***number***REMOVED*** id Value id
 * @param ***REMOVED***string***REMOVED*** [comment] Comment, if any
 * @returns ***REMOVED***Enum***REMOVED*** `this`
 * @throws ***REMOVED***TypeError***REMOVED*** If arguments are invalid
 * @throws ***REMOVED***Error***REMOVED*** If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) ***REMOVED***
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) ***REMOVED***
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    ***REMOVED*** else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
***REMOVED***;

/**
 * Removes a value from this enum
 * @param ***REMOVED***string***REMOVED*** name Value name
 * @returns ***REMOVED***Enum***REMOVED*** `this`
 * @throws ***REMOVED***TypeError***REMOVED*** If arguments are invalid
 * @throws ***REMOVED***Error***REMOVED*** If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) ***REMOVED***

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
***REMOVED***;

/**
 * Tests if the specified id is reserved.
 * @param ***REMOVED***number***REMOVED*** id Id to test
 * @returns ***REMOVED***boolean***REMOVED*** `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) ***REMOVED***
    return Namespace.isReservedId(this.reserved, id);
***REMOVED***;

/**
 * Tests if the specified name is reserved.
 * @param ***REMOVED***string***REMOVED*** name Name to test
 * @returns ***REMOVED***boolean***REMOVED*** `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) ***REMOVED***
    return Namespace.isReservedName(this.reserved, name);
***REMOVED***;
