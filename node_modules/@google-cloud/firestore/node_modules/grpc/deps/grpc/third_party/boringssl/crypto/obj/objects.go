// Copyright (c) 2016, Google Inc.
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
// OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
// CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"
)

func sanitizeName(in string) string ***REMOVED***
	in = strings.Replace(in, "-", "_", -1)
	in = strings.Replace(in, ".", "_", -1)
	in = strings.Replace(in, " ", "_", -1)
	return in
***REMOVED***

type object struct ***REMOVED***
	name string
	// shortName and longName are the short and long names, respectively. If
	// one is missing, it takes the value of the other, but the
	// corresponding SN_foo or LN_foo macro is not defined.
	shortName, longName       string
	hasShortName, hasLongName bool
	oid                       []int
	encoded                   []byte
***REMOVED***

type objects struct ***REMOVED***
	// byNID is the list of all objects, indexed by nid.
	byNID []object
	// nameToNID is a map from object name to nid.
	nameToNID map[string]int
***REMOVED***

func readNumbers(path string) (nameToNID map[string]int, numNIDs int, err error) ***REMOVED***
	in, err := os.Open(path)
	if err != nil ***REMOVED***
		return nil, 0, err
	***REMOVED***
	defer in.Close()

	nameToNID = make(map[string]int)
	nidsSeen := make(map[int]struct***REMOVED******REMOVED***)

	// Reserve NID 0 for NID_undef.
	numNIDs = 1
	nameToNID["undef"] = 0
	nidsSeen[0] = struct***REMOVED******REMOVED******REMOVED******REMOVED***

	var lineNo int
	scanner := bufio.NewScanner(in)
	for scanner.Scan() ***REMOVED***
		line := scanner.Text()
		lineNo++
		withLine := func(err error) error ***REMOVED***
			return fmt.Errorf("%s:%d: %s", path, lineNo, err)
		***REMOVED***

		fields := strings.Fields(line)
		if len(fields) == 0 ***REMOVED***
			// Skip blank lines.
			continue
		***REMOVED***

		// Each line is a name and a nid, separated by space.
		if len(fields) != 2 ***REMOVED***
			return nil, 0, withLine(errors.New("syntax error"))
		***REMOVED***
		name := fields[0]
		nid, err := strconv.Atoi(fields[1])
		if err != nil ***REMOVED***
			return nil, 0, withLine(err)
		***REMOVED***
		if nid < 0 ***REMOVED***
			return nil, 0, withLine(errors.New("invalid NID"))
		***REMOVED***

		// NID_undef is implicitly defined.
		if name == "undef" && nid == 0 ***REMOVED***
			continue
		***REMOVED***

		// Forbid duplicates.
		if _, ok := nameToNID[name]; ok ***REMOVED***
			return nil, 0, withLine(fmt.Errorf("duplicate name %q", name))
		***REMOVED***
		if _, ok := nidsSeen[nid]; ok ***REMOVED***
			return nil, 0, withLine(fmt.Errorf("duplicate NID %d", nid))
		***REMOVED***

		nameToNID[name] = nid
		nidsSeen[nid] = struct***REMOVED******REMOVED******REMOVED******REMOVED***

		if nid >= numNIDs ***REMOVED***
			numNIDs = nid + 1
		***REMOVED***
	***REMOVED***
	if err := scanner.Err(); err != nil ***REMOVED***
		return nil, 0, fmt.Errorf("error reading %s: %s", path, err)
	***REMOVED***

	return nameToNID, numNIDs, nil
***REMOVED***

func parseOID(aliases map[string][]int, in []string) (oid []int, err error) ***REMOVED***
	if len(in) == 0 ***REMOVED***
		return
	***REMOVED***

	// The first entry may be a reference to a previous alias.
	if alias, ok := aliases[sanitizeName(in[0])]; ok ***REMOVED***
		in = in[1:]
		oid = append(oid, alias...)
	***REMOVED***

	for _, c := range in ***REMOVED***
		val, err := strconv.Atoi(c)
		if err != nil ***REMOVED***
			return nil, err
		***REMOVED***
		if val < 0 ***REMOVED***
			return nil, fmt.Errorf("negative component")
		***REMOVED***
		oid = append(oid, val)
	***REMOVED***
	return
***REMOVED***

func appendBase128(dst []byte, value int) []byte ***REMOVED***
	// Zero is encoded with one, not zero bytes.
	if value == 0 ***REMOVED***
		return append(dst, 0)
	***REMOVED***

	// Count how many bytes are needed.
	var l int
	for n := value; n != 0; n >>= 7 ***REMOVED***
		l++
	***REMOVED***
	for ; l > 0; l-- ***REMOVED***
		b := byte(value>>uint(7*(l-1))) & 0x7f
		if l > 1 ***REMOVED***
			b |= 0x80
		***REMOVED***
		dst = append(dst, b)
	***REMOVED***
	return dst
***REMOVED***

func encodeOID(oid []int) []byte ***REMOVED***
	if len(oid) < 2 ***REMOVED***
		return nil
	***REMOVED***

	var der []byte
	der = appendBase128(der, 40*oid[0]+oid[1])
	for _, value := range oid[2:] ***REMOVED***
		der = appendBase128(der, value)
	***REMOVED***
	return der
***REMOVED***

func readObjects(numPath, objectsPath string) (*objects, error) ***REMOVED***
	nameToNID, numNIDs, err := readNumbers(numPath)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	in, err := os.Open(objectsPath)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	defer in.Close()

	// Implicitly define NID_undef.
	objs := &objects***REMOVED***
		byNID:     make([]object, numNIDs),
		nameToNID: make(map[string]int),
	***REMOVED***

	objs.byNID[0] = object***REMOVED***
		name:         "undef",
		shortName:    "UNDEF",
		longName:     "undefined",
		hasShortName: true,
		hasLongName:  true,
	***REMOVED***
	objs.nameToNID["undef"] = 0

	var module, nextName string
	var lineNo int
	longNamesSeen := make(map[string]struct***REMOVED******REMOVED***)
	shortNamesSeen := make(map[string]struct***REMOVED******REMOVED***)
	aliases := make(map[string][]int)
	scanner := bufio.NewScanner(in)
	for scanner.Scan() ***REMOVED***
		line := scanner.Text()
		lineNo++
		withLine := func(err error) error ***REMOVED***
			return fmt.Errorf("%s:%d: %s", objectsPath, lineNo, err)
		***REMOVED***

		// Remove comments.
		idx := strings.IndexRune(line, '#')
		if idx >= 0 ***REMOVED***
			line = line[:idx]
		***REMOVED***

		// Skip empty lines.
		line = strings.TrimSpace(line)
		if len(line) == 0 ***REMOVED***
			continue
		***REMOVED***

		if line[0] == '!' ***REMOVED***
			args := strings.Fields(line)
			switch args[0] ***REMOVED***
			case "!module":
				if len(args) != 2 ***REMOVED***
					return nil, withLine(errors.New("too many arguments"))
				***REMOVED***
				module = sanitizeName(args[1]) + "_"
			case "!global":
				module = ""
			case "!Cname":
				// !Cname directives override the name for the
				// next object.
				if len(args) != 2 ***REMOVED***
					return nil, withLine(errors.New("too many arguments"))
				***REMOVED***
				nextName = sanitizeName(args[1])
			case "!Alias":
				// !Alias directives define an alias for an OID
				// without emitting an object.
				if len(nextName) != 0 ***REMOVED***
					return nil, withLine(errors.New("!Cname directives may not modify !Alias directives."))
				***REMOVED***
				if len(args) < 3 ***REMOVED***
					return nil, withLine(errors.New("not enough arguments"))
				***REMOVED***
				aliasName := module + sanitizeName(args[1])
				oid, err := parseOID(aliases, args[2:])
				if err != nil ***REMOVED***
					return nil, withLine(err)
				***REMOVED***
				if _, ok := aliases[aliasName]; ok ***REMOVED***
					return nil, withLine(fmt.Errorf("duplicate name '%s'", aliasName))
				***REMOVED***
				aliases[aliasName] = oid
			default:
				return nil, withLine(fmt.Errorf("unknown directive '%s'", args[0]))
			***REMOVED***
			continue
		***REMOVED***

		fields := strings.Split(line, ":")
		if len(fields) < 2 || len(fields) > 3 ***REMOVED***
			return nil, withLine(errors.New("invalid field count"))
		***REMOVED***

		obj := object***REMOVED***name: nextName***REMOVED***
		nextName = ""

		var err error
		obj.oid, err = parseOID(aliases, strings.Fields(fields[0]))
		if err != nil ***REMOVED***
			return nil, withLine(err)
		***REMOVED***
		obj.encoded = encodeOID(obj.oid)

		obj.shortName = strings.TrimSpace(fields[1])
		if len(fields) == 3 ***REMOVED***
			obj.longName = strings.TrimSpace(fields[2])
		***REMOVED***

		// Long and short names default to each other if missing.
		if len(obj.shortName) == 0 ***REMOVED***
			obj.shortName = obj.longName
		***REMOVED*** else ***REMOVED***
			obj.hasShortName = true
		***REMOVED***
		if len(obj.longName) == 0 ***REMOVED***
			obj.longName = obj.shortName
		***REMOVED*** else ***REMOVED***
			obj.hasLongName = true
		***REMOVED***
		if len(obj.shortName) == 0 || len(obj.longName) == 0 ***REMOVED***
			return nil, withLine(errors.New("object with no name"))
		***REMOVED***

		// If not already specified, prefer the long name if it has no
		// spaces, otherwise the short name.
		if len(obj.name) == 0 && strings.IndexRune(obj.longName, ' ') < 0 ***REMOVED***
			obj.name = sanitizeName(obj.longName)
		***REMOVED***
		if len(obj.name) == 0 ***REMOVED***
			obj.name = sanitizeName(obj.shortName)
		***REMOVED***
		obj.name = module + obj.name

		// Check for duplicate names.
		if _, ok := aliases[obj.name]; ok ***REMOVED***
			return nil, withLine(fmt.Errorf("duplicate name '%s'", obj.name))
		***REMOVED***
		if _, ok := shortNamesSeen[obj.shortName]; ok && len(obj.shortName) > 0 ***REMOVED***
			return nil, withLine(fmt.Errorf("duplicate short name '%s'", obj.shortName))
		***REMOVED***
		if _, ok := longNamesSeen[obj.longName]; ok && len(obj.longName) > 0 ***REMOVED***
			return nil, withLine(fmt.Errorf("duplicate long name '%s'", obj.longName))
		***REMOVED***

		// Allocate a NID.
		nid, ok := nameToNID[obj.name]
		if !ok ***REMOVED***
			nid = len(objs.byNID)
			objs.byNID = append(objs.byNID, object***REMOVED******REMOVED***)
		***REMOVED***

		objs.byNID[nid] = obj
		objs.nameToNID[obj.name] = nid

		longNamesSeen[obj.longName] = struct***REMOVED******REMOVED******REMOVED******REMOVED***
		shortNamesSeen[obj.shortName] = struct***REMOVED******REMOVED******REMOVED******REMOVED***
		aliases[obj.name] = obj.oid
	***REMOVED***
	if err := scanner.Err(); err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	return objs, nil
***REMOVED***

func writeNumbers(path string, objs *objects) error ***REMOVED***
	out, err := os.Create(path)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	defer out.Close()

	for nid, obj := range objs.byNID ***REMOVED***
		if len(obj.name) == 0 ***REMOVED***
			continue
		***REMOVED***
		if _, err := fmt.Fprintf(out, "%s\t\t%d\n", obj.name, nid); err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***
	return nil
***REMOVED***

func clangFormat(input string) (string, error) ***REMOVED***
	var b bytes.Buffer
	cmd := exec.Command("clang-format")
	cmd.Stdin = strings.NewReader(input)
	cmd.Stdout = &b
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil ***REMOVED***
		return "", err
	***REMOVED***
	return b.String(), nil
***REMOVED***

func writeHeader(path string, objs *objects) error ***REMOVED***
	var b bytes.Buffer
	fmt.Fprintf(&b, `/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG `+"``"+`AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.] */

/* This file is generated by crypto/obj/objects.go. */

#ifndef OPENSSL_HEADER_NID_H
#define OPENSSL_HEADER_NID_H

#include <openssl/base.h>

#if defined(__cplusplus)
extern "C" ***REMOVED***
#endif


/* The nid library provides numbered values for ASN.1 object identifiers and
 * other symbols. These values are used by other libraries to identify
 * cryptographic primitives.
 *
 * A separate objects library, obj.h, provides functions for converting between
 * nids and object identifiers. However it depends on large internal tables with
 * the encodings of every nid defined. Consumers concerned with binary size
 * should instead embed the encodings of the few consumed OIDs and compare
 * against those.
 *
 * These values should not be used outside of a single process; they are not
 * stable identifiers. */


`)

	for nid, obj := range objs.byNID ***REMOVED***
		if len(obj.name) == 0 ***REMOVED***
			continue
		***REMOVED***

		if obj.hasShortName ***REMOVED***
			fmt.Fprintf(&b, "#define SN_%s \"%s\"\n", obj.name, obj.shortName)
		***REMOVED***
		if obj.hasLongName ***REMOVED***
			fmt.Fprintf(&b, "#define LN_%s \"%s\"\n", obj.name, obj.longName)
		***REMOVED***
		fmt.Fprintf(&b, "#define NID_%s %d\n", obj.name, nid)

		// Although NID_undef does not have an OID, OpenSSL emits
		// OBJ_undef as if it were zero.
		oid := obj.oid
		if nid == 0 ***REMOVED***
			oid = []int***REMOVED***0***REMOVED***
		***REMOVED***
		if len(oid) != 0 ***REMOVED***
			var oidStr string
			for _, val := range oid ***REMOVED***
				if len(oidStr) != 0 ***REMOVED***
					oidStr += ","
				***REMOVED***
				oidStr += fmt.Sprintf("%dL", val)
			***REMOVED***

			fmt.Fprintf(&b, "#define OBJ_%s %s\n", obj.name, oidStr)
		***REMOVED***

		fmt.Fprintf(&b, "\n")
	***REMOVED***

	fmt.Fprintf(&b, `
#if defined(__cplusplus)
***REMOVED***  /* extern C */
#endif

#endif  /* OPENSSL_HEADER_NID_H */
`)

	formatted, err := clangFormat(b.String())
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	return ioutil.WriteFile(path, []byte(formatted), 0666)
***REMOVED***

// TODO(davidben): Replace this with sort.Slice once Go 1.8 is sufficiently
// common.
type nidSorter struct ***REMOVED***
	nids []int
	objs *objects
	cmp  func(a, b object) bool
***REMOVED***

func (a nidSorter) obj(i int) object   ***REMOVED*** return a.objs.byNID[a.nids[i]] ***REMOVED***
func (a nidSorter) Len() int           ***REMOVED*** return len(a.nids) ***REMOVED***
func (a nidSorter) Swap(i, j int)      ***REMOVED*** a.nids[i], a.nids[j] = a.nids[j], a.nids[i] ***REMOVED***
func (a nidSorter) Less(i, j int) bool ***REMOVED*** return a.cmp(a.obj(i), a.obj(j)) ***REMOVED***

func sortNIDs(nids []int, objs *objects, cmp func(a, b object) bool) ***REMOVED***
	sort.Sort(&nidSorter***REMOVED***nids, objs, cmp***REMOVED***)
***REMOVED***

func writeData(path string, objs *objects) error ***REMOVED***
	var b bytes.Buffer
	fmt.Fprintf(&b, `/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG `+"``"+`AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.] */

/* This file is generated by crypto/obj/objects.go. */


`)

	fmt.Fprintf(&b, "#define NUM_NID %d\n", len(objs.byNID))

	// Emit each object's DER encoding, concatenated, and save the offsets.
	fmt.Fprintf(&b, "\nstatic const uint8_t kObjectData[] = ***REMOVED***\n")
	offsets := make([]int, len(objs.byNID))
	var nextOffset int
	for nid, obj := range objs.byNID ***REMOVED***
		if len(obj.name) == 0 || len(obj.encoded) == 0 ***REMOVED***
			offsets[nid] = -1
			continue
		***REMOVED***

		offsets[nid] = nextOffset
		nextOffset += len(obj.encoded)
		fmt.Fprintf(&b, "/* NID_%s */\n", obj.name)
		for _, val := range obj.encoded ***REMOVED***
			fmt.Fprintf(&b, "0x%02x, ", val)
		***REMOVED***
		fmt.Fprintf(&b, "\n")
	***REMOVED***
	fmt.Fprintf(&b, "***REMOVED***;\n")

	// Emit an ASN1_OBJECT for each object.
	fmt.Fprintf(&b, "\nstatic const ASN1_OBJECT kObjects[NUM_NID] = ***REMOVED***\n")
	for nid, obj := range objs.byNID ***REMOVED***
		if len(obj.name) == 0 ***REMOVED***
			fmt.Fprintf(&b, "***REMOVED***NULL, NULL, NID_undef, 0, NULL, 0***REMOVED***,\n")
			continue
		***REMOVED***

		fmt.Fprintf(&b, "***REMOVED***\"%s\", \"%s\", NID_%s, ", obj.shortName, obj.longName, obj.name)
		if offset := offsets[nid]; offset >= 0 ***REMOVED***
			fmt.Fprintf(&b, "%d, &kObjectData[%d], 0***REMOVED***,\n", len(obj.encoded), offset)
		***REMOVED*** else ***REMOVED***
			fmt.Fprintf(&b, "0, NULL, 0***REMOVED***,\n")
		***REMOVED***
	***REMOVED***
	fmt.Fprintf(&b, "***REMOVED***;\n")

	// Emit a list of NIDs sorted by short name.
	var nids []int
	for nid, obj := range objs.byNID ***REMOVED***
		if len(obj.name) == 0 || len(obj.shortName) == 0 ***REMOVED***
			continue
		***REMOVED***
		nids = append(nids, nid)
	***REMOVED***
	sortNIDs(nids, objs, func(a, b object) bool ***REMOVED*** return a.shortName < b.shortName ***REMOVED***)

	fmt.Fprintf(&b, "\nstatic const unsigned kNIDsInShortNameOrder[] = ***REMOVED***\n")
	for _, nid := range nids ***REMOVED***
		fmt.Fprintf(&b, "%d /* %s */,\n", nid, objs.byNID[nid].shortName)
	***REMOVED***
	fmt.Fprintf(&b, "***REMOVED***;\n")

	// Emit a list of NIDs sorted by long name.
	nids = nil
	for nid, obj := range objs.byNID ***REMOVED***
		if len(obj.name) == 0 || len(obj.longName) == 0 ***REMOVED***
			continue
		***REMOVED***
		nids = append(nids, nid)
	***REMOVED***
	sortNIDs(nids, objs, func(a, b object) bool ***REMOVED*** return a.longName < b.longName ***REMOVED***)

	fmt.Fprintf(&b, "\nstatic const unsigned kNIDsInLongNameOrder[] = ***REMOVED***\n")
	for _, nid := range nids ***REMOVED***
		fmt.Fprintf(&b, "%d /* %s */,\n", nid, objs.byNID[nid].longName)
	***REMOVED***
	fmt.Fprintf(&b, "***REMOVED***;\n")

	// Emit a list of NIDs sorted by OID.
	nids = nil
	for nid, obj := range objs.byNID ***REMOVED***
		if len(obj.name) == 0 || len(obj.encoded) == 0 ***REMOVED***
			continue
		***REMOVED***
		nids = append(nids, nid)
	***REMOVED***
	sortNIDs(nids, objs, func(a, b object) bool ***REMOVED***
		// This comparison must match the definition of |obj_cmp|.
		if len(a.encoded) < len(b.encoded) ***REMOVED***
			return true
		***REMOVED***
		if len(a.encoded) > len(b.encoded) ***REMOVED***
			return false
		***REMOVED***
		return bytes.Compare(a.encoded, b.encoded) < 0
	***REMOVED***)

	fmt.Fprintf(&b, "\nstatic const unsigned kNIDsInOIDOrder[] = ***REMOVED***\n")
	for _, nid := range nids ***REMOVED***
		obj := objs.byNID[nid]
		fmt.Fprintf(&b, "%d /* ", nid)
		for i, c := range obj.oid ***REMOVED***
			if i > 0 ***REMOVED***
				fmt.Fprintf(&b, ".")
			***REMOVED***
			fmt.Fprintf(&b, "%d", c)
		***REMOVED***
		fmt.Fprintf(&b, " (OBJ_%s) */,\n", obj.name)
	***REMOVED***
	fmt.Fprintf(&b, "***REMOVED***;\n")

	formatted, err := clangFormat(b.String())
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	return ioutil.WriteFile(path, []byte(formatted), 0666)
***REMOVED***

func main() ***REMOVED***
	objs, err := readObjects("obj_mac.num", "objects.txt")
	if err != nil ***REMOVED***
		fmt.Fprintf(os.Stderr, "Error reading objects: %s\n", err)
		os.Exit(1)
	***REMOVED***

	if err := writeNumbers("obj_mac.num", objs); err != nil ***REMOVED***
		fmt.Fprintf(os.Stderr, "Error writing numbers: %s\n", err)
		os.Exit(1)
	***REMOVED***

	if err := writeHeader("../../include/openssl/nid.h", objs); err != nil ***REMOVED***
		fmt.Fprintf(os.Stderr, "Error writing header: %s\n", err)
		os.Exit(1)
	***REMOVED***

	if err := writeData("obj_dat.h", objs); err != nil ***REMOVED***
		fmt.Fprintf(os.Stderr, "Error writing data: %s\n", err)
		os.Exit(1)
	***REMOVED***
***REMOVED***
