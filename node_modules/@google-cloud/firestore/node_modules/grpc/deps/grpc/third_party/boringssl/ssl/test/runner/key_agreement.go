// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runner

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/subtle"
	"crypto/x509"
	"errors"
	"fmt"
	"io"
	"math/big"

	"./curve25519"
)

type keyType int

const (
	keyTypeRSA keyType = iota + 1
	keyTypeECDSA
)

var errClientKeyExchange = errors.New("tls: invalid ClientKeyExchange message")
var errServerKeyExchange = errors.New("tls: invalid ServerKeyExchange message")

// rsaKeyAgreement implements the standard TLS key agreement where the client
// encrypts the pre-master secret to the server's public key.
type rsaKeyAgreement struct ***REMOVED***
	version       uint16
	clientVersion uint16
	exportKey     *rsa.PrivateKey
***REMOVED***

func (ka *rsaKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) ***REMOVED***
	// Save the client version for comparison later.
	ka.clientVersion = clientHello.vers

	if !config.Bugs.RSAEphemeralKey ***REMOVED***
		return nil, nil
	***REMOVED***

	// Generate an ephemeral RSA key to use instead of the real
	// one, as in RSA_EXPORT.
	key, err := rsa.GenerateKey(config.rand(), 512)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	ka.exportKey = key

	modulus := key.N.Bytes()
	exponent := big.NewInt(int64(key.E)).Bytes()
	serverRSAParams := make([]byte, 0, 2+len(modulus)+2+len(exponent))
	serverRSAParams = append(serverRSAParams, byte(len(modulus)>>8), byte(len(modulus)))
	serverRSAParams = append(serverRSAParams, modulus...)
	serverRSAParams = append(serverRSAParams, byte(len(exponent)>>8), byte(len(exponent)))
	serverRSAParams = append(serverRSAParams, exponent...)

	var sigAlg signatureAlgorithm
	if ka.version >= VersionTLS12 ***REMOVED***
		sigAlg, err = selectSignatureAlgorithm(ka.version, cert.PrivateKey, config, clientHello.signatureAlgorithms)
		if err != nil ***REMOVED***
			return nil, err
		***REMOVED***
	***REMOVED***

	sig, err := signMessage(ka.version, cert.PrivateKey, config, sigAlg, serverRSAParams)
	if err != nil ***REMOVED***
		return nil, errors.New("failed to sign RSA parameters: " + err.Error())
	***REMOVED***

	skx := new(serverKeyExchangeMsg)
	sigAlgsLen := 0
	if ka.version >= VersionTLS12 ***REMOVED***
		sigAlgsLen = 2
	***REMOVED***
	skx.key = make([]byte, len(serverRSAParams)+sigAlgsLen+2+len(sig))
	copy(skx.key, serverRSAParams)
	k := skx.key[len(serverRSAParams):]
	if ka.version >= VersionTLS12 ***REMOVED***
		k[0] = byte(sigAlg >> 8)
		k[1] = byte(sigAlg)
		k = k[2:]
	***REMOVED***
	k[0] = byte(len(sig) >> 8)
	k[1] = byte(len(sig))
	copy(k[2:], sig)

	return skx, nil
***REMOVED***

func (ka *rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) ***REMOVED***
	preMasterSecret := make([]byte, 48)
	_, err := io.ReadFull(config.rand(), preMasterSecret[2:])
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	if len(ckx.ciphertext) < 2 ***REMOVED***
		return nil, errClientKeyExchange
	***REMOVED***

	ciphertext := ckx.ciphertext
	if version != VersionSSL30 ***REMOVED***
		ciphertextLen := int(ckx.ciphertext[0])<<8 | int(ckx.ciphertext[1])
		if ciphertextLen != len(ckx.ciphertext)-2 ***REMOVED***
			return nil, errClientKeyExchange
		***REMOVED***
		ciphertext = ckx.ciphertext[2:]
	***REMOVED***

	key := cert.PrivateKey.(*rsa.PrivateKey)
	if ka.exportKey != nil ***REMOVED***
		key = ka.exportKey
	***REMOVED***
	err = rsa.DecryptPKCS1v15SessionKey(config.rand(), key, ciphertext, preMasterSecret)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	// This check should be done in constant-time, but this is a testing
	// implementation. See the discussion at the end of section 7.4.7.1 of
	// RFC 4346.
	vers := uint16(preMasterSecret[0])<<8 | uint16(preMasterSecret[1])
	if ka.clientVersion != vers ***REMOVED***
		return nil, fmt.Errorf("tls: invalid version in RSA premaster (got %04x, wanted %04x)", vers, ka.clientVersion)
	***REMOVED***
	return preMasterSecret, nil
***REMOVED***

func (ka *rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error ***REMOVED***
	return errors.New("tls: unexpected ServerKeyExchange")
***REMOVED***

func (ka *rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) ***REMOVED***
	bad := config.Bugs.BadRSAClientKeyExchange
	preMasterSecret := make([]byte, 48)
	vers := clientHello.vers
	if bad == RSABadValueWrongVersion ***REMOVED***
		vers ^= 1
	***REMOVED***
	preMasterSecret[0] = byte(vers >> 8)
	preMasterSecret[1] = byte(vers)
	_, err := io.ReadFull(config.rand(), preMasterSecret[2:])
	if err != nil ***REMOVED***
		return nil, nil, err
	***REMOVED***

	sentPreMasterSecret := preMasterSecret
	if bad == RSABadValueTooLong ***REMOVED***
		sentPreMasterSecret = make([]byte, len(sentPreMasterSecret)+1)
		copy(sentPreMasterSecret, preMasterSecret)
	***REMOVED*** else if bad == RSABadValueTooShort ***REMOVED***
		sentPreMasterSecret = sentPreMasterSecret[:len(sentPreMasterSecret)-1]
	***REMOVED***

	encrypted, err := rsa.EncryptPKCS1v15(config.rand(), cert.PublicKey.(*rsa.PublicKey), sentPreMasterSecret)
	if err != nil ***REMOVED***
		return nil, nil, err
	***REMOVED***
	if bad == RSABadValueCorrupt ***REMOVED***
		encrypted[len(encrypted)-1] ^= 1
		// Clear the high byte to ensure |encrypted| is still below the RSA modulus.
		encrypted[0] = 0
	***REMOVED***
	ckx := new(clientKeyExchangeMsg)
	if clientHello.vers != VersionSSL30 ***REMOVED***
		ckx.ciphertext = make([]byte, len(encrypted)+2)
		ckx.ciphertext[0] = byte(len(encrypted) >> 8)
		ckx.ciphertext[1] = byte(len(encrypted))
		copy(ckx.ciphertext[2:], encrypted)
	***REMOVED*** else ***REMOVED***
		ckx.ciphertext = encrypted
	***REMOVED***
	return preMasterSecret, ckx, nil
***REMOVED***

func (ka *rsaKeyAgreement) peerSignatureAlgorithm() signatureAlgorithm ***REMOVED***
	return 0
***REMOVED***

// A ecdhCurve is an instance of ECDH-style key agreement for TLS.
type ecdhCurve interface ***REMOVED***
	// offer generates a keypair using rand. It returns the encoded |publicKey|.
	offer(rand io.Reader) (publicKey []byte, err error)

	// accept responds to the |peerKey| generated by |offer| with the acceptor's
	// |publicKey|, and returns agreed-upon |preMasterSecret| to the acceptor.
	accept(rand io.Reader, peerKey []byte) (publicKey []byte, preMasterSecret []byte, err error)

	// finish returns the computed |preMasterSecret|, given the |peerKey|
	// generated by |accept|.
	finish(peerKey []byte) (preMasterSecret []byte, err error)
***REMOVED***

// ellipticECDHCurve implements ecdhCurve with an elliptic.Curve.
type ellipticECDHCurve struct ***REMOVED***
	curve      elliptic.Curve
	privateKey []byte
***REMOVED***

func (e *ellipticECDHCurve) offer(rand io.Reader) (publicKey []byte, err error) ***REMOVED***
	var x, y *big.Int
	e.privateKey, x, y, err = elliptic.GenerateKey(e.curve, rand)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	return elliptic.Marshal(e.curve, x, y), nil
***REMOVED***

func (e *ellipticECDHCurve) accept(rand io.Reader, peerKey []byte) (publicKey []byte, preMasterSecret []byte, err error) ***REMOVED***
	publicKey, err = e.offer(rand)
	if err != nil ***REMOVED***
		return nil, nil, err
	***REMOVED***
	preMasterSecret, err = e.finish(peerKey)
	if err != nil ***REMOVED***
		return nil, nil, err
	***REMOVED***
	return
***REMOVED***

func (e *ellipticECDHCurve) finish(peerKey []byte) (preMasterSecret []byte, err error) ***REMOVED***
	x, y := elliptic.Unmarshal(e.curve, peerKey)
	if x == nil ***REMOVED***
		return nil, errors.New("tls: invalid peer key")
	***REMOVED***
	x, _ = e.curve.ScalarMult(x, y, e.privateKey)
	preMasterSecret = make([]byte, (e.curve.Params().BitSize+7)>>3)
	xBytes := x.Bytes()
	copy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)

	return preMasterSecret, nil
***REMOVED***

// x25519ECDHCurve implements ecdhCurve with X25519.
type x25519ECDHCurve struct ***REMOVED***
	privateKey [32]byte
***REMOVED***

func (e *x25519ECDHCurve) offer(rand io.Reader) (publicKey []byte, err error) ***REMOVED***
	_, err = io.ReadFull(rand, e.privateKey[:])
	if err != nil ***REMOVED***
		return
	***REMOVED***
	var out [32]byte
	curve25519.ScalarBaseMult(&out, &e.privateKey)
	return out[:], nil
***REMOVED***

func (e *x25519ECDHCurve) accept(rand io.Reader, peerKey []byte) (publicKey []byte, preMasterSecret []byte, err error) ***REMOVED***
	publicKey, err = e.offer(rand)
	if err != nil ***REMOVED***
		return nil, nil, err
	***REMOVED***
	preMasterSecret, err = e.finish(peerKey)
	if err != nil ***REMOVED***
		return nil, nil, err
	***REMOVED***
	return
***REMOVED***

func (e *x25519ECDHCurve) finish(peerKey []byte) (preMasterSecret []byte, err error) ***REMOVED***
	if len(peerKey) != 32 ***REMOVED***
		return nil, errors.New("tls: invalid peer key")
	***REMOVED***
	var out, peerKeyCopy [32]byte
	copy(peerKeyCopy[:], peerKey)
	curve25519.ScalarMult(&out, &e.privateKey, &peerKeyCopy)

	// Per RFC 7748, reject the all-zero value in constant time.
	var zeros [32]byte
	if subtle.ConstantTimeCompare(zeros[:], out[:]) == 1 ***REMOVED***
		return nil, errors.New("tls: X25519 value with wrong order")
	***REMOVED***

	return out[:], nil
***REMOVED***

func curveForCurveID(id CurveID) (ecdhCurve, bool) ***REMOVED***
	switch id ***REMOVED***
	case CurveP224:
		return &ellipticECDHCurve***REMOVED***curve: elliptic.P224()***REMOVED***, true
	case CurveP256:
		return &ellipticECDHCurve***REMOVED***curve: elliptic.P256()***REMOVED***, true
	case CurveP384:
		return &ellipticECDHCurve***REMOVED***curve: elliptic.P384()***REMOVED***, true
	case CurveP521:
		return &ellipticECDHCurve***REMOVED***curve: elliptic.P521()***REMOVED***, true
	case CurveX25519:
		return &x25519ECDHCurve***REMOVED******REMOVED***, true
	default:
		return nil, false
	***REMOVED***

***REMOVED***

// keyAgreementAuthentication is a helper interface that specifies how
// to authenticate the ServerKeyExchange parameters.
type keyAgreementAuthentication interface ***REMOVED***
	signParameters(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg, params []byte) (*serverKeyExchangeMsg, error)
	verifyParameters(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, params []byte, sig []byte) error
***REMOVED***

// nilKeyAgreementAuthentication does not authenticate the key
// agreement parameters.
type nilKeyAgreementAuthentication struct***REMOVED******REMOVED***

func (ka *nilKeyAgreementAuthentication) signParameters(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg, params []byte) (*serverKeyExchangeMsg, error) ***REMOVED***
	skx := new(serverKeyExchangeMsg)
	skx.key = params
	return skx, nil
***REMOVED***

func (ka *nilKeyAgreementAuthentication) verifyParameters(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, params []byte, sig []byte) error ***REMOVED***
	return nil
***REMOVED***

// signedKeyAgreement signs the ServerKeyExchange parameters with the
// server's private key.
type signedKeyAgreement struct ***REMOVED***
	keyType                keyType
	version                uint16
	peerSignatureAlgorithm signatureAlgorithm
***REMOVED***

func (ka *signedKeyAgreement) signParameters(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg, params []byte) (*serverKeyExchangeMsg, error) ***REMOVED***
	// The message to be signed is prepended by the randoms.
	var msg []byte
	msg = append(msg, clientHello.random...)
	msg = append(msg, hello.random...)
	msg = append(msg, params...)

	var sigAlg signatureAlgorithm
	var err error
	if ka.version >= VersionTLS12 ***REMOVED***
		sigAlg, err = selectSignatureAlgorithm(ka.version, cert.PrivateKey, config, clientHello.signatureAlgorithms)
		if err != nil ***REMOVED***
			return nil, err
		***REMOVED***
	***REMOVED***

	sig, err := signMessage(ka.version, cert.PrivateKey, config, sigAlg, msg)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	if config.Bugs.SendSignatureAlgorithm != 0 ***REMOVED***
		sigAlg = config.Bugs.SendSignatureAlgorithm
	***REMOVED***

	skx := new(serverKeyExchangeMsg)
	if config.Bugs.UnauthenticatedECDH ***REMOVED***
		skx.key = params
	***REMOVED*** else ***REMOVED***
		sigAlgsLen := 0
		if ka.version >= VersionTLS12 ***REMOVED***
			sigAlgsLen = 2
		***REMOVED***
		skx.key = make([]byte, len(params)+sigAlgsLen+2+len(sig))
		copy(skx.key, params)
		k := skx.key[len(params):]
		if ka.version >= VersionTLS12 ***REMOVED***
			k[0] = byte(sigAlg >> 8)
			k[1] = byte(sigAlg)
			k = k[2:]
		***REMOVED***
		k[0] = byte(len(sig) >> 8)
		k[1] = byte(len(sig))
		copy(k[2:], sig)
	***REMOVED***

	return skx, nil
***REMOVED***

func (ka *signedKeyAgreement) verifyParameters(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, params []byte, sig []byte) error ***REMOVED***
	// The peer's key must match the cipher type.
	switch ka.keyType ***REMOVED***
	case keyTypeECDSA:
		_, ok := cert.PublicKey.(*ecdsa.PublicKey)
		if !ok ***REMOVED***
			return errors.New("tls: ECDHE ECDSA requires a ECDSA server public key")
		***REMOVED***
	case keyTypeRSA:
		_, ok := cert.PublicKey.(*rsa.PublicKey)
		if !ok ***REMOVED***
			return errors.New("tls: ECDHE RSA requires a RSA server public key")
		***REMOVED***
	default:
		return errors.New("tls: unknown key type")
	***REMOVED***

	// The message to be signed is prepended by the randoms.
	var msg []byte
	msg = append(msg, clientHello.random...)
	msg = append(msg, serverHello.random...)
	msg = append(msg, params...)

	var sigAlg signatureAlgorithm
	if ka.version >= VersionTLS12 ***REMOVED***
		if len(sig) < 2 ***REMOVED***
			return errServerKeyExchange
		***REMOVED***
		sigAlg = signatureAlgorithm(sig[0])<<8 | signatureAlgorithm(sig[1])
		sig = sig[2:]
		// Stash the signature algorithm to be extracted by the handshake.
		ka.peerSignatureAlgorithm = sigAlg
	***REMOVED***

	if len(sig) < 2 ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	sigLen := int(sig[0])<<8 | int(sig[1])
	if sigLen+2 != len(sig) ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	sig = sig[2:]

	return verifyMessage(ka.version, cert.PublicKey, config, sigAlg, msg, sig)
***REMOVED***

// ecdheKeyAgreement implements a TLS key agreement where the server
// generates a ephemeral EC public/private key pair and signs it. The
// pre-master secret is then calculated using ECDH. The signature may
// either be ECDSA or RSA.
type ecdheKeyAgreement struct ***REMOVED***
	auth    keyAgreementAuthentication
	curve   ecdhCurve
	curveID CurveID
	peerKey []byte
***REMOVED***

func (ka *ecdheKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) ***REMOVED***
	var curveid CurveID
	preferredCurves := config.curvePreferences()

NextCandidate:
	for _, candidate := range preferredCurves ***REMOVED***
		for _, c := range clientHello.supportedCurves ***REMOVED***
			if candidate == c ***REMOVED***
				curveid = c
				break NextCandidate
			***REMOVED***
		***REMOVED***
	***REMOVED***

	if curveid == 0 ***REMOVED***
		return nil, errors.New("tls: no supported elliptic curves offered")
	***REMOVED***

	var ok bool
	if ka.curve, ok = curveForCurveID(curveid); !ok ***REMOVED***
		return nil, errors.New("tls: preferredCurves includes unsupported curve")
	***REMOVED***
	ka.curveID = curveid

	publicKey, err := ka.curve.offer(config.rand())
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	// http://tools.ietf.org/html/rfc4492#section-5.4
	serverECDHParams := make([]byte, 1+2+1+len(publicKey))
	serverECDHParams[0] = 3 // named curve
	if config.Bugs.SendCurve != 0 ***REMOVED***
		curveid = config.Bugs.SendCurve
	***REMOVED***
	serverECDHParams[1] = byte(curveid >> 8)
	serverECDHParams[2] = byte(curveid)
	serverECDHParams[3] = byte(len(publicKey))
	copy(serverECDHParams[4:], publicKey)
	if config.Bugs.InvalidECDHPoint ***REMOVED***
		serverECDHParams[4] ^= 0xff
	***REMOVED***

	return ka.auth.signParameters(config, cert, clientHello, hello, serverECDHParams)
***REMOVED***

func (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) ***REMOVED***
	if len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 ***REMOVED***
		return nil, errClientKeyExchange
	***REMOVED***
	return ka.curve.finish(ckx.ciphertext[1:])
***REMOVED***

func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error ***REMOVED***
	if len(skx.key) < 4 ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	if skx.key[0] != 3 ***REMOVED*** // named curve
		return errors.New("tls: server selected unsupported curve")
	***REMOVED***
	curveid := CurveID(skx.key[1])<<8 | CurveID(skx.key[2])
	ka.curveID = curveid

	var ok bool
	if ka.curve, ok = curveForCurveID(curveid); !ok ***REMOVED***
		return errors.New("tls: server selected unsupported curve")
	***REMOVED***

	publicLen := int(skx.key[3])
	if publicLen+4 > len(skx.key) ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	// Save the peer key for later.
	ka.peerKey = skx.key[4 : 4+publicLen]

	// Check the signature.
	serverECDHParams := skx.key[:4+publicLen]
	sig := skx.key[4+publicLen:]
	return ka.auth.verifyParameters(config, clientHello, serverHello, cert, serverECDHParams, sig)
***REMOVED***

func (ka *ecdheKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) ***REMOVED***
	if ka.curve == nil ***REMOVED***
		return nil, nil, errors.New("missing ServerKeyExchange message")
	***REMOVED***

	publicKey, preMasterSecret, err := ka.curve.accept(config.rand(), ka.peerKey)
	if err != nil ***REMOVED***
		return nil, nil, err
	***REMOVED***

	ckx := new(clientKeyExchangeMsg)
	ckx.ciphertext = make([]byte, 1+len(publicKey))
	ckx.ciphertext[0] = byte(len(publicKey))
	copy(ckx.ciphertext[1:], publicKey)
	if config.Bugs.InvalidECDHPoint ***REMOVED***
		ckx.ciphertext[1] ^= 0xff
	***REMOVED***

	return preMasterSecret, ckx, nil
***REMOVED***

func (ka *ecdheKeyAgreement) peerSignatureAlgorithm() signatureAlgorithm ***REMOVED***
	if auth, ok := ka.auth.(*signedKeyAgreement); ok ***REMOVED***
		return auth.peerSignatureAlgorithm
	***REMOVED***
	return 0
***REMOVED***

// dheRSAKeyAgreement implements a TLS key agreement where the server generates
// an ephemeral Diffie-Hellman public/private key pair and signs it. The
// pre-master secret is then calculated using Diffie-Hellman.
type dheKeyAgreement struct ***REMOVED***
	auth    keyAgreementAuthentication
	p, g    *big.Int
	yTheirs *big.Int
	xOurs   *big.Int
***REMOVED***

func (ka *dheKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) ***REMOVED***
	var q *big.Int
	if p := config.Bugs.DHGroupPrime; p != nil ***REMOVED***
		ka.p = p
		ka.g = big.NewInt(2)
		q = p
	***REMOVED*** else ***REMOVED***
		// 2048-bit MODP Group with 256-bit Prime Order Subgroup (RFC
		// 5114, Section 2.3)
		ka.p, _ = new(big.Int).SetString("87A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F25D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA3016C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0EF13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D967E144E5140564251CCACB83E6B486F6B3CA3F7971506026C0B857F689962856DED4010ABD0BE621C3A3960A54E710C375F26375D7014103A4B54330C198AF126116D2276E11715F693877FAD7EF09CADB094AE91E1A1597", 16)
		ka.g, _ = new(big.Int).SetString("3FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF205407F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC831D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6184B523D1DB246C32F63078490F00EF8D647D148D47954515E2327CFEF98C582664B4C0F6CC41659", 16)
		q, _ = new(big.Int).SetString("8CF83642A709A097B447997640129DA299B1A47D1EB3750BA308B0FE64F5FBD3", 16)
	***REMOVED***

	var err error
	ka.xOurs, err = rand.Int(config.rand(), q)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	yOurs := new(big.Int).Exp(ka.g, ka.xOurs, ka.p)

	// http://tools.ietf.org/html/rfc5246#section-7.4.3
	pBytes := ka.p.Bytes()
	gBytes := ka.g.Bytes()
	yBytes := yOurs.Bytes()
	serverDHParams := make([]byte, 0, 2+len(pBytes)+2+len(gBytes)+2+len(yBytes))
	serverDHParams = append(serverDHParams, byte(len(pBytes)>>8), byte(len(pBytes)))
	serverDHParams = append(serverDHParams, pBytes...)
	serverDHParams = append(serverDHParams, byte(len(gBytes)>>8), byte(len(gBytes)))
	serverDHParams = append(serverDHParams, gBytes...)
	serverDHParams = append(serverDHParams, byte(len(yBytes)>>8), byte(len(yBytes)))
	serverDHParams = append(serverDHParams, yBytes...)

	return ka.auth.signParameters(config, cert, clientHello, hello, serverDHParams)
***REMOVED***

func (ka *dheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) ***REMOVED***
	if len(ckx.ciphertext) < 2 ***REMOVED***
		return nil, errClientKeyExchange
	***REMOVED***
	yLen := (int(ckx.ciphertext[0]) << 8) | int(ckx.ciphertext[1])
	if yLen != len(ckx.ciphertext)-2 ***REMOVED***
		return nil, errClientKeyExchange
	***REMOVED***
	yTheirs := new(big.Int).SetBytes(ckx.ciphertext[2:])
	if yTheirs.Sign() <= 0 || yTheirs.Cmp(ka.p) >= 0 ***REMOVED***
		return nil, errClientKeyExchange
	***REMOVED***
	return new(big.Int).Exp(yTheirs, ka.xOurs, ka.p).Bytes(), nil
***REMOVED***

func (ka *dheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error ***REMOVED***
	// Read dh_p
	k := skx.key
	if len(k) < 2 ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	pLen := (int(k[0]) << 8) | int(k[1])
	k = k[2:]
	if len(k) < pLen ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	ka.p = new(big.Int).SetBytes(k[:pLen])
	k = k[pLen:]

	// Read dh_g
	if len(k) < 2 ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	gLen := (int(k[0]) << 8) | int(k[1])
	k = k[2:]
	if len(k) < gLen ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	ka.g = new(big.Int).SetBytes(k[:gLen])
	k = k[gLen:]

	// Read dh_Ys
	if len(k) < 2 ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	yLen := (int(k[0]) << 8) | int(k[1])
	k = k[2:]
	if len(k) < yLen ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	ka.yTheirs = new(big.Int).SetBytes(k[:yLen])
	k = k[yLen:]
	if ka.yTheirs.Sign() <= 0 || ka.yTheirs.Cmp(ka.p) >= 0 ***REMOVED***
		return errServerKeyExchange
	***REMOVED***

	if l := config.Bugs.RequireDHPublicValueLen; l != 0 && l != yLen ***REMOVED***
		return fmt.Errorf("RequireDHPublicValueLen set to %d, but server's public value was %d bytes on the wire and %d bytes if minimal", l, yLen, (ka.yTheirs.BitLen()+7)/8)
	***REMOVED***

	sig := k
	serverDHParams := skx.key[:len(skx.key)-len(sig)]

	return ka.auth.verifyParameters(config, clientHello, serverHello, cert, serverDHParams, sig)
***REMOVED***

func (ka *dheKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) ***REMOVED***
	if ka.p == nil || ka.g == nil || ka.yTheirs == nil ***REMOVED***
		return nil, nil, errors.New("missing ServerKeyExchange message")
	***REMOVED***

	xOurs, err := rand.Int(config.rand(), ka.p)
	if err != nil ***REMOVED***
		return nil, nil, err
	***REMOVED***
	preMasterSecret := new(big.Int).Exp(ka.yTheirs, xOurs, ka.p).Bytes()

	yOurs := new(big.Int).Exp(ka.g, xOurs, ka.p)
	yBytes := yOurs.Bytes()
	ckx := new(clientKeyExchangeMsg)
	ckx.ciphertext = make([]byte, 2+len(yBytes))
	ckx.ciphertext[0] = byte(len(yBytes) >> 8)
	ckx.ciphertext[1] = byte(len(yBytes))
	copy(ckx.ciphertext[2:], yBytes)

	return preMasterSecret, ckx, nil
***REMOVED***

func (ka *dheKeyAgreement) peerSignatureAlgorithm() signatureAlgorithm ***REMOVED***
	if auth, ok := ka.auth.(*signedKeyAgreement); ok ***REMOVED***
		return auth.peerSignatureAlgorithm
	***REMOVED***
	return 0
***REMOVED***

// nilKeyAgreement is a fake key agreement used to implement the plain PSK key
// exchange.
type nilKeyAgreement struct***REMOVED******REMOVED***

func (ka *nilKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) ***REMOVED***
	return nil, nil
***REMOVED***

func (ka *nilKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) ***REMOVED***
	if len(ckx.ciphertext) != 0 ***REMOVED***
		return nil, errClientKeyExchange
	***REMOVED***

	// Although in plain PSK, otherSecret is all zeros, the base key
	// agreement does not access to the length of the pre-shared
	// key. pskKeyAgreement instead interprets nil to mean to use all zeros
	// of the appropriate length.
	return nil, nil
***REMOVED***

func (ka *nilKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error ***REMOVED***
	if len(skx.key) != 0 ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	return nil
***REMOVED***

func (ka *nilKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) ***REMOVED***
	// Although in plain PSK, otherSecret is all zeros, the base key
	// agreement does not access to the length of the pre-shared
	// key. pskKeyAgreement instead interprets nil to mean to use all zeros
	// of the appropriate length.
	return nil, &clientKeyExchangeMsg***REMOVED******REMOVED***, nil
***REMOVED***

func (ka *nilKeyAgreement) peerSignatureAlgorithm() signatureAlgorithm ***REMOVED***
	return 0
***REMOVED***

// makePSKPremaster formats a PSK pre-master secret based on otherSecret from
// the base key exchange and psk.
func makePSKPremaster(otherSecret, psk []byte) []byte ***REMOVED***
	out := make([]byte, 0, 2+len(otherSecret)+2+len(psk))
	out = append(out, byte(len(otherSecret)>>8), byte(len(otherSecret)))
	out = append(out, otherSecret...)
	out = append(out, byte(len(psk)>>8), byte(len(psk)))
	out = append(out, psk...)
	return out
***REMOVED***

// pskKeyAgreement implements the PSK key agreement.
type pskKeyAgreement struct ***REMOVED***
	base         keyAgreement
	identityHint string
***REMOVED***

func (ka *pskKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) ***REMOVED***
	// Assemble the identity hint.
	bytes := make([]byte, 2+len(config.PreSharedKeyIdentity))
	bytes[0] = byte(len(config.PreSharedKeyIdentity) >> 8)
	bytes[1] = byte(len(config.PreSharedKeyIdentity))
	copy(bytes[2:], []byte(config.PreSharedKeyIdentity))

	// If there is one, append the base key agreement's
	// ServerKeyExchange.
	baseSkx, err := ka.base.generateServerKeyExchange(config, cert, clientHello, hello)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	if baseSkx != nil ***REMOVED***
		bytes = append(bytes, baseSkx.key...)
	***REMOVED*** else if config.PreSharedKeyIdentity == "" && !config.Bugs.AlwaysSendPreSharedKeyIdentityHint ***REMOVED***
		// ServerKeyExchange is optional if the identity hint is empty
		// and there would otherwise be no ServerKeyExchange.
		return nil, nil
	***REMOVED***

	skx := new(serverKeyExchangeMsg)
	skx.key = bytes
	return skx, nil
***REMOVED***

func (ka *pskKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) ***REMOVED***
	// First, process the PSK identity.
	if len(ckx.ciphertext) < 2 ***REMOVED***
		return nil, errClientKeyExchange
	***REMOVED***
	identityLen := (int(ckx.ciphertext[0]) << 8) | int(ckx.ciphertext[1])
	if 2+identityLen > len(ckx.ciphertext) ***REMOVED***
		return nil, errClientKeyExchange
	***REMOVED***
	identity := string(ckx.ciphertext[2 : 2+identityLen])

	if identity != config.PreSharedKeyIdentity ***REMOVED***
		return nil, errors.New("tls: unexpected identity")
	***REMOVED***

	if config.PreSharedKey == nil ***REMOVED***
		return nil, errors.New("tls: pre-shared key not configured")
	***REMOVED***

	// Process the remainder of the ClientKeyExchange to compute the base
	// pre-master secret.
	newCkx := new(clientKeyExchangeMsg)
	newCkx.ciphertext = ckx.ciphertext[2+identityLen:]
	otherSecret, err := ka.base.processClientKeyExchange(config, cert, newCkx, version)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	if otherSecret == nil ***REMOVED***
		// Special-case for the plain PSK key exchanges.
		otherSecret = make([]byte, len(config.PreSharedKey))
	***REMOVED***
	return makePSKPremaster(otherSecret, config.PreSharedKey), nil
***REMOVED***

func (ka *pskKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error ***REMOVED***
	if len(skx.key) < 2 ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	identityLen := (int(skx.key[0]) << 8) | int(skx.key[1])
	if 2+identityLen > len(skx.key) ***REMOVED***
		return errServerKeyExchange
	***REMOVED***
	ka.identityHint = string(skx.key[2 : 2+identityLen])

	// Process the remainder of the ServerKeyExchange.
	newSkx := new(serverKeyExchangeMsg)
	newSkx.key = skx.key[2+identityLen:]
	return ka.base.processServerKeyExchange(config, clientHello, serverHello, cert, newSkx)
***REMOVED***

func (ka *pskKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) ***REMOVED***
	// The server only sends an identity hint but, for purposes of
	// test code, the server always sends the hint and it is
	// required to match.
	if ka.identityHint != config.PreSharedKeyIdentity ***REMOVED***
		return nil, nil, errors.New("tls: unexpected identity")
	***REMOVED***

	// Serialize the identity.
	bytes := make([]byte, 2+len(config.PreSharedKeyIdentity))
	bytes[0] = byte(len(config.PreSharedKeyIdentity) >> 8)
	bytes[1] = byte(len(config.PreSharedKeyIdentity))
	copy(bytes[2:], []byte(config.PreSharedKeyIdentity))

	// Append the base key exchange's ClientKeyExchange.
	otherSecret, baseCkx, err := ka.base.generateClientKeyExchange(config, clientHello, cert)
	if err != nil ***REMOVED***
		return nil, nil, err
	***REMOVED***
	ckx := new(clientKeyExchangeMsg)
	ckx.ciphertext = append(bytes, baseCkx.ciphertext...)

	if config.PreSharedKey == nil ***REMOVED***
		return nil, nil, errors.New("tls: pre-shared key not configured")
	***REMOVED***
	if otherSecret == nil ***REMOVED***
		otherSecret = make([]byte, len(config.PreSharedKey))
	***REMOVED***
	return makePSKPremaster(otherSecret, config.PreSharedKey), ckx, nil
***REMOVED***

func (ka *pskKeyAgreement) peerSignatureAlgorithm() signatureAlgorithm ***REMOVED***
	return 0
***REMOVED***
