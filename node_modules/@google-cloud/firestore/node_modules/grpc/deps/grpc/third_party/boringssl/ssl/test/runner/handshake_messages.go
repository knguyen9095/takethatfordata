// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runner

import (
	"bytes"
	"encoding/binary"
)

func writeLen(buf []byte, v, size int) ***REMOVED***
	for i := 0; i < size; i++ ***REMOVED***
		buf[size-i-1] = byte(v)
		v >>= 8
	***REMOVED***
	if v != 0 ***REMOVED***
		panic("length is too long")
	***REMOVED***
***REMOVED***

type byteBuilder struct ***REMOVED***
	buf       *[]byte
	start     int
	prefixLen int
	child     *byteBuilder
***REMOVED***

func newByteBuilder() *byteBuilder ***REMOVED***
	buf := make([]byte, 0, 32)
	return &byteBuilder***REMOVED***buf: &buf***REMOVED***
***REMOVED***

func (bb *byteBuilder) len() int ***REMOVED***
	return len(*bb.buf) - bb.start - bb.prefixLen
***REMOVED***

func (bb *byteBuilder) flush() ***REMOVED***
	if bb.child == nil ***REMOVED***
		return
	***REMOVED***
	bb.child.flush()
	writeLen((*bb.buf)[bb.child.start:], bb.child.len(), bb.child.prefixLen)
	bb.child = nil
	return
***REMOVED***

func (bb *byteBuilder) finish() []byte ***REMOVED***
	bb.flush()
	return *bb.buf
***REMOVED***

func (bb *byteBuilder) addU8(u uint8) ***REMOVED***
	bb.flush()
	*bb.buf = append(*bb.buf, u)
***REMOVED***

func (bb *byteBuilder) addU16(u uint16) ***REMOVED***
	bb.flush()
	*bb.buf = append(*bb.buf, byte(u>>8), byte(u))
***REMOVED***

func (bb *byteBuilder) addU24(u int) ***REMOVED***
	bb.flush()
	*bb.buf = append(*bb.buf, byte(u>>16), byte(u>>8), byte(u))
***REMOVED***

func (bb *byteBuilder) addU32(u uint32) ***REMOVED***
	bb.flush()
	*bb.buf = append(*bb.buf, byte(u>>24), byte(u>>16), byte(u>>8), byte(u))
***REMOVED***

func (bb *byteBuilder) addU64(u uint64) ***REMOVED***
	bb.flush()
	var b [8]byte
	binary.BigEndian.PutUint64(b[:], u)
	*bb.buf = append(*bb.buf, b[:]...)
***REMOVED***

func (bb *byteBuilder) addU8LengthPrefixed() *byteBuilder ***REMOVED***
	return bb.createChild(1)
***REMOVED***

func (bb *byteBuilder) addU16LengthPrefixed() *byteBuilder ***REMOVED***
	return bb.createChild(2)
***REMOVED***

func (bb *byteBuilder) addU24LengthPrefixed() *byteBuilder ***REMOVED***
	return bb.createChild(3)
***REMOVED***

func (bb *byteBuilder) addU32LengthPrefixed() *byteBuilder ***REMOVED***
	return bb.createChild(4)
***REMOVED***

func (bb *byteBuilder) addBytes(b []byte) ***REMOVED***
	bb.flush()
	*bb.buf = append(*bb.buf, b...)
***REMOVED***

func (bb *byteBuilder) createChild(lengthPrefixSize int) *byteBuilder ***REMOVED***
	bb.flush()
	bb.child = &byteBuilder***REMOVED***
		buf:       bb.buf,
		start:     len(*bb.buf),
		prefixLen: lengthPrefixSize,
	***REMOVED***
	for i := 0; i < lengthPrefixSize; i++ ***REMOVED***
		*bb.buf = append(*bb.buf, 0)
	***REMOVED***
	return bb.child
***REMOVED***

func (bb *byteBuilder) discardChild() ***REMOVED***
	if bb.child != nil ***REMOVED***
		return
	***REMOVED***
	bb.child = nil
	*bb.buf = (*bb.buf)[:bb.start]
***REMOVED***

type keyShareEntry struct ***REMOVED***
	group       CurveID
	keyExchange []byte
***REMOVED***

type pskIdentity struct ***REMOVED***
	ticket              []uint8
	obfuscatedTicketAge uint32
***REMOVED***

type clientHelloMsg struct ***REMOVED***
	raw                     []byte
	isDTLS                  bool
	vers                    uint16
	random                  []byte
	sessionId               []byte
	cookie                  []byte
	cipherSuites            []uint16
	compressionMethods      []uint8
	nextProtoNeg            bool
	serverName              string
	ocspStapling            bool
	supportedCurves         []CurveID
	supportedPoints         []uint8
	hasKeyShares            bool
	keyShares               []keyShareEntry
	trailingKeyShareData    bool
	pskIdentities           []pskIdentity
	pskKEModes              []byte
	pskBinders              [][]uint8
	hasEarlyData            bool
	tls13Cookie             []byte
	ticketSupported         bool
	sessionTicket           []uint8
	signatureAlgorithms     []signatureAlgorithm
	supportedVersions       []uint16
	secureRenegotiation     []byte
	alpnProtocols           []string
	duplicateExtension      bool
	channelIDSupported      bool
	npnAfterAlpn            bool
	extendedMasterSecret    bool
	srtpProtectionProfiles  []uint16
	srtpMasterKeyIdentifier string
	sctListSupported        bool
	customExtension         string
	hasGREASEExtension      bool
	pskBinderFirst          bool
	shortHeaderSupported    bool
***REMOVED***

func (m *clientHelloMsg) equal(i interface***REMOVED******REMOVED***) bool ***REMOVED***
	m1, ok := i.(*clientHelloMsg)
	if !ok ***REMOVED***
		return false
	***REMOVED***

	return bytes.Equal(m.raw, m1.raw) &&
		m.isDTLS == m1.isDTLS &&
		m.vers == m1.vers &&
		bytes.Equal(m.random, m1.random) &&
		bytes.Equal(m.sessionId, m1.sessionId) &&
		bytes.Equal(m.cookie, m1.cookie) &&
		eqUint16s(m.cipherSuites, m1.cipherSuites) &&
		bytes.Equal(m.compressionMethods, m1.compressionMethods) &&
		m.nextProtoNeg == m1.nextProtoNeg &&
		m.serverName == m1.serverName &&
		m.ocspStapling == m1.ocspStapling &&
		eqCurveIDs(m.supportedCurves, m1.supportedCurves) &&
		bytes.Equal(m.supportedPoints, m1.supportedPoints) &&
		m.hasKeyShares == m1.hasKeyShares &&
		eqKeyShareEntryLists(m.keyShares, m1.keyShares) &&
		m.trailingKeyShareData == m1.trailingKeyShareData &&
		eqPSKIdentityLists(m.pskIdentities, m1.pskIdentities) &&
		bytes.Equal(m.pskKEModes, m1.pskKEModes) &&
		eqByteSlices(m.pskBinders, m1.pskBinders) &&
		m.hasEarlyData == m1.hasEarlyData &&
		bytes.Equal(m.tls13Cookie, m1.tls13Cookie) &&
		m.ticketSupported == m1.ticketSupported &&
		bytes.Equal(m.sessionTicket, m1.sessionTicket) &&
		eqSignatureAlgorithms(m.signatureAlgorithms, m1.signatureAlgorithms) &&
		eqUint16s(m.supportedVersions, m1.supportedVersions) &&
		bytes.Equal(m.secureRenegotiation, m1.secureRenegotiation) &&
		(m.secureRenegotiation == nil) == (m1.secureRenegotiation == nil) &&
		eqStrings(m.alpnProtocols, m1.alpnProtocols) &&
		m.duplicateExtension == m1.duplicateExtension &&
		m.channelIDSupported == m1.channelIDSupported &&
		m.npnAfterAlpn == m1.npnAfterAlpn &&
		m.extendedMasterSecret == m1.extendedMasterSecret &&
		eqUint16s(m.srtpProtectionProfiles, m1.srtpProtectionProfiles) &&
		m.srtpMasterKeyIdentifier == m1.srtpMasterKeyIdentifier &&
		m.sctListSupported == m1.sctListSupported &&
		m.customExtension == m1.customExtension &&
		m.hasGREASEExtension == m1.hasGREASEExtension &&
		m.pskBinderFirst == m1.pskBinderFirst &&
		m.shortHeaderSupported == m1.shortHeaderSupported
***REMOVED***

func (m *clientHelloMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	handshakeMsg := newByteBuilder()
	handshakeMsg.addU8(typeClientHello)
	hello := handshakeMsg.addU24LengthPrefixed()
	hello.addU16(m.vers)
	hello.addBytes(m.random)
	sessionId := hello.addU8LengthPrefixed()
	sessionId.addBytes(m.sessionId)
	if m.isDTLS ***REMOVED***
		cookie := hello.addU8LengthPrefixed()
		cookie.addBytes(m.cookie)
	***REMOVED***
	cipherSuites := hello.addU16LengthPrefixed()
	for _, suite := range m.cipherSuites ***REMOVED***
		cipherSuites.addU16(suite)
	***REMOVED***
	compressionMethods := hello.addU8LengthPrefixed()
	compressionMethods.addBytes(m.compressionMethods)

	extensions := hello.addU16LengthPrefixed()
	if len(m.pskIdentities) > 0 && m.pskBinderFirst ***REMOVED***
		extensions.addU16(extensionPreSharedKey)
		pskExtension := extensions.addU16LengthPrefixed()

		pskIdentities := pskExtension.addU16LengthPrefixed()
		for _, psk := range m.pskIdentities ***REMOVED***
			pskIdentities.addU16LengthPrefixed().addBytes(psk.ticket)
			pskIdentities.addU32(psk.obfuscatedTicketAge)
		***REMOVED***
		pskBinders := pskExtension.addU16LengthPrefixed()
		for _, binder := range m.pskBinders ***REMOVED***
			pskBinders.addU8LengthPrefixed().addBytes(binder)
		***REMOVED***
	***REMOVED***
	if m.duplicateExtension ***REMOVED***
		// Add a duplicate bogus extension at the beginning and end.
		extensions.addU16(0xffff)
		extensions.addU16(0) // 0-length for empty extension
	***REMOVED***
	if m.nextProtoNeg && !m.npnAfterAlpn ***REMOVED***
		extensions.addU16(extensionNextProtoNeg)
		extensions.addU16(0) // The length is always 0
	***REMOVED***
	if len(m.serverName) > 0 ***REMOVED***
		extensions.addU16(extensionServerName)
		serverNameList := extensions.addU16LengthPrefixed()

		// RFC 3546, section 3.1
		//
		// struct ***REMOVED***
		//     NameType name_type;
		//     select (name_type) ***REMOVED***
		//         case host_name: HostName;
		//     ***REMOVED*** name;
		// ***REMOVED*** ServerName;
		//
		// enum ***REMOVED***
		//     host_name(0), (255)
		// ***REMOVED*** NameType;
		//
		// opaque HostName<1..2^16-1>;
		//
		// struct ***REMOVED***
		//     ServerName server_name_list<1..2^16-1>
		// ***REMOVED*** ServerNameList;

		serverName := serverNameList.addU16LengthPrefixed()
		serverName.addU8(0) // NameType host_name(0)
		hostName := serverName.addU16LengthPrefixed()
		hostName.addBytes([]byte(m.serverName))
	***REMOVED***
	if m.ocspStapling ***REMOVED***
		extensions.addU16(extensionStatusRequest)
		certificateStatusRequest := extensions.addU16LengthPrefixed()

		// RFC 4366, section 3.6
		certificateStatusRequest.addU8(1) // OCSP type
		// Two zero valued uint16s for the two lengths.
		certificateStatusRequest.addU16(0) // ResponderID length
		certificateStatusRequest.addU16(0) // Extensions length
	***REMOVED***
	if len(m.supportedCurves) > 0 ***REMOVED***
		// http://tools.ietf.org/html/rfc4492#section-5.1.1
		extensions.addU16(extensionSupportedCurves)
		supportedCurvesList := extensions.addU16LengthPrefixed()
		supportedCurves := supportedCurvesList.addU16LengthPrefixed()
		for _, curve := range m.supportedCurves ***REMOVED***
			supportedCurves.addU16(uint16(curve))
		***REMOVED***
	***REMOVED***
	if len(m.supportedPoints) > 0 ***REMOVED***
		// http://tools.ietf.org/html/rfc4492#section-5.1.2
		extensions.addU16(extensionSupportedPoints)
		supportedPointsList := extensions.addU16LengthPrefixed()
		supportedPoints := supportedPointsList.addU8LengthPrefixed()
		supportedPoints.addBytes(m.supportedPoints)
	***REMOVED***
	if m.hasKeyShares ***REMOVED***
		extensions.addU16(extensionKeyShare)
		keyShareList := extensions.addU16LengthPrefixed()

		keyShares := keyShareList.addU16LengthPrefixed()
		for _, keyShare := range m.keyShares ***REMOVED***
			keyShares.addU16(uint16(keyShare.group))
			keyExchange := keyShares.addU16LengthPrefixed()
			keyExchange.addBytes(keyShare.keyExchange)
		***REMOVED***

		if m.trailingKeyShareData ***REMOVED***
			keyShares.addU8(0)
		***REMOVED***
	***REMOVED***
	if len(m.pskKEModes) > 0 ***REMOVED***
		extensions.addU16(extensionPSKKeyExchangeModes)
		pskModesExtension := extensions.addU16LengthPrefixed()
		pskModesExtension.addU8LengthPrefixed().addBytes(m.pskKEModes)
	***REMOVED***
	if m.hasEarlyData ***REMOVED***
		extensions.addU16(extensionEarlyData)
		extensions.addU16(0) // The length is zero.
	***REMOVED***
	if len(m.tls13Cookie) > 0 ***REMOVED***
		extensions.addU16(extensionCookie)
		body := extensions.addU16LengthPrefixed()
		body.addU16LengthPrefixed().addBytes(m.tls13Cookie)
	***REMOVED***
	if m.ticketSupported ***REMOVED***
		// http://tools.ietf.org/html/rfc5077#section-3.2
		extensions.addU16(extensionSessionTicket)
		sessionTicketExtension := extensions.addU16LengthPrefixed()
		sessionTicketExtension.addBytes(m.sessionTicket)
	***REMOVED***
	if len(m.signatureAlgorithms) > 0 ***REMOVED***
		// https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
		extensions.addU16(extensionSignatureAlgorithms)
		signatureAlgorithmsExtension := extensions.addU16LengthPrefixed()
		signatureAlgorithms := signatureAlgorithmsExtension.addU16LengthPrefixed()
		for _, sigAlg := range m.signatureAlgorithms ***REMOVED***
			signatureAlgorithms.addU16(uint16(sigAlg))
		***REMOVED***
	***REMOVED***
	if len(m.supportedVersions) > 0 ***REMOVED***
		extensions.addU16(extensionSupportedVersions)
		supportedVersionsExtension := extensions.addU16LengthPrefixed()
		supportedVersions := supportedVersionsExtension.addU8LengthPrefixed()
		for _, version := range m.supportedVersions ***REMOVED***
			supportedVersions.addU16(uint16(version))
		***REMOVED***
	***REMOVED***
	if m.secureRenegotiation != nil ***REMOVED***
		extensions.addU16(extensionRenegotiationInfo)
		secureRenegoExt := extensions.addU16LengthPrefixed()
		secureRenego := secureRenegoExt.addU8LengthPrefixed()
		secureRenego.addBytes(m.secureRenegotiation)
	***REMOVED***
	if len(m.alpnProtocols) > 0 ***REMOVED***
		// https://tools.ietf.org/html/rfc7301#section-3.1
		extensions.addU16(extensionALPN)
		alpnExtension := extensions.addU16LengthPrefixed()

		protocolNameList := alpnExtension.addU16LengthPrefixed()
		for _, s := range m.alpnProtocols ***REMOVED***
			protocolName := protocolNameList.addU8LengthPrefixed()
			protocolName.addBytes([]byte(s))
		***REMOVED***
	***REMOVED***
	if m.channelIDSupported ***REMOVED***
		extensions.addU16(extensionChannelID)
		extensions.addU16(0) // Length is always 0
	***REMOVED***
	if m.nextProtoNeg && m.npnAfterAlpn ***REMOVED***
		extensions.addU16(extensionNextProtoNeg)
		extensions.addU16(0) // Length is always 0
	***REMOVED***
	if m.duplicateExtension ***REMOVED***
		// Add a duplicate bogus extension at the beginning and end.
		extensions.addU16(0xffff)
		extensions.addU16(0)
	***REMOVED***
	if m.extendedMasterSecret ***REMOVED***
		// https://tools.ietf.org/html/rfc7627
		extensions.addU16(extensionExtendedMasterSecret)
		extensions.addU16(0) // Length is always 0
	***REMOVED***
	if len(m.srtpProtectionProfiles) > 0 ***REMOVED***
		// https://tools.ietf.org/html/rfc5764#section-4.1.1
		extensions.addU16(extensionUseSRTP)
		useSrtpExt := extensions.addU16LengthPrefixed()

		srtpProtectionProfiles := useSrtpExt.addU16LengthPrefixed()
		for _, p := range m.srtpProtectionProfiles ***REMOVED***
			// An SRTPProtectionProfile is defined as uint8[2],
			// not uint16. For some reason, we're storing it
			// as a uint16.
			srtpProtectionProfiles.addU8(byte(p >> 8))
			srtpProtectionProfiles.addU8(byte(p))
		***REMOVED***
		srtpMki := useSrtpExt.addU8LengthPrefixed()
		srtpMki.addBytes([]byte(m.srtpMasterKeyIdentifier))
	***REMOVED***
	if m.sctListSupported ***REMOVED***
		extensions.addU16(extensionSignedCertificateTimestamp)
		extensions.addU16(0) // Length is always 0
	***REMOVED***
	if l := len(m.customExtension); l > 0 ***REMOVED***
		extensions.addU16(extensionCustom)
		customExt := extensions.addU16LengthPrefixed()
		customExt.addBytes([]byte(m.customExtension))
	***REMOVED***
	if m.shortHeaderSupported ***REMOVED***
		extensions.addU16(extensionShortHeader)
		extensions.addU16(0) // Length is always 0
	***REMOVED***
	// The PSK extension must be last (draft-ietf-tls-tls13-18 section 4.2.6).
	if len(m.pskIdentities) > 0 && !m.pskBinderFirst ***REMOVED***
		extensions.addU16(extensionPreSharedKey)
		pskExtension := extensions.addU16LengthPrefixed()

		pskIdentities := pskExtension.addU16LengthPrefixed()
		for _, psk := range m.pskIdentities ***REMOVED***
			pskIdentities.addU16LengthPrefixed().addBytes(psk.ticket)
			pskIdentities.addU32(psk.obfuscatedTicketAge)
		***REMOVED***
		pskBinders := pskExtension.addU16LengthPrefixed()
		for _, binder := range m.pskBinders ***REMOVED***
			pskBinders.addU8LengthPrefixed().addBytes(binder)
		***REMOVED***
	***REMOVED***

	if extensions.len() == 0 ***REMOVED***
		hello.discardChild()
	***REMOVED***

	m.raw = handshakeMsg.finish()
	return m.raw
***REMOVED***

func (m *clientHelloMsg) unmarshal(data []byte) bool ***REMOVED***
	if len(data) < 42 ***REMOVED***
		return false
	***REMOVED***
	m.raw = data
	m.vers = uint16(data[4])<<8 | uint16(data[5])
	m.random = data[6:38]
	sessionIdLen := int(data[38])
	if sessionIdLen > 32 || len(data) < 39+sessionIdLen ***REMOVED***
		return false
	***REMOVED***
	m.sessionId = data[39 : 39+sessionIdLen]
	data = data[39+sessionIdLen:]
	if m.isDTLS ***REMOVED***
		if len(data) < 1 ***REMOVED***
			return false
		***REMOVED***
		cookieLen := int(data[0])
		if cookieLen > 32 || len(data) < 1+cookieLen ***REMOVED***
			return false
		***REMOVED***
		m.cookie = data[1 : 1+cookieLen]
		data = data[1+cookieLen:]
	***REMOVED***
	if len(data) < 2 ***REMOVED***
		return false
	***REMOVED***
	// cipherSuiteLen is the number of bytes of cipher suite numbers. Since
	// they are uint16s, the number must be even.
	cipherSuiteLen := int(data[0])<<8 | int(data[1])
	if cipherSuiteLen%2 == 1 || len(data) < 2+cipherSuiteLen ***REMOVED***
		return false
	***REMOVED***
	numCipherSuites := cipherSuiteLen / 2
	m.cipherSuites = make([]uint16, numCipherSuites)
	for i := 0; i < numCipherSuites; i++ ***REMOVED***
		m.cipherSuites[i] = uint16(data[2+2*i])<<8 | uint16(data[3+2*i])
		if m.cipherSuites[i] == scsvRenegotiation ***REMOVED***
			m.secureRenegotiation = []byte***REMOVED******REMOVED***
		***REMOVED***
	***REMOVED***
	data = data[2+cipherSuiteLen:]
	if len(data) < 1 ***REMOVED***
		return false
	***REMOVED***
	compressionMethodsLen := int(data[0])
	if len(data) < 1+compressionMethodsLen ***REMOVED***
		return false
	***REMOVED***
	m.compressionMethods = data[1 : 1+compressionMethodsLen]

	data = data[1+compressionMethodsLen:]

	m.nextProtoNeg = false
	m.serverName = ""
	m.ocspStapling = false
	m.keyShares = nil
	m.pskIdentities = nil
	m.hasEarlyData = false
	m.ticketSupported = false
	m.sessionTicket = nil
	m.signatureAlgorithms = nil
	m.supportedVersions = nil
	m.alpnProtocols = nil
	m.extendedMasterSecret = false
	m.customExtension = ""

	if len(data) == 0 ***REMOVED***
		// ClientHello is optionally followed by extension data
		return true
	***REMOVED***
	if len(data) < 2 ***REMOVED***
		return false
	***REMOVED***

	extensionsLength := int(data[0])<<8 | int(data[1])
	data = data[2:]
	if extensionsLength != len(data) ***REMOVED***
		return false
	***REMOVED***

	for len(data) != 0 ***REMOVED***
		if len(data) < 4 ***REMOVED***
			return false
		***REMOVED***
		extension := uint16(data[0])<<8 | uint16(data[1])
		length := int(data[2])<<8 | int(data[3])
		data = data[4:]
		if len(data) < length ***REMOVED***
			return false
		***REMOVED***

		switch extension ***REMOVED***
		case extensionServerName:
			if length < 2 ***REMOVED***
				return false
			***REMOVED***
			numNames := int(data[0])<<8 | int(data[1])
			d := data[2:]
			for i := 0; i < numNames; i++ ***REMOVED***
				if len(d) < 3 ***REMOVED***
					return false
				***REMOVED***
				nameType := d[0]
				nameLen := int(d[1])<<8 | int(d[2])
				d = d[3:]
				if len(d) < nameLen ***REMOVED***
					return false
				***REMOVED***
				if nameType == 0 ***REMOVED***
					m.serverName = string(d[0:nameLen])
					break
				***REMOVED***
				d = d[nameLen:]
			***REMOVED***
		case extensionNextProtoNeg:
			if length > 0 ***REMOVED***
				return false
			***REMOVED***
			m.nextProtoNeg = true
		case extensionStatusRequest:
			m.ocspStapling = length > 0 && data[0] == statusTypeOCSP
		case extensionSupportedCurves:
			// http://tools.ietf.org/html/rfc4492#section-5.5.1
			if length < 2 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])<<8 | int(data[1])
			if l%2 == 1 || length != l+2 ***REMOVED***
				return false
			***REMOVED***
			numCurves := l / 2
			m.supportedCurves = make([]CurveID, numCurves)
			d := data[2:]
			for i := 0; i < numCurves; i++ ***REMOVED***
				m.supportedCurves[i] = CurveID(d[0])<<8 | CurveID(d[1])
				d = d[2:]
			***REMOVED***
		case extensionSupportedPoints:
			// http://tools.ietf.org/html/rfc4492#section-5.5.2
			if length < 1 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])
			if length != l+1 ***REMOVED***
				return false
			***REMOVED***
			m.supportedPoints = data[1 : 1+l]
		case extensionSessionTicket:
			// http://tools.ietf.org/html/rfc5077#section-3.2
			m.ticketSupported = true
			m.sessionTicket = data[:length]
		case extensionKeyShare:
			// draft-ietf-tls-tls13 section 6.3.2.3
			if length < 2 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])<<8 | int(data[1])
			if l != length-2 ***REMOVED***
				return false
			***REMOVED***
			d := data[2:length]
			m.hasKeyShares = true
			for len(d) > 0 ***REMOVED***
				// The next KeyShareEntry contains a NamedGroup (2 bytes) and a
				// key_exchange (2-byte length prefix with at least 1 byte of content).
				if len(d) < 5 ***REMOVED***
					return false
				***REMOVED***
				entry := keyShareEntry***REMOVED******REMOVED***
				entry.group = CurveID(d[0])<<8 | CurveID(d[1])
				keyExchLen := int(d[2])<<8 | int(d[3])
				d = d[4:]
				if len(d) < keyExchLen ***REMOVED***
					return false
				***REMOVED***
				entry.keyExchange = d[:keyExchLen]
				d = d[keyExchLen:]
				m.keyShares = append(m.keyShares, entry)
			***REMOVED***
		case extensionPreSharedKey:
			// draft-ietf-tls-tls13-18 section 4.2.6
			if length < 2 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])<<8 | int(data[1])
			d := data[2 : l+2]
			// Parse PSK identities.
			for len(d) > 0 ***REMOVED***
				if len(d) < 2 ***REMOVED***
					return false
				***REMOVED***
				pskLen := int(d[0])<<8 | int(d[1])
				d = d[2:]

				if len(d) < pskLen+4 ***REMOVED***
					return false
				***REMOVED***
				ticket := d[:pskLen]
				obfuscatedTicketAge := uint32(d[pskLen])<<24 | uint32(d[pskLen+1])<<16 | uint32(d[pskLen+2])<<8 | uint32(d[pskLen+3])
				psk := pskIdentity***REMOVED***
					ticket:              ticket,
					obfuscatedTicketAge: obfuscatedTicketAge,
				***REMOVED***
				m.pskIdentities = append(m.pskIdentities, psk)
				d = d[pskLen+4:]
			***REMOVED***
			d = data[l+2:]
			if len(d) < 2 ***REMOVED***
				return false
			***REMOVED***
			l = int(d[0])<<8 | int(d[1])
			d = d[2:]
			if l != len(d) ***REMOVED***
				return false
			***REMOVED***
			// Parse PSK binders.
			for len(d) > 0 ***REMOVED***
				if len(d) < 1 ***REMOVED***
					return false
				***REMOVED***
				binderLen := int(d[0])
				d = d[1:]
				if binderLen > len(d) ***REMOVED***
					return false
				***REMOVED***
				m.pskBinders = append(m.pskBinders, d[:binderLen])
				d = d[binderLen:]
			***REMOVED***

			// There must be the same number of identities as binders.
			if len(m.pskIdentities) != len(m.pskBinders) ***REMOVED***
				return false
			***REMOVED***
		case extensionPSKKeyExchangeModes:
			// draft-ietf-tls-tls13-18 section 4.2.7
			if length < 1 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])
			if l != length-1 ***REMOVED***
				return false
			***REMOVED***
			m.pskKEModes = data[1:length]
		case extensionEarlyData:
			// draft-ietf-tls-tls13 section 6.3.2.5
			if length != 0 ***REMOVED***
				return false
			***REMOVED***
			m.hasEarlyData = true
		case extensionCookie:
			if length < 2 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])<<8 | int(data[1])
			if l != length-2 || l == 0 ***REMOVED***
				return false
			***REMOVED***
			m.tls13Cookie = data[2 : 2+l]
		case extensionSignatureAlgorithms:
			// https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
			if length < 2 || length&1 != 0 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])<<8 | int(data[1])
			if l != length-2 ***REMOVED***
				return false
			***REMOVED***
			n := l / 2
			d := data[2:]
			m.signatureAlgorithms = make([]signatureAlgorithm, n)
			for i := range m.signatureAlgorithms ***REMOVED***
				m.signatureAlgorithms[i] = signatureAlgorithm(d[0])<<8 | signatureAlgorithm(d[1])
				d = d[2:]
			***REMOVED***
		case extensionSupportedVersions:
			if length < 1+2 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])
			if l != length-1 || l%2 == 1 || l < 2 ***REMOVED***
				return false
			***REMOVED***
			n := l / 2
			d := data[1:]
			m.supportedVersions = make([]uint16, n)
			for i := range m.supportedVersions ***REMOVED***
				m.supportedVersions[i] = uint16(d[0])<<8 | uint16(d[1])
				d = d[2:]
			***REMOVED***
		case extensionRenegotiationInfo:
			if length < 1 || length != int(data[0])+1 ***REMOVED***
				return false
			***REMOVED***
			m.secureRenegotiation = data[1:length]
		case extensionALPN:
			if length < 2 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])<<8 | int(data[1])
			if l != length-2 ***REMOVED***
				return false
			***REMOVED***
			d := data[2:length]
			for len(d) != 0 ***REMOVED***
				stringLen := int(d[0])
				d = d[1:]
				if stringLen == 0 || stringLen > len(d) ***REMOVED***
					return false
				***REMOVED***
				m.alpnProtocols = append(m.alpnProtocols, string(d[:stringLen]))
				d = d[stringLen:]
			***REMOVED***
		case extensionChannelID:
			if length > 0 ***REMOVED***
				return false
			***REMOVED***
			m.channelIDSupported = true
		case extensionExtendedMasterSecret:
			if length != 0 ***REMOVED***
				return false
			***REMOVED***
			m.extendedMasterSecret = true
		case extensionUseSRTP:
			if length < 2 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])<<8 | int(data[1])
			if l > length-2 || l%2 != 0 ***REMOVED***
				return false
			***REMOVED***
			n := l / 2
			m.srtpProtectionProfiles = make([]uint16, n)
			d := data[2:length]
			for i := 0; i < n; i++ ***REMOVED***
				m.srtpProtectionProfiles[i] = uint16(d[0])<<8 | uint16(d[1])
				d = d[2:]
			***REMOVED***
			if len(d) < 1 || int(d[0]) != len(d)-1 ***REMOVED***
				return false
			***REMOVED***
			m.srtpMasterKeyIdentifier = string(d[1:])
		case extensionSignedCertificateTimestamp:
			if length != 0 ***REMOVED***
				return false
			***REMOVED***
			m.sctListSupported = true
		case extensionShortHeader:
			if length != 0 ***REMOVED***
				return false
			***REMOVED***
			m.shortHeaderSupported = true
		case extensionCustom:
			m.customExtension = string(data[:length])
		***REMOVED***
		data = data[length:]

		if isGREASEValue(extension) ***REMOVED***
			m.hasGREASEExtension = true
		***REMOVED***
	***REMOVED***

	return true
***REMOVED***

type serverHelloMsg struct ***REMOVED***
	raw               []byte
	isDTLS            bool
	vers              uint16
	versOverride      uint16
	random            []byte
	sessionId         []byte
	cipherSuite       uint16
	hasKeyShare       bool
	keyShare          keyShareEntry
	hasPSKIdentity    bool
	pskIdentity       uint16
	compressionMethod uint8
	customExtension   string
	unencryptedALPN   string
	shortHeader       bool
	extensions        serverExtensions
***REMOVED***

func (m *serverHelloMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	handshakeMsg := newByteBuilder()
	handshakeMsg.addU8(typeServerHello)
	hello := handshakeMsg.addU24LengthPrefixed()

	// m.vers is used both to determine the format of the rest of the
	// ServerHello and to override the value, so include a second version
	// field.
	vers, ok := wireToVersion(m.vers, m.isDTLS)
	if !ok ***REMOVED***
		panic("unknown version")
	***REMOVED***
	if m.versOverride != 0 ***REMOVED***
		hello.addU16(m.versOverride)
	***REMOVED*** else ***REMOVED***
		hello.addU16(m.vers)
	***REMOVED***

	hello.addBytes(m.random)
	if vers < VersionTLS13 ***REMOVED***
		sessionId := hello.addU8LengthPrefixed()
		sessionId.addBytes(m.sessionId)
	***REMOVED***
	hello.addU16(m.cipherSuite)
	if vers < VersionTLS13 ***REMOVED***
		hello.addU8(m.compressionMethod)
	***REMOVED***

	extensions := hello.addU16LengthPrefixed()

	if m.shortHeader ***REMOVED***
		extensions.addU16(extensionShortHeader)
		extensions.addU16(0) // Length
	***REMOVED***

	if vers >= VersionTLS13 ***REMOVED***
		if m.hasKeyShare ***REMOVED***
			extensions.addU16(extensionKeyShare)
			keyShare := extensions.addU16LengthPrefixed()
			keyShare.addU16(uint16(m.keyShare.group))
			keyExchange := keyShare.addU16LengthPrefixed()
			keyExchange.addBytes(m.keyShare.keyExchange)
		***REMOVED***
		if m.hasPSKIdentity ***REMOVED***
			extensions.addU16(extensionPreSharedKey)
			extensions.addU16(2) // Length
			extensions.addU16(m.pskIdentity)
		***REMOVED***
		if len(m.customExtension) > 0 ***REMOVED***
			extensions.addU16(extensionCustom)
			customExt := extensions.addU16LengthPrefixed()
			customExt.addBytes([]byte(m.customExtension))
		***REMOVED***
		if len(m.unencryptedALPN) > 0 ***REMOVED***
			extensions.addU16(extensionALPN)
			extension := extensions.addU16LengthPrefixed()

			protocolNameList := extension.addU16LengthPrefixed()
			protocolName := protocolNameList.addU8LengthPrefixed()
			protocolName.addBytes([]byte(m.unencryptedALPN))
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		m.extensions.marshal(extensions)
		if extensions.len() == 0 ***REMOVED***
			hello.discardChild()
		***REMOVED***
	***REMOVED***

	m.raw = handshakeMsg.finish()
	return m.raw
***REMOVED***

func (m *serverHelloMsg) unmarshal(data []byte) bool ***REMOVED***
	if len(data) < 42 ***REMOVED***
		return false
	***REMOVED***
	m.raw = data
	m.vers = uint16(data[4])<<8 | uint16(data[5])
	vers, ok := wireToVersion(m.vers, m.isDTLS)
	if !ok ***REMOVED***
		return false
	***REMOVED***
	m.random = data[6:38]
	data = data[38:]
	if vers < VersionTLS13 ***REMOVED***
		sessionIdLen := int(data[0])
		if sessionIdLen > 32 || len(data) < 1+sessionIdLen ***REMOVED***
			return false
		***REMOVED***
		m.sessionId = data[1 : 1+sessionIdLen]
		data = data[1+sessionIdLen:]
	***REMOVED***
	if len(data) < 2 ***REMOVED***
		return false
	***REMOVED***
	m.cipherSuite = uint16(data[0])<<8 | uint16(data[1])
	data = data[2:]
	if vers < VersionTLS13 ***REMOVED***
		if len(data) < 1 ***REMOVED***
			return false
		***REMOVED***
		m.compressionMethod = data[0]
		data = data[1:]
	***REMOVED***

	if len(data) == 0 && m.vers < VersionTLS13 ***REMOVED***
		// Extension data is optional before TLS 1.3.
		m.extensions = serverExtensions***REMOVED******REMOVED***
		return true
	***REMOVED***
	if len(data) < 2 ***REMOVED***
		return false
	***REMOVED***

	extensionsLength := int(data[0])<<8 | int(data[1])
	data = data[2:]
	if len(data) != extensionsLength ***REMOVED***
		return false
	***REMOVED***

	if vers >= VersionTLS13 ***REMOVED***
		for len(data) != 0 ***REMOVED***
			if len(data) < 4 ***REMOVED***
				return false
			***REMOVED***
			extension := uint16(data[0])<<8 | uint16(data[1])
			length := int(data[2])<<8 | int(data[3])
			data = data[4:]

			if len(data) < length ***REMOVED***
				return false
			***REMOVED***
			d := data[:length]
			data = data[length:]

			switch extension ***REMOVED***
			case extensionKeyShare:
				m.hasKeyShare = true
				if len(d) < 4 ***REMOVED***
					return false
				***REMOVED***
				m.keyShare.group = CurveID(uint16(d[0])<<8 | uint16(d[1]))
				keyExchLen := int(d[2])<<8 | int(d[3])
				if keyExchLen != len(d)-4 ***REMOVED***
					return false
				***REMOVED***
				m.keyShare.keyExchange = make([]byte, keyExchLen)
				copy(m.keyShare.keyExchange, d[4:])
			case extensionPreSharedKey:
				if len(d) != 2 ***REMOVED***
					return false
				***REMOVED***
				m.pskIdentity = uint16(d[0])<<8 | uint16(d[1])
				m.hasPSKIdentity = true
			case extensionShortHeader:
				if len(d) != 0 ***REMOVED***
					return false
				***REMOVED***
				m.shortHeader = true
			default:
				// Only allow the 3 extensions that are sent in
				// the clear in TLS 1.3.
				return false
			***REMOVED***
		***REMOVED***
	***REMOVED*** else if !m.extensions.unmarshal(data, vers) ***REMOVED***
		return false
	***REMOVED***

	return true
***REMOVED***

type encryptedExtensionsMsg struct ***REMOVED***
	raw        []byte
	extensions serverExtensions
	empty      bool
***REMOVED***

func (m *encryptedExtensionsMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	encryptedExtensionsMsg := newByteBuilder()
	encryptedExtensionsMsg.addU8(typeEncryptedExtensions)
	encryptedExtensions := encryptedExtensionsMsg.addU24LengthPrefixed()
	if !m.empty ***REMOVED***
		extensions := encryptedExtensions.addU16LengthPrefixed()
		m.extensions.marshal(extensions)
	***REMOVED***

	m.raw = encryptedExtensionsMsg.finish()
	return m.raw
***REMOVED***

func (m *encryptedExtensionsMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data
	if len(data) < 6 ***REMOVED***
		return false
	***REMOVED***
	if data[0] != typeEncryptedExtensions ***REMOVED***
		return false
	***REMOVED***
	msgLen := int(data[1])<<16 | int(data[2])<<8 | int(data[3])
	data = data[4:]
	if len(data) != msgLen ***REMOVED***
		return false
	***REMOVED***
	extLen := int(data[0])<<8 | int(data[1])
	data = data[2:]
	if extLen != len(data) ***REMOVED***
		return false
	***REMOVED***
	return m.extensions.unmarshal(data, VersionTLS13)
***REMOVED***

type serverExtensions struct ***REMOVED***
	nextProtoNeg            bool
	nextProtos              []string
	ocspStapling            bool
	ticketSupported         bool
	secureRenegotiation     []byte
	alpnProtocol            string
	alpnProtocolEmpty       bool
	duplicateExtension      bool
	channelIDRequested      bool
	extendedMasterSecret    bool
	srtpProtectionProfile   uint16
	srtpMasterKeyIdentifier string
	sctList                 []byte
	customExtension         string
	npnAfterAlpn            bool
	hasKeyShare             bool
	hasEarlyData            bool
	keyShare                keyShareEntry
	supportedPoints         []uint8
	serverNameAck           bool
***REMOVED***

func (m *serverExtensions) marshal(extensions *byteBuilder) ***REMOVED***
	if m.duplicateExtension ***REMOVED***
		// Add a duplicate bogus extension at the beginning and end.
		extensions.addU16(0xffff)
		extensions.addU16(0) // length = 0 for empty extension
	***REMOVED***
	if m.nextProtoNeg && !m.npnAfterAlpn ***REMOVED***
		extensions.addU16(extensionNextProtoNeg)
		extension := extensions.addU16LengthPrefixed()

		for _, v := range m.nextProtos ***REMOVED***
			if len(v) > 255 ***REMOVED***
				v = v[:255]
			***REMOVED***
			npn := extension.addU8LengthPrefixed()
			npn.addBytes([]byte(v))
		***REMOVED***
	***REMOVED***
	if m.ocspStapling ***REMOVED***
		extensions.addU16(extensionStatusRequest)
		extensions.addU16(0)
	***REMOVED***
	if m.ticketSupported ***REMOVED***
		extensions.addU16(extensionSessionTicket)
		extensions.addU16(0)
	***REMOVED***
	if m.secureRenegotiation != nil ***REMOVED***
		extensions.addU16(extensionRenegotiationInfo)
		extension := extensions.addU16LengthPrefixed()
		secureRenego := extension.addU8LengthPrefixed()
		secureRenego.addBytes(m.secureRenegotiation)
	***REMOVED***
	if len(m.alpnProtocol) > 0 || m.alpnProtocolEmpty ***REMOVED***
		extensions.addU16(extensionALPN)
		extension := extensions.addU16LengthPrefixed()

		protocolNameList := extension.addU16LengthPrefixed()
		protocolName := protocolNameList.addU8LengthPrefixed()
		protocolName.addBytes([]byte(m.alpnProtocol))
	***REMOVED***
	if m.channelIDRequested ***REMOVED***
		extensions.addU16(extensionChannelID)
		extensions.addU16(0)
	***REMOVED***
	if m.duplicateExtension ***REMOVED***
		// Add a duplicate bogus extension at the beginning and end.
		extensions.addU16(0xffff)
		extensions.addU16(0)
	***REMOVED***
	if m.extendedMasterSecret ***REMOVED***
		extensions.addU16(extensionExtendedMasterSecret)
		extensions.addU16(0)
	***REMOVED***
	if m.srtpProtectionProfile != 0 ***REMOVED***
		extensions.addU16(extensionUseSRTP)
		extension := extensions.addU16LengthPrefixed()

		srtpProtectionProfiles := extension.addU16LengthPrefixed()
		srtpProtectionProfiles.addU8(byte(m.srtpProtectionProfile >> 8))
		srtpProtectionProfiles.addU8(byte(m.srtpProtectionProfile))
		srtpMki := extension.addU8LengthPrefixed()
		srtpMki.addBytes([]byte(m.srtpMasterKeyIdentifier))
	***REMOVED***
	if m.sctList != nil ***REMOVED***
		extensions.addU16(extensionSignedCertificateTimestamp)
		extension := extensions.addU16LengthPrefixed()
		extension.addBytes(m.sctList)
	***REMOVED***
	if l := len(m.customExtension); l > 0 ***REMOVED***
		extensions.addU16(extensionCustom)
		customExt := extensions.addU16LengthPrefixed()
		customExt.addBytes([]byte(m.customExtension))
	***REMOVED***
	if m.nextProtoNeg && m.npnAfterAlpn ***REMOVED***
		extensions.addU16(extensionNextProtoNeg)
		extension := extensions.addU16LengthPrefixed()

		for _, v := range m.nextProtos ***REMOVED***
			if len(v) > 255 ***REMOVED***
				v = v[0:255]
			***REMOVED***
			npn := extension.addU8LengthPrefixed()
			npn.addBytes([]byte(v))
		***REMOVED***
	***REMOVED***
	if m.hasKeyShare ***REMOVED***
		extensions.addU16(extensionKeyShare)
		keyShare := extensions.addU16LengthPrefixed()
		keyShare.addU16(uint16(m.keyShare.group))
		keyExchange := keyShare.addU16LengthPrefixed()
		keyExchange.addBytes(m.keyShare.keyExchange)
	***REMOVED***
	if len(m.supportedPoints) > 0 ***REMOVED***
		// http://tools.ietf.org/html/rfc4492#section-5.1.2
		extensions.addU16(extensionSupportedPoints)
		supportedPointsList := extensions.addU16LengthPrefixed()
		supportedPoints := supportedPointsList.addU8LengthPrefixed()
		supportedPoints.addBytes(m.supportedPoints)
	***REMOVED***
	if m.hasEarlyData ***REMOVED***
		extensions.addU16(extensionEarlyData)
		extensions.addBytes([]byte***REMOVED***0, 0***REMOVED***)
	***REMOVED***
	if m.serverNameAck ***REMOVED***
		extensions.addU16(extensionServerName)
		extensions.addU16(0) // zero length
	***REMOVED***
***REMOVED***

func (m *serverExtensions) unmarshal(data []byte, version uint16) bool ***REMOVED***
	// Reset all fields.
	*m = serverExtensions***REMOVED******REMOVED***

	for len(data) != 0 ***REMOVED***
		if len(data) < 4 ***REMOVED***
			return false
		***REMOVED***
		extension := uint16(data[0])<<8 | uint16(data[1])
		length := int(data[2])<<8 | int(data[3])
		data = data[4:]
		if len(data) < length ***REMOVED***
			return false
		***REMOVED***

		switch extension ***REMOVED***
		case extensionNextProtoNeg:
			m.nextProtoNeg = true
			d := data[:length]
			for len(d) > 0 ***REMOVED***
				l := int(d[0])
				d = d[1:]
				if l == 0 || l > len(d) ***REMOVED***
					return false
				***REMOVED***
				m.nextProtos = append(m.nextProtos, string(d[:l]))
				d = d[l:]
			***REMOVED***
		case extensionStatusRequest:
			if length > 0 ***REMOVED***
				return false
			***REMOVED***
			m.ocspStapling = true
		case extensionSessionTicket:
			if length > 0 ***REMOVED***
				return false
			***REMOVED***
			m.ticketSupported = true
		case extensionRenegotiationInfo:
			if length < 1 || length != int(data[0])+1 ***REMOVED***
				return false
			***REMOVED***
			m.secureRenegotiation = data[1:length]
		case extensionALPN:
			d := data[:length]
			if len(d) < 3 ***REMOVED***
				return false
			***REMOVED***
			l := int(d[0])<<8 | int(d[1])
			if l != len(d)-2 ***REMOVED***
				return false
			***REMOVED***
			d = d[2:]
			l = int(d[0])
			if l != len(d)-1 ***REMOVED***
				return false
			***REMOVED***
			d = d[1:]
			m.alpnProtocol = string(d)
			m.alpnProtocolEmpty = len(d) == 0
		case extensionChannelID:
			if length > 0 ***REMOVED***
				return false
			***REMOVED***
			m.channelIDRequested = true
		case extensionExtendedMasterSecret:
			if length != 0 ***REMOVED***
				return false
			***REMOVED***
			m.extendedMasterSecret = true
		case extensionUseSRTP:
			if length < 2+2+1 ***REMOVED***
				return false
			***REMOVED***
			if data[0] != 0 || data[1] != 2 ***REMOVED***
				return false
			***REMOVED***
			m.srtpProtectionProfile = uint16(data[2])<<8 | uint16(data[3])
			d := data[4:length]
			l := int(d[0])
			if l != len(d)-1 ***REMOVED***
				return false
			***REMOVED***
			m.srtpMasterKeyIdentifier = string(d[1:])
		case extensionSignedCertificateTimestamp:
			m.sctList = data[:length]
		case extensionCustom:
			m.customExtension = string(data[:length])
		case extensionServerName:
			if length != 0 ***REMOVED***
				return false
			***REMOVED***
			m.serverNameAck = true
		case extensionSupportedPoints:
			// supported_points is illegal in TLS 1.3.
			if version >= VersionTLS13 ***REMOVED***
				return false
			***REMOVED***
			// http://tools.ietf.org/html/rfc4492#section-5.5.2
			if length < 1 ***REMOVED***
				return false
			***REMOVED***
			l := int(data[0])
			if length != l+1 ***REMOVED***
				return false
			***REMOVED***
			m.supportedPoints = data[1 : 1+l]
		case extensionSupportedCurves:
			// The server can only send supported_curves in TLS 1.3.
			if version < VersionTLS13 ***REMOVED***
				return false
			***REMOVED***
		case extensionEarlyData:
			if version < VersionTLS13 || length != 0 ***REMOVED***
				return false
			***REMOVED***
			m.hasEarlyData = true
		default:
			// Unknown extensions are illegal from the server.
			return false
		***REMOVED***
		data = data[length:]
	***REMOVED***

	return true
***REMOVED***

type helloRetryRequestMsg struct ***REMOVED***
	raw                 []byte
	vers                uint16
	hasSelectedGroup    bool
	selectedGroup       CurveID
	cookie              []byte
	customExtension     string
	duplicateExtensions bool
***REMOVED***

func (m *helloRetryRequestMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	retryRequestMsg := newByteBuilder()
	retryRequestMsg.addU8(typeHelloRetryRequest)
	retryRequest := retryRequestMsg.addU24LengthPrefixed()
	retryRequest.addU16(m.vers)
	extensions := retryRequest.addU16LengthPrefixed()

	count := 1
	if m.duplicateExtensions ***REMOVED***
		count = 2
	***REMOVED***

	for i := 0; i < count; i++ ***REMOVED***
		if m.hasSelectedGroup ***REMOVED***
			extensions.addU16(extensionKeyShare)
			extensions.addU16(2) // length
			extensions.addU16(uint16(m.selectedGroup))
		***REMOVED***
		if len(m.cookie) > 0 ***REMOVED***
			extensions.addU16(extensionCookie)
			body := extensions.addU16LengthPrefixed()
			body.addU16LengthPrefixed().addBytes(m.cookie)
		***REMOVED***
		if len(m.customExtension) > 0 ***REMOVED***
			extensions.addU16(extensionCustom)
			extensions.addU16LengthPrefixed().addBytes([]byte(m.customExtension))
		***REMOVED***
	***REMOVED***

	m.raw = retryRequestMsg.finish()
	return m.raw
***REMOVED***

func (m *helloRetryRequestMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data
	if len(data) < 8 ***REMOVED***
		return false
	***REMOVED***
	m.vers = uint16(data[4])<<8 | uint16(data[5])
	extLen := int(data[6])<<8 | int(data[7])
	data = data[8:]
	if len(data) != extLen || len(data) == 0 ***REMOVED***
		return false
	***REMOVED***
	for len(data) > 0 ***REMOVED***
		if len(data) < 4 ***REMOVED***
			return false
		***REMOVED***
		extension := uint16(data[0])<<8 | uint16(data[1])
		length := int(data[2])<<8 | int(data[3])
		data = data[4:]
		if len(data) < length ***REMOVED***
			return false
		***REMOVED***

		switch extension ***REMOVED***
		case extensionKeyShare:
			if length != 2 ***REMOVED***
				return false
			***REMOVED***
			m.hasSelectedGroup = true
			m.selectedGroup = CurveID(data[0])<<8 | CurveID(data[1])
		case extensionCookie:
			if length < 2 ***REMOVED***
				return false
			***REMOVED***
			cookieLen := int(data[0])<<8 | int(data[1])
			if 2+cookieLen != length ***REMOVED***
				return false
			***REMOVED***
			m.cookie = data[2 : 2+cookieLen]
		default:
			// Unknown extensions are illegal from the server.
			return false
		***REMOVED***
		data = data[length:]
	***REMOVED***
	return true
***REMOVED***

type certificateEntry struct ***REMOVED***
	data                []byte
	ocspResponse        []byte
	sctList             []byte
	duplicateExtensions bool
	extraExtension      []byte
***REMOVED***

type certificateMsg struct ***REMOVED***
	raw               []byte
	hasRequestContext bool
	requestContext    []byte
	certificates      []certificateEntry
***REMOVED***

func (m *certificateMsg) marshal() (x []byte) ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	certMsg := newByteBuilder()
	certMsg.addU8(typeCertificate)
	certificate := certMsg.addU24LengthPrefixed()
	if m.hasRequestContext ***REMOVED***
		context := certificate.addU8LengthPrefixed()
		context.addBytes(m.requestContext)
	***REMOVED***
	certificateList := certificate.addU24LengthPrefixed()
	for _, cert := range m.certificates ***REMOVED***
		certEntry := certificateList.addU24LengthPrefixed()
		certEntry.addBytes(cert.data)
		if m.hasRequestContext ***REMOVED***
			extensions := certificateList.addU16LengthPrefixed()
			count := 1
			if cert.duplicateExtensions ***REMOVED***
				count = 2
			***REMOVED***

			for i := 0; i < count; i++ ***REMOVED***
				if cert.ocspResponse != nil ***REMOVED***
					extensions.addU16(extensionStatusRequest)
					body := extensions.addU16LengthPrefixed()
					body.addU8(statusTypeOCSP)
					response := body.addU24LengthPrefixed()
					response.addBytes(cert.ocspResponse)
				***REMOVED***

				if cert.sctList != nil ***REMOVED***
					extensions.addU16(extensionSignedCertificateTimestamp)
					extension := extensions.addU16LengthPrefixed()
					extension.addBytes(cert.sctList)
				***REMOVED***
			***REMOVED***
			if cert.extraExtension != nil ***REMOVED***
				extensions.addBytes(cert.extraExtension)
			***REMOVED***
		***REMOVED***
	***REMOVED***

	m.raw = certMsg.finish()
	return m.raw
***REMOVED***

func (m *certificateMsg) unmarshal(data []byte) bool ***REMOVED***
	if len(data) < 4 ***REMOVED***
		return false
	***REMOVED***

	m.raw = data
	data = data[4:]

	if m.hasRequestContext ***REMOVED***
		if len(data) == 0 ***REMOVED***
			return false
		***REMOVED***
		contextLen := int(data[0])
		if len(data) < 1+contextLen ***REMOVED***
			return false
		***REMOVED***
		m.requestContext = make([]byte, contextLen)
		copy(m.requestContext, data[1:])
		data = data[1+contextLen:]
	***REMOVED***

	if len(data) < 3 ***REMOVED***
		return false
	***REMOVED***
	certsLen := int(data[0])<<16 | int(data[1])<<8 | int(data[2])
	data = data[3:]
	if len(data) != certsLen ***REMOVED***
		return false
	***REMOVED***

	m.certificates = nil
	for len(data) != 0 ***REMOVED***
		if len(data) < 3 ***REMOVED***
			return false
		***REMOVED***
		certLen := int(data[0])<<16 | int(data[1])<<8 | int(data[2])
		if len(data) < 3+certLen ***REMOVED***
			return false
		***REMOVED***
		cert := certificateEntry***REMOVED***
			data: data[3 : 3+certLen],
		***REMOVED***
		data = data[3+certLen:]
		if m.hasRequestContext ***REMOVED***
			if len(data) < 2 ***REMOVED***
				return false
			***REMOVED***
			extensionsLen := int(data[0])<<8 | int(data[1])
			if len(data) < 2+extensionsLen ***REMOVED***
				return false
			***REMOVED***
			extensions := data[2 : 2+extensionsLen]
			data = data[2+extensionsLen:]
			for len(extensions) != 0 ***REMOVED***
				if len(extensions) < 4 ***REMOVED***
					return false
				***REMOVED***
				extension := uint16(extensions[0])<<8 | uint16(extensions[1])
				length := int(extensions[2])<<8 | int(extensions[3])
				if len(extensions) < 4+length ***REMOVED***
					return false
				***REMOVED***
				contents := extensions[4 : 4+length]
				extensions = extensions[4+length:]

				switch extension ***REMOVED***
				case extensionStatusRequest:
					if length < 4 ***REMOVED***
						return false
					***REMOVED***
					if contents[0] != statusTypeOCSP ***REMOVED***
						return false
					***REMOVED***
					respLen := int(contents[1])<<16 | int(contents[2])<<8 | int(contents[3])
					if respLen+4 != len(contents) || respLen == 0 ***REMOVED***
						return false
					***REMOVED***
					cert.ocspResponse = contents[4:]
				case extensionSignedCertificateTimestamp:
					cert.sctList = contents
				default:
					return false
				***REMOVED***
			***REMOVED***
		***REMOVED***
		m.certificates = append(m.certificates, cert)
	***REMOVED***

	return true
***REMOVED***

type serverKeyExchangeMsg struct ***REMOVED***
	raw []byte
	key []byte
***REMOVED***

func (m *serverKeyExchangeMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***
	length := len(m.key)
	x := make([]byte, length+4)
	x[0] = typeServerKeyExchange
	x[1] = uint8(length >> 16)
	x[2] = uint8(length >> 8)
	x[3] = uint8(length)
	copy(x[4:], m.key)

	m.raw = x
	return x
***REMOVED***

func (m *serverKeyExchangeMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data
	if len(data) < 4 ***REMOVED***
		return false
	***REMOVED***
	m.key = data[4:]
	return true
***REMOVED***

type certificateStatusMsg struct ***REMOVED***
	raw        []byte
	statusType uint8
	response   []byte
***REMOVED***

func (m *certificateStatusMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	var x []byte
	if m.statusType == statusTypeOCSP ***REMOVED***
		x = make([]byte, 4+4+len(m.response))
		x[0] = typeCertificateStatus
		l := len(m.response) + 4
		x[1] = byte(l >> 16)
		x[2] = byte(l >> 8)
		x[3] = byte(l)
		x[4] = statusTypeOCSP

		l -= 4
		x[5] = byte(l >> 16)
		x[6] = byte(l >> 8)
		x[7] = byte(l)
		copy(x[8:], m.response)
	***REMOVED*** else ***REMOVED***
		x = []byte***REMOVED***typeCertificateStatus, 0, 0, 1, m.statusType***REMOVED***
	***REMOVED***

	m.raw = x
	return x
***REMOVED***

func (m *certificateStatusMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data
	if len(data) < 5 ***REMOVED***
		return false
	***REMOVED***
	m.statusType = data[4]

	m.response = nil
	if m.statusType == statusTypeOCSP ***REMOVED***
		if len(data) < 8 ***REMOVED***
			return false
		***REMOVED***
		respLen := uint32(data[5])<<16 | uint32(data[6])<<8 | uint32(data[7])
		if uint32(len(data)) != 4+4+respLen ***REMOVED***
			return false
		***REMOVED***
		m.response = data[8:]
	***REMOVED***
	return true
***REMOVED***

type serverHelloDoneMsg struct***REMOVED******REMOVED***

func (m *serverHelloDoneMsg) marshal() []byte ***REMOVED***
	x := make([]byte, 4)
	x[0] = typeServerHelloDone
	return x
***REMOVED***

func (m *serverHelloDoneMsg) unmarshal(data []byte) bool ***REMOVED***
	return len(data) == 4
***REMOVED***

type clientKeyExchangeMsg struct ***REMOVED***
	raw        []byte
	ciphertext []byte
***REMOVED***

func (m *clientKeyExchangeMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***
	length := len(m.ciphertext)
	x := make([]byte, length+4)
	x[0] = typeClientKeyExchange
	x[1] = uint8(length >> 16)
	x[2] = uint8(length >> 8)
	x[3] = uint8(length)
	copy(x[4:], m.ciphertext)

	m.raw = x
	return x
***REMOVED***

func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data
	if len(data) < 4 ***REMOVED***
		return false
	***REMOVED***
	l := int(data[1])<<16 | int(data[2])<<8 | int(data[3])
	if l != len(data)-4 ***REMOVED***
		return false
	***REMOVED***
	m.ciphertext = data[4:]
	return true
***REMOVED***

type finishedMsg struct ***REMOVED***
	raw        []byte
	verifyData []byte
***REMOVED***

func (m *finishedMsg) marshal() (x []byte) ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	x = make([]byte, 4+len(m.verifyData))
	x[0] = typeFinished
	x[3] = byte(len(m.verifyData))
	copy(x[4:], m.verifyData)
	m.raw = x
	return
***REMOVED***

func (m *finishedMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data
	if len(data) < 4 ***REMOVED***
		return false
	***REMOVED***
	m.verifyData = data[4:]
	return true
***REMOVED***

type nextProtoMsg struct ***REMOVED***
	raw   []byte
	proto string
***REMOVED***

func (m *nextProtoMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***
	l := len(m.proto)
	if l > 255 ***REMOVED***
		l = 255
	***REMOVED***

	padding := 32 - (l+2)%32
	length := l + padding + 2
	x := make([]byte, length+4)
	x[0] = typeNextProtocol
	x[1] = uint8(length >> 16)
	x[2] = uint8(length >> 8)
	x[3] = uint8(length)

	y := x[4:]
	y[0] = byte(l)
	copy(y[1:], []byte(m.proto[0:l]))
	y = y[1+l:]
	y[0] = byte(padding)

	m.raw = x

	return x
***REMOVED***

func (m *nextProtoMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data

	if len(data) < 5 ***REMOVED***
		return false
	***REMOVED***
	data = data[4:]
	protoLen := int(data[0])
	data = data[1:]
	if len(data) < protoLen ***REMOVED***
		return false
	***REMOVED***
	m.proto = string(data[0:protoLen])
	data = data[protoLen:]

	if len(data) < 1 ***REMOVED***
		return false
	***REMOVED***
	paddingLen := int(data[0])
	data = data[1:]
	if len(data) != paddingLen ***REMOVED***
		return false
	***REMOVED***

	return true
***REMOVED***

type certificateRequestMsg struct ***REMOVED***
	raw []byte
	// hasSignatureAlgorithm indicates whether this message includes a list
	// of signature and hash functions. This change was introduced with TLS
	// 1.2.
	hasSignatureAlgorithm bool
	// hasRequestContext indicates whether this message includes a context
	// field instead of certificateTypes. This change was introduced with
	// TLS 1.3.
	hasRequestContext bool

	certificateTypes       []byte
	requestContext         []byte
	signatureAlgorithms    []signatureAlgorithm
	certificateAuthorities [][]byte
***REMOVED***

func (m *certificateRequestMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	// See http://tools.ietf.org/html/rfc4346#section-7.4.4
	builder := newByteBuilder()
	builder.addU8(typeCertificateRequest)
	body := builder.addU24LengthPrefixed()

	if m.hasRequestContext ***REMOVED***
		requestContext := body.addU8LengthPrefixed()
		requestContext.addBytes(m.requestContext)
	***REMOVED*** else ***REMOVED***
		certificateTypes := body.addU8LengthPrefixed()
		certificateTypes.addBytes(m.certificateTypes)
	***REMOVED***

	if m.hasSignatureAlgorithm ***REMOVED***
		signatureAlgorithms := body.addU16LengthPrefixed()
		for _, sigAlg := range m.signatureAlgorithms ***REMOVED***
			signatureAlgorithms.addU16(uint16(sigAlg))
		***REMOVED***
	***REMOVED***

	certificateAuthorities := body.addU16LengthPrefixed()
	for _, ca := range m.certificateAuthorities ***REMOVED***
		caEntry := certificateAuthorities.addU16LengthPrefixed()
		caEntry.addBytes(ca)
	***REMOVED***

	if m.hasRequestContext ***REMOVED***
		// Emit no certificate extensions.
		body.addU16(0)
	***REMOVED***

	m.raw = builder.finish()
	return m.raw
***REMOVED***

func (m *certificateRequestMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data

	if len(data) < 5 ***REMOVED***
		return false
	***REMOVED***
	data = data[4:]

	if m.hasRequestContext ***REMOVED***
		contextLen := int(data[0])
		if len(data) < 1+contextLen ***REMOVED***
			return false
		***REMOVED***
		m.requestContext = make([]byte, contextLen)
		copy(m.requestContext, data[1:])
		data = data[1+contextLen:]
	***REMOVED*** else ***REMOVED***
		numCertTypes := int(data[0])
		if len(data) < 1+numCertTypes ***REMOVED***
			return false
		***REMOVED***
		m.certificateTypes = make([]byte, numCertTypes)
		copy(m.certificateTypes, data[1:])
		data = data[1+numCertTypes:]
	***REMOVED***

	if m.hasSignatureAlgorithm ***REMOVED***
		if len(data) < 2 ***REMOVED***
			return false
		***REMOVED***
		sigAlgsLen := uint16(data[0])<<8 | uint16(data[1])
		data = data[2:]
		if sigAlgsLen&1 != 0 ***REMOVED***
			return false
		***REMOVED***
		if len(data) < int(sigAlgsLen) ***REMOVED***
			return false
		***REMOVED***
		numSigAlgs := sigAlgsLen / 2
		m.signatureAlgorithms = make([]signatureAlgorithm, numSigAlgs)
		for i := range m.signatureAlgorithms ***REMOVED***
			m.signatureAlgorithms[i] = signatureAlgorithm(data[0])<<8 | signatureAlgorithm(data[1])
			data = data[2:]
		***REMOVED***
	***REMOVED***

	if len(data) < 2 ***REMOVED***
		return false
	***REMOVED***
	casLength := uint16(data[0])<<8 | uint16(data[1])
	data = data[2:]
	if len(data) < int(casLength) ***REMOVED***
		return false
	***REMOVED***
	cas := make([]byte, casLength)
	copy(cas, data)
	data = data[casLength:]

	m.certificateAuthorities = nil
	for len(cas) > 0 ***REMOVED***
		if len(cas) < 2 ***REMOVED***
			return false
		***REMOVED***
		caLen := uint16(cas[0])<<8 | uint16(cas[1])
		cas = cas[2:]

		if len(cas) < int(caLen) ***REMOVED***
			return false
		***REMOVED***

		m.certificateAuthorities = append(m.certificateAuthorities, cas[:caLen])
		cas = cas[caLen:]
	***REMOVED***

	if m.hasRequestContext ***REMOVED***
		// Ignore certificate extensions.
		if len(data) < 2 ***REMOVED***
			return false
		***REMOVED***
		extsLength := int(data[0])<<8 | int(data[1])
		if len(data) < 2+extsLength ***REMOVED***
			return false
		***REMOVED***
		data = data[2+extsLength:]
	***REMOVED***

	if len(data) > 0 ***REMOVED***
		return false
	***REMOVED***

	return true
***REMOVED***

type certificateVerifyMsg struct ***REMOVED***
	raw                   []byte
	hasSignatureAlgorithm bool
	signatureAlgorithm    signatureAlgorithm
	signature             []byte
***REMOVED***

func (m *certificateVerifyMsg) marshal() (x []byte) ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	// See http://tools.ietf.org/html/rfc4346#section-7.4.8
	siglength := len(m.signature)
	length := 2 + siglength
	if m.hasSignatureAlgorithm ***REMOVED***
		length += 2
	***REMOVED***
	x = make([]byte, 4+length)
	x[0] = typeCertificateVerify
	x[1] = uint8(length >> 16)
	x[2] = uint8(length >> 8)
	x[3] = uint8(length)
	y := x[4:]
	if m.hasSignatureAlgorithm ***REMOVED***
		y[0] = byte(m.signatureAlgorithm >> 8)
		y[1] = byte(m.signatureAlgorithm)
		y = y[2:]
	***REMOVED***
	y[0] = uint8(siglength >> 8)
	y[1] = uint8(siglength)
	copy(y[2:], m.signature)

	m.raw = x

	return
***REMOVED***

func (m *certificateVerifyMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data

	if len(data) < 6 ***REMOVED***
		return false
	***REMOVED***

	length := uint32(data[1])<<16 | uint32(data[2])<<8 | uint32(data[3])
	if uint32(len(data))-4 != length ***REMOVED***
		return false
	***REMOVED***

	data = data[4:]
	if m.hasSignatureAlgorithm ***REMOVED***
		m.signatureAlgorithm = signatureAlgorithm(data[0])<<8 | signatureAlgorithm(data[1])
		data = data[2:]
	***REMOVED***

	if len(data) < 2 ***REMOVED***
		return false
	***REMOVED***
	siglength := int(data[0])<<8 + int(data[1])
	data = data[2:]
	if len(data) != siglength ***REMOVED***
		return false
	***REMOVED***

	m.signature = data

	return true
***REMOVED***

type newSessionTicketMsg struct ***REMOVED***
	raw                    []byte
	version                uint16
	ticketLifetime         uint32
	ticketAgeAdd           uint32
	ticket                 []byte
	maxEarlyDataSize       uint32
	customExtension        string
	duplicateEarlyDataInfo bool
	hasGREASEExtension     bool
***REMOVED***

func (m *newSessionTicketMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	// See http://tools.ietf.org/html/rfc5077#section-3.3
	ticketMsg := newByteBuilder()
	ticketMsg.addU8(typeNewSessionTicket)
	body := ticketMsg.addU24LengthPrefixed()
	body.addU32(m.ticketLifetime)
	if m.version >= VersionTLS13 ***REMOVED***
		body.addU32(m.ticketAgeAdd)
	***REMOVED***

	ticket := body.addU16LengthPrefixed()
	ticket.addBytes(m.ticket)

	if m.version >= VersionTLS13 ***REMOVED***
		extensions := body.addU16LengthPrefixed()
		if m.maxEarlyDataSize > 0 ***REMOVED***
			extensions.addU16(extensionTicketEarlyDataInfo)
			extensions.addU16LengthPrefixed().addU32(m.maxEarlyDataSize)
			if m.duplicateEarlyDataInfo ***REMOVED***
				extensions.addU16(extensionTicketEarlyDataInfo)
				extensions.addU16LengthPrefixed().addU32(m.maxEarlyDataSize)
			***REMOVED***
		***REMOVED***
		if len(m.customExtension) > 0 ***REMOVED***
			extensions.addU16(extensionCustom)
			extensions.addU16LengthPrefixed().addBytes([]byte(m.customExtension))
		***REMOVED***
	***REMOVED***

	m.raw = ticketMsg.finish()
	return m.raw
***REMOVED***

func (m *newSessionTicketMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data

	if len(data) < 8 ***REMOVED***
		return false
	***REMOVED***
	m.ticketLifetime = uint32(data[4])<<24 | uint32(data[5])<<16 | uint32(data[6])<<8 | uint32(data[7])
	data = data[8:]

	if m.version >= VersionTLS13 ***REMOVED***
		if len(data) < 4 ***REMOVED***
			return false
		***REMOVED***
		m.ticketAgeAdd = uint32(data[0])<<24 | uint32(data[1])<<16 | uint32(data[2])<<8 | uint32(data[3])
		data = data[4:]
	***REMOVED***

	if len(data) < 2 ***REMOVED***
		return false
	***REMOVED***
	ticketLen := int(data[0])<<8 + int(data[1])
	data = data[2:]
	if len(data) < ticketLen ***REMOVED***
		return false
	***REMOVED***

	if m.version >= VersionTLS13 && ticketLen == 0 ***REMOVED***
		return false
	***REMOVED***

	m.ticket = data[:ticketLen]
	data = data[ticketLen:]

	if m.version >= VersionTLS13 ***REMOVED***
		if len(data) < 2 ***REMOVED***
			return false
		***REMOVED***

		extensionsLength := int(data[0])<<8 | int(data[1])
		data = data[2:]
		if extensionsLength != len(data) ***REMOVED***
			return false
		***REMOVED***

		for len(data) != 0 ***REMOVED***
			if len(data) < 4 ***REMOVED***
				return false
			***REMOVED***
			extension := uint16(data[0])<<8 | uint16(data[1])
			length := int(data[2])<<8 | int(data[3])
			data = data[4:]
			if len(data) < length ***REMOVED***
				return false
			***REMOVED***

			switch extension ***REMOVED***
			case extensionTicketEarlyDataInfo:
				if length != 4 ***REMOVED***
					return false
				***REMOVED***
				m.maxEarlyDataSize = uint32(data[0])<<24 | uint32(data[1])<<16 | uint32(data[2])<<8 | uint32(data[3])
			default:
				if isGREASEValue(extension) ***REMOVED***
					m.hasGREASEExtension = true
				***REMOVED***
			***REMOVED***

			data = data[length:]
		***REMOVED***
	***REMOVED***

	if len(data) > 0 ***REMOVED***
		return false
	***REMOVED***

	return true
***REMOVED***

type v2ClientHelloMsg struct ***REMOVED***
	raw          []byte
	vers         uint16
	cipherSuites []uint16
	sessionId    []byte
	challenge    []byte
***REMOVED***

func (m *v2ClientHelloMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	length := 1 + 2 + 2 + 2 + 2 + len(m.cipherSuites)*3 + len(m.sessionId) + len(m.challenge)

	x := make([]byte, length)
	x[0] = 1
	x[1] = uint8(m.vers >> 8)
	x[2] = uint8(m.vers)
	x[3] = uint8((len(m.cipherSuites) * 3) >> 8)
	x[4] = uint8(len(m.cipherSuites) * 3)
	x[5] = uint8(len(m.sessionId) >> 8)
	x[6] = uint8(len(m.sessionId))
	x[7] = uint8(len(m.challenge) >> 8)
	x[8] = uint8(len(m.challenge))
	y := x[9:]
	for i, spec := range m.cipherSuites ***REMOVED***
		y[i*3] = 0
		y[i*3+1] = uint8(spec >> 8)
		y[i*3+2] = uint8(spec)
	***REMOVED***
	y = y[len(m.cipherSuites)*3:]
	copy(y, m.sessionId)
	y = y[len(m.sessionId):]
	copy(y, m.challenge)

	m.raw = x

	return x
***REMOVED***

type helloVerifyRequestMsg struct ***REMOVED***
	raw    []byte
	vers   uint16
	cookie []byte
***REMOVED***

func (m *helloVerifyRequestMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	length := 2 + 1 + len(m.cookie)

	x := make([]byte, 4+length)
	x[0] = typeHelloVerifyRequest
	x[1] = uint8(length >> 16)
	x[2] = uint8(length >> 8)
	x[3] = uint8(length)
	vers := m.vers
	x[4] = uint8(vers >> 8)
	x[5] = uint8(vers)
	x[6] = uint8(len(m.cookie))
	copy(x[7:7+len(m.cookie)], m.cookie)

	return x
***REMOVED***

func (m *helloVerifyRequestMsg) unmarshal(data []byte) bool ***REMOVED***
	if len(data) < 4+2+1 ***REMOVED***
		return false
	***REMOVED***
	m.raw = data
	m.vers = uint16(data[4])<<8 | uint16(data[5])
	cookieLen := int(data[6])
	if cookieLen > 32 || len(data) != 7+cookieLen ***REMOVED***
		return false
	***REMOVED***
	m.cookie = data[7 : 7+cookieLen]

	return true
***REMOVED***

type channelIDMsg struct ***REMOVED***
	raw       []byte
	channelID []byte
***REMOVED***

func (m *channelIDMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	length := 2 + 2 + len(m.channelID)

	x := make([]byte, 4+length)
	x[0] = typeChannelID
	x[1] = uint8(length >> 16)
	x[2] = uint8(length >> 8)
	x[3] = uint8(length)
	x[4] = uint8(extensionChannelID >> 8)
	x[5] = uint8(extensionChannelID & 0xff)
	x[6] = uint8(len(m.channelID) >> 8)
	x[7] = uint8(len(m.channelID) & 0xff)
	copy(x[8:], m.channelID)

	return x
***REMOVED***

func (m *channelIDMsg) unmarshal(data []byte) bool ***REMOVED***
	if len(data) != 4+2+2+128 ***REMOVED***
		return false
	***REMOVED***
	m.raw = data
	if (uint16(data[4])<<8)|uint16(data[5]) != extensionChannelID ***REMOVED***
		return false
	***REMOVED***
	if int(data[6])<<8|int(data[7]) != 128 ***REMOVED***
		return false
	***REMOVED***
	m.channelID = data[4+2+2:]

	return true
***REMOVED***

type helloRequestMsg struct ***REMOVED***
***REMOVED***

func (*helloRequestMsg) marshal() []byte ***REMOVED***
	return []byte***REMOVED***typeHelloRequest, 0, 0, 0***REMOVED***
***REMOVED***

func (*helloRequestMsg) unmarshal(data []byte) bool ***REMOVED***
	return len(data) == 4
***REMOVED***

type keyUpdateMsg struct ***REMOVED***
	raw              []byte
	keyUpdateRequest byte
***REMOVED***

func (m *keyUpdateMsg) marshal() []byte ***REMOVED***
	if m.raw != nil ***REMOVED***
		return m.raw
	***REMOVED***

	return []byte***REMOVED***typeKeyUpdate, 0, 0, 1, m.keyUpdateRequest***REMOVED***
***REMOVED***

func (m *keyUpdateMsg) unmarshal(data []byte) bool ***REMOVED***
	m.raw = data

	if len(data) != 5 ***REMOVED***
		return false
	***REMOVED***

	length := int(data[1])<<16 | int(data[2])<<8 | int(data[3])
	if len(data)-4 != length ***REMOVED***
		return false
	***REMOVED***

	m.keyUpdateRequest = data[4]
	return m.keyUpdateRequest == keyUpdateNotRequested || m.keyUpdateRequest == keyUpdateRequested
***REMOVED***

// ssl3NoCertificateMsg is a dummy message to handle SSL 3.0 using a warning
// alert in the handshake.
type ssl3NoCertificateMsg struct***REMOVED******REMOVED***

func eqUint16s(x, y []uint16) bool ***REMOVED***
	if len(x) != len(y) ***REMOVED***
		return false
	***REMOVED***
	for i, v := range x ***REMOVED***
		if y[i] != v ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***
	return true
***REMOVED***

func eqCurveIDs(x, y []CurveID) bool ***REMOVED***
	if len(x) != len(y) ***REMOVED***
		return false
	***REMOVED***
	for i, v := range x ***REMOVED***
		if y[i] != v ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***
	return true
***REMOVED***

func eqStrings(x, y []string) bool ***REMOVED***
	if len(x) != len(y) ***REMOVED***
		return false
	***REMOVED***
	for i, v := range x ***REMOVED***
		if y[i] != v ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***
	return true
***REMOVED***

func eqByteSlices(x, y [][]byte) bool ***REMOVED***
	if len(x) != len(y) ***REMOVED***
		return false
	***REMOVED***
	for i, v := range x ***REMOVED***
		if !bytes.Equal(v, y[i]) ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***
	return true
***REMOVED***

func eqSignatureAlgorithms(x, y []signatureAlgorithm) bool ***REMOVED***
	if len(x) != len(y) ***REMOVED***
		return false
	***REMOVED***
	for i, v := range x ***REMOVED***
		v2 := y[i]
		if v != v2 ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***
	return true
***REMOVED***

func eqKeyShareEntryLists(x, y []keyShareEntry) bool ***REMOVED***
	if len(x) != len(y) ***REMOVED***
		return false
	***REMOVED***
	for i, v := range x ***REMOVED***
		if y[i].group != v.group || !bytes.Equal(y[i].keyExchange, v.keyExchange) ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***
	return true

***REMOVED***

func eqPSKIdentityLists(x, y []pskIdentity) bool ***REMOVED***
	if len(x) != len(y) ***REMOVED***
		return false
	***REMOVED***
	for i, v := range x ***REMOVED***
		if !bytes.Equal(y[i].ticket, v.ticket) || y[i].obfuscatedTicketAge != v.obfuscatedTicketAge ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***
	return true

***REMOVED***
