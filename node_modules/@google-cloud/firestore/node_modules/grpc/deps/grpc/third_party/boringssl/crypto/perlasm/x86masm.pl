#! /usr/bin/env perl
# Copyright 2007-2016 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the OpenSSL license (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


package x86masm;

*out=\@::out;

$::lbdecor="\$L";	# local label decoration
$nmdecor="_";		# external name decoration

$initseg="";
$segment="";

sub ::generic
***REMOVED*** my ($opcode,@arg)=@_;

    # fix hexadecimal constants
    for (@arg) ***REMOVED*** s/(?<![\w\$\.])0x([0-9a-f]+)/0$1h/oi; ***REMOVED***

    if ($opcode =~ /lea/ && @arg[1] =~ s/.*PTR\s+(\(.*\))$/OFFSET $1/)	# no []
    ***REMOVED***	$opcode="mov";	***REMOVED***
    elsif ($opcode !~ /mov[dq]$/)
    ***REMOVED***	# fix xmm references
	$arg[0] =~ s/\b[A-Z]+WORD\s+PTR/XMMWORD PTR/i if ($arg[-1]=~/\bxmm[0-7]\b/i);
	$arg[-1] =~ s/\b[A-Z]+WORD\s+PTR/XMMWORD PTR/i if ($arg[0]=~/\bxmm[0-7]\b/i);
    ***REMOVED***

    &::emit($opcode,@arg);
  1;
***REMOVED***
#
# opcodes not covered by ::generic above, mostly inconsistent namings...
#
sub ::call	***REMOVED*** &::emit("call",(&::islabel($_[0]) or "$nmdecor$_[0]")); ***REMOVED***
sub ::call_ptr	***REMOVED*** &::emit("call",@_);	***REMOVED***
sub ::jmp_ptr	***REMOVED*** &::emit("jmp",@_);	***REMOVED***
sub ::lock	***REMOVED*** &::data_byte(0xf0);	***REMOVED***

sub get_mem
***REMOVED*** my($size,$addr,$reg1,$reg2,$idx)=@_;
  my($post,$ret);

    if (!defined($idx) && 1*$reg2) ***REMOVED*** $idx=$reg2; $reg2=$reg1; undef $reg1; ***REMOVED***

    $ret .= "$size PTR " if ($size ne "");

    $addr =~ s/^\s+//;
    # prepend global references with optional underscore
    $addr =~ s/^([^\+\-0-9][^\+\-]*)/&::islabel($1) or "$nmdecor$1"/ige;
    # put address arithmetic expression in parenthesis
    $addr="($addr)" if ($addr =~ /^.+[\-\+].+$/);

    if (($addr ne "") && ($addr ne 0))
    ***REMOVED***	if ($addr !~ /^-/)	***REMOVED*** $ret .= "$addr";  ***REMOVED***
	else			***REMOVED*** $post=$addr;      ***REMOVED***
    ***REMOVED***
    $ret .= "[";

    if ($reg2 ne "")
    ***REMOVED***	$idx!=0 or $idx=1;
	$ret .= "$reg2*$idx";
	$ret .= "+$reg1" if ($reg1 ne "");
    ***REMOVED***
    else
    ***REMOVED***	$ret .= "$reg1";   ***REMOVED***

    $ret .= "$post]";
    $ret =~ s/\+\]/]/; # in case $addr was the only argument
    $ret =~ s/\[\s*\]//;

  $ret;
***REMOVED***
sub ::BP	***REMOVED*** &get_mem("BYTE",@_);  ***REMOVED***
sub ::WP	***REMOVED*** &get_mem("WORD",@_);	***REMOVED***
sub ::DWP	***REMOVED*** &get_mem("DWORD",@_); ***REMOVED***
sub ::QWP	***REMOVED*** &get_mem("QWORD",@_); ***REMOVED***
sub ::BC	***REMOVED*** "@_";  ***REMOVED***
sub ::DWC	***REMOVED*** "@_"; ***REMOVED***

sub ::file
***REMOVED*** my $tmp=<<___;
TITLE	$_[0].asm
IF \@Version LT 800
ECHO MASM version 8.00 or later is strongly recommended.
ENDIF
.486
.MODEL	FLAT
OPTION	DOTNAME
IF \@Version LT 800
.text\$	SEGMENT PAGE 'CODE'
ELSE
.text\$	SEGMENT ALIGN(64) 'CODE'
ENDIF
___
    push(@out,$tmp);
    $segment = ".text\$";
***REMOVED***

sub ::function_begin_B
***REMOVED*** my $func=shift;
  my $global=($func !~ /^_/);
  my $begin="$***REMOVED***::lbdecor***REMOVED***_$***REMOVED***func***REMOVED***_begin";

    &::LABEL($func,$global?"$begin":"$nmdecor$func");
    $func="ALIGN\t16\n".$nmdecor.$func."\tPROC";

    if ($global)    ***REMOVED*** $func.=" PUBLIC\n$***REMOVED***begin***REMOVED***::\n"; ***REMOVED***
    else	    ***REMOVED*** $func.=" PRIVATE\n";            ***REMOVED***
    push(@out,$func);
    $::stack=4;
***REMOVED***
sub ::function_end_B
***REMOVED*** my $func=shift;

    push(@out,"$nmdecor$func ENDP\n");
    $::stack=0;
    &::wipe_labels();
***REMOVED***

sub ::file_end
***REMOVED*** my $xmmheader=<<___;
.686
.XMM
IF \@Version LT 800
XMMWORD STRUCT 16
DQ	2 dup (?)
XMMWORD	ENDS
ENDIF
___
    if (grep ***REMOVED***/\b[x]?mm[0-7]\b/i***REMOVED*** @out) ***REMOVED***
	grep ***REMOVED***s/\.[3-7]86/$xmmheader/***REMOVED*** @out;
    ***REMOVED***

    push(@out,"$segment	ENDS\n");

    if (grep ***REMOVED***/\b$***REMOVED***nmdecor***REMOVED***OPENSSL_ia32cap_P\b/i***REMOVED*** @out)
    ***REMOVED***	my $comm=<<___;
.bss	SEGMENT 'BSS'
COMM	$***REMOVED***nmdecor***REMOVED***OPENSSL_ia32cap_P:DWORD:4
.bss	ENDS
___
	# comment out OPENSSL_ia32cap_P declarations
	grep ***REMOVED***s/(^EXTERN\s+$***REMOVED***nmdecor***REMOVED***OPENSSL_ia32cap_P)/\;$1/***REMOVED*** @out;
	push (@out,$comm);
    ***REMOVED***
    push (@out,$initseg) if ($initseg);
    push (@out,"END\n");
***REMOVED***

sub ::comment ***REMOVED***   foreach (@_) ***REMOVED*** push(@out,"\t; $_\n"); ***REMOVED***   ***REMOVED***

*::set_label_B = sub
***REMOVED*** my $l=shift; push(@out,$l.($l=~/^\Q$***REMOVED***::lbdecor***REMOVED***\E[0-9]***REMOVED***3***REMOVED***/?":\n":"::\n")); ***REMOVED***;

sub ::external_label
***REMOVED***   foreach(@_)
    ***REMOVED***	push(@out, "EXTERN\t".&::LABEL($_,$nmdecor.$_).":NEAR\n");   ***REMOVED***
***REMOVED***

sub ::public_label
***REMOVED***   push(@out,"PUBLIC\t".&::LABEL($_[0],$nmdecor.$_[0])."\n");   ***REMOVED***

sub ::data_byte
***REMOVED***   push(@out,("DB\t").join(',',splice(@_,0,16))."\n") while(@_);	***REMOVED***

sub ::data_short
***REMOVED***   push(@out,("DW\t").join(',',splice(@_,0,8))."\n") while(@_);	***REMOVED***

sub ::data_word
***REMOVED***   push(@out,("DD\t").join(',',splice(@_,0,4))."\n") while(@_);	***REMOVED***

sub ::align
***REMOVED***   push(@out,"ALIGN\t$_[0]\n");	***REMOVED***

sub ::picmeup
***REMOVED*** my($dst,$sym)=@_;
    &::lea($dst,&::DWP($sym));
***REMOVED***

sub ::initseg
***REMOVED*** my $f=$nmdecor.shift;

    $initseg.=<<___;
.CRT\$XCU	SEGMENT DWORD PUBLIC 'DATA'
EXTERN	$f:NEAR
DD	$f
.CRT\$XCU	ENDS
___
***REMOVED***

sub ::dataseg
***REMOVED***   push(@out,"$segment\tENDS\n_DATA\tSEGMENT\n"); $segment="_DATA";   ***REMOVED***

sub ::safeseh
***REMOVED*** my $nm=shift;
    push(@out,"IF \@Version GE 710\n");
    push(@out,".SAFESEH	".&::LABEL($nm,$nmdecor.$nm)."\n");
    push(@out,"ENDIF\n");
***REMOVED***

1;
