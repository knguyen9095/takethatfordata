// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runner

import (
	"bytes"
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rsa"
	"crypto/subtle"
	"crypto/x509"
	"errors"
	"fmt"
	"io"
	"math/big"
	"time"
)

// serverHandshakeState contains details of a server handshake in progress.
// It's discarded once the handshake has completed.
type serverHandshakeState struct ***REMOVED***
	c               *Conn
	clientHello     *clientHelloMsg
	hello           *serverHelloMsg
	suite           *cipherSuite
	ellipticOk      bool
	ecdsaOk         bool
	sessionState    *sessionState
	finishedHash    finishedHash
	masterSecret    []byte
	certsFromClient [][]byte
	cert            *Certificate
	finishedBytes   []byte
***REMOVED***

// serverHandshake performs a TLS handshake as a server.
func (c *Conn) serverHandshake() error ***REMOVED***
	config := c.config

	// If this is the first server handshake, we generate a random key to
	// encrypt the tickets with.
	config.serverInitOnce.Do(config.serverInit)

	c.sendHandshakeSeq = 0
	c.recvHandshakeSeq = 0

	hs := serverHandshakeState***REMOVED***
		c: c,
	***REMOVED***
	if err := hs.readClientHello(); err != nil ***REMOVED***
		return err
	***REMOVED***

	if c.vers >= VersionTLS13 ***REMOVED***
		if err := hs.doTLS13Handshake(); err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		isResume, err := hs.processClientHello()
		if err != nil ***REMOVED***
			return err
		***REMOVED***

		// For an overview of TLS handshaking, see https://tools.ietf.org/html/rfc5246#section-7.3
		if isResume ***REMOVED***
			// The client has included a session ticket and so we do an abbreviated handshake.
			if err := hs.doResumeHandshake(); err != nil ***REMOVED***
				return err
			***REMOVED***
			if err := hs.establishKeys(); err != nil ***REMOVED***
				return err
			***REMOVED***
			if c.config.Bugs.RenewTicketOnResume ***REMOVED***
				if err := hs.sendSessionTicket(); err != nil ***REMOVED***
					return err
				***REMOVED***
			***REMOVED***
			if err := hs.sendFinished(c.firstFinished[:]); err != nil ***REMOVED***
				return err
			***REMOVED***
			// Most retransmits are triggered by a timeout, but the final
			// leg of the handshake is retransmited upon re-receiving a
			// Finished.
			if err := c.simulatePacketLoss(func() ***REMOVED***
				c.sendHandshakeSeq--
				c.writeRecord(recordTypeHandshake, hs.finishedBytes)
				c.flushHandshake()
			***REMOVED***); err != nil ***REMOVED***
				return err
			***REMOVED***
			if err := hs.readFinished(nil, isResume); err != nil ***REMOVED***
				return err
			***REMOVED***
			c.didResume = true
		***REMOVED*** else ***REMOVED***
			// The client didn't include a session ticket, or it wasn't
			// valid so we do a full handshake.
			if err := hs.doFullHandshake(); err != nil ***REMOVED***
				return err
			***REMOVED***
			if err := hs.establishKeys(); err != nil ***REMOVED***
				return err
			***REMOVED***
			if err := hs.readFinished(c.firstFinished[:], isResume); err != nil ***REMOVED***
				return err
			***REMOVED***
			if c.config.Bugs.AlertBeforeFalseStartTest != 0 ***REMOVED***
				c.sendAlert(c.config.Bugs.AlertBeforeFalseStartTest)
			***REMOVED***
			if c.config.Bugs.ExpectFalseStart ***REMOVED***
				if err := c.readRecord(recordTypeApplicationData); err != nil ***REMOVED***
					return fmt.Errorf("tls: peer did not false start: %s", err)
				***REMOVED***
			***REMOVED***
			if err := hs.sendSessionTicket(); err != nil ***REMOVED***
				return err
			***REMOVED***
			if err := hs.sendFinished(nil); err != nil ***REMOVED***
				return err
			***REMOVED***
		***REMOVED***

		c.exporterSecret = hs.masterSecret
	***REMOVED***
	c.handshakeComplete = true
	copy(c.clientRandom[:], hs.clientHello.random)
	copy(c.serverRandom[:], hs.hello.random)

	return nil
***REMOVED***

// readClientHello reads a ClientHello message from the client and determines
// the protocol version.
func (hs *serverHandshakeState) readClientHello() error ***REMOVED***
	config := hs.c.config
	c := hs.c

	if err := c.simulatePacketLoss(nil); err != nil ***REMOVED***
		return err
	***REMOVED***
	msg, err := c.readHandshake()
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	var ok bool
	hs.clientHello, ok = msg.(*clientHelloMsg)
	if !ok ***REMOVED***
		c.sendAlert(alertUnexpectedMessage)
		return unexpectedMessageError(hs.clientHello, msg)
	***REMOVED***
	if size := config.Bugs.RequireClientHelloSize; size != 0 && len(hs.clientHello.raw) != size ***REMOVED***
		return fmt.Errorf("tls: ClientHello record size is %d, but expected %d", len(hs.clientHello.raw), size)
	***REMOVED***

	if c.isDTLS && !config.Bugs.SkipHelloVerifyRequest ***REMOVED***
		// Per RFC 6347, the version field in HelloVerifyRequest SHOULD
		// be always DTLS 1.0
		helloVerifyRequest := &helloVerifyRequestMsg***REMOVED***
			vers:   versionToWire(VersionTLS10, c.isDTLS),
			cookie: make([]byte, 32),
		***REMOVED***
		if _, err := io.ReadFull(c.config.rand(), helloVerifyRequest.cookie); err != nil ***REMOVED***
			c.sendAlert(alertInternalError)
			return errors.New("dtls: short read from Rand: " + err.Error())
		***REMOVED***
		c.writeRecord(recordTypeHandshake, helloVerifyRequest.marshal())
		c.flushHandshake()

		if err := c.simulatePacketLoss(nil); err != nil ***REMOVED***
			return err
		***REMOVED***
		msg, err := c.readHandshake()
		if err != nil ***REMOVED***
			return err
		***REMOVED***
		newClientHello, ok := msg.(*clientHelloMsg)
		if !ok ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return unexpectedMessageError(hs.clientHello, msg)
		***REMOVED***
		if !bytes.Equal(newClientHello.cookie, helloVerifyRequest.cookie) ***REMOVED***
			return errors.New("dtls: invalid cookie")
		***REMOVED***

		// Apart from the cookie, the two ClientHellos must
		// match. Note that clientHello.equal compares the
		// serialization, so we make a copy.
		oldClientHelloCopy := *hs.clientHello
		oldClientHelloCopy.raw = nil
		oldClientHelloCopy.cookie = nil
		newClientHelloCopy := *newClientHello
		newClientHelloCopy.raw = nil
		newClientHelloCopy.cookie = nil
		if !oldClientHelloCopy.equal(&newClientHelloCopy) ***REMOVED***
			return errors.New("dtls: retransmitted ClientHello does not match")
		***REMOVED***
		hs.clientHello = newClientHello
	***REMOVED***

	if config.Bugs.RequireSameRenegoClientVersion && c.clientVersion != 0 ***REMOVED***
		if c.clientVersion != hs.clientHello.vers ***REMOVED***
			return fmt.Errorf("tls: client offered different version on renego")
		***REMOVED***
	***REMOVED***

	c.clientVersion = hs.clientHello.vers

	// Convert the ClientHello wire version to a protocol version.
	var clientVersion uint16
	if c.isDTLS ***REMOVED***
		if hs.clientHello.vers <= 0xfefd ***REMOVED***
			clientVersion = VersionTLS12
		***REMOVED*** else if hs.clientHello.vers <= 0xfeff ***REMOVED***
			clientVersion = VersionTLS10
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		if hs.clientHello.vers >= VersionTLS12 ***REMOVED***
			clientVersion = VersionTLS12
		***REMOVED*** else if hs.clientHello.vers >= VersionTLS11 ***REMOVED***
			clientVersion = VersionTLS11
		***REMOVED*** else if hs.clientHello.vers >= VersionTLS10 ***REMOVED***
			clientVersion = VersionTLS10
		***REMOVED*** else if hs.clientHello.vers >= VersionSSL30 ***REMOVED***
			clientVersion = VersionSSL30
		***REMOVED***
	***REMOVED***

	if config.Bugs.NegotiateVersion != 0 ***REMOVED***
		c.vers = config.Bugs.NegotiateVersion
	***REMOVED*** else if c.haveVers && config.Bugs.NegotiateVersionOnRenego != 0 ***REMOVED***
		c.vers = config.Bugs.NegotiateVersionOnRenego
	***REMOVED*** else if len(hs.clientHello.supportedVersions) > 0 ***REMOVED***
		// Use the versions extension if supplied.
		var foundVersion, foundGREASE bool
		for _, extVersion := range hs.clientHello.supportedVersions ***REMOVED***
			if isGREASEValue(extVersion) ***REMOVED***
				foundGREASE = true
			***REMOVED***
			extVersion, ok = wireToVersion(extVersion, c.isDTLS)
			if !ok ***REMOVED***
				continue
			***REMOVED***
			if config.isSupportedVersion(extVersion, c.isDTLS) && !foundVersion ***REMOVED***
				c.vers = extVersion
				foundVersion = true
				break
			***REMOVED***
		***REMOVED***
		if !foundVersion ***REMOVED***
			c.sendAlert(alertProtocolVersion)
			return errors.New("tls: client did not offer any supported protocol versions")
		***REMOVED***
		if config.Bugs.ExpectGREASE && !foundGREASE ***REMOVED***
			return errors.New("tls: no GREASE version value found")
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		// Otherwise, use the legacy ClientHello version.
		version := clientVersion
		if maxVersion := config.maxVersion(c.isDTLS); version > maxVersion ***REMOVED***
			version = maxVersion
		***REMOVED***
		if version == 0 || !config.isSupportedVersion(version, c.isDTLS) ***REMOVED***
			return fmt.Errorf("tls: client offered an unsupported, maximum protocol version of %x", hs.clientHello.vers)
		***REMOVED***
		c.vers = version
	***REMOVED***
	c.haveVers = true

	// Reject < 1.2 ClientHellos with signature_algorithms.
	if clientVersion < VersionTLS12 && len(hs.clientHello.signatureAlgorithms) > 0 ***REMOVED***
		return fmt.Errorf("tls: client included signature_algorithms before TLS 1.2")
	***REMOVED***

	// Check the client cipher list is consistent with the version.
	if clientVersion < VersionTLS12 ***REMOVED***
		for _, id := range hs.clientHello.cipherSuites ***REMOVED***
			if isTLS12Cipher(id) ***REMOVED***
				return fmt.Errorf("tls: client offered TLS 1.2 cipher before TLS 1.2")
			***REMOVED***
		***REMOVED***
	***REMOVED***

	if config.Bugs.ExpectNoTLS12Session ***REMOVED***
		if len(hs.clientHello.sessionId) > 0 ***REMOVED***
			return fmt.Errorf("tls: client offered an unexpected session ID")
		***REMOVED***
		if len(hs.clientHello.sessionTicket) > 0 ***REMOVED***
			return fmt.Errorf("tls: client offered an unexpected session ticket")
		***REMOVED***
	***REMOVED***

	if config.Bugs.ExpectNoTLS13PSK && len(hs.clientHello.pskIdentities) > 0 ***REMOVED***
		return fmt.Errorf("tls: client offered unexpected PSK identities")
	***REMOVED***

	var scsvFound, greaseFound bool
	for _, cipherSuite := range hs.clientHello.cipherSuites ***REMOVED***
		if cipherSuite == fallbackSCSV ***REMOVED***
			scsvFound = true
		***REMOVED***
		if isGREASEValue(cipherSuite) ***REMOVED***
			greaseFound = true
		***REMOVED***
	***REMOVED***

	if !scsvFound && config.Bugs.FailIfNotFallbackSCSV ***REMOVED***
		return errors.New("tls: no fallback SCSV found when expected")
	***REMOVED*** else if scsvFound && !config.Bugs.FailIfNotFallbackSCSV ***REMOVED***
		return errors.New("tls: fallback SCSV found when not expected")
	***REMOVED***

	if !greaseFound && config.Bugs.ExpectGREASE ***REMOVED***
		return errors.New("tls: no GREASE cipher suite value found")
	***REMOVED***

	greaseFound = false
	for _, curve := range hs.clientHello.supportedCurves ***REMOVED***
		if isGREASEValue(uint16(curve)) ***REMOVED***
			greaseFound = true
			break
		***REMOVED***
	***REMOVED***

	if !greaseFound && config.Bugs.ExpectGREASE ***REMOVED***
		return errors.New("tls: no GREASE curve value found")
	***REMOVED***

	if len(hs.clientHello.keyShares) > 0 ***REMOVED***
		greaseFound = false
		for _, keyShare := range hs.clientHello.keyShares ***REMOVED***
			if isGREASEValue(uint16(keyShare.group)) ***REMOVED***
				greaseFound = true
				break
			***REMOVED***
		***REMOVED***

		if !greaseFound && config.Bugs.ExpectGREASE ***REMOVED***
			return errors.New("tls: no GREASE curve value found")
		***REMOVED***
	***REMOVED***

	if config.Bugs.IgnorePeerSignatureAlgorithmPreferences ***REMOVED***
		hs.clientHello.signatureAlgorithms = config.signSignatureAlgorithms()
	***REMOVED***
	if config.Bugs.IgnorePeerCurvePreferences ***REMOVED***
		hs.clientHello.supportedCurves = config.curvePreferences()
	***REMOVED***
	if config.Bugs.IgnorePeerCipherPreferences ***REMOVED***
		hs.clientHello.cipherSuites = config.cipherSuites()
	***REMOVED***

	return nil
***REMOVED***

func (hs *serverHandshakeState) doTLS13Handshake() error ***REMOVED***
	c := hs.c
	config := c.config

	hs.hello = &serverHelloMsg***REMOVED***
		isDTLS:          c.isDTLS,
		vers:            versionToWire(c.vers, c.isDTLS),
		versOverride:    config.Bugs.SendServerHelloVersion,
		customExtension: config.Bugs.CustomUnencryptedExtension,
		unencryptedALPN: config.Bugs.SendUnencryptedALPN,
		shortHeader:     hs.clientHello.shortHeaderSupported && config.Bugs.EnableShortHeader,
	***REMOVED***

	if config.Bugs.AlwaysNegotiateShortHeader ***REMOVED***
		hs.hello.shortHeader = true
	***REMOVED***

	if hs.hello.shortHeader ***REMOVED***
		c.setShortHeader()
	***REMOVED***

	hs.hello.random = make([]byte, 32)
	if _, err := io.ReadFull(config.rand(), hs.hello.random); err != nil ***REMOVED***
		c.sendAlert(alertInternalError)
		return err
	***REMOVED***

	// TLS 1.3 forbids clients from advertising any non-null compression.
	if len(hs.clientHello.compressionMethods) != 1 || hs.clientHello.compressionMethods[0] != compressionNone ***REMOVED***
		return errors.New("tls: client sent compression method other than null for TLS 1.3")
	***REMOVED***

	// Prepare an EncryptedExtensions message, but do not send it yet.
	encryptedExtensions := new(encryptedExtensionsMsg)
	encryptedExtensions.empty = config.Bugs.EmptyEncryptedExtensions
	if err := hs.processClientExtensions(&encryptedExtensions.extensions); err != nil ***REMOVED***
		return err
	***REMOVED***

	// Select the cipher suite.
	var preferenceList, supportedList []uint16
	if config.PreferServerCipherSuites ***REMOVED***
		preferenceList = config.cipherSuites()
		supportedList = hs.clientHello.cipherSuites
	***REMOVED*** else ***REMOVED***
		preferenceList = hs.clientHello.cipherSuites
		supportedList = config.cipherSuites()
	***REMOVED***

	for _, id := range preferenceList ***REMOVED***
		if hs.suite = c.tryCipherSuite(id, supportedList, c.vers, true, true); hs.suite != nil ***REMOVED***
			break
		***REMOVED***
	***REMOVED***

	if hs.suite == nil ***REMOVED***
		c.sendAlert(alertHandshakeFailure)
		return errors.New("tls: no cipher suite supported by both client and server")
	***REMOVED***

	hs.hello.cipherSuite = hs.suite.id
	if c.config.Bugs.SendCipherSuite != 0 ***REMOVED***
		hs.hello.cipherSuite = c.config.Bugs.SendCipherSuite
	***REMOVED***

	hs.finishedHash = newFinishedHash(c.vers, hs.suite)
	hs.finishedHash.discardHandshakeBuffer()
	hs.writeClientHash(hs.clientHello.marshal())

	supportedCurve := false
	var selectedCurve CurveID
	preferredCurves := config.curvePreferences()
Curves:
	for _, curve := range hs.clientHello.supportedCurves ***REMOVED***
		for _, supported := range preferredCurves ***REMOVED***
			if supported == curve ***REMOVED***
				supportedCurve = true
				selectedCurve = curve
				break Curves
			***REMOVED***
		***REMOVED***
	***REMOVED***

	if !supportedCurve ***REMOVED***
		c.sendAlert(alertHandshakeFailure)
		return errors.New("tls: no curve supported by both client and server")
	***REMOVED***

	pskIdentities := hs.clientHello.pskIdentities
	pskKEModes := hs.clientHello.pskKEModes

	if len(pskIdentities) == 0 && len(hs.clientHello.sessionTicket) > 0 && c.config.Bugs.AcceptAnySession ***REMOVED***
		psk := pskIdentity***REMOVED***
			ticket: hs.clientHello.sessionTicket,
		***REMOVED***
		pskIdentities = []pskIdentity***REMOVED***psk***REMOVED***
		pskKEModes = []byte***REMOVED***pskDHEKEMode***REMOVED***
	***REMOVED***

	var pskIndex int
	foundKEMode := bytes.IndexByte(pskKEModes, pskDHEKEMode) >= 0
	if foundKEMode ***REMOVED***
		for i, pskIdentity := range pskIdentities ***REMOVED***
			// TODO(svaldez): Check the obfuscatedTicketAge before accepting 0-RTT.
			sessionState, ok := c.decryptTicket(pskIdentity.ticket)
			if !ok ***REMOVED***
				continue
			***REMOVED***

			if !config.Bugs.AcceptAnySession ***REMOVED***
				if sessionState.vers != c.vers ***REMOVED***
					continue
				***REMOVED***
				if sessionState.ticketExpiration.Before(c.config.time()) ***REMOVED***
					continue
				***REMOVED***
				sessionCipher := cipherSuiteFromID(sessionState.cipherSuite)
				if sessionCipher == nil || sessionCipher.hash() != hs.suite.hash() ***REMOVED***
					continue
				***REMOVED***
			***REMOVED***

			clientTicketAge := time.Duration(uint32(pskIdentity.obfuscatedTicketAge-sessionState.ticketAgeAdd)) * time.Millisecond
			if config.Bugs.ExpectTicketAge != 0 && clientTicketAge != config.Bugs.ExpectTicketAge ***REMOVED***
				c.sendAlert(alertHandshakeFailure)
				return errors.New("tls: invalid ticket age")
			***REMOVED***

			hs.sessionState = sessionState
			hs.hello.hasPSKIdentity = true
			hs.hello.pskIdentity = uint16(i)
			pskIndex = i
			if config.Bugs.SelectPSKIdentityOnResume != 0 ***REMOVED***
				hs.hello.pskIdentity = config.Bugs.SelectPSKIdentityOnResume
			***REMOVED***
			c.didResume = true
			break
		***REMOVED***
	***REMOVED***

	if config.Bugs.AlwaysSelectPSKIdentity ***REMOVED***
		hs.hello.hasPSKIdentity = true
		hs.hello.pskIdentity = 0
	***REMOVED***

	// Verify the PSK binder. Note there may not be a PSK binder if
	// AcceptAnyBinder is set. See https://crbug.com/boringssl/115.
	if hs.sessionState != nil && !config.Bugs.AcceptAnySession ***REMOVED***
		binderToVerify := hs.clientHello.pskBinders[pskIndex]
		if err := verifyPSKBinder(hs.clientHello, hs.sessionState, binderToVerify, []byte***REMOVED******REMOVED***); err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	// Resolve PSK and compute the early secret.
	if hs.sessionState != nil ***REMOVED***
		hs.finishedHash.addEntropy(hs.sessionState.masterSecret)
	***REMOVED*** else ***REMOVED***
		hs.finishedHash.addEntropy(hs.finishedHash.zeroSecret())
	***REMOVED***

	hs.hello.hasKeyShare = true
	if hs.sessionState != nil && config.Bugs.NegotiatePSKResumption ***REMOVED***
		hs.hello.hasKeyShare = false
	***REMOVED***
	if config.Bugs.MissingKeyShare ***REMOVED***
		hs.hello.hasKeyShare = false
	***REMOVED***

	firstHelloRetryRequest := true

ResendHelloRetryRequest:
	var sendHelloRetryRequest bool
	helloRetryRequest := &helloRetryRequestMsg***REMOVED***
		vers:                versionToWire(c.vers, c.isDTLS),
		duplicateExtensions: config.Bugs.DuplicateHelloRetryRequestExtensions,
	***REMOVED***

	if config.Bugs.AlwaysSendHelloRetryRequest ***REMOVED***
		sendHelloRetryRequest = true
	***REMOVED***

	if config.Bugs.SendHelloRetryRequestCookie != nil ***REMOVED***
		sendHelloRetryRequest = true
		helloRetryRequest.cookie = config.Bugs.SendHelloRetryRequestCookie
	***REMOVED***

	if len(config.Bugs.CustomHelloRetryRequestExtension) > 0 ***REMOVED***
		sendHelloRetryRequest = true
		helloRetryRequest.customExtension = config.Bugs.CustomHelloRetryRequestExtension
	***REMOVED***

	var selectedKeyShare *keyShareEntry
	if hs.hello.hasKeyShare ***REMOVED***
		// Look for the key share corresponding to our selected curve.
		for i := range hs.clientHello.keyShares ***REMOVED***
			if hs.clientHello.keyShares[i].group == selectedCurve ***REMOVED***
				selectedKeyShare = &hs.clientHello.keyShares[i]
				break
			***REMOVED***
		***REMOVED***

		if config.Bugs.ExpectMissingKeyShare && selectedKeyShare != nil ***REMOVED***
			return errors.New("tls: expected missing key share")
		***REMOVED***

		if selectedKeyShare == nil ***REMOVED***
			helloRetryRequest.hasSelectedGroup = true
			helloRetryRequest.selectedGroup = selectedCurve
			sendHelloRetryRequest = true
		***REMOVED***
	***REMOVED***

	if config.Bugs.SendHelloRetryRequestCurve != 0 ***REMOVED***
		helloRetryRequest.hasSelectedGroup = true
		helloRetryRequest.selectedGroup = config.Bugs.SendHelloRetryRequestCurve
		sendHelloRetryRequest = true
	***REMOVED***

	if config.Bugs.SkipHelloRetryRequest ***REMOVED***
		sendHelloRetryRequest = false
	***REMOVED***

	if sendHelloRetryRequest ***REMOVED***
		oldClientHelloBytes := hs.clientHello.marshal()
		hs.writeServerHash(helloRetryRequest.marshal())
		c.writeRecord(recordTypeHandshake, helloRetryRequest.marshal())
		c.flushHandshake()

		// Read new ClientHello.
		newMsg, err := c.readHandshake()
		if err != nil ***REMOVED***
			return err
		***REMOVED***
		newClientHello, ok := newMsg.(*clientHelloMsg)
		if !ok ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return unexpectedMessageError(newClientHello, newMsg)
		***REMOVED***
		hs.writeClientHash(newClientHello.marshal())

		// Check that the new ClientHello matches the old ClientHello,
		// except for relevant modifications.
		//
		// TODO(davidben): Make this check more precise.
		oldClientHelloCopy := *hs.clientHello
		oldClientHelloCopy.raw = nil
		oldClientHelloCopy.hasEarlyData = false
		newClientHelloCopy := *newClientHello
		newClientHelloCopy.raw = nil

		if helloRetryRequest.hasSelectedGroup ***REMOVED***
			newKeyShares := newClientHelloCopy.keyShares
			if len(newKeyShares) != 1 || newKeyShares[0].group != helloRetryRequest.selectedGroup ***REMOVED***
				return errors.New("tls: KeyShare from HelloRetryRequest not in new ClientHello")
			***REMOVED***
			selectedKeyShare = &newKeyShares[0]
			newClientHelloCopy.keyShares = oldClientHelloCopy.keyShares
		***REMOVED***

		if len(helloRetryRequest.cookie) > 0 ***REMOVED***
			if !bytes.Equal(newClientHelloCopy.tls13Cookie, helloRetryRequest.cookie) ***REMOVED***
				return errors.New("tls: cookie from HelloRetryRequest not present in new ClientHello")
			***REMOVED***
			newClientHelloCopy.tls13Cookie = nil
		***REMOVED***

		// PSK binders and obfuscated ticket age are both updated in the
		// second ClientHello.
		if len(oldClientHelloCopy.pskIdentities) != len(newClientHelloCopy.pskIdentities) ***REMOVED***
			return errors.New("tls: PSK identity count from old and new ClientHello do not match")
		***REMOVED***
		for i, identity := range oldClientHelloCopy.pskIdentities ***REMOVED***
			newClientHelloCopy.pskIdentities[i].obfuscatedTicketAge = identity.obfuscatedTicketAge
		***REMOVED***
		newClientHelloCopy.pskBinders = oldClientHelloCopy.pskBinders

		if !oldClientHelloCopy.equal(&newClientHelloCopy) ***REMOVED***
			return errors.New("tls: new ClientHello does not match")
		***REMOVED***

		if firstHelloRetryRequest && config.Bugs.SecondHelloRetryRequest ***REMOVED***
			firstHelloRetryRequest = false
			goto ResendHelloRetryRequest
		***REMOVED***

		// Verify the PSK binder. Note there may not be a PSK binder if
		// AcceptAnyBinder is set. See https://crbug.com/115.
		if hs.sessionState != nil && !config.Bugs.AcceptAnySession ***REMOVED***
			binderToVerify := newClientHello.pskBinders[pskIndex]
			err := verifyPSKBinder(newClientHello, hs.sessionState, binderToVerify, append(oldClientHelloBytes, helloRetryRequest.marshal()...))
			if err != nil ***REMOVED***
				return err
			***REMOVED***
		***REMOVED***
	***REMOVED***

	// Decide whether or not to accept early data.
	// TODO(nharper): This does not check that ALPN or SNI matches.
	if hs.clientHello.hasEarlyData ***REMOVED***
		if !sendHelloRetryRequest && hs.sessionState != nil ***REMOVED***
			encryptedExtensions.extensions.hasEarlyData = true
			earlyTrafficSecret := hs.finishedHash.deriveSecret(earlyTrafficLabel)
			c.in.useTrafficSecret(c.vers, hs.suite, earlyTrafficSecret, clientWrite)

			for _, expectedMsg := range config.Bugs.ExpectEarlyData ***REMOVED***
				if err := c.readRecord(recordTypeApplicationData); err != nil ***REMOVED***
					return err
				***REMOVED***
				if !bytes.Equal(c.input.data[c.input.off:], expectedMsg) ***REMOVED***
					return errors.New("ExpectEarlyData: did not get expected message")
				***REMOVED***
				c.in.freeBlock(c.input)
				c.input = nil

			***REMOVED***
		***REMOVED*** else ***REMOVED***
			c.skipEarlyData = true
		***REMOVED***
	***REMOVED***

	// Resolve ECDHE and compute the handshake secret.
	if hs.hello.hasKeyShare ***REMOVED***
		// Once a curve has been selected and a key share identified,
		// the server needs to generate a public value and send it in
		// the ServerHello.
		curve, ok := curveForCurveID(selectedCurve)
		if !ok ***REMOVED***
			panic("tls: server failed to look up curve ID")
		***REMOVED***
		c.curveID = selectedCurve

		var peerKey []byte
		if config.Bugs.SkipHelloRetryRequest ***REMOVED***
			// If skipping HelloRetryRequest, use a random key to
			// avoid crashing.
			curve2, _ := curveForCurveID(selectedCurve)
			var err error
			peerKey, err = curve2.offer(config.rand())
			if err != nil ***REMOVED***
				return err
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			peerKey = selectedKeyShare.keyExchange
		***REMOVED***

		publicKey, ecdheSecret, err := curve.accept(config.rand(), peerKey)
		if err != nil ***REMOVED***
			c.sendAlert(alertHandshakeFailure)
			return err
		***REMOVED***
		hs.finishedHash.addEntropy(ecdheSecret)
		hs.hello.hasKeyShare = true

		curveID := selectedCurve
		if c.config.Bugs.SendCurve != 0 ***REMOVED***
			curveID = config.Bugs.SendCurve
		***REMOVED***
		if c.config.Bugs.InvalidECDHPoint ***REMOVED***
			publicKey[0] ^= 0xff
		***REMOVED***

		hs.hello.keyShare = keyShareEntry***REMOVED***
			group:       curveID,
			keyExchange: publicKey,
		***REMOVED***

		if config.Bugs.EncryptedExtensionsWithKeyShare ***REMOVED***
			encryptedExtensions.extensions.hasKeyShare = true
			encryptedExtensions.extensions.keyShare = keyShareEntry***REMOVED***
				group:       curveID,
				keyExchange: publicKey,
			***REMOVED***
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		hs.finishedHash.addEntropy(hs.finishedHash.zeroSecret())
	***REMOVED***

	// Send unencrypted ServerHello.
	hs.writeServerHash(hs.hello.marshal())
	if config.Bugs.PartialEncryptedExtensionsWithServerHello ***REMOVED***
		helloBytes := hs.hello.marshal()
		toWrite := make([]byte, 0, len(helloBytes)+1)
		toWrite = append(toWrite, helloBytes...)
		toWrite = append(toWrite, typeEncryptedExtensions)
		c.writeRecord(recordTypeHandshake, toWrite)
	***REMOVED*** else ***REMOVED***
		c.writeRecord(recordTypeHandshake, hs.hello.marshal())
	***REMOVED***
	c.flushHandshake()

	// Switch to handshake traffic keys.
	serverHandshakeTrafficSecret := hs.finishedHash.deriveSecret(serverHandshakeTrafficLabel)
	c.out.useTrafficSecret(c.vers, hs.suite, serverHandshakeTrafficSecret, serverWrite)
	// Derive handshake traffic read key, but don't switch yet.
	clientHandshakeTrafficSecret := hs.finishedHash.deriveSecret(clientHandshakeTrafficLabel)

	// Send EncryptedExtensions.
	hs.writeServerHash(encryptedExtensions.marshal())
	if config.Bugs.PartialEncryptedExtensionsWithServerHello ***REMOVED***
		// The first byte has already been sent.
		c.writeRecord(recordTypeHandshake, encryptedExtensions.marshal()[1:])
	***REMOVED*** else ***REMOVED***
		c.writeRecord(recordTypeHandshake, encryptedExtensions.marshal())
	***REMOVED***

	if hs.sessionState == nil ***REMOVED***
		if config.ClientAuth >= RequestClientCert ***REMOVED***
			// Request a client certificate
			certReq := &certificateRequestMsg***REMOVED***
				hasSignatureAlgorithm: true,
				hasRequestContext:     true,
				requestContext:        config.Bugs.SendRequestContext,
			***REMOVED***
			if !config.Bugs.NoSignatureAlgorithms ***REMOVED***
				certReq.signatureAlgorithms = config.verifySignatureAlgorithms()
			***REMOVED***

			// An empty list of certificateAuthorities signals to
			// the client that it may send any certificate in response
			// to our request. When we know the CAs we trust, then
			// we can send them down, so that the client can choose
			// an appropriate certificate to give to us.
			if config.ClientCAs != nil ***REMOVED***
				certReq.certificateAuthorities = config.ClientCAs.Subjects()
			***REMOVED***
			hs.writeServerHash(certReq.marshal())
			c.writeRecord(recordTypeHandshake, certReq.marshal())
		***REMOVED***

		certMsg := &certificateMsg***REMOVED***
			hasRequestContext: true,
		***REMOVED***
		if !config.Bugs.EmptyCertificateList ***REMOVED***
			for i, certData := range hs.cert.Certificate ***REMOVED***
				cert := certificateEntry***REMOVED***
					data: certData,
				***REMOVED***
				if i == 0 ***REMOVED***
					if hs.clientHello.ocspStapling ***REMOVED***
						cert.ocspResponse = hs.cert.OCSPStaple
					***REMOVED***
					if hs.clientHello.sctListSupported ***REMOVED***
						cert.sctList = hs.cert.SignedCertificateTimestampList
					***REMOVED***
					cert.duplicateExtensions = config.Bugs.SendDuplicateCertExtensions
					cert.extraExtension = config.Bugs.SendExtensionOnCertificate
				***REMOVED*** else ***REMOVED***
					if config.Bugs.SendOCSPOnIntermediates != nil ***REMOVED***
						cert.ocspResponse = config.Bugs.SendOCSPOnIntermediates
					***REMOVED***
					if config.Bugs.SendSCTOnIntermediates != nil ***REMOVED***
						cert.sctList = config.Bugs.SendSCTOnIntermediates
					***REMOVED***
				***REMOVED***
				certMsg.certificates = append(certMsg.certificates, cert)
			***REMOVED***
		***REMOVED***
		certMsgBytes := certMsg.marshal()
		hs.writeServerHash(certMsgBytes)
		c.writeRecord(recordTypeHandshake, certMsgBytes)

		certVerify := &certificateVerifyMsg***REMOVED***
			hasSignatureAlgorithm: true,
		***REMOVED***

		// Determine the hash to sign.
		privKey := hs.cert.PrivateKey

		var err error
		certVerify.signatureAlgorithm, err = selectSignatureAlgorithm(c.vers, privKey, config, hs.clientHello.signatureAlgorithms)
		if err != nil ***REMOVED***
			c.sendAlert(alertInternalError)
			return err
		***REMOVED***

		input := hs.finishedHash.certificateVerifyInput(serverCertificateVerifyContextTLS13)
		certVerify.signature, err = signMessage(c.vers, privKey, c.config, certVerify.signatureAlgorithm, input)
		if err != nil ***REMOVED***
			c.sendAlert(alertInternalError)
			return err
		***REMOVED***

		if config.Bugs.SendSignatureAlgorithm != 0 ***REMOVED***
			certVerify.signatureAlgorithm = config.Bugs.SendSignatureAlgorithm
		***REMOVED***

		hs.writeServerHash(certVerify.marshal())
		c.writeRecord(recordTypeHandshake, certVerify.marshal())
	***REMOVED*** else if hs.sessionState != nil ***REMOVED***
		// Pick up certificates from the session instead.
		if len(hs.sessionState.certificates) > 0 ***REMOVED***
			if _, err := hs.processCertsFromClient(hs.sessionState.certificates); err != nil ***REMOVED***
				return err
			***REMOVED***
		***REMOVED***
	***REMOVED***

	finished := new(finishedMsg)
	finished.verifyData = hs.finishedHash.serverSum(serverHandshakeTrafficSecret)
	if config.Bugs.BadFinished ***REMOVED***
		finished.verifyData[0]++
	***REMOVED***
	hs.writeServerHash(finished.marshal())
	c.writeRecord(recordTypeHandshake, finished.marshal())
	if c.config.Bugs.SendExtraFinished ***REMOVED***
		c.writeRecord(recordTypeHandshake, finished.marshal())
	***REMOVED***
	c.flushHandshake()

	// The various secrets do not incorporate the client's final leg, so
	// derive them now before updating the handshake context.
	hs.finishedHash.addEntropy(hs.finishedHash.zeroSecret())
	clientTrafficSecret := hs.finishedHash.deriveSecret(clientApplicationTrafficLabel)
	serverTrafficSecret := hs.finishedHash.deriveSecret(serverApplicationTrafficLabel)
	c.exporterSecret = hs.finishedHash.deriveSecret(exporterLabel)

	// Switch to application data keys on write. In particular, any alerts
	// from the client certificate are sent over these keys.
	c.out.useTrafficSecret(c.vers, hs.suite, serverTrafficSecret, serverWrite)

	// Send 0.5-RTT messages.
	for _, halfRTTMsg := range config.Bugs.SendHalfRTTData ***REMOVED***
		if _, err := c.writeRecord(recordTypeApplicationData, halfRTTMsg); err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	// Read end_of_early_data alert.
	if encryptedExtensions.extensions.hasEarlyData ***REMOVED***
		if err := c.readRecord(recordTypeAlert); err != errEndOfEarlyDataAlert ***REMOVED***
			if err == nil ***REMOVED***
				panic("readRecord(recordTypeAlert) returned nil")
			***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	// Switch input stream to handshake traffic keys.
	c.in.useTrafficSecret(c.vers, hs.suite, clientHandshakeTrafficSecret, clientWrite)

	// If we requested a client certificate, then the client must send a
	// certificate message, even if it's empty.
	if config.ClientAuth >= RequestClientCert ***REMOVED***
		msg, err := c.readHandshake()
		if err != nil ***REMOVED***
			return err
		***REMOVED***

		certMsg, ok := msg.(*certificateMsg)
		if !ok ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return unexpectedMessageError(certMsg, msg)
		***REMOVED***
		hs.writeClientHash(certMsg.marshal())

		if len(certMsg.certificates) == 0 ***REMOVED***
			// The client didn't actually send a certificate
			switch config.ClientAuth ***REMOVED***
			case RequireAnyClientCert, RequireAndVerifyClientCert:
				c.sendAlert(alertCertificateRequired)
				return errors.New("tls: client didn't provide a certificate")
			***REMOVED***
		***REMOVED***

		var certs [][]byte
		for _, cert := range certMsg.certificates ***REMOVED***
			certs = append(certs, cert.data)
			// OCSP responses and SCT lists are not negotiated in
			// client certificates.
			if cert.ocspResponse != nil || cert.sctList != nil ***REMOVED***
				c.sendAlert(alertUnsupportedExtension)
				return errors.New("tls: unexpected extensions in the client certificate")
			***REMOVED***
		***REMOVED***
		pub, err := hs.processCertsFromClient(certs)
		if err != nil ***REMOVED***
			return err
		***REMOVED***

		if len(c.peerCertificates) > 0 ***REMOVED***
			msg, err = c.readHandshake()
			if err != nil ***REMOVED***
				return err
			***REMOVED***

			certVerify, ok := msg.(*certificateVerifyMsg)
			if !ok ***REMOVED***
				c.sendAlert(alertUnexpectedMessage)
				return unexpectedMessageError(certVerify, msg)
			***REMOVED***

			c.peerSignatureAlgorithm = certVerify.signatureAlgorithm
			input := hs.finishedHash.certificateVerifyInput(clientCertificateVerifyContextTLS13)
			if err := verifyMessage(c.vers, pub, config, certVerify.signatureAlgorithm, input, certVerify.signature); err != nil ***REMOVED***
				c.sendAlert(alertBadCertificate)
				return err
			***REMOVED***
			hs.writeClientHash(certVerify.marshal())
		***REMOVED***
	***REMOVED***

	if encryptedExtensions.extensions.channelIDRequested ***REMOVED***
		msg, err := c.readHandshake()
		if err != nil ***REMOVED***
			return err
		***REMOVED***
		channelIDMsg, ok := msg.(*channelIDMsg)
		if !ok ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return unexpectedMessageError(channelIDMsg, msg)
		***REMOVED***
		channelIDHash := crypto.SHA256.New()
		channelIDHash.Write(hs.finishedHash.certificateVerifyInput(channelIDContextTLS13))
		channelID, err := verifyChannelIDMessage(channelIDMsg, channelIDHash.Sum(nil))
		if err != nil ***REMOVED***
			return err
		***REMOVED***
		c.channelID = channelID

		hs.writeClientHash(channelIDMsg.marshal())
	***REMOVED***

	// Read the client Finished message.
	msg, err := c.readHandshake()
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	clientFinished, ok := msg.(*finishedMsg)
	if !ok ***REMOVED***
		c.sendAlert(alertUnexpectedMessage)
		return unexpectedMessageError(clientFinished, msg)
	***REMOVED***

	verify := hs.finishedHash.clientSum(clientHandshakeTrafficSecret)
	if len(verify) != len(clientFinished.verifyData) ||
		subtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 ***REMOVED***
		c.sendAlert(alertHandshakeFailure)
		return errors.New("tls: client's Finished message was incorrect")
	***REMOVED***
	hs.writeClientHash(clientFinished.marshal())

	// Switch to application data keys on read.
	c.in.useTrafficSecret(c.vers, hs.suite, clientTrafficSecret, clientWrite)

	c.cipherSuite = hs.suite
	c.resumptionSecret = hs.finishedHash.deriveSecret(resumptionLabel)

	// TODO(davidben): Allow configuring the number of tickets sent for
	// testing.
	if !c.config.SessionTicketsDisabled && foundKEMode ***REMOVED***
		ticketCount := 2
		for i := 0; i < ticketCount; i++ ***REMOVED***
			c.SendNewSessionTicket()
		***REMOVED***
	***REMOVED***
	return nil
***REMOVED***

// processClientHello processes the ClientHello message from the client and
// decides whether we will perform session resumption.
func (hs *serverHandshakeState) processClientHello() (isResume bool, err error) ***REMOVED***
	config := hs.c.config
	c := hs.c

	hs.hello = &serverHelloMsg***REMOVED***
		isDTLS:            c.isDTLS,
		vers:              versionToWire(c.vers, c.isDTLS),
		versOverride:      config.Bugs.SendServerHelloVersion,
		compressionMethod: compressionNone,
		shortHeader:       config.Bugs.AlwaysNegotiateShortHeader,
	***REMOVED***

	hs.hello.random = make([]byte, 32)
	_, err = io.ReadFull(config.rand(), hs.hello.random)
	if err != nil ***REMOVED***
		c.sendAlert(alertInternalError)
		return false, err
	***REMOVED***
	// Signal downgrades in the server random, per draft-ietf-tls-tls13-16,
	// section 4.1.3.
	if c.vers <= VersionTLS12 && config.maxVersion(c.isDTLS) >= VersionTLS13 ***REMOVED***
		copy(hs.hello.random[len(hs.hello.random)-8:], downgradeTLS13)
	***REMOVED***
	if c.vers <= VersionTLS11 && config.maxVersion(c.isDTLS) == VersionTLS12 ***REMOVED***
		copy(hs.hello.random[len(hs.hello.random)-8:], downgradeTLS12)
	***REMOVED***

	foundCompression := false
	// We only support null compression, so check that the client offered it.
	for _, compression := range hs.clientHello.compressionMethods ***REMOVED***
		if compression == compressionNone ***REMOVED***
			foundCompression = true
			break
		***REMOVED***
	***REMOVED***

	if !foundCompression ***REMOVED***
		c.sendAlert(alertHandshakeFailure)
		return false, errors.New("tls: client does not support uncompressed connections")
	***REMOVED***

	if err := hs.processClientExtensions(&hs.hello.extensions); err != nil ***REMOVED***
		return false, err
	***REMOVED***

	supportedCurve := false
	preferredCurves := config.curvePreferences()
Curves:
	for _, curve := range hs.clientHello.supportedCurves ***REMOVED***
		for _, supported := range preferredCurves ***REMOVED***
			if supported == curve ***REMOVED***
				supportedCurve = true
				break Curves
			***REMOVED***
		***REMOVED***
	***REMOVED***

	supportedPointFormat := false
	for _, pointFormat := range hs.clientHello.supportedPoints ***REMOVED***
		if pointFormat == pointFormatUncompressed ***REMOVED***
			supportedPointFormat = true
			break
		***REMOVED***
	***REMOVED***
	hs.ellipticOk = supportedCurve && supportedPointFormat

	_, hs.ecdsaOk = hs.cert.PrivateKey.(*ecdsa.PrivateKey)

	// For test purposes, check that the peer never offers a session when
	// renegotiating.
	if c.cipherSuite != nil && len(hs.clientHello.sessionId) > 0 && c.config.Bugs.FailIfResumeOnRenego ***REMOVED***
		return false, errors.New("tls: offered resumption on renegotiation")
	***REMOVED***

	if c.config.Bugs.FailIfSessionOffered && (len(hs.clientHello.sessionTicket) > 0 || len(hs.clientHello.sessionId) > 0) ***REMOVED***
		return false, errors.New("tls: client offered a session ticket or ID")
	***REMOVED***

	if hs.checkForResumption() ***REMOVED***
		return true, nil
	***REMOVED***

	var preferenceList, supportedList []uint16
	if c.config.PreferServerCipherSuites ***REMOVED***
		preferenceList = c.config.cipherSuites()
		supportedList = hs.clientHello.cipherSuites
	***REMOVED*** else ***REMOVED***
		preferenceList = hs.clientHello.cipherSuites
		supportedList = c.config.cipherSuites()
	***REMOVED***

	for _, id := range preferenceList ***REMOVED***
		if hs.suite = c.tryCipherSuite(id, supportedList, c.vers, hs.ellipticOk, hs.ecdsaOk); hs.suite != nil ***REMOVED***
			break
		***REMOVED***
	***REMOVED***

	if hs.suite == nil ***REMOVED***
		c.sendAlert(alertHandshakeFailure)
		return false, errors.New("tls: no cipher suite supported by both client and server")
	***REMOVED***

	return false, nil
***REMOVED***

// processClientExtensions processes all ClientHello extensions not directly
// related to cipher suite negotiation and writes responses in serverExtensions.
func (hs *serverHandshakeState) processClientExtensions(serverExtensions *serverExtensions) error ***REMOVED***
	config := hs.c.config
	c := hs.c

	if c.vers < VersionTLS13 || config.Bugs.NegotiateRenegotiationInfoAtAllVersions ***REMOVED***
		if !bytes.Equal(c.clientVerify, hs.clientHello.secureRenegotiation) ***REMOVED***
			c.sendAlert(alertHandshakeFailure)
			return errors.New("tls: renegotiation mismatch")
		***REMOVED***

		if len(c.clientVerify) > 0 && !c.config.Bugs.EmptyRenegotiationInfo ***REMOVED***
			serverExtensions.secureRenegotiation = append(serverExtensions.secureRenegotiation, c.clientVerify...)
			serverExtensions.secureRenegotiation = append(serverExtensions.secureRenegotiation, c.serverVerify...)
			if c.config.Bugs.BadRenegotiationInfo ***REMOVED***
				serverExtensions.secureRenegotiation[0] ^= 0x80
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			serverExtensions.secureRenegotiation = hs.clientHello.secureRenegotiation
		***REMOVED***

		if c.noRenegotiationInfo() ***REMOVED***
			serverExtensions.secureRenegotiation = nil
		***REMOVED***
	***REMOVED***

	serverExtensions.duplicateExtension = c.config.Bugs.DuplicateExtension

	if len(hs.clientHello.serverName) > 0 ***REMOVED***
		c.serverName = hs.clientHello.serverName
	***REMOVED***
	if len(config.Certificates) == 0 ***REMOVED***
		c.sendAlert(alertInternalError)
		return errors.New("tls: no certificates configured")
	***REMOVED***
	hs.cert = &config.Certificates[0]
	if len(hs.clientHello.serverName) > 0 ***REMOVED***
		hs.cert = config.getCertificateForName(hs.clientHello.serverName)
	***REMOVED***
	if expected := c.config.Bugs.ExpectServerName; expected != "" && expected != hs.clientHello.serverName ***REMOVED***
		return errors.New("tls: unexpected server name")
	***REMOVED***

	if len(hs.clientHello.alpnProtocols) > 0 ***REMOVED***
		if proto := c.config.Bugs.ALPNProtocol; proto != nil ***REMOVED***
			serverExtensions.alpnProtocol = *proto
			serverExtensions.alpnProtocolEmpty = len(*proto) == 0
			c.clientProtocol = *proto
			c.usedALPN = true
		***REMOVED*** else if selectedProto, fallback := mutualProtocol(hs.clientHello.alpnProtocols, c.config.NextProtos); !fallback ***REMOVED***
			serverExtensions.alpnProtocol = selectedProto
			c.clientProtocol = selectedProto
			c.usedALPN = true
		***REMOVED***
	***REMOVED***

	if len(c.config.Bugs.SendALPN) > 0 ***REMOVED***
		serverExtensions.alpnProtocol = c.config.Bugs.SendALPN
	***REMOVED***

	if c.vers < VersionTLS13 || config.Bugs.NegotiateNPNAtAllVersions ***REMOVED***
		if len(hs.clientHello.alpnProtocols) == 0 || c.config.Bugs.NegotiateALPNAndNPN ***REMOVED***
			// Although sending an empty NPN extension is reasonable, Firefox has
			// had a bug around this. Best to send nothing at all if
			// config.NextProtos is empty. See
			// https://code.google.com/p/go/issues/detail?id=5445.
			if hs.clientHello.nextProtoNeg && len(config.NextProtos) > 0 ***REMOVED***
				serverExtensions.nextProtoNeg = true
				serverExtensions.nextProtos = config.NextProtos
				serverExtensions.npnAfterAlpn = config.Bugs.SwapNPNAndALPN
			***REMOVED***
		***REMOVED***
	***REMOVED***

	if c.vers < VersionTLS13 || config.Bugs.NegotiateEMSAtAllVersions ***REMOVED***
		disableEMS := config.Bugs.NoExtendedMasterSecret
		if c.cipherSuite != nil ***REMOVED***
			disableEMS = config.Bugs.NoExtendedMasterSecretOnRenegotiation
		***REMOVED***
		serverExtensions.extendedMasterSecret = c.vers >= VersionTLS10 && hs.clientHello.extendedMasterSecret && !disableEMS
	***REMOVED***

	if hs.clientHello.channelIDSupported && config.RequestChannelID ***REMOVED***
		serverExtensions.channelIDRequested = true
	***REMOVED***

	if hs.clientHello.srtpProtectionProfiles != nil ***REMOVED***
	SRTPLoop:
		for _, p1 := range c.config.SRTPProtectionProfiles ***REMOVED***
			for _, p2 := range hs.clientHello.srtpProtectionProfiles ***REMOVED***
				if p1 == p2 ***REMOVED***
					serverExtensions.srtpProtectionProfile = p1
					c.srtpProtectionProfile = p1
					break SRTPLoop
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***

	if c.config.Bugs.SendSRTPProtectionProfile != 0 ***REMOVED***
		serverExtensions.srtpProtectionProfile = c.config.Bugs.SendSRTPProtectionProfile
	***REMOVED***

	if expected := c.config.Bugs.ExpectedCustomExtension; expected != nil ***REMOVED***
		if hs.clientHello.customExtension != *expected ***REMOVED***
			return fmt.Errorf("tls: bad custom extension contents %q", hs.clientHello.customExtension)
		***REMOVED***
	***REMOVED***
	serverExtensions.customExtension = config.Bugs.CustomExtension

	if c.config.Bugs.AdvertiseTicketExtension ***REMOVED***
		serverExtensions.ticketSupported = true
	***REMOVED***

	if c.config.Bugs.SendSupportedPointFormats != nil ***REMOVED***
		serverExtensions.supportedPoints = c.config.Bugs.SendSupportedPointFormats
	***REMOVED***

	if !hs.clientHello.hasGREASEExtension && config.Bugs.ExpectGREASE ***REMOVED***
		return errors.New("tls: no GREASE extension found")
	***REMOVED***

	serverExtensions.serverNameAck = c.config.Bugs.SendServerNameAck

	return nil
***REMOVED***

// checkForResumption returns true if we should perform resumption on this connection.
func (hs *serverHandshakeState) checkForResumption() bool ***REMOVED***
	c := hs.c

	ticket := hs.clientHello.sessionTicket
	if len(ticket) == 0 && len(hs.clientHello.pskIdentities) > 0 && c.config.Bugs.AcceptAnySession ***REMOVED***
		ticket = hs.clientHello.pskIdentities[0].ticket
	***REMOVED***
	if len(ticket) > 0 ***REMOVED***
		if c.config.SessionTicketsDisabled ***REMOVED***
			return false
		***REMOVED***

		var ok bool
		if hs.sessionState, ok = c.decryptTicket(ticket); !ok ***REMOVED***
			return false
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		if c.config.ServerSessionCache == nil ***REMOVED***
			return false
		***REMOVED***

		var ok bool
		sessionId := string(hs.clientHello.sessionId)
		if hs.sessionState, ok = c.config.ServerSessionCache.Get(sessionId); !ok ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***

	if c.config.Bugs.AcceptAnySession ***REMOVED***
		// Replace the cipher suite with one known to work, to test
		// cross-version resumption attempts.
		hs.sessionState.cipherSuite = TLS_RSA_WITH_AES_128_CBC_SHA
	***REMOVED*** else ***REMOVED***
		// Never resume a session for a different SSL version.
		if c.vers != hs.sessionState.vers ***REMOVED***
			return false
		***REMOVED***

		cipherSuiteOk := false
		// Check that the client is still offering the ciphersuite in the session.
		for _, id := range hs.clientHello.cipherSuites ***REMOVED***
			if id == hs.sessionState.cipherSuite ***REMOVED***
				cipherSuiteOk = true
				break
			***REMOVED***
		***REMOVED***
		if !cipherSuiteOk ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***

	// Check that we also support the ciphersuite from the session.
	hs.suite = c.tryCipherSuite(hs.sessionState.cipherSuite, c.config.cipherSuites(), c.vers, hs.ellipticOk, hs.ecdsaOk)

	if hs.suite == nil ***REMOVED***
		return false
	***REMOVED***

	sessionHasClientCerts := len(hs.sessionState.certificates) != 0
	needClientCerts := c.config.ClientAuth == RequireAnyClientCert || c.config.ClientAuth == RequireAndVerifyClientCert
	if needClientCerts && !sessionHasClientCerts ***REMOVED***
		return false
	***REMOVED***
	if sessionHasClientCerts && c.config.ClientAuth == NoClientCert ***REMOVED***
		return false
	***REMOVED***

	return true
***REMOVED***

func (hs *serverHandshakeState) doResumeHandshake() error ***REMOVED***
	c := hs.c

	hs.hello.cipherSuite = hs.suite.id
	if c.config.Bugs.SendCipherSuite != 0 ***REMOVED***
		hs.hello.cipherSuite = c.config.Bugs.SendCipherSuite
	***REMOVED***
	// We echo the client's session ID in the ServerHello to let it know
	// that we're doing a resumption.
	hs.hello.sessionId = hs.clientHello.sessionId
	hs.hello.extensions.ticketSupported = c.config.Bugs.RenewTicketOnResume

	if c.config.Bugs.SendSCTListOnResume != nil ***REMOVED***
		hs.hello.extensions.sctList = c.config.Bugs.SendSCTListOnResume
	***REMOVED***

	if c.config.Bugs.SendOCSPResponseOnResume != nil ***REMOVED***
		// There is no way, syntactically, to send an OCSP response on a
		// resumption handshake.
		hs.hello.extensions.ocspStapling = true
	***REMOVED***

	hs.finishedHash = newFinishedHash(c.vers, hs.suite)
	hs.finishedHash.discardHandshakeBuffer()
	hs.writeClientHash(hs.clientHello.marshal())
	hs.writeServerHash(hs.hello.marshal())

	c.writeRecord(recordTypeHandshake, hs.hello.marshal())

	if len(hs.sessionState.certificates) > 0 ***REMOVED***
		if _, err := hs.processCertsFromClient(hs.sessionState.certificates); err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	hs.masterSecret = hs.sessionState.masterSecret
	c.extendedMasterSecret = hs.sessionState.extendedMasterSecret

	return nil
***REMOVED***

func (hs *serverHandshakeState) doFullHandshake() error ***REMOVED***
	config := hs.c.config
	c := hs.c

	isPSK := hs.suite.flags&suitePSK != 0
	if !isPSK && hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0 ***REMOVED***
		hs.hello.extensions.ocspStapling = true
	***REMOVED***

	if hs.clientHello.sctListSupported && len(hs.cert.SignedCertificateTimestampList) > 0 ***REMOVED***
		hs.hello.extensions.sctList = hs.cert.SignedCertificateTimestampList
	***REMOVED***

	hs.hello.extensions.ticketSupported = hs.clientHello.ticketSupported && !config.SessionTicketsDisabled && c.vers > VersionSSL30
	hs.hello.cipherSuite = hs.suite.id
	if config.Bugs.SendCipherSuite != 0 ***REMOVED***
		hs.hello.cipherSuite = config.Bugs.SendCipherSuite
	***REMOVED***
	c.extendedMasterSecret = hs.hello.extensions.extendedMasterSecret

	// Generate a session ID if we're to save the session.
	if !hs.hello.extensions.ticketSupported && config.ServerSessionCache != nil ***REMOVED***
		hs.hello.sessionId = make([]byte, 32)
		if _, err := io.ReadFull(config.rand(), hs.hello.sessionId); err != nil ***REMOVED***
			c.sendAlert(alertInternalError)
			return errors.New("tls: short read from Rand: " + err.Error())
		***REMOVED***
	***REMOVED***

	hs.finishedHash = newFinishedHash(c.vers, hs.suite)
	hs.writeClientHash(hs.clientHello.marshal())
	hs.writeServerHash(hs.hello.marshal())

	if config.Bugs.SendSNIWarningAlert ***REMOVED***
		c.SendAlert(alertLevelWarning, alertUnrecognizedName)
	***REMOVED***

	c.writeRecord(recordTypeHandshake, hs.hello.marshal())

	if !isPSK ***REMOVED***
		certMsg := new(certificateMsg)
		if !config.Bugs.EmptyCertificateList ***REMOVED***
			for _, certData := range hs.cert.Certificate ***REMOVED***
				certMsg.certificates = append(certMsg.certificates, certificateEntry***REMOVED***
					data: certData,
				***REMOVED***)
			***REMOVED***
		***REMOVED***
		if !config.Bugs.UnauthenticatedECDH ***REMOVED***
			certMsgBytes := certMsg.marshal()
			hs.writeServerHash(certMsgBytes)
			c.writeRecord(recordTypeHandshake, certMsgBytes)
		***REMOVED***
	***REMOVED***

	if hs.hello.extensions.ocspStapling && !c.config.Bugs.SkipCertificateStatus ***REMOVED***
		certStatus := new(certificateStatusMsg)
		certStatus.statusType = statusTypeOCSP
		certStatus.response = hs.cert.OCSPStaple
		hs.writeServerHash(certStatus.marshal())
		c.writeRecord(recordTypeHandshake, certStatus.marshal())
	***REMOVED***

	keyAgreement := hs.suite.ka(c.vers)
	skx, err := keyAgreement.generateServerKeyExchange(config, hs.cert, hs.clientHello, hs.hello)
	if err != nil ***REMOVED***
		c.sendAlert(alertHandshakeFailure)
		return err
	***REMOVED***
	if ecdhe, ok := keyAgreement.(*ecdheKeyAgreement); ok ***REMOVED***
		c.curveID = ecdhe.curveID
	***REMOVED***
	if skx != nil && !config.Bugs.SkipServerKeyExchange ***REMOVED***
		hs.writeServerHash(skx.marshal())
		c.writeRecord(recordTypeHandshake, skx.marshal())
	***REMOVED***

	if config.ClientAuth >= RequestClientCert ***REMOVED***
		// Request a client certificate
		certReq := &certificateRequestMsg***REMOVED***
			certificateTypes: config.ClientCertificateTypes,
		***REMOVED***
		if certReq.certificateTypes == nil ***REMOVED***
			certReq.certificateTypes = []byte***REMOVED***
				byte(CertTypeRSASign),
				byte(CertTypeECDSASign),
			***REMOVED***
		***REMOVED***
		if c.vers >= VersionTLS12 ***REMOVED***
			certReq.hasSignatureAlgorithm = true
			if !config.Bugs.NoSignatureAlgorithms ***REMOVED***
				certReq.signatureAlgorithms = config.verifySignatureAlgorithms()
			***REMOVED***
		***REMOVED***

		// An empty list of certificateAuthorities signals to
		// the client that it may send any certificate in response
		// to our request. When we know the CAs we trust, then
		// we can send them down, so that the client can choose
		// an appropriate certificate to give to us.
		if config.ClientCAs != nil ***REMOVED***
			certReq.certificateAuthorities = config.ClientCAs.Subjects()
		***REMOVED***
		hs.writeServerHash(certReq.marshal())
		c.writeRecord(recordTypeHandshake, certReq.marshal())
	***REMOVED***

	helloDone := new(serverHelloDoneMsg)
	hs.writeServerHash(helloDone.marshal())
	c.writeRecord(recordTypeHandshake, helloDone.marshal())
	c.flushHandshake()

	var pub crypto.PublicKey // public key for client auth, if any

	if err := c.simulatePacketLoss(nil); err != nil ***REMOVED***
		return err
	***REMOVED***
	msg, err := c.readHandshake()
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	var ok bool
	// If we requested a client certificate, then the client must send a
	// certificate message, even if it's empty.
	if config.ClientAuth >= RequestClientCert ***REMOVED***
		var certMsg *certificateMsg
		var certificates [][]byte
		if certMsg, ok = msg.(*certificateMsg); ok ***REMOVED***
			if c.vers == VersionSSL30 && len(certMsg.certificates) == 0 ***REMOVED***
				return errors.New("tls: empty certificate message in SSL 3.0")
			***REMOVED***

			hs.writeClientHash(certMsg.marshal())
			for _, cert := range certMsg.certificates ***REMOVED***
				certificates = append(certificates, cert.data)
			***REMOVED***
		***REMOVED*** else if c.vers == VersionSSL30 ***REMOVED***
			// In SSL 3.0, no certificate is signaled by a warning
			// alert which we translate to ssl3NoCertificateMsg.
			if _, ok := msg.(*ssl3NoCertificateMsg); !ok ***REMOVED***
				return errors.New("tls: client provided neither a certificate nor no_certificate warning alert")
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			// In TLS, the Certificate message is required. In SSL
			// 3.0, the peer skips it when sending no certificates.
			c.sendAlert(alertUnexpectedMessage)
			return unexpectedMessageError(certMsg, msg)
		***REMOVED***

		if len(certificates) == 0 ***REMOVED***
			// The client didn't actually send a certificate
			switch config.ClientAuth ***REMOVED***
			case RequireAnyClientCert, RequireAndVerifyClientCert:
				c.sendAlert(alertBadCertificate)
				return errors.New("tls: client didn't provide a certificate")
			***REMOVED***
		***REMOVED***

		pub, err = hs.processCertsFromClient(certificates)
		if err != nil ***REMOVED***
			return err
		***REMOVED***

		msg, err = c.readHandshake()
		if err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	// Get client key exchange
	ckx, ok := msg.(*clientKeyExchangeMsg)
	if !ok ***REMOVED***
		c.sendAlert(alertUnexpectedMessage)
		return unexpectedMessageError(ckx, msg)
	***REMOVED***
	hs.writeClientHash(ckx.marshal())

	preMasterSecret, err := keyAgreement.processClientKeyExchange(config, hs.cert, ckx, c.vers)
	if err != nil ***REMOVED***
		c.sendAlert(alertHandshakeFailure)
		return err
	***REMOVED***
	if c.extendedMasterSecret ***REMOVED***
		hs.masterSecret = extendedMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.finishedHash)
	***REMOVED*** else ***REMOVED***
		if c.config.Bugs.RequireExtendedMasterSecret ***REMOVED***
			return errors.New("tls: extended master secret required but not supported by peer")
		***REMOVED***
		hs.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.clientHello.random, hs.hello.random)
	***REMOVED***

	// If we received a client cert in response to our certificate request message,
	// the client will send us a certificateVerifyMsg immediately after the
	// clientKeyExchangeMsg.  This message is a digest of all preceding
	// handshake-layer messages that is signed using the private key corresponding
	// to the client's certificate. This allows us to verify that the client is in
	// possession of the private key of the certificate.
	if len(c.peerCertificates) > 0 ***REMOVED***
		msg, err = c.readHandshake()
		if err != nil ***REMOVED***
			return err
		***REMOVED***
		certVerify, ok := msg.(*certificateVerifyMsg)
		if !ok ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return unexpectedMessageError(certVerify, msg)
		***REMOVED***

		// Determine the signature type.
		var sigAlg signatureAlgorithm
		if certVerify.hasSignatureAlgorithm ***REMOVED***
			sigAlg = certVerify.signatureAlgorithm
			c.peerSignatureAlgorithm = sigAlg
		***REMOVED***

		if c.vers > VersionSSL30 ***REMOVED***
			err = verifyMessage(c.vers, pub, c.config, sigAlg, hs.finishedHash.buffer, certVerify.signature)
		***REMOVED*** else ***REMOVED***
			// SSL 3.0's client certificate construction is
			// incompatible with signatureAlgorithm.
			rsaPub, ok := pub.(*rsa.PublicKey)
			if !ok ***REMOVED***
				err = errors.New("unsupported key type for client certificate")
			***REMOVED*** else ***REMOVED***
				digest := hs.finishedHash.hashForClientCertificateSSL3(hs.masterSecret)
				err = rsa.VerifyPKCS1v15(rsaPub, crypto.MD5SHA1, digest, certVerify.signature)
			***REMOVED***
		***REMOVED***
		if err != nil ***REMOVED***
			c.sendAlert(alertBadCertificate)
			return errors.New("could not validate signature of connection nonces: " + err.Error())
		***REMOVED***

		hs.writeClientHash(certVerify.marshal())
	***REMOVED***

	hs.finishedHash.discardHandshakeBuffer()

	return nil
***REMOVED***

func (hs *serverHandshakeState) establishKeys() error ***REMOVED***
	c := hs.c

	clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
		keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen(c.vers))

	var clientCipher, serverCipher interface***REMOVED******REMOVED***
	var clientHash, serverHash macFunction

	if hs.suite.aead == nil ***REMOVED***
		clientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)
		clientHash = hs.suite.mac(c.vers, clientMAC)
		serverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */)
		serverHash = hs.suite.mac(c.vers, serverMAC)
	***REMOVED*** else ***REMOVED***
		clientCipher = hs.suite.aead(c.vers, clientKey, clientIV)
		serverCipher = hs.suite.aead(c.vers, serverKey, serverIV)
	***REMOVED***

	c.in.prepareCipherSpec(c.vers, clientCipher, clientHash)
	c.out.prepareCipherSpec(c.vers, serverCipher, serverHash)

	return nil
***REMOVED***

func (hs *serverHandshakeState) readFinished(out []byte, isResume bool) error ***REMOVED***
	c := hs.c

	c.readRecord(recordTypeChangeCipherSpec)
	if err := c.in.error(); err != nil ***REMOVED***
		return err
	***REMOVED***

	if hs.hello.extensions.nextProtoNeg ***REMOVED***
		msg, err := c.readHandshake()
		if err != nil ***REMOVED***
			return err
		***REMOVED***
		nextProto, ok := msg.(*nextProtoMsg)
		if !ok ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return unexpectedMessageError(nextProto, msg)
		***REMOVED***
		hs.writeClientHash(nextProto.marshal())
		c.clientProtocol = nextProto.proto
	***REMOVED***

	if hs.hello.extensions.channelIDRequested ***REMOVED***
		msg, err := c.readHandshake()
		if err != nil ***REMOVED***
			return err
		***REMOVED***
		channelIDMsg, ok := msg.(*channelIDMsg)
		if !ok ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return unexpectedMessageError(channelIDMsg, msg)
		***REMOVED***
		var resumeHash []byte
		if isResume ***REMOVED***
			resumeHash = hs.sessionState.handshakeHash
		***REMOVED***
		channelID, err := verifyChannelIDMessage(channelIDMsg, hs.finishedHash.hashForChannelID(resumeHash))
		if err != nil ***REMOVED***
			return err
		***REMOVED***
		c.channelID = channelID

		hs.writeClientHash(channelIDMsg.marshal())
	***REMOVED***

	msg, err := c.readHandshake()
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	clientFinished, ok := msg.(*finishedMsg)
	if !ok ***REMOVED***
		c.sendAlert(alertUnexpectedMessage)
		return unexpectedMessageError(clientFinished, msg)
	***REMOVED***

	verify := hs.finishedHash.clientSum(hs.masterSecret)
	if len(verify) != len(clientFinished.verifyData) ||
		subtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 ***REMOVED***
		c.sendAlert(alertHandshakeFailure)
		return errors.New("tls: client's Finished message is incorrect")
	***REMOVED***
	c.clientVerify = append(c.clientVerify[:0], clientFinished.verifyData...)
	copy(out, clientFinished.verifyData)

	hs.writeClientHash(clientFinished.marshal())
	return nil
***REMOVED***

func (hs *serverHandshakeState) sendSessionTicket() error ***REMOVED***
	c := hs.c
	state := sessionState***REMOVED***
		vers:          c.vers,
		cipherSuite:   hs.suite.id,
		masterSecret:  hs.masterSecret,
		certificates:  hs.certsFromClient,
		handshakeHash: hs.finishedHash.Sum(),
	***REMOVED***

	if !hs.hello.extensions.ticketSupported || hs.c.config.Bugs.SkipNewSessionTicket ***REMOVED***
		if c.config.ServerSessionCache != nil && len(hs.hello.sessionId) != 0 ***REMOVED***
			c.config.ServerSessionCache.Put(string(hs.hello.sessionId), &state)
		***REMOVED***
		return nil
	***REMOVED***

	m := new(newSessionTicketMsg)
	if c.config.Bugs.SendTicketLifetime != 0 ***REMOVED***
		m.ticketLifetime = uint32(c.config.Bugs.SendTicketLifetime / time.Second)
	***REMOVED***

	if !c.config.Bugs.SendEmptySessionTicket ***REMOVED***
		var err error
		m.ticket, err = c.encryptTicket(&state)
		if err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	hs.writeServerHash(m.marshal())
	c.writeRecord(recordTypeHandshake, m.marshal())

	return nil
***REMOVED***

func (hs *serverHandshakeState) sendFinished(out []byte) error ***REMOVED***
	c := hs.c

	finished := new(finishedMsg)
	finished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)
	copy(out, finished.verifyData)
	if c.config.Bugs.BadFinished ***REMOVED***
		finished.verifyData[0]++
	***REMOVED***
	c.serverVerify = append(c.serverVerify[:0], finished.verifyData...)
	hs.finishedBytes = finished.marshal()
	hs.writeServerHash(hs.finishedBytes)
	postCCSBytes := hs.finishedBytes

	if c.config.Bugs.FragmentAcrossChangeCipherSpec ***REMOVED***
		c.writeRecord(recordTypeHandshake, postCCSBytes[:5])
		postCCSBytes = postCCSBytes[5:]
	***REMOVED*** else if c.config.Bugs.SendUnencryptedFinished ***REMOVED***
		c.writeRecord(recordTypeHandshake, postCCSBytes)
		postCCSBytes = nil
	***REMOVED***
	c.flushHandshake()

	if !c.config.Bugs.SkipChangeCipherSpec ***REMOVED***
		ccs := []byte***REMOVED***1***REMOVED***
		if c.config.Bugs.BadChangeCipherSpec != nil ***REMOVED***
			ccs = c.config.Bugs.BadChangeCipherSpec
		***REMOVED***
		c.writeRecord(recordTypeChangeCipherSpec, ccs)
	***REMOVED***

	if c.config.Bugs.AppDataAfterChangeCipherSpec != nil ***REMOVED***
		c.writeRecord(recordTypeApplicationData, c.config.Bugs.AppDataAfterChangeCipherSpec)
	***REMOVED***
	if c.config.Bugs.AlertAfterChangeCipherSpec != 0 ***REMOVED***
		c.sendAlert(c.config.Bugs.AlertAfterChangeCipherSpec)
		return errors.New("tls: simulating post-CCS alert")
	***REMOVED***

	if !c.config.Bugs.SkipFinished && len(postCCSBytes) > 0 ***REMOVED***
		c.writeRecord(recordTypeHandshake, postCCSBytes)
		if c.config.Bugs.SendExtraFinished ***REMOVED***
			c.writeRecord(recordTypeHandshake, finished.marshal())
		***REMOVED***

		if !c.config.Bugs.PackHelloRequestWithFinished ***REMOVED***
			// Defer flushing until renegotiation.
			c.flushHandshake()
		***REMOVED***
	***REMOVED***

	c.cipherSuite = hs.suite

	return nil
***REMOVED***

// processCertsFromClient takes a chain of client certificates either from a
// Certificates message or from a sessionState and verifies them. It returns
// the public key of the leaf certificate.
func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (crypto.PublicKey, error) ***REMOVED***
	c := hs.c

	hs.certsFromClient = certificates
	certs := make([]*x509.Certificate, len(certificates))
	var err error
	for i, asn1Data := range certificates ***REMOVED***
		if certs[i], err = x509.ParseCertificate(asn1Data); err != nil ***REMOVED***
			c.sendAlert(alertBadCertificate)
			return nil, errors.New("tls: failed to parse client certificate: " + err.Error())
		***REMOVED***
	***REMOVED***

	if c.config.ClientAuth >= VerifyClientCertIfGiven && len(certs) > 0 ***REMOVED***
		opts := x509.VerifyOptions***REMOVED***
			Roots:         c.config.ClientCAs,
			CurrentTime:   c.config.time(),
			Intermediates: x509.NewCertPool(),
			KeyUsages:     []x509.ExtKeyUsage***REMOVED***x509.ExtKeyUsageClientAuth***REMOVED***,
		***REMOVED***

		for _, cert := range certs[1:] ***REMOVED***
			opts.Intermediates.AddCert(cert)
		***REMOVED***

		chains, err := certs[0].Verify(opts)
		if err != nil ***REMOVED***
			c.sendAlert(alertBadCertificate)
			return nil, errors.New("tls: failed to verify client's certificate: " + err.Error())
		***REMOVED***

		ok := false
		for _, ku := range certs[0].ExtKeyUsage ***REMOVED***
			if ku == x509.ExtKeyUsageClientAuth ***REMOVED***
				ok = true
				break
			***REMOVED***
		***REMOVED***
		if !ok ***REMOVED***
			c.sendAlert(alertHandshakeFailure)
			return nil, errors.New("tls: client's certificate's extended key usage doesn't permit it to be used for client authentication")
		***REMOVED***

		c.verifiedChains = chains
	***REMOVED***

	if len(certs) > 0 ***REMOVED***
		var pub crypto.PublicKey
		switch key := certs[0].PublicKey.(type) ***REMOVED***
		case *ecdsa.PublicKey, *rsa.PublicKey:
			pub = key
		default:
			c.sendAlert(alertUnsupportedCertificate)
			return nil, fmt.Errorf("tls: client's certificate contains an unsupported public key of type %T", certs[0].PublicKey)
		***REMOVED***
		c.peerCertificates = certs
		return pub, nil
	***REMOVED***

	return nil, nil
***REMOVED***

func verifyChannelIDMessage(channelIDMsg *channelIDMsg, channelIDHash []byte) (*ecdsa.PublicKey, error) ***REMOVED***
	x := new(big.Int).SetBytes(channelIDMsg.channelID[0:32])
	y := new(big.Int).SetBytes(channelIDMsg.channelID[32:64])
	r := new(big.Int).SetBytes(channelIDMsg.channelID[64:96])
	s := new(big.Int).SetBytes(channelIDMsg.channelID[96:128])
	if !elliptic.P256().IsOnCurve(x, y) ***REMOVED***
		return nil, errors.New("tls: invalid channel ID public key")
	***REMOVED***
	channelID := &ecdsa.PublicKey***REMOVED***elliptic.P256(), x, y***REMOVED***
	if !ecdsa.Verify(channelID, channelIDHash, r, s) ***REMOVED***
		return nil, errors.New("tls: invalid channel ID signature")
	***REMOVED***
	return channelID, nil
***REMOVED***

func (hs *serverHandshakeState) writeServerHash(msg []byte) ***REMOVED***
	// writeServerHash is called before writeRecord.
	hs.writeHash(msg, hs.c.sendHandshakeSeq)
***REMOVED***

func (hs *serverHandshakeState) writeClientHash(msg []byte) ***REMOVED***
	// writeClientHash is called after readHandshake.
	hs.writeHash(msg, hs.c.recvHandshakeSeq-1)
***REMOVED***

func (hs *serverHandshakeState) writeHash(msg []byte, seqno uint16) ***REMOVED***
	if hs.c.isDTLS ***REMOVED***
		// This is somewhat hacky. DTLS hashes a slightly different format.
		// First, the TLS header.
		hs.finishedHash.Write(msg[:4])
		// Then the sequence number and reassembled fragment offset (always 0).
		hs.finishedHash.Write([]byte***REMOVED***byte(seqno >> 8), byte(seqno), 0, 0, 0***REMOVED***)
		// Then the reassembled fragment (always equal to the message length).
		hs.finishedHash.Write(msg[1:4])
		// And then the message body.
		hs.finishedHash.Write(msg[4:])
	***REMOVED*** else ***REMOVED***
		hs.finishedHash.Write(msg)
	***REMOVED***
***REMOVED***

// tryCipherSuite returns a cipherSuite with the given id if that cipher suite
// is acceptable to use.
func (c *Conn) tryCipherSuite(id uint16, supportedCipherSuites []uint16, version uint16, ellipticOk, ecdsaOk bool) *cipherSuite ***REMOVED***
	for _, supported := range supportedCipherSuites ***REMOVED***
		if id == supported ***REMOVED***
			var candidate *cipherSuite

			for _, s := range cipherSuites ***REMOVED***
				if s.id == id ***REMOVED***
					candidate = s
					break
				***REMOVED***
			***REMOVED***
			if candidate == nil ***REMOVED***
				continue
			***REMOVED***

			// Don't select a ciphersuite which we can't
			// support for this client.
			if version >= VersionTLS13 || candidate.flags&suiteTLS13 != 0 ***REMOVED***
				if version < VersionTLS13 || candidate.flags&suiteTLS13 == 0 ***REMOVED***
					continue
				***REMOVED***
				return candidate
			***REMOVED***
			if (candidate.flags&suiteECDHE != 0) && !ellipticOk ***REMOVED***
				continue
			***REMOVED***
			if (candidate.flags&suiteECDSA != 0) != ecdsaOk ***REMOVED***
				continue
			***REMOVED***
			if version < VersionTLS12 && candidate.flags&suiteTLS12 != 0 ***REMOVED***
				continue
			***REMOVED***
			if c.isDTLS && candidate.flags&suiteNoDTLS != 0 ***REMOVED***
				continue
			***REMOVED***
			return candidate
		***REMOVED***
	***REMOVED***

	return nil
***REMOVED***

func isTLS12Cipher(id uint16) bool ***REMOVED***
	for _, cipher := range cipherSuites ***REMOVED***
		if cipher.id != id ***REMOVED***
			continue
		***REMOVED***
		return cipher.flags&suiteTLS12 != 0
	***REMOVED***
	// Unknown cipher.
	return false
***REMOVED***

func isGREASEValue(val uint16) bool ***REMOVED***
	return val&0x0f0f == 0x0a0a && val&0xff == val>>8
***REMOVED***

func verifyPSKBinder(clientHello *clientHelloMsg, sessionState *sessionState, binderToVerify, transcript []byte) error ***REMOVED***
	binderLen := 2
	for _, binder := range clientHello.pskBinders ***REMOVED***
		binderLen += 1 + len(binder)
	***REMOVED***

	truncatedHello := clientHello.marshal()
	truncatedHello = truncatedHello[:len(truncatedHello)-binderLen]
	pskCipherSuite := cipherSuiteFromID(sessionState.cipherSuite)
	if pskCipherSuite == nil ***REMOVED***
		return errors.New("tls: Unknown cipher suite for PSK in session")
	***REMOVED***

	binder := computePSKBinder(sessionState.masterSecret, resumptionPSKBinderLabel, pskCipherSuite, transcript, truncatedHello)
	if !bytes.Equal(binder, binderToVerify) ***REMOVED***
		return errors.New("tls: PSK binder does not verify")
	***REMOVED***

	return nil
***REMOVED***
