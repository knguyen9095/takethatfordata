// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runner

import (
	"encoding/binary"
	"fmt"
	"io"
	"net"
	"time"
)

// opcodePacket signals a packet, encoded with a 32-bit length prefix, followed
// by the payload.
const opcodePacket = byte('P')

// opcodeTimeout signals a read timeout, encoded by a 64-bit number of
// nanoseconds. On receipt, the peer should reply with
// opcodeTimeoutAck. opcodeTimeout may only be sent by the Go side.
const opcodeTimeout = byte('T')

// opcodeTimeoutAck acknowledges a read timeout. This opcode has no payload and
// may only be sent by the C side. Timeout ACKs act as a synchronization point
// at the timeout, to bracket one flight of messages from C.
const opcodeTimeoutAck = byte('t')

type packetAdaptor struct ***REMOVED***
	net.Conn
	debug *recordingConn
***REMOVED***

// newPacketAdaptor wraps a reliable streaming net.Conn into a reliable
// packet-based net.Conn. The stream contains packets and control commands,
// distinguished by a one byte opcode.
func newPacketAdaptor(conn net.Conn) *packetAdaptor ***REMOVED***
	return &packetAdaptor***REMOVED***conn, nil***REMOVED***
***REMOVED***

func (p *packetAdaptor) log(message string, data []byte) ***REMOVED***
	if p.debug == nil ***REMOVED***
		return
	***REMOVED***

	p.debug.LogSpecial(message, data)
***REMOVED***

func (p *packetAdaptor) readOpcode() (byte, error) ***REMOVED***
	out := make([]byte, 1)
	if _, err := io.ReadFull(p.Conn, out); err != nil ***REMOVED***
		return 0, err
	***REMOVED***
	return out[0], nil
***REMOVED***

func (p *packetAdaptor) readPacketBody() ([]byte, error) ***REMOVED***
	var length uint32
	if err := binary.Read(p.Conn, binary.BigEndian, &length); err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	out := make([]byte, length)
	if _, err := io.ReadFull(p.Conn, out); err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	return out, nil
***REMOVED***

func (p *packetAdaptor) Read(b []byte) (int, error) ***REMOVED***
	opcode, err := p.readOpcode()
	if err != nil ***REMOVED***
		return 0, err
	***REMOVED***
	if opcode != opcodePacket ***REMOVED***
		return 0, fmt.Errorf("unexpected opcode '%d'", opcode)
	***REMOVED***
	out, err := p.readPacketBody()
	if err != nil ***REMOVED***
		return 0, err
	***REMOVED***
	return copy(b, out), nil
***REMOVED***

func (p *packetAdaptor) Write(b []byte) (int, error) ***REMOVED***
	payload := make([]byte, 1+4+len(b))
	payload[0] = opcodePacket
	binary.BigEndian.PutUint32(payload[1:5], uint32(len(b)))
	copy(payload[5:], b)
	if _, err := p.Conn.Write(payload); err != nil ***REMOVED***
		return 0, err
	***REMOVED***
	return len(b), nil
***REMOVED***

// SendReadTimeout instructs the peer to simulate a read timeout. It then waits
// for acknowledgement of the timeout, buffering any packets received since
// then. The packets are then returned.
func (p *packetAdaptor) SendReadTimeout(d time.Duration) ([][]byte, error) ***REMOVED***
	p.log("Simulating read timeout: "+d.String(), nil)

	payload := make([]byte, 1+8)
	payload[0] = opcodeTimeout
	binary.BigEndian.PutUint64(payload[1:], uint64(d.Nanoseconds()))
	if _, err := p.Conn.Write(payload); err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	var packets [][]byte
	for ***REMOVED***
		opcode, err := p.readOpcode()
		if err != nil ***REMOVED***
			return nil, err
		***REMOVED***
		switch opcode ***REMOVED***
		case opcodeTimeoutAck:
			p.log("Received timeout ACK", nil)
			// Done! Return the packets buffered and continue.
			return packets, nil
		case opcodePacket:
			// Buffer the packet for the caller to process.
			packet, err := p.readPacketBody()
			if err != nil ***REMOVED***
				return nil, err
			***REMOVED***
			p.log("Simulating dropped packet", packet)
			packets = append(packets, packet)
		default:
			return nil, fmt.Errorf("unexpected opcode '%d'", opcode)
		***REMOVED***
	***REMOVED***
***REMOVED***

type replayAdaptor struct ***REMOVED***
	net.Conn
	prevWrite []byte
***REMOVED***

// newReplayAdaptor wraps a packeted net.Conn. It transforms it into
// one which, after writing a packet, always replays the previous
// write.
func newReplayAdaptor(conn net.Conn) net.Conn ***REMOVED***
	return &replayAdaptor***REMOVED***Conn: conn***REMOVED***
***REMOVED***

func (r *replayAdaptor) Write(b []byte) (int, error) ***REMOVED***
	n, err := r.Conn.Write(b)

	// Replay the previous packet and save the current one to
	// replay next.
	if r.prevWrite != nil ***REMOVED***
		r.Conn.Write(r.prevWrite)
	***REMOVED***
	r.prevWrite = append(r.prevWrite[:0], b...)

	return n, err
***REMOVED***

type damageAdaptor struct ***REMOVED***
	net.Conn
	damage bool
***REMOVED***

// newDamageAdaptor wraps a packeted net.Conn. It transforms it into one which
// optionally damages the final byte of every Write() call.
func newDamageAdaptor(conn net.Conn) *damageAdaptor ***REMOVED***
	return &damageAdaptor***REMOVED***Conn: conn***REMOVED***
***REMOVED***

func (d *damageAdaptor) setDamage(damage bool) ***REMOVED***
	d.damage = damage
***REMOVED***

func (d *damageAdaptor) Write(b []byte) (int, error) ***REMOVED***
	if d.damage && len(b) > 0 ***REMOVED***
		b = append([]byte***REMOVED******REMOVED***, b...)
		b[len(b)-1]++
	***REMOVED***
	return d.Conn.Write(b)
***REMOVED***
