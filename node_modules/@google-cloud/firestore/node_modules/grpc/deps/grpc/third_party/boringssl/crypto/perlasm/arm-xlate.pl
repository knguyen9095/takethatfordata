#!/usr/bin/env perl

# ARM assembler distiller by <appro>.

use strict;

my $flavour = shift;
my $output = shift;
open STDOUT,">$output" || die "can't open $output: $!";

$flavour = "linux32" if (!$flavour or $flavour eq "void");

my %GLOBALS;
my $dotinlocallabels=($flavour=~/linux/)?1:0;

################################################################
# directives which need special treatment on different platforms
################################################################
my $arch = sub ***REMOVED***
    if ($flavour =~ /linux/)	***REMOVED*** ".arch\t".join(',',@_); ***REMOVED***
    else			***REMOVED*** ""; ***REMOVED***
***REMOVED***;
my $fpu = sub ***REMOVED***
    if ($flavour =~ /linux/)	***REMOVED*** ".fpu\t".join(',',@_); ***REMOVED***
    else			***REMOVED*** ""; ***REMOVED***
***REMOVED***;
my $hidden = sub ***REMOVED***
    if ($flavour =~ /ios/)	***REMOVED*** ".private_extern\t".join(',',@_); ***REMOVED***
    else			***REMOVED*** ".hidden\t".join(',',@_); ***REMOVED***
***REMOVED***;
my $comm = sub ***REMOVED***
    my @args = split(/,\s*/,shift);
    my $name = @args[0];
    my $global = \$GLOBALS***REMOVED***$name***REMOVED***;
    my $ret;

    if ($flavour =~ /ios32/)	***REMOVED***
	$ret = ".comm\t_$name,@args[1]\n";
	$ret .= ".non_lazy_symbol_pointer\n";
	$ret .= "$name:\n";
	$ret .= ".indirect_symbol\t_$name\n";
	$ret .= ".long\t0";
	$name = "_$name";
    ***REMOVED*** else			***REMOVED*** $ret = ".comm\t".join(',',@args); ***REMOVED***

    $$global = $name;
    $ret;
***REMOVED***;
my $globl = sub ***REMOVED***
    my $name = shift;
    my $global = \$GLOBALS***REMOVED***$name***REMOVED***;
    my $ret;

    SWITCH: for ($flavour) ***REMOVED***
	/ios/		&& do ***REMOVED*** $name = "_$name";
				last;
			      ***REMOVED***;
    ***REMOVED***

    $ret = ".globl	$name\n";
    # All symbols in assembly files are hidden.
    $ret .= &$hidden($name);
    $$global = $name;
    $ret;
***REMOVED***;
my $global = $globl;
my $extern = sub ***REMOVED***
    &$globl(@_);
    return;	# return nothing
***REMOVED***;
my $type = sub ***REMOVED***
    if ($flavour =~ /linux/)	***REMOVED*** ".type\t".join(',',@_); ***REMOVED***
    else			***REMOVED*** ""; ***REMOVED***
***REMOVED***;
my $size = sub ***REMOVED***
    if ($flavour =~ /linux/)	***REMOVED*** ".size\t".join(',',@_); ***REMOVED***
    else			***REMOVED*** ""; ***REMOVED***
***REMOVED***;
my $inst = sub ***REMOVED***
    if ($flavour =~ /linux/)    ***REMOVED*** ".inst\t".join(',',@_); ***REMOVED***
    else                        ***REMOVED*** ".long\t".join(',',@_); ***REMOVED***
***REMOVED***;
my $asciz = sub ***REMOVED***
    my $line = join(",",@_);
    if ($line =~ /^"(.*)"$/)
    ***REMOVED***	".byte	" . join(",",unpack("C*",$1),0) . "\n.align	2";	***REMOVED***
    else
    ***REMOVED***	"";	***REMOVED***
***REMOVED***;

sub range ***REMOVED***
  my ($r,$sfx,$start,$end) = @_;

    join(",",map("$r$_$sfx",($start..$end)));
***REMOVED***

sub expand_line ***REMOVED***
  my $line = shift;
  my @ret = ();

    pos($line)=0;

    while ($line =~ m/\G[^@\/\***REMOVED***\"]*/g) ***REMOVED***
	if ($line =~ m/\G(@|\/\/|$)/gc) ***REMOVED***
	    last;
	***REMOVED***
	elsif ($line =~ m/\G\***REMOVED***/gc) ***REMOVED***
	    my $saved_pos = pos($line);
	    $line =~ s/\G([rdqv])([0-9]+)([^\-]*)\-\1([0-9]+)\3/range($1,$3,$2,$4)/e;
	    pos($line) = $saved_pos;
	    $line =~ m/\G[^\***REMOVED***]*\***REMOVED***/g;
	***REMOVED***
	elsif ($line =~ m/\G\"/gc) ***REMOVED***
	    $line =~ m/\G[^\"]*\"/g;
	***REMOVED***
    ***REMOVED***

    $line =~ s/\b(\w+)/$GLOBALS***REMOVED***$1***REMOVED*** or $1/ge;

    return $line;
***REMOVED***

print "#if defined(__arm__)\n" if ($flavour eq "linux32");
print "#if defined(__aarch64__)\n" if ($flavour eq "linux64");

while(my $line=<>) ***REMOVED***

    if ($line =~ m/^\s*(#|@|\/\/)/)	***REMOVED*** print $line; next; ***REMOVED***

    $line =~ s|/\*.*\*/||;	# get rid of C-style comments...
    $line =~ s|^\s+||;		# ... and skip white spaces in beginning...
    $line =~ s|\s+$||;		# ... and at the end

    ***REMOVED***
	$line =~ s|[\b\.]L(\w***REMOVED***2,***REMOVED***)|L$1|g;	# common denominator for Locallabel
	$line =~ s|\bL(\w***REMOVED***2,***REMOVED***)|\.L$1|g	if ($dotinlocallabels);
    ***REMOVED***

    ***REMOVED***
	$line =~ s|(^[\.\w]+)\:\s*||;
	my $label = $1;
	if ($label) ***REMOVED***
	    printf "%s:",($GLOBALS***REMOVED***$label***REMOVED*** or $label);
	***REMOVED***
    ***REMOVED***

    if ($line !~ m/^[#@]/) ***REMOVED***
	$line =~ s|^\s*(\.?)(\S+)\s*||;
	my $c = $1; $c = "\t" if ($c eq "");
	my $mnemonic = $2;
	my $opcode;
	if ($mnemonic =~ m/([^\.]+)\.([^\.]+)/) ***REMOVED***
	    $opcode = eval("\$$1_$2");
	***REMOVED*** else ***REMOVED***
	    $opcode = eval("\$$mnemonic");
	***REMOVED***

	my $arg=expand_line($line);

	if (ref($opcode) eq 'CODE') ***REMOVED***
		$line = &$opcode($arg);
	***REMOVED*** elsif ($mnemonic)         ***REMOVED***
		$line = $c.$mnemonic;
		$line.= "\t$arg" if ($arg ne "");
	***REMOVED***
    ***REMOVED***

    print $line if ($line);
    print "\n";
***REMOVED***

print "#endif\n" if ($flavour eq "linux32" || $flavour eq "linux64");

close STDOUT;
