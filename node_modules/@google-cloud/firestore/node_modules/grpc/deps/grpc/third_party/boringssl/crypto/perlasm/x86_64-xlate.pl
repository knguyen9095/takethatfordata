#! /usr/bin/env perl
# Copyright 2005-2016 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the OpenSSL license (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


# Ascetic x86_64 AT&T to MASM/NASM assembler translator by <appro>.
#
# Why AT&T to MASM and not vice versa? Several reasons. Because AT&T
# format is way easier to parse. Because it's simpler to "gear" from
# Unix ABI to Windows one [see cross-reference "card" at the end of
# file]. Because Linux targets were available first...
#
# In addition the script also "distills" code suitable for GNU
# assembler, so that it can be compiled with more rigid assemblers,
# such as Solaris /usr/ccs/bin/as.
#
# This translator is not designed to convert *arbitrary* assembler
# code from AT&T format to MASM one. It's designed to convert just
# enough to provide for dual-ABI OpenSSL modules development...
# There *are* limitations and you might have to modify your assembler
# code or this script to achieve the desired result...
#
# Currently recognized limitations:
#
# - can't use multiple ops per line;
#
# Dual-ABI styling rules.
#
# 1. Adhere to Unix register and stack layout [see cross-reference
#    ABI "card" at the end for explanation].
# 2. Forget about "red zone," stick to more traditional blended
#    stack frame allocation. If volatile storage is actually required
#    that is. If not, just leave the stack as is.
# 3. Functions tagged with ".type name,@function" get crafted with
#    unified Win64 prologue and epilogue automatically. If you want
#    to take care of ABI differences yourself, tag functions as
#    ".type name,@abi-omnipotent" instead.
# 4. To optimize the Win64 prologue you can specify number of input
#    arguments as ".type name,@function,N." Keep in mind that if N is
#    larger than 6, then you *have to* write "abi-omnipotent" code,
#    because >6 cases can't be addressed with unified prologue.
# 5. Name local labels as .L*, do *not* use dynamic labels such as 1:
#    (sorry about latter).
# 6. Don't use [or hand-code with .byte] "rep ret." "ret" mnemonic is
#    required to identify the spots, where to inject Win64 epilogue!
#    But on the pros, it's then prefixed with rep automatically:-)
# 7. Stick to explicit ip-relative addressing. If you have to use
#    GOTPCREL addressing, stick to mov symbol@GOTPCREL(%rip),%r??.
#    Both are recognized and translated to proper Win64 addressing
#    modes.
#
# 8. In order to provide for structured exception handling unified
#    Win64 prologue copies %rsp value to %rax. For further details
#    see SEH paragraph at the end.
# 9. .init segment is allowed to contain calls to functions only.
# a. If function accepts more than 4 arguments *and* >4th argument
#    is declared as non 64-bit value, do clear its upper part.


use strict;

my $flavour = shift;
my $output  = shift;
if ($flavour =~ /\./) ***REMOVED*** $output = $flavour; undef $flavour; ***REMOVED***

open STDOUT,">$output" || die "can't open $output: $!"
	if (defined($output));

my $gas=1;	$gas=0 if ($output =~ /\.asm$/);
my $elf=1;	$elf=0 if (!$gas);
my $win64=0;
my $prefix="";
my $decor=".L";

my $masmref=8 + 50727*2**-32;	# 8.00.50727 shipped with VS2005
my $masm=0;
my $PTR=" PTR";

my $nasmref=2.03;
my $nasm=0;

if    ($flavour eq "mingw64")	***REMOVED*** $gas=1; $elf=0; $win64=1;
				  # TODO(davidben): Before supporting the
				  # mingw64 perlasm flavour, do away with this
				  # environment variable check.
                                  die "mingw64 not supported";
				  $prefix=`echo __USER_LABEL_PREFIX__ | $ENV***REMOVED***CC***REMOVED*** -E -P -`;
				  $prefix =~ s|\R$||; # Better chomp
				***REMOVED***
elsif ($flavour eq "macosx")	***REMOVED*** $gas=1; $elf=0; $prefix="_"; $decor="L\$"; ***REMOVED***
elsif ($flavour eq "masm")	***REMOVED*** $gas=0; $elf=0; $masm=$masmref; $win64=1; $decor="\$L\$"; ***REMOVED***
elsif ($flavour eq "nasm")	***REMOVED*** $gas=0; $elf=0; $nasm=$nasmref; $win64=1; $decor="\$L\$"; $PTR=""; ***REMOVED***
elsif (!$gas)			***REMOVED*** die "unknown flavour $flavour"; ***REMOVED***

my $current_segment;
my $current_function;
my %globals;

***REMOVED*** package opcode;	# pick up opcodes
    sub re ***REMOVED***
	my	($class, $line) = @_;
	my	$self = ***REMOVED******REMOVED***;
	my	$ret;

	if ($$line =~ /^([a-z][a-z0-9]*)/i) ***REMOVED***
	    bless $self,$class;
	    $self->***REMOVED***op***REMOVED*** = $1;
	    $ret = $self;
	    $$line = substr($$line,@+[0]); $$line =~ s/^\s+//;

	    undef $self->***REMOVED***sz***REMOVED***;
	    if ($self->***REMOVED***op***REMOVED*** =~ /^(movz)x?([bw]).*/) ***REMOVED***	# movz is pain...
		$self->***REMOVED***op***REMOVED*** = $1;
		$self->***REMOVED***sz***REMOVED*** = $2;
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** =~ /call|jmp/) ***REMOVED***
		$self->***REMOVED***sz***REMOVED*** = "";
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** =~ /^p/ && $' !~ /^(ush|op|insrw)/) ***REMOVED*** # SSEn
		$self->***REMOVED***sz***REMOVED*** = "";
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** =~ /^[vk]/) ***REMOVED*** # VEX or k* such as kmov
		$self->***REMOVED***sz***REMOVED*** = "";
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** =~ /mov[dq]/ && $$line =~ /%xmm/) ***REMOVED***
		$self->***REMOVED***sz***REMOVED*** = "";
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** =~ /([a-z]***REMOVED***3,***REMOVED***)([qlwb])$/) ***REMOVED***
		$self->***REMOVED***op***REMOVED*** = $1;
		$self->***REMOVED***sz***REMOVED*** = $2;
	    ***REMOVED***
	***REMOVED***
	$ret;
    ***REMOVED***
    sub size ***REMOVED***
	my ($self, $sz) = @_;
	$self->***REMOVED***sz***REMOVED*** = $sz if (defined($sz) && !defined($self->***REMOVED***sz***REMOVED***));
	$self->***REMOVED***sz***REMOVED***;
    ***REMOVED***
    sub out ***REMOVED***
	my $self = shift;
	if ($gas) ***REMOVED***
	    if ($self->***REMOVED***op***REMOVED*** eq "movz") ***REMOVED***	# movz is pain...
		sprintf "%s%s%s",$self->***REMOVED***op***REMOVED***,$self->***REMOVED***sz***REMOVED***,shift;
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** =~ /^set/) ***REMOVED***
		"$self->***REMOVED***op***REMOVED***";
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** eq "ret") ***REMOVED***
		my $epilogue = "";
		if ($win64 && $current_function->***REMOVED***abi***REMOVED*** eq "svr4") ***REMOVED***
		    $epilogue = "movq	8(%rsp),%rdi\n\t" .
				"movq	16(%rsp),%rsi\n\t";
		***REMOVED***
	    	$epilogue . ".byte	0xf3,0xc3";
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** eq "call" && !$elf && $current_segment eq ".init") ***REMOVED***
		".p2align\t3\n\t.quad";
	    ***REMOVED*** else ***REMOVED***
		"$self->***REMOVED***op***REMOVED***$self->***REMOVED***sz***REMOVED***";
	    ***REMOVED***
	***REMOVED*** else ***REMOVED***
	    $self->***REMOVED***op***REMOVED*** =~ s/^movz/movzx/;
	    if ($self->***REMOVED***op***REMOVED*** eq "ret") ***REMOVED***
		$self->***REMOVED***op***REMOVED*** = "";
		if ($win64 && $current_function->***REMOVED***abi***REMOVED*** eq "svr4") ***REMOVED***
		    $self->***REMOVED***op***REMOVED*** = "mov	rdi,QWORD$PTR\[8+rsp\]\t;WIN64 epilogue\n\t".
				  "mov	rsi,QWORD$PTR\[16+rsp\]\n\t";
	    	***REMOVED***
		$self->***REMOVED***op***REMOVED*** .= "DB\t0F3h,0C3h\t\t;repret";
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** =~ /^(pop|push)f/) ***REMOVED***
		$self->***REMOVED***op***REMOVED*** .= $self->***REMOVED***sz***REMOVED***;
	    ***REMOVED*** elsif ($self->***REMOVED***op***REMOVED*** eq "call" && $current_segment eq ".CRT\$XCU") ***REMOVED***
		$self->***REMOVED***op***REMOVED*** = "\tDQ";
	    ***REMOVED***
	    $self->***REMOVED***op***REMOVED***;
	***REMOVED***
    ***REMOVED***
    sub mnemonic ***REMOVED***
	my ($self, $op) = @_;
	$self->***REMOVED***op***REMOVED***=$op if (defined($op));
	$self->***REMOVED***op***REMOVED***;
    ***REMOVED***
***REMOVED***
***REMOVED*** package const;	# pick up constants, which start with $
    sub re ***REMOVED***
	my	($class, $line) = @_;
	my	$self = ***REMOVED******REMOVED***;
	my	$ret;

	if ($$line =~ /^\$([^,]+)/) ***REMOVED***
	    bless $self, $class;
	    $self->***REMOVED***value***REMOVED*** = $1;
	    $ret = $self;
	    $$line = substr($$line,@+[0]); $$line =~ s/^\s+//;
	***REMOVED***
	$ret;
    ***REMOVED***
    sub out ***REMOVED***
    	my $self = shift;

	$self->***REMOVED***value***REMOVED*** =~ s/\b(0b[0-1]+)/oct($1)/eig;
	if ($gas) ***REMOVED***
	    # Solaris /usr/ccs/bin/as can't handle multiplications
	    # in $self->***REMOVED***value***REMOVED***
	    my $value = $self->***REMOVED***value***REMOVED***;
	    no warnings;    # oct might complain about overflow, ignore here...
	    $value =~ s/(?<![\w\$\.])(0x?[0-9a-f]+)/oct($1)/egi;
	    if ($value =~ s/([0-9]+\s*[\*\/\%]\s*[0-9]+)/eval($1)/eg) ***REMOVED***
		$self->***REMOVED***value***REMOVED*** = $value;
	    ***REMOVED***
	    sprintf "\$%s",$self->***REMOVED***value***REMOVED***;
	***REMOVED*** else ***REMOVED***
	    $self->***REMOVED***value***REMOVED*** =~ s/0x([0-9a-f]+)/0$1h/ig if ($masm);
	    sprintf "%s",$self->***REMOVED***value***REMOVED***;
	***REMOVED***
    ***REMOVED***
***REMOVED***
***REMOVED*** package ea;		# pick up effective addresses: expr(%reg,%reg,scale)

    my %szmap = (	b=>"BYTE$PTR",    w=>"WORD$PTR",
			l=>"DWORD$PTR",   d=>"DWORD$PTR",
			q=>"QWORD$PTR",   o=>"OWORD$PTR",
			x=>"XMMWORD$PTR", y=>"YMMWORD$PTR",
			z=>"ZMMWORD$PTR" ) if (!$gas);

    sub re ***REMOVED***
	my	($class, $line, $opcode) = @_;
	my	$self = ***REMOVED******REMOVED***;
	my	$ret;

	# optional * ----vvv--- appears in indirect jmp/call
	if ($$line =~ /^(\*?)([^\(,]*)\(([%\w,]+)\)((?:***REMOVED***[^***REMOVED***]+***REMOVED***)*)/) ***REMOVED***
	    bless $self, $class;
	    $self->***REMOVED***asterisk***REMOVED*** = $1;
	    $self->***REMOVED***label***REMOVED*** = $2;
	    ($self->***REMOVED***base***REMOVED***,$self->***REMOVED***index***REMOVED***,$self->***REMOVED***scale***REMOVED***)=split(/,/,$3);
	    $self->***REMOVED***scale***REMOVED*** = 1 if (!defined($self->***REMOVED***scale***REMOVED***));
	    $self->***REMOVED***opmask***REMOVED*** = $4;
	    $ret = $self;
	    $$line = substr($$line,@+[0]); $$line =~ s/^\s+//;

	    if ($win64 && $self->***REMOVED***label***REMOVED*** =~ s/\@GOTPCREL//) ***REMOVED***
		die if ($opcode->mnemonic() ne "mov");
		$opcode->mnemonic("lea");
	    ***REMOVED***
	    $self->***REMOVED***base***REMOVED***  =~ s/^%//;
	    $self->***REMOVED***index***REMOVED*** =~ s/^%// if (defined($self->***REMOVED***index***REMOVED***));
	    $self->***REMOVED***opcode***REMOVED*** = $opcode;
	***REMOVED***
	$ret;
    ***REMOVED***
    sub size ***REMOVED******REMOVED***
    sub out ***REMOVED***
	my ($self, $sz) = @_;

	$self->***REMOVED***label***REMOVED*** =~ s/([_a-z][_a-z0-9]*)/$globals***REMOVED***$1***REMOVED*** or $1/gei;
	$self->***REMOVED***label***REMOVED*** =~ s/\.L/$decor/g;

	# Silently convert all EAs to 64-bit. This is required for
	# elder GNU assembler and results in more compact code,
	# *but* most importantly AES module depends on this feature!
	$self->***REMOVED***index***REMOVED*** =~ s/^[er](.?[0-9xpi])[d]?$/r\1/;
	$self->***REMOVED***base***REMOVED***  =~ s/^[er](.?[0-9xpi])[d]?$/r\1/;

	# Solaris /usr/ccs/bin/as can't handle multiplications
	# in $self->***REMOVED***label***REMOVED***...
	use integer;
	$self->***REMOVED***label***REMOVED*** =~ s/(?<![\w\$\.])(0x?[0-9a-f]+)/oct($1)/egi;
	$self->***REMOVED***label***REMOVED*** =~ s/\b([0-9]+\s*[\*\/\%]\s*[0-9]+)\b/eval($1)/eg;

	# Some assemblers insist on signed presentation of 32-bit
	# offsets, but sign extension is a tricky business in perl...
	if ((1<<31)<<1) ***REMOVED***
	    $self->***REMOVED***label***REMOVED*** =~ s/\b([0-9]+)\b/$1<<32>>32/eg;
	***REMOVED*** else ***REMOVED***
	    $self->***REMOVED***label***REMOVED*** =~ s/\b([0-9]+)\b/$1>>0/eg;
	***REMOVED***

	# if base register is %rbp or %r13, see if it's possible to
	# flip base and index registers [for better performance]
	if (!$self->***REMOVED***label***REMOVED*** && $self->***REMOVED***index***REMOVED*** && $self->***REMOVED***scale***REMOVED***==1 &&
	    $self->***REMOVED***base***REMOVED*** =~ /(rbp|r13)/) ***REMOVED***
		$self->***REMOVED***base***REMOVED*** = $self->***REMOVED***index***REMOVED***; $self->***REMOVED***index***REMOVED*** = $1;
	***REMOVED***

	if ($gas) ***REMOVED***
	    $self->***REMOVED***label***REMOVED*** =~ s/^___imp_/__imp__/   if ($flavour eq "mingw64");

	    if (defined($self->***REMOVED***index***REMOVED***)) ***REMOVED***
		sprintf "%s%s(%s,%%%s,%d)%s",
					$self->***REMOVED***asterisk***REMOVED***,$self->***REMOVED***label***REMOVED***,
					$self->***REMOVED***base***REMOVED***?"%$self->***REMOVED***base***REMOVED***":"",
					$self->***REMOVED***index***REMOVED***,$self->***REMOVED***scale***REMOVED***,
					$self->***REMOVED***opmask***REMOVED***;
	    ***REMOVED*** else ***REMOVED***
		sprintf "%s%s(%%%s)%s",	$self->***REMOVED***asterisk***REMOVED***,$self->***REMOVED***label***REMOVED***,
					$self->***REMOVED***base***REMOVED***,$self->***REMOVED***opmask***REMOVED***;
	    ***REMOVED***
	***REMOVED*** else ***REMOVED***
	    $self->***REMOVED***label***REMOVED*** =~ s/\./\$/g;
	    $self->***REMOVED***label***REMOVED*** =~ s/(?<![\w\$\.])0x([0-9a-f]+)/0$1h/ig;
	    $self->***REMOVED***label***REMOVED*** = "($self->***REMOVED***label***REMOVED***)" if ($self->***REMOVED***label***REMOVED*** =~ /[\*\+\-\/]/);

	    my $mnemonic = $self->***REMOVED***opcode***REMOVED***->mnemonic();
	    ($self->***REMOVED***asterisk***REMOVED***)				&& ($sz="q") ||
	    ($mnemonic =~ /^v?mov([qd])$/)		&& ($sz=$1)  ||
	    ($mnemonic =~ /^v?pinsr([qdwb])$/)		&& ($sz=$1)  ||
	    ($mnemonic =~ /^vpbroadcast([qdwb])$/)	&& ($sz=$1)  ||
	    ($mnemonic =~ /^v(?!perm)[a-z]+[fi]128$/)	&& ($sz="x");

	    $self->***REMOVED***opmask***REMOVED***  =~ s/%(k[0-7])/$1/;

	    if (defined($self->***REMOVED***index***REMOVED***)) ***REMOVED***
		sprintf "%s[%s%s*%d%s]%s",$szmap***REMOVED***$sz***REMOVED***,
					$self->***REMOVED***label***REMOVED***?"$self->***REMOVED***label***REMOVED***+":"",
					$self->***REMOVED***index***REMOVED***,$self->***REMOVED***scale***REMOVED***,
					$self->***REMOVED***base***REMOVED***?"+$self->***REMOVED***base***REMOVED***":"",
					$self->***REMOVED***opmask***REMOVED***;
	    ***REMOVED*** elsif ($self->***REMOVED***base***REMOVED*** eq "rip") ***REMOVED***
		sprintf "%s[%s]",$szmap***REMOVED***$sz***REMOVED***,$self->***REMOVED***label***REMOVED***;
	    ***REMOVED*** else ***REMOVED***
		sprintf "%s[%s%s]%s",	$szmap***REMOVED***$sz***REMOVED***,
					$self->***REMOVED***label***REMOVED***?"$self->***REMOVED***label***REMOVED***+":"",
					$self->***REMOVED***base***REMOVED***,$self->***REMOVED***opmask***REMOVED***;
	    ***REMOVED***
	***REMOVED***
    ***REMOVED***
***REMOVED***
***REMOVED*** package register;	# pick up registers, which start with %.
    sub re ***REMOVED***
	my	($class, $line, $opcode) = @_;
	my	$self = ***REMOVED******REMOVED***;
	my	$ret;

	# optional * ----vvv--- appears in indirect jmp/call
	if ($$line =~ /^(\*?)%(\w+)((?:***REMOVED***[^***REMOVED***]+***REMOVED***)*)/) ***REMOVED***
	    bless $self,$class;
	    $self->***REMOVED***asterisk***REMOVED*** = $1;
	    $self->***REMOVED***value***REMOVED*** = $2;
	    $self->***REMOVED***opmask***REMOVED*** = $3;
	    $opcode->size($self->size());
	    $ret = $self;
	    $$line = substr($$line,@+[0]); $$line =~ s/^\s+//;
	***REMOVED***
	$ret;
    ***REMOVED***
    sub size ***REMOVED***
	my	$self = shift;
	my	$ret;

	if    ($self->***REMOVED***value***REMOVED*** =~ /^r[\d]+b$/i)	***REMOVED*** $ret="b"; ***REMOVED***
	elsif ($self->***REMOVED***value***REMOVED*** =~ /^r[\d]+w$/i)	***REMOVED*** $ret="w"; ***REMOVED***
	elsif ($self->***REMOVED***value***REMOVED*** =~ /^r[\d]+d$/i)	***REMOVED*** $ret="l"; ***REMOVED***
	elsif ($self->***REMOVED***value***REMOVED*** =~ /^r[\w]+$/i)	***REMOVED*** $ret="q"; ***REMOVED***
	elsif ($self->***REMOVED***value***REMOVED*** =~ /^[a-d][hl]$/i)***REMOVED*** $ret="b"; ***REMOVED***
	elsif ($self->***REMOVED***value***REMOVED*** =~ /^[\w]***REMOVED***2***REMOVED***l$/i)	***REMOVED*** $ret="b"; ***REMOVED***
	elsif ($self->***REMOVED***value***REMOVED*** =~ /^[\w]***REMOVED***2***REMOVED***$/i)	***REMOVED*** $ret="w"; ***REMOVED***
	elsif ($self->***REMOVED***value***REMOVED*** =~ /^e[a-z]***REMOVED***2***REMOVED***$/i)***REMOVED*** $ret="l"; ***REMOVED***

	$ret;
    ***REMOVED***
    sub out ***REMOVED***
    	my $self = shift;
	if ($gas)	***REMOVED*** sprintf "%s%%%s%s",	$self->***REMOVED***asterisk***REMOVED***,
						$self->***REMOVED***value***REMOVED***,
						$self->***REMOVED***opmask***REMOVED***; ***REMOVED***
	else		***REMOVED*** $self->***REMOVED***opmask***REMOVED*** =~ s/%(k[0-7])/$1/;
			  $self->***REMOVED***value***REMOVED***.$self->***REMOVED***opmask***REMOVED***; ***REMOVED***
    ***REMOVED***
***REMOVED***
***REMOVED*** package label;	# pick up labels, which end with :
    sub re ***REMOVED***
	my	($class, $line) = @_;
	my	$self = ***REMOVED******REMOVED***;
	my	$ret;

	if ($$line =~ /(^[\.\w]+)\:/) ***REMOVED***
	    bless $self,$class;
	    $self->***REMOVED***value***REMOVED*** = $1;
	    $ret = $self;
	    $$line = substr($$line,@+[0]); $$line =~ s/^\s+//;

	    $self->***REMOVED***value***REMOVED*** =~ s/^\.L/$decor/;
	***REMOVED***
	$ret;
    ***REMOVED***
    sub out ***REMOVED***
	my $self = shift;

	if ($gas) ***REMOVED***
	    my $func = ($globals***REMOVED***$self->***REMOVED***value***REMOVED******REMOVED*** or $self->***REMOVED***value***REMOVED***) . ":";
	    if ($win64	&& $current_function->***REMOVED***name***REMOVED*** eq $self->***REMOVED***value***REMOVED***
			&& $current_function->***REMOVED***abi***REMOVED*** eq "svr4") ***REMOVED***
		$func .= "\n";
		$func .= "	movq	%rdi,8(%rsp)\n";
		$func .= "	movq	%rsi,16(%rsp)\n";
		$func .= "	movq	%rsp,%rax\n";
		$func .= "$***REMOVED***decor***REMOVED***SEH_begin_$current_function->***REMOVED***name***REMOVED***:\n";
		my $narg = $current_function->***REMOVED***narg***REMOVED***;
		$narg=6 if (!defined($narg));
		$func .= "	movq	%rcx,%rdi\n" if ($narg>0);
		$func .= "	movq	%rdx,%rsi\n" if ($narg>1);
		$func .= "	movq	%r8,%rdx\n"  if ($narg>2);
		$func .= "	movq	%r9,%rcx\n"  if ($narg>3);
		$func .= "	movq	40(%rsp),%r8\n" if ($narg>4);
		$func .= "	movq	48(%rsp),%r9\n" if ($narg>5);
	    ***REMOVED***
	    $func;
	***REMOVED*** elsif ($self->***REMOVED***value***REMOVED*** ne "$current_function->***REMOVED***name***REMOVED***") ***REMOVED***
	    # Make all labels in masm global.
	    $self->***REMOVED***value***REMOVED*** .= ":" if ($masm);
	    $self->***REMOVED***value***REMOVED*** . ":";
	***REMOVED*** elsif ($win64 && $current_function->***REMOVED***abi***REMOVED*** eq "svr4") ***REMOVED***
	    my $func =	"$current_function->***REMOVED***name***REMOVED***" .
			($nasm ? ":" : "\tPROC $current_function->***REMOVED***scope***REMOVED***") .
			"\n";
	    $func .= "	mov	QWORD$PTR\[8+rsp\],rdi\t;WIN64 prologue\n";
	    $func .= "	mov	QWORD$PTR\[16+rsp\],rsi\n";
	    $func .= "	mov	rax,rsp\n";
	    $func .= "$***REMOVED***decor***REMOVED***SEH_begin_$current_function->***REMOVED***name***REMOVED***:";
	    $func .= ":" if ($masm);
	    $func .= "\n";
	    my $narg = $current_function->***REMOVED***narg***REMOVED***;
	    $narg=6 if (!defined($narg));
	    $func .= "	mov	rdi,rcx\n" if ($narg>0);
	    $func .= "	mov	rsi,rdx\n" if ($narg>1);
	    $func .= "	mov	rdx,r8\n"  if ($narg>2);
	    $func .= "	mov	rcx,r9\n"  if ($narg>3);
	    $func .= "	mov	r8,QWORD$PTR\[40+rsp\]\n" if ($narg>4);
	    $func .= "	mov	r9,QWORD$PTR\[48+rsp\]\n" if ($narg>5);
	    $func .= "\n";
	***REMOVED*** else ***REMOVED***
	   "$current_function->***REMOVED***name***REMOVED***".
			($nasm ? ":" : "\tPROC $current_function->***REMOVED***scope***REMOVED***");
	***REMOVED***
    ***REMOVED***
***REMOVED***
***REMOVED*** package expr;		# pick up expressions
    sub re ***REMOVED***
	my	($class, $line, $opcode) = @_;
	my	$self = ***REMOVED******REMOVED***;
	my	$ret;

	if ($$line =~ /(^[^,]+)/) ***REMOVED***
	    bless $self,$class;
	    $self->***REMOVED***value***REMOVED*** = $1;
	    $ret = $self;
	    $$line = substr($$line,@+[0]); $$line =~ s/^\s+//;

	    $self->***REMOVED***value***REMOVED*** =~ s/\@PLT// if (!$elf);
	    $self->***REMOVED***value***REMOVED*** =~ s/([_a-z][_a-z0-9]*)/$globals***REMOVED***$1***REMOVED*** or $1/gei;
	    $self->***REMOVED***value***REMOVED*** =~ s/\.L/$decor/g;
	    $self->***REMOVED***opcode***REMOVED*** = $opcode;
	***REMOVED***
	$ret;
    ***REMOVED***
    sub out ***REMOVED***
	my $self = shift;
	if ($nasm && $self->***REMOVED***opcode***REMOVED***->mnemonic()=~m/^j(?![re]cxz)/) ***REMOVED***
	    "NEAR ".$self->***REMOVED***value***REMOVED***;
	***REMOVED*** else ***REMOVED***
	    $self->***REMOVED***value***REMOVED***;
	***REMOVED***
    ***REMOVED***
***REMOVED***
***REMOVED*** package cfi_directive;
    # CFI directives annotate instructions that are significant for
    # stack unwinding procedure compliant with DWARF specification,
    # see http://dwarfstd.org/. Besides naturally expected for this
    # script platform-specific filtering function, this module adds
    # three auxiliary synthetic directives not recognized by [GNU]
    # assembler:
    #
    # - .cfi_push to annotate push instructions in prologue, which
    #   translates to .cfi_adjust_cfa_offset (if needed) and
    #   .cfi_offset;
    # - .cfi_pop to annotate pop instructions in epilogue, which
    #   translates to .cfi_adjust_cfa_offset (if needed) and
    #   .cfi_restore;
    # - [and most notably] .cfi_cfa_expression which encodes
    #   DW_CFA_def_cfa_expression and passes it to .cfi_escape as
    #   byte vector;
    #
    # CFA expressions were introduced in DWARF specification version
    # 3 and describe how to deduce CFA, Canonical Frame Address. This
    # becomes handy if your stack frame is variable and you can't
    # spare register for [previous] frame pointer. Suggested directive
    # syntax is made-up mix of DWARF operator suffixes [subset of]
    # and references to registers with optional bias. Following example
    # describes offloaded *original* stack pointer at specific offset
    # from *current* stack pointer:
    #
    #   .cfi_cfa_expression     %rsp+40,deref,+8
    #
    # Final +8 has everything to do with the fact that CFA is defined
    # as reference to top of caller's stack, and on x86_64 call to
    # subroutine pushes 8-byte return address. In other words original
    # stack pointer upon entry to a subroutine is 8 bytes off from CFA.

    # Below constants are taken from "DWARF Expressions" section of the
    # DWARF specification, section is numbered 7.7 in versions 3 and 4.
    my %DW_OP_simple = (	# no-arg operators, mapped directly
	deref	=> 0x06,	dup	=> 0x12,
	drop	=> 0x13,	over	=> 0x14,
	pick	=> 0x15,	swap	=> 0x16,
	rot	=> 0x17,	xderef	=> 0x18,

	abs	=> 0x19,	and	=> 0x1a,
	div	=> 0x1b,	minus	=> 0x1c,
	mod	=> 0x1d,	mul	=> 0x1e,
	neg	=> 0x1f,	not	=> 0x20,
	or	=> 0x21,	plus	=> 0x22,
	shl	=> 0x24,	shr	=> 0x25,
	shra	=> 0x26,	xor	=> 0x27,
	);

    my %DW_OP_complex = (	# used in specific subroutines
	constu		=> 0x10,	# uleb128
	consts		=> 0x11,	# sleb128
	plus_uconst	=> 0x23,	# uleb128
	lit0 		=> 0x30,	# add 0-31 to opcode
	reg0		=> 0x50,	# add 0-31 to opcode
	breg0		=> 0x70,	# add 0-31 to opcole, sleb128
	regx		=> 0x90,	# uleb28
	fbreg		=> 0x91,	# sleb128
	bregx		=> 0x92,	# uleb128, sleb128
	piece		=> 0x93,	# uleb128
	);

    # Following constants are defined in x86_64 ABI supplement, for
    # example avaiable at https://www.uclibc.org/docs/psABI-x86_64.pdf,
    # see section 3.7 "Stack Unwind Algorithm".
    my %DW_reg_idx = (
	"%rax"=>0,  "%rdx"=>1,  "%rcx"=>2,  "%rbx"=>3,
	"%rsi"=>4,  "%rdi"=>5,  "%rbp"=>6,  "%rsp"=>7,
	"%r8" =>8,  "%r9" =>9,  "%r10"=>10, "%r11"=>11,
	"%r12"=>12, "%r13"=>13, "%r14"=>14, "%r15"=>15
	);

    my ($cfa_reg, $cfa_rsp);

    # [us]leb128 format is variable-length integer representation base
    # 2^128, with most significant bit of each byte being 0 denoting
    # *last* most significat digit. See "Variable Length Data" in the
    # DWARF specification, numbered 7.6 at least in versions 3 and 4.
    sub sleb128 ***REMOVED***
	use integer;	# get right shift extend sign

	my $val = shift;
	my $sign = ($val < 0) ? -1 : 0;
	my @ret = ();

	while(1) ***REMOVED***
	    push @ret, $val&0x7f;

	    # see if remaining bits are same and equal to most
	    # significant bit of the current digit, if so, it's
	    # last digit...
	    last if (($val>>6) == $sign);

	    @ret[-1] |= 0x80;
	    $val >>= 7;
	***REMOVED***

	return @ret;
    ***REMOVED***
    sub uleb128 ***REMOVED***
	my $val = shift;
	my @ret = ();

	while(1) ***REMOVED***
	    push @ret, $val&0x7f;

	    # see if it's last significant digit...
	    last if (($val >>= 7) == 0);

	    @ret[-1] |= 0x80;
	***REMOVED***

	return @ret;
    ***REMOVED***
    sub const ***REMOVED***
	my $val = shift;

	if ($val >= 0 && $val < 32) ***REMOVED***
            return ($DW_OP_complex***REMOVED***lit0***REMOVED***+$val);
	***REMOVED***
	return ($DW_OP_complex***REMOVED***consts***REMOVED***, sleb128($val));
    ***REMOVED***
    sub reg ***REMOVED***
	my $val = shift;

	return if ($val !~ m/^(%r\w+)(?:([\+\-])((?:0x)?[0-9a-f]+))?/);

	my $reg = $DW_reg_idx***REMOVED***$1***REMOVED***;
	my $off = eval ("0 $2 $3");

	return (($DW_OP_complex***REMOVED***breg0***REMOVED*** + $reg), sleb128($off));
	# Yes, we use DW_OP_bregX+0 to push register value and not
	# DW_OP_regX, because latter would require even DW_OP_piece,
	# which would be a waste under the circumstances. If you have
	# to use DWP_OP_reg, use "regx:N"...
    ***REMOVED***
    sub cfa_expression ***REMOVED***
	my $line = shift;
	my @ret;

	foreach my $token (split(/,\s*/,$line)) ***REMOVED***
	    if ($token =~ /^%r/) ***REMOVED***
		push @ret,reg($token);
	    ***REMOVED*** elsif ($token =~ /((?:0x)?[0-9a-f]+)\((%r\w+)\)/) ***REMOVED***
		push @ret,reg("$2+$1");
	    ***REMOVED*** elsif ($token =~ /(\w+):(\-?(?:0x)?[0-9a-f]+)(U?)/i) ***REMOVED***
		my $i = 1*eval($2);
		push @ret,$DW_OP_complex***REMOVED***$1***REMOVED***, ($3 ? uleb128($i) : sleb128($i));
	    ***REMOVED*** elsif (my $i = 1*eval($token) or $token eq "0") ***REMOVED***
		if ($token =~ /^\+/) ***REMOVED***
		    push @ret,$DW_OP_complex***REMOVED***plus_uconst***REMOVED***,uleb128($i);
		***REMOVED*** else ***REMOVED***
		    push @ret,const($i);
		***REMOVED***
	    ***REMOVED*** else ***REMOVED***
		push @ret,$DW_OP_simple***REMOVED***$token***REMOVED***;
	    ***REMOVED***
	***REMOVED***

	# Finally we return DW_CFA_def_cfa_expression, 15, followed by
	# length of the expression and of course the expression itself.
	return (15,scalar(@ret),@ret);
    ***REMOVED***
    sub re ***REMOVED***
	my	($class, $line) = @_;
	my	$self = ***REMOVED******REMOVED***;
	my	$ret;

	if ($$line =~ s/^\s*\.cfi_(\w+)\s*//) ***REMOVED***
	    bless $self,$class;
	    $ret = $self;
	    undef $self->***REMOVED***value***REMOVED***;
	    my $dir = $1;

	    SWITCH: for ($dir) ***REMOVED***
	    # What is $cfa_rsp? Effectively it's difference between %rsp
	    # value and current CFA, Canonical Frame Address, which is
	    # why it starts with -8. Recall that CFA is top of caller's
	    # stack...
	    /startproc/	&& do ***REMOVED***	($cfa_reg, $cfa_rsp) = ("%rsp", -8); last; ***REMOVED***;
	    /endproc/	&& do ***REMOVED***	($cfa_reg, $cfa_rsp) = ("%rsp",  0); last; ***REMOVED***;
	    /def_cfa_register/
			&& do ***REMOVED***	$cfa_reg = $$line; last; ***REMOVED***;
	    /def_cfa_offset/
			&& do ***REMOVED***	$cfa_rsp = -1*eval($$line) if ($cfa_reg eq "%rsp");
				last;
			      ***REMOVED***;
	    /adjust_cfa_offset/
			&& do ***REMOVED***	$cfa_rsp -= 1*eval($$line) if ($cfa_reg eq "%rsp");
				last;
			      ***REMOVED***;
	    /def_cfa/	&& do ***REMOVED***	if ($$line =~ /(%r\w+)\s*,\s*(.+)/) ***REMOVED***
				    $cfa_reg = $1;
				    $cfa_rsp = -1*eval($2) if ($cfa_reg eq "%rsp");
				***REMOVED***
				last;
			      ***REMOVED***;
	    /push/	&& do ***REMOVED***	$dir = undef;
				$cfa_rsp -= 8;
				if ($cfa_reg eq "%rsp") ***REMOVED***
				    $self->***REMOVED***value***REMOVED*** = ".cfi_adjust_cfa_offset\t8\n";
				***REMOVED***
				$self->***REMOVED***value***REMOVED*** .= ".cfi_offset\t$$line,$cfa_rsp";
				last;
			      ***REMOVED***;
	    /pop/	&& do ***REMOVED***	$dir = undef;
				$cfa_rsp += 8;
				if ($cfa_reg eq "%rsp") ***REMOVED***
				    $self->***REMOVED***value***REMOVED*** = ".cfi_adjust_cfa_offset\t-8\n";
				***REMOVED***
				$self->***REMOVED***value***REMOVED*** .= ".cfi_restore\t$$line";
				last;
			      ***REMOVED***;
	    /cfa_expression/
			&& do ***REMOVED***	$dir = undef;
				$self->***REMOVED***value***REMOVED*** = ".cfi_escape\t" .
					join(",", map(sprintf("0x%02x", $_),
						      cfa_expression($$line)));
				last;
			      ***REMOVED***;
	    ***REMOVED***

	    $self->***REMOVED***value***REMOVED*** = ".cfi_$dir\t$$line" if ($dir);

	    $$line = "";
	***REMOVED***

	return $ret;
    ***REMOVED***
    sub out ***REMOVED***
	my $self = shift;
	return ($elf ? $self->***REMOVED***value***REMOVED*** : undef);
    ***REMOVED***
***REMOVED***
***REMOVED*** package directive;	# pick up directives, which start with .
    sub re ***REMOVED***
	my	($class, $line) = @_;
	my	$self = ***REMOVED******REMOVED***;
	my	$ret;
	my	$dir;

	# chain-call to cfi_directive
	$ret = cfi_directive->re($line) and return $ret;

	if ($$line =~ /^\s*(\.\w+)/) ***REMOVED***
	    bless $self,$class;
	    $dir = $1;
	    $ret = $self;
	    undef $self->***REMOVED***value***REMOVED***;
	    $$line = substr($$line,@+[0]); $$line =~ s/^\s+//;

	    SWITCH: for ($dir) ***REMOVED***
		/\.global|\.globl|\.extern/
			    && do ***REMOVED*** $globals***REMOVED***$$line***REMOVED*** = $prefix . $$line;
				    $$line = $globals***REMOVED***$$line***REMOVED*** if ($prefix);
				    last;
				  ***REMOVED***;
		/\.type/    && do ***REMOVED*** my ($sym,$type,$narg) = split(',',$$line);
				    if ($type eq "\@function") ***REMOVED***
					undef $current_function;
					$current_function->***REMOVED***name***REMOVED*** = $sym;
					$current_function->***REMOVED***abi***REMOVED***  = "svr4";
					$current_function->***REMOVED***narg***REMOVED*** = $narg;
					$current_function->***REMOVED***scope***REMOVED*** = defined($globals***REMOVED***$sym***REMOVED***)?"PUBLIC":"PRIVATE";
				    ***REMOVED*** elsif ($type eq "\@abi-omnipotent") ***REMOVED***
					undef $current_function;
					$current_function->***REMOVED***name***REMOVED*** = $sym;
					$current_function->***REMOVED***scope***REMOVED*** = defined($globals***REMOVED***$sym***REMOVED***)?"PUBLIC":"PRIVATE";
				    ***REMOVED***
				    $$line =~ s/\@abi\-omnipotent/\@function/;
				    $$line =~ s/\@function.*/\@function/;
				    last;
				  ***REMOVED***;
		/\.asciz/   && do ***REMOVED*** if ($$line =~ /^"(.*)"$/) ***REMOVED***
					$dir  = ".byte";
					$$line = join(",",unpack("C*",$1),0);
				    ***REMOVED***
				    last;
				  ***REMOVED***;
		/\.rva|\.long|\.quad/
			    && do ***REMOVED*** $$line =~ s/([_a-z][_a-z0-9]*)/$globals***REMOVED***$1***REMOVED*** or $1/gei;
				    $$line =~ s/\.L/$decor/g;
				    last;
				  ***REMOVED***;
	    ***REMOVED***

	    if ($gas) ***REMOVED***
		$self->***REMOVED***value***REMOVED*** = $dir . "\t" . $$line;

		if ($dir =~ /\.extern/) ***REMOVED***
		    if ($flavour eq "elf") ***REMOVED***
			$self->***REMOVED***value***REMOVED*** .= "\n.hidden $$line";
		    ***REMOVED*** else ***REMOVED***
			$self->***REMOVED***value***REMOVED*** = "";
		    ***REMOVED***
		***REMOVED*** elsif (!$elf && $dir =~ /\.type/) ***REMOVED***
		    $self->***REMOVED***value***REMOVED*** = "";
		    $self->***REMOVED***value***REMOVED*** = ".def\t" . ($globals***REMOVED***$1***REMOVED*** or $1) . ";\t" .
				(defined($globals***REMOVED***$1***REMOVED***)?".scl 2;":".scl 3;") .
				"\t.type 32;\t.endef"
				if ($win64 && $$line =~ /([^,]+),\@function/);
		***REMOVED*** elsif (!$elf && $dir =~ /\.size/) ***REMOVED***
		    $self->***REMOVED***value***REMOVED*** = "";
		    if (defined($current_function)) ***REMOVED***
			$self->***REMOVED***value***REMOVED*** .= "$***REMOVED***decor***REMOVED***SEH_end_$current_function->***REMOVED***name***REMOVED***:"
				if ($win64 && $current_function->***REMOVED***abi***REMOVED*** eq "svr4");
			undef $current_function;
		    ***REMOVED***
		***REMOVED*** elsif (!$elf && $dir =~ /\.align/) ***REMOVED***
		    $self->***REMOVED***value***REMOVED*** = ".p2align\t" . (log($$line)/log(2));
		***REMOVED*** elsif ($dir eq ".section") ***REMOVED***
		    $current_segment=$$line;
		    if (!$elf && $current_segment eq ".init") ***REMOVED***
			if	($flavour eq "macosx")	***REMOVED*** $self->***REMOVED***value***REMOVED*** = ".mod_init_func"; ***REMOVED***
			elsif	($flavour eq "mingw64")	***REMOVED*** $self->***REMOVED***value***REMOVED*** = ".section\t.ctors"; ***REMOVED***
		    ***REMOVED***
		***REMOVED*** elsif ($dir =~ /\.(text|data)/) ***REMOVED***
		    $current_segment=".$1";
		***REMOVED*** elsif ($dir =~ /\.global|\.globl|\.extern/) ***REMOVED***
		    if ($flavour eq "macosx") ***REMOVED***
		        $self->***REMOVED***value***REMOVED*** .= "\n.private_extern $$line";
		    ***REMOVED*** else ***REMOVED***
		        $self->***REMOVED***value***REMOVED*** .= "\n.hidden $$line";
		    ***REMOVED***
		***REMOVED*** elsif ($dir =~ /\.hidden/) ***REMOVED***
		    if    ($flavour eq "macosx")  ***REMOVED*** $self->***REMOVED***value***REMOVED*** = ".private_extern\t$prefix$$line"; ***REMOVED***
		    elsif ($flavour eq "mingw64") ***REMOVED*** $self->***REMOVED***value***REMOVED*** = ""; ***REMOVED***
		***REMOVED*** elsif ($dir =~ /\.comm/) ***REMOVED***
		    $self->***REMOVED***value***REMOVED*** = "$dir\t$prefix$$line";
		    $self->***REMOVED***value***REMOVED*** =~ s|,([0-9]+),([0-9]+)$|",$1,".log($2)/log(2)|e if ($flavour eq "macosx");
		***REMOVED***
		$$line = "";
		return $self;
	    ***REMOVED***

	    # non-gas case or nasm/masm
	    SWITCH: for ($dir) ***REMOVED***
		/\.text/    && do ***REMOVED*** my $v=undef;
				    if ($nasm) ***REMOVED***
					$v="section	.text code align=64\n";
				    ***REMOVED*** else ***REMOVED***
					$v="$current_segment\tENDS\n" if ($current_segment);
					$current_segment = ".text\$";
					$v.="$current_segment\tSEGMENT ";
					$v.=$masm>=$masmref ? "ALIGN(256)" : "PAGE";
					$v.=" 'CODE'";
				    ***REMOVED***
				    $self->***REMOVED***value***REMOVED*** = $v;
				    last;
				  ***REMOVED***;
		/\.data/    && do ***REMOVED*** my $v=undef;
				    if ($nasm) ***REMOVED***
					$v="section	.data data align=8\n";
				    ***REMOVED*** else ***REMOVED***
					$v="$current_segment\tENDS\n" if ($current_segment);
					$current_segment = "_DATA";
					$v.="$current_segment\tSEGMENT";
				    ***REMOVED***
				    $self->***REMOVED***value***REMOVED*** = $v;
				    last;
				  ***REMOVED***;
		/\.section/ && do ***REMOVED*** my $v=undef;
				    $$line =~ s/([^,]*).*/$1/;
				    $$line = ".CRT\$XCU" if ($$line eq ".init");
				    if ($nasm) ***REMOVED***
					$v="section	$$line";
					if ($$line=~/\.([px])data/) ***REMOVED***
					    $v.=" rdata align=";
					    $v.=$1 eq "p"? 4 : 8;
					***REMOVED*** elsif ($$line=~/\.CRT\$/i) ***REMOVED***
					    $v.=" rdata align=8";
					***REMOVED***
				    ***REMOVED*** else ***REMOVED***
					$v="$current_segment\tENDS\n" if ($current_segment);
					$v.="$$line\tSEGMENT";
					if ($$line=~/\.([px])data/) ***REMOVED***
					    $v.=" READONLY";
					    $v.=" ALIGN(".($1 eq "p" ? 4 : 8).")" if ($masm>=$masmref);
					***REMOVED*** elsif ($$line=~/\.CRT\$/i) ***REMOVED***
					    $v.=" READONLY ";
					    $v.=$masm>=$masmref ? "ALIGN(8)" : "DWORD";
					***REMOVED***
				    ***REMOVED***
				    $current_segment = $$line;
				    $self->***REMOVED***value***REMOVED*** = $v;
				    last;
				  ***REMOVED***;
		/\.extern/  && do ***REMOVED*** $self->***REMOVED***value***REMOVED***  = "EXTERN\t".$$line;
				    $self->***REMOVED***value***REMOVED*** .= ":NEAR" if ($masm);
				    last;
				  ***REMOVED***;
		/\.globl|.global/
			    && do ***REMOVED*** $self->***REMOVED***value***REMOVED***  = $masm?"PUBLIC":"global";
				    $self->***REMOVED***value***REMOVED*** .= "\t".$$line;
				    last;
				  ***REMOVED***;
		/\.size/    && do ***REMOVED*** if (defined($current_function)) ***REMOVED***
					undef $self->***REMOVED***value***REMOVED***;
					if ($current_function->***REMOVED***abi***REMOVED*** eq "svr4") ***REMOVED***
					    $self->***REMOVED***value***REMOVED***="$***REMOVED***decor***REMOVED***SEH_end_$current_function->***REMOVED***name***REMOVED***:";
					    $self->***REMOVED***value***REMOVED***.=":\n" if($masm);
					***REMOVED***
					$self->***REMOVED***value***REMOVED***.="$current_function->***REMOVED***name***REMOVED***\tENDP" if($masm && $current_function->***REMOVED***name***REMOVED***);
					undef $current_function;
				    ***REMOVED***
				    last;
				  ***REMOVED***;
		/\.align/   && do ***REMOVED*** my $max = ($masm && $masm>=$masmref) ? 256 : 4096;
				    $self->***REMOVED***value***REMOVED*** = "ALIGN\t".($$line>$max?$max:$$line);
				    last;
				  ***REMOVED***;
		/\.(value|long|rva|quad)/
			    && do ***REMOVED*** my $sz  = substr($1,0,1);
				    my @arr = split(/,\s*/,$$line);
				    my $last = pop(@arr);
				    my $conv = sub  ***REMOVED***	my $var=shift;
							$var=~s/^(0b[0-1]+)/oct($1)/eig;
							$var=~s/^0x([0-9a-f]+)/0$1h/ig if ($masm);
							if ($sz eq "D" && ($current_segment=~/.[px]data/ || $dir eq ".rva"))
							***REMOVED*** $var=~s/([_a-z\$\@][_a-z0-9\$\@]*)/$nasm?"$1 wrt ..imagebase":"imagerel $1"/egi; ***REMOVED***
							$var;
						    ***REMOVED***;

				    $sz =~ tr/bvlrq/BWDDQ/;
				    $self->***REMOVED***value***REMOVED*** = "\tD$sz\t";
				    for (@arr) ***REMOVED*** $self->***REMOVED***value***REMOVED*** .= &$conv($_).","; ***REMOVED***
				    $self->***REMOVED***value***REMOVED*** .= &$conv($last);
				    last;
				  ***REMOVED***;
		/\.byte/    && do ***REMOVED*** my @str=split(/,\s*/,$$line);
				    map(s/(0b[0-1]+)/oct($1)/eig,@str);
				    map(s/0x([0-9a-f]+)/0$1h/ig,@str) if ($masm);
				    while ($#str>15) ***REMOVED***
					$self->***REMOVED***value***REMOVED***.="DB\t"
						.join(",",@str[0..15])."\n";
					foreach (0..15) ***REMOVED*** shift @str; ***REMOVED***
				    ***REMOVED***
				    $self->***REMOVED***value***REMOVED***.="DB\t"
						.join(",",@str) if (@str);
				    last;
				  ***REMOVED***;
		/\.comm/    && do ***REMOVED*** my @str=split(/,\s*/,$$line);
				    my $v=undef;
				    if ($nasm) ***REMOVED***
					$v.="common	$prefix@str[0] @str[1]";
				    ***REMOVED*** else ***REMOVED***
					$v="$current_segment\tENDS\n" if ($current_segment);
					$current_segment = "_DATA";
					$v.="$current_segment\tSEGMENT\n";
					$v.="COMM	@str[0]:DWORD:".@str[1]/4;
				    ***REMOVED***
				    $self->***REMOVED***value***REMOVED*** = $v;
				    last;
				  ***REMOVED***;
	    ***REMOVED***
	    $$line = "";
	***REMOVED***

	$ret;
    ***REMOVED***
    sub out ***REMOVED***
	my $self = shift;
	$self->***REMOVED***value***REMOVED***;
    ***REMOVED***
***REMOVED***

# Upon initial x86_64 introduction SSE>2 extensions were not introduced
# yet. In order not to be bothered by tracing exact assembler versions,
# but at the same time to provide a bare security minimum of AES-NI, we
# hard-code some instructions. Extensions past AES-NI on the other hand
# are traced by examining assembler version in individual perlasm
# modules...

my %regrm = (	"%eax"=>0, "%ecx"=>1, "%edx"=>2, "%ebx"=>3,
		"%esp"=>4, "%ebp"=>5, "%esi"=>6, "%edi"=>7	);

sub rex ***REMOVED***
 my $opcode=shift;
 my ($dst,$src,$rex)=@_;

   $rex|=0x04 if($dst>=8);
   $rex|=0x01 if($src>=8);
   push @$opcode,($rex|0x40) if ($rex);
***REMOVED***

my $movq = sub ***REMOVED***	# elderly gas can't handle inter-register movq
  my $arg = shift;
  my @opcode=(0x66);
    if ($arg =~ /%xmm([0-9]+),\s*%r(\w+)/) ***REMOVED***
	my ($src,$dst)=($1,$2);
	if ($dst !~ /[0-9]+/)	***REMOVED*** $dst = $regrm***REMOVED***"%e$dst"***REMOVED***; ***REMOVED***
	rex(\@opcode,$src,$dst,0x8);
	push @opcode,0x0f,0x7e;
	push @opcode,0xc0|(($src&7)<<3)|($dst&7);	# ModR/M
	@opcode;
    ***REMOVED*** elsif ($arg =~ /%r(\w+),\s*%xmm([0-9]+)/) ***REMOVED***
	my ($src,$dst)=($2,$1);
	if ($dst !~ /[0-9]+/)	***REMOVED*** $dst = $regrm***REMOVED***"%e$dst"***REMOVED***; ***REMOVED***
	rex(\@opcode,$src,$dst,0x8);
	push @opcode,0x0f,0x6e;
	push @opcode,0xc0|(($src&7)<<3)|($dst&7);	# ModR/M
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

my $pextrd = sub ***REMOVED***
    if (shift =~ /\$([0-9]+),\s*%xmm([0-9]+),\s*(%\w+)/) ***REMOVED***
      my @opcode=(0x66);
	my $imm=$1;
	my $src=$2;
	my $dst=$3;
	if ($dst =~ /%r([0-9]+)d/)	***REMOVED*** $dst = $1; ***REMOVED***
	elsif ($dst =~ /%e/)		***REMOVED*** $dst = $regrm***REMOVED***$dst***REMOVED***; ***REMOVED***
	rex(\@opcode,$src,$dst);
	push @opcode,0x0f,0x3a,0x16;
	push @opcode,0xc0|(($src&7)<<3)|($dst&7);	# ModR/M
	push @opcode,$imm;
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

my $pinsrd = sub ***REMOVED***
    if (shift =~ /\$([0-9]+),\s*(%\w+),\s*%xmm([0-9]+)/) ***REMOVED***
      my @opcode=(0x66);
	my $imm=$1;
	my $src=$2;
	my $dst=$3;
	if ($src =~ /%r([0-9]+)/)	***REMOVED*** $src = $1; ***REMOVED***
	elsif ($src =~ /%e/)		***REMOVED*** $src = $regrm***REMOVED***$src***REMOVED***; ***REMOVED***
	rex(\@opcode,$dst,$src);
	push @opcode,0x0f,0x3a,0x22;
	push @opcode,0xc0|(($dst&7)<<3)|($src&7);	# ModR/M
	push @opcode,$imm;
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

my $pshufb = sub ***REMOVED***
    if (shift =~ /%xmm([0-9]+),\s*%xmm([0-9]+)/) ***REMOVED***
      my @opcode=(0x66);
	rex(\@opcode,$2,$1);
	push @opcode,0x0f,0x38,0x00;
	push @opcode,0xc0|($1&7)|(($2&7)<<3);		# ModR/M
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

my $palignr = sub ***REMOVED***
    if (shift =~ /\$([0-9]+),\s*%xmm([0-9]+),\s*%xmm([0-9]+)/) ***REMOVED***
      my @opcode=(0x66);
	rex(\@opcode,$3,$2);
	push @opcode,0x0f,0x3a,0x0f;
	push @opcode,0xc0|($2&7)|(($3&7)<<3);		# ModR/M
	push @opcode,$1;
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

my $pclmulqdq = sub ***REMOVED***
    if (shift =~ /\$([x0-9a-f]+),\s*%xmm([0-9]+),\s*%xmm([0-9]+)/) ***REMOVED***
      my @opcode=(0x66);
	rex(\@opcode,$3,$2);
	push @opcode,0x0f,0x3a,0x44;
	push @opcode,0xc0|($2&7)|(($3&7)<<3);		# ModR/M
	my $c=$1;
	push @opcode,$c=~/^0/?oct($c):$c;
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

my $rdrand = sub ***REMOVED***
    if (shift =~ /%[er](\w+)/) ***REMOVED***
      my @opcode=();
      my $dst=$1;
	if ($dst !~ /[0-9]+/) ***REMOVED*** $dst = $regrm***REMOVED***"%e$dst"***REMOVED***; ***REMOVED***
	rex(\@opcode,0,$dst,8);
	push @opcode,0x0f,0xc7,0xf0|($dst&7);
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

my $rdseed = sub ***REMOVED***
    if (shift =~ /%[er](\w+)/) ***REMOVED***
      my @opcode=();
      my $dst=$1;
	if ($dst !~ /[0-9]+/) ***REMOVED*** $dst = $regrm***REMOVED***"%e$dst"***REMOVED***; ***REMOVED***
	rex(\@opcode,0,$dst,8);
	push @opcode,0x0f,0xc7,0xf8|($dst&7);
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

# Not all AVX-capable assemblers recognize AMD XOP extension. Since we
# are using only two instructions hand-code them in order to be excused
# from chasing assembler versions...

sub rxb ***REMOVED***
 my $opcode=shift;
 my ($dst,$src1,$src2,$rxb)=@_;

   $rxb|=0x7<<5;
   $rxb&=~(0x04<<5) if($dst>=8);
   $rxb&=~(0x01<<5) if($src1>=8);
   $rxb&=~(0x02<<5) if($src2>=8);
   push @$opcode,$rxb;
***REMOVED***

my $vprotd = sub ***REMOVED***
    if (shift =~ /\$([x0-9a-f]+),\s*%xmm([0-9]+),\s*%xmm([0-9]+)/) ***REMOVED***
      my @opcode=(0x8f);
	rxb(\@opcode,$3,$2,-1,0x08);
	push @opcode,0x78,0xc2;
	push @opcode,0xc0|($2&7)|(($3&7)<<3);		# ModR/M
	my $c=$1;
	push @opcode,$c=~/^0/?oct($c):$c;
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

my $vprotq = sub ***REMOVED***
    if (shift =~ /\$([x0-9a-f]+),\s*%xmm([0-9]+),\s*%xmm([0-9]+)/) ***REMOVED***
      my @opcode=(0x8f);
	rxb(\@opcode,$3,$2,-1,0x08);
	push @opcode,0x78,0xc3;
	push @opcode,0xc0|($2&7)|(($3&7)<<3);		# ModR/M
	my $c=$1;
	push @opcode,$c=~/^0/?oct($c):$c;
	@opcode;
    ***REMOVED*** else ***REMOVED***
	();
    ***REMOVED***
***REMOVED***;

# Intel Control-flow Enforcement Technology extension. All functions and
# indirect branch targets will have to start with this instruction...

my $endbranch = sub ***REMOVED***
    (0xf3,0x0f,0x1e,0xfa);
***REMOVED***;

########################################################################

if ($nasm) ***REMOVED***
    print <<___;
default	rel
%define XMMWORD
%define YMMWORD
%define ZMMWORD
___
***REMOVED*** elsif ($masm) ***REMOVED***
    print <<___;
OPTION	DOTNAME
___
***REMOVED***
print STDOUT "#if defined(__x86_64__)\n" if ($gas);

while(defined(my $line=<>)) ***REMOVED***

    $line =~ s|\R$||;           # Better chomp

    $line =~ s|[#!].*$||;	# get rid of asm-style comments...
    $line =~ s|/\*.*\*/||;	# ... and C-style comments...
    $line =~ s|^\s+||;		# ... and skip white spaces in beginning
    $line =~ s|\s+$||;		# ... and at the end

    if (my $label=label->re(\$line))	***REMOVED*** print $label->out(); ***REMOVED***

    if (my $directive=directive->re(\$line)) ***REMOVED***
	printf "%s",$directive->out();
    ***REMOVED*** elsif (my $opcode=opcode->re(\$line)) ***REMOVED***
	my $asm = eval("\$".$opcode->mnemonic());

	if ((ref($asm) eq 'CODE') && scalar(my @bytes=&$asm($line))) ***REMOVED***
	    print $gas?".byte\t":"DB\t",join(',',@bytes),"\n";
	    next;
	***REMOVED***

	my @args;
	ARGUMENT: while (1) ***REMOVED***
	    my $arg;

	    ($arg=register->re(\$line, $opcode))||
	    ($arg=const->re(\$line))		||
	    ($arg=ea->re(\$line, $opcode))	||
	    ($arg=expr->re(\$line, $opcode))	||
	    last ARGUMENT;

	    push @args,$arg;

	    last ARGUMENT if ($line !~ /^,/);

	    $line =~ s/^,\s*//;
	***REMOVED*** # ARGUMENT:

	if ($#args>=0) ***REMOVED***
	    my $insn;
	    my $sz=$opcode->size();

	    if ($gas) ***REMOVED***
		$insn = $opcode->out($#args>=1?$args[$#args]->size():$sz);
		@args = map($_->out($sz),@args);
		printf "\t%s\t%s",$insn,join(",",@args);
	    ***REMOVED*** else ***REMOVED***
		$insn = $opcode->out();
		foreach (@args) ***REMOVED***
		    my $arg = $_->out();
		    # $insn.=$sz compensates for movq, pinsrw, ...
		    if ($arg =~ /^xmm[0-9]+$/) ***REMOVED*** $insn.=$sz; $sz="x" if(!$sz); last; ***REMOVED***
		    if ($arg =~ /^ymm[0-9]+$/) ***REMOVED*** $insn.=$sz; $sz="y" if(!$sz); last; ***REMOVED***
		    if ($arg =~ /^zmm[0-9]+$/) ***REMOVED*** $insn.=$sz; $sz="z" if(!$sz); last; ***REMOVED***
		    if ($arg =~ /^mm[0-9]+$/)  ***REMOVED*** $insn.=$sz; $sz="q" if(!$sz); last; ***REMOVED***
		***REMOVED***
		@args = reverse(@args);
		undef $sz if ($nasm && $opcode->mnemonic() eq "lea");

		if ($insn eq "movq" && $#args == 1 && $args[0]->out($sz) eq "xmm0" && $args[1]->out($sz) eq "rax") ***REMOVED***
		    # I have no clue why MASM can't parse this instruction.
		    printf "DB 66h, 48h, 0fh, 6eh, 0c0h";
		***REMOVED*** else ***REMOVED***
		    printf "\t%s\t%s",$insn,join(",",map($_->out($sz),@args));
		***REMOVED***
	    ***REMOVED***
	***REMOVED*** else ***REMOVED***
	    printf "\t%s",$opcode->out();
	***REMOVED***
    ***REMOVED***

    print $line,"\n";
***REMOVED***

print "\n$current_segment\tENDS\n"	if ($current_segment && $masm);
print "END\n"				if ($masm);
print "#endif\n"			if ($gas);


close STDOUT;

#################################################
# Cross-reference x86_64 ABI "card"
#
# 		Unix		Win64
# %rax		*		*
# %rbx		-		-
# %rcx		#4		#1
# %rdx		#3		#2
# %rsi		#2		-
# %rdi		#1		-
# %rbp		-		-
# %rsp		-		-
# %r8		#5		#3
# %r9		#6		#4
# %r10		*		*
# %r11		*		*
# %r12		-		-
# %r13		-		-
# %r14		-		-
# %r15		-		-
#
# (*)	volatile register
# (-)	preserved by callee
# (#)	Nth argument, volatile
#
# In Unix terms top of stack is argument transfer area for arguments
# which could not be accommodated in registers. Or in other words 7th
# [integer] argument resides at 8(%rsp) upon function entry point.
# 128 bytes above %rsp constitute a "red zone" which is not touched
# by signal handlers and can be used as temporal storage without
# allocating a frame.
#
# In Win64 terms N*8 bytes on top of stack is argument transfer area,
# which belongs to/can be overwritten by callee. N is the number of
# arguments passed to callee, *but* not less than 4! This means that
# upon function entry point 5th argument resides at 40(%rsp), as well
# as that 32 bytes from 8(%rsp) can always be used as temporal
# storage [without allocating a frame]. One can actually argue that
# one can assume a "red zone" above stack pointer under Win64 as well.
# Point is that at apparently no occasion Windows kernel would alter
# the area above user stack pointer in true asynchronous manner...
#
# All the above means that if assembler programmer adheres to Unix
# register and stack layout, but disregards the "red zone" existence,
# it's possible to use following prologue and epilogue to "gear" from
# Unix to Win64 ABI in leaf functions with not more than 6 arguments.
#
# omnipotent_function:
# ifdef WIN64
#	movq	%rdi,8(%rsp)
#	movq	%rsi,16(%rsp)
#	movq	%rcx,%rdi	; if 1st argument is actually present
#	movq	%rdx,%rsi	; if 2nd argument is actually ...
#	movq	%r8,%rdx	; if 3rd argument is ...
#	movq	%r9,%rcx	; if 4th argument ...
#	movq	40(%rsp),%r8	; if 5th ...
#	movq	48(%rsp),%r9	; if 6th ...
# endif
#	...
# ifdef WIN64
#	movq	8(%rsp),%rdi
#	movq	16(%rsp),%rsi
# endif
#	ret
#
#################################################
# Win64 SEH, Structured Exception Handling.
#
# Unlike on Unix systems(*) lack of Win64 stack unwinding information
# has undesired side-effect at run-time: if an exception is raised in
# assembler subroutine such as those in question (basically we're
# referring to segmentation violations caused by malformed input
# parameters), the application is briskly terminated without invoking
# any exception handlers, most notably without generating memory dump
# or any user notification whatsoever. This poses a problem. It's
# possible to address it by registering custom language-specific
# handler that would restore processor context to the state at
# subroutine entry point and return "exception is not handled, keep
# unwinding" code. Writing such handler can be a challenge... But it's
# doable, though requires certain coding convention. Consider following
# snippet:
#
# .type	function,@function
# function:
#	movq	%rsp,%rax	# copy rsp to volatile register
#	pushq	%r15		# save non-volatile registers
#	pushq	%rbx
#	pushq	%rbp
#	movq	%rsp,%r11
#	subq	%rdi,%r11	# prepare [variable] stack frame
#	andq	$-64,%r11
#	movq	%rax,0(%r11)	# check for exceptions
#	movq	%r11,%rsp	# allocate [variable] stack frame
#	movq	%rax,0(%rsp)	# save original rsp value
# magic_point:
#	...
#	movq	0(%rsp),%rcx	# pull original rsp value
#	movq	-24(%rcx),%rbp	# restore non-volatile registers
#	movq	-16(%rcx),%rbx
#	movq	-8(%rcx),%r15
#	movq	%rcx,%rsp	# restore original rsp
# magic_epilogue:
#	ret
# .size function,.-function
#
# The key is that up to magic_point copy of original rsp value remains
# in chosen volatile register and no non-volatile register, except for
# rsp, is modified. While past magic_point rsp remains constant till
# the very end of the function. In this case custom language-specific
# exception handler would look like this:
#
# EXCEPTION_DISPOSITION handler (EXCEPTION_RECORD *rec,ULONG64 frame,
#		CONTEXT *context,DISPATCHER_CONTEXT *disp)
# ***REMOVED***	ULONG64 *rsp = (ULONG64 *)context->Rax;
#	ULONG64  rip = context->Rip;
#
#	if (rip >= magic_point)
#	***REMOVED***   rsp = (ULONG64 *)context->Rsp;
#	    if (rip < magic_epilogue)
#	    ***REMOVED***	rsp = (ULONG64 *)rsp[0];
#		context->Rbp = rsp[-3];
#		context->Rbx = rsp[-2];
#		context->R15 = rsp[-1];
#	    ***REMOVED***
#	***REMOVED***
#	context->Rsp = (ULONG64)rsp;
#	context->Rdi = rsp[1];
#	context->Rsi = rsp[2];
#
#	memcpy (disp->ContextRecord,context,sizeof(CONTEXT));
#	RtlVirtualUnwind(UNW_FLAG_NHANDLER,disp->ImageBase,
#		dips->ControlPc,disp->FunctionEntry,disp->ContextRecord,
#		&disp->HandlerData,&disp->EstablisherFrame,NULL);
#	return ExceptionContinueSearch;
# ***REMOVED***
#
# It's appropriate to implement this handler in assembler, directly in
# function's module. In order to do that one has to know members'
# offsets in CONTEXT and DISPATCHER_CONTEXT structures and some constant
# values. Here they are:
#
#	CONTEXT.Rax				120
#	CONTEXT.Rcx				128
#	CONTEXT.Rdx				136
#	CONTEXT.Rbx				144
#	CONTEXT.Rsp				152
#	CONTEXT.Rbp				160
#	CONTEXT.Rsi				168
#	CONTEXT.Rdi				176
#	CONTEXT.R8				184
#	CONTEXT.R9				192
#	CONTEXT.R10				200
#	CONTEXT.R11				208
#	CONTEXT.R12				216
#	CONTEXT.R13				224
#	CONTEXT.R14				232
#	CONTEXT.R15				240
#	CONTEXT.Rip				248
#	CONTEXT.Xmm6				512
#	sizeof(CONTEXT)				1232
#	DISPATCHER_CONTEXT.ControlPc		0
#	DISPATCHER_CONTEXT.ImageBase		8
#	DISPATCHER_CONTEXT.FunctionEntry	16
#	DISPATCHER_CONTEXT.EstablisherFrame	24
#	DISPATCHER_CONTEXT.TargetIp		32
#	DISPATCHER_CONTEXT.ContextRecord	40
#	DISPATCHER_CONTEXT.LanguageHandler	48
#	DISPATCHER_CONTEXT.HandlerData		56
#	UNW_FLAG_NHANDLER			0
#	ExceptionContinueSearch			1
#
# In order to tie the handler to the function one has to compose
# couple of structures: one for .xdata segment and one for .pdata.
#
# UNWIND_INFO structure for .xdata segment would be
#
# function_unwind_info:
#	.byte	9,0,0,0
#	.rva	handler
#
# This structure designates exception handler for a function with
# zero-length prologue, no stack frame or frame register.
#
# To facilitate composing of .pdata structures, auto-generated "gear"
# prologue copies rsp value to rax and denotes next instruction with
# .LSEH_begin_***REMOVED***function_name***REMOVED*** label. This essentially defines the SEH
# styling rule mentioned in the beginning. Position of this label is
# chosen in such manner that possible exceptions raised in the "gear"
# prologue would be accounted to caller and unwound from latter's frame.
# End of function is marked with respective .LSEH_end_***REMOVED***function_name***REMOVED***
# label. To summarize, .pdata segment would contain
#
#	.rva	.LSEH_begin_function
#	.rva	.LSEH_end_function
#	.rva	function_unwind_info
#
# Reference to function_unwind_info from .xdata segment is the anchor.
# In case you wonder why references are 32-bit .rvas and not 64-bit
# .quads. References put into these two segments are required to be
# *relative* to the base address of the current binary module, a.k.a.
# image base. No Win64 module, be it .exe or .dll, can be larger than
# 2GB and thus such relative references can be and are accommodated in
# 32 bits.
#
# Having reviewed the example function code, one can argue that "movq
# %rsp,%rax" above is redundant. It is not! Keep in mind that on Unix
# rax would contain an undefined value. If this "offends" you, use
# another register and refrain from modifying rax till magic_point is
# reached, i.e. as if it was a non-volatile register. If more registers
# are required prior [variable] frame setup is completed, note that
# nobody says that you can have only one "magic point." You can
# "liberate" non-volatile registers by denoting last stack off-load
# instruction and reflecting it in finer grade unwind logic in handler.
# After all, isn't it why it's called *language-specific* handler...
#
# SE handlers are also involved in unwinding stack when executable is
# profiled or debugged. Profiling implies additional limitations that
# are too subtle to discuss here. For now it's sufficient to say that
# in order to simplify handlers one should either a) offload original
# %rsp to stack (like discussed above); or b) if you have a register to
# spare for frame pointer, choose volatile one.
#
# (*)	Note that we're talking about run-time, not debug-time. Lack of
#	unwind information makes debugging hard on both Windows and
#	Unix. "Unlike" referes to the fact that on Unix signal handler
#	will always be invoked, core dumped and appropriate exit code
#	returned to parent (for user notification).
