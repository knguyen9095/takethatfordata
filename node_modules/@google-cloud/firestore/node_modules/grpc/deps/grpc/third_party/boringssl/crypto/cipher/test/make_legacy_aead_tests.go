package main

import (
	"crypto"
	"crypto/aes"
	"crypto/cipher"
	"crypto/des"
	"crypto/hmac"
	_ "crypto/md5"
	"crypto/rc4"
	_ "crypto/sha1"
	_ "crypto/sha256"
	_ "crypto/sha512"
	"encoding/hex"
	"flag"
	"fmt"
	"os"
)

var bulkCipher *string = flag.String("cipher", "", "The bulk cipher to use")
var mac *string = flag.String("mac", "", "The hash function to use in the MAC")
var implicitIV *bool = flag.Bool("implicit-iv", false, "If true, generate tests for a cipher using a pre-TLS-1.0 implicit IV")
var ssl3 *bool = flag.Bool("ssl3", false, "If true, use the SSLv3 MAC and padding rather than TLS")

// rc4Stream produces a deterministic stream of pseudorandom bytes. This is to
// make this script idempotent.
type rc4Stream struct ***REMOVED***
	cipher *rc4.Cipher
***REMOVED***

func newRc4Stream(seed string) (*rc4Stream, error) ***REMOVED***
	cipher, err := rc4.NewCipher([]byte(seed))
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	return &rc4Stream***REMOVED***cipher***REMOVED***, nil
***REMOVED***

func (rs *rc4Stream) fillBytes(p []byte) ***REMOVED***
	for i := range p ***REMOVED***
		p[i] = 0
	***REMOVED***
	rs.cipher.XORKeyStream(p, p)
***REMOVED***

func getHash(name string) (crypto.Hash, bool) ***REMOVED***
	switch name ***REMOVED***
	case "md5":
		return crypto.MD5, true
	case "sha1":
		return crypto.SHA1, true
	case "sha256":
		return crypto.SHA256, true
	case "sha384":
		return crypto.SHA384, true
	default:
		return 0, false
	***REMOVED***
***REMOVED***

func getKeySize(name string) int ***REMOVED***
	switch name ***REMOVED***
	case "aes128":
		return 16
	case "aes256":
		return 32
	case "3des":
		return 24
	default:
		return 0
	***REMOVED***
***REMOVED***

func newBlockCipher(name string, key []byte) (cipher.Block, error) ***REMOVED***
	switch name ***REMOVED***
	case "aes128":
		return aes.NewCipher(key)
	case "aes256":
		return aes.NewCipher(key)
	case "3des":
		return des.NewTripleDESCipher(key)
	default:
		return nil, fmt.Errorf("unknown cipher '%s'", name)
	***REMOVED***
***REMOVED***

var ssl30Pad1 = [48]byte***REMOVED***0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36***REMOVED***

var ssl30Pad2 = [48]byte***REMOVED***0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c***REMOVED***

func ssl30MAC(hash crypto.Hash, key, input, ad []byte) []byte ***REMOVED***
	padLength := 48
	if hash.Size() == 20 ***REMOVED***
		padLength = 40
	***REMOVED***

	h := hash.New()
	h.Write(key)
	h.Write(ssl30Pad1[:padLength])
	h.Write(ad)
	h.Write(input)
	digestBuf := h.Sum(nil)

	h.Reset()
	h.Write(key)
	h.Write(ssl30Pad2[:padLength])
	h.Write(digestBuf)
	return h.Sum(digestBuf[:0])
***REMOVED***

type testCase struct ***REMOVED***
	digest     []byte
	key        []byte
	nonce      []byte
	input      []byte
	ad         []byte
	ciphertext []byte
	tag        []byte
	noSeal     bool
	fails      bool
***REMOVED***

// options adds additional options for a test.
type options struct ***REMOVED***
	// extraPadding causes an extra block of padding to be added.
	extraPadding bool
	// maximalPadding causes 256 bytes of padding to be added.
	maximalPadding bool
	// wrongPadding causes one of the padding bytes to be wrong.
	wrongPadding bool
	// wrongPaddingOffset specifies the byte offset of the incorrect padding
	// byte.
	wrongPaddingOffset int
	// noPadding causes padding is to be omitted. The plaintext + MAC must
	// be a multiple of the block size.
	noPadding bool
	// omitMAC causes the MAC to be omitted.
	omitMAC bool
***REMOVED***

func makeTestCase(length int, options options) (*testCase, error) ***REMOVED***
	rand, err := newRc4Stream("input stream")
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	input := make([]byte, length)
	rand.fillBytes(input)

	var adFull []byte
	if *ssl3 ***REMOVED***
		adFull = make([]byte, 11)
	***REMOVED*** else ***REMOVED***
		adFull = make([]byte, 13)
	***REMOVED***
	ad := adFull[:len(adFull)-2]
	rand.fillBytes(ad)
	adFull[len(adFull)-2] = uint8(length >> 8)
	adFull[len(adFull)-1] = uint8(length & 0xff)

	hash, ok := getHash(*mac)
	if !ok ***REMOVED***
		return nil, fmt.Errorf("unknown hash function '%s'", *mac)
	***REMOVED***

	macKey := make([]byte, hash.Size())
	rand.fillBytes(macKey)

	var digest []byte
	if *ssl3 ***REMOVED***
		if hash != crypto.SHA1 && hash != crypto.MD5 ***REMOVED***
			return nil, fmt.Errorf("invalid hash for SSLv3: '%s'", *mac)
		***REMOVED***
		digest = ssl30MAC(hash, macKey, input, adFull)
	***REMOVED*** else ***REMOVED***
		h := hmac.New(hash.New, macKey)
		h.Write(adFull)
		h.Write(input)
		digest = h.Sum(nil)
	***REMOVED***

	size := getKeySize(*bulkCipher)
	if size == 0 ***REMOVED***
		return nil, fmt.Errorf("unknown cipher '%s'", *bulkCipher)
	***REMOVED***
	encKey := make([]byte, size)
	rand.fillBytes(encKey)

	var fixedIV []byte
	var nonce []byte
	var sealed []byte
	var noSeal, fails bool
	block, err := newBlockCipher(*bulkCipher, encKey)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	iv := make([]byte, block.BlockSize())
	rand.fillBytes(iv)
	if *implicitIV || *ssl3 ***REMOVED***
		fixedIV = iv
	***REMOVED*** else ***REMOVED***
		nonce = iv
	***REMOVED***

	cbc := cipher.NewCBCEncrypter(block, iv)

	sealed = make([]byte, 0, len(input)+len(digest)+cbc.BlockSize())
	sealed = append(sealed, input...)
	if options.omitMAC ***REMOVED***
		noSeal = true
		fails = true
	***REMOVED*** else ***REMOVED***
		sealed = append(sealed, digest...)
	***REMOVED***
	paddingLen := cbc.BlockSize() - (len(sealed) % cbc.BlockSize())
	if options.noPadding ***REMOVED***
		if paddingLen != cbc.BlockSize() ***REMOVED***
			return nil, fmt.Errorf("invalid length for noPadding")
		***REMOVED***
		noSeal = true
		fails = true
	***REMOVED*** else ***REMOVED***
		if options.extraPadding || options.maximalPadding ***REMOVED***
			if options.extraPadding ***REMOVED***
				paddingLen += cbc.BlockSize()
			***REMOVED*** else ***REMOVED***
				if paddingLen != cbc.BlockSize() ***REMOVED***
					return nil, fmt.Errorf("invalid length for maximalPadding")
				***REMOVED***
				paddingLen = 256
			***REMOVED***
			noSeal = true
			if *ssl3 ***REMOVED***
				// SSLv3 padding must be minimal.
				fails = true
			***REMOVED***
		***REMOVED***
		if *ssl3 ***REMOVED***
			sealed = append(sealed, make([]byte, paddingLen-1)...)
			sealed = append(sealed, byte(paddingLen-1))
		***REMOVED*** else ***REMOVED***
			pad := make([]byte, paddingLen)
			for i := range pad ***REMOVED***
				pad[i] = byte(paddingLen - 1)
			***REMOVED***
			sealed = append(sealed, pad...)
		***REMOVED***
		if options.wrongPadding ***REMOVED***
			if options.wrongPaddingOffset >= paddingLen ***REMOVED***
				return nil, fmt.Errorf("invalid wrongPaddingOffset")
			***REMOVED***
			sealed[len(sealed)-paddingLen+options.wrongPaddingOffset]++
			noSeal = true
			if !*ssl3 ***REMOVED***
				// TLS specifies the all the padding bytes.
				fails = true
			***REMOVED***
		***REMOVED***
	***REMOVED***
	cbc.CryptBlocks(sealed, sealed)

	key := make([]byte, 0, len(macKey)+len(encKey)+len(fixedIV))
	key = append(key, macKey...)
	key = append(key, encKey...)
	key = append(key, fixedIV...)
	t := &testCase***REMOVED***
		digest:     digest,
		key:        key,
		nonce:      nonce,
		input:      input,
		ad:         ad,
		ciphertext: sealed[:len(sealed)-hash.Size()],
		tag:        sealed[len(sealed)-hash.Size():],
		noSeal:     noSeal,
		fails:      fails,
	***REMOVED***
	return t, nil
***REMOVED***

func printTestCase(t *testCase) ***REMOVED***
	fmt.Printf("# DIGEST: %s\n", hex.EncodeToString(t.digest))
	fmt.Printf("KEY: %s\n", hex.EncodeToString(t.key))
	fmt.Printf("NONCE: %s\n", hex.EncodeToString(t.nonce))
	fmt.Printf("IN: %s\n", hex.EncodeToString(t.input))
	fmt.Printf("AD: %s\n", hex.EncodeToString(t.ad))
	fmt.Printf("CT: %s\n", hex.EncodeToString(t.ciphertext))
	fmt.Printf("TAG: %s\n", hex.EncodeToString(t.tag))
	if t.noSeal ***REMOVED***
		fmt.Printf("NO_SEAL: 01\n")
	***REMOVED***
	if t.fails ***REMOVED***
		fmt.Printf("FAILS: 01\n")
	***REMOVED***
***REMOVED***

func addTestCase(length int, options options) ***REMOVED***
	t, err := makeTestCase(length, options)
	if err != nil ***REMOVED***
		fmt.Fprintf(os.Stderr, "%s\n", err)
		os.Exit(1)
	***REMOVED***
	printTestCase(t)
	fmt.Printf("\n")
***REMOVED***

func main() ***REMOVED***
	flag.Parse()

	commandLine := fmt.Sprintf("go run make_legacy_aead_tests.go -cipher %s -mac %s", *bulkCipher, *mac)
	if *implicitIV ***REMOVED***
		commandLine += " -implicit-iv"
	***REMOVED***
	if *ssl3 ***REMOVED***
		commandLine += " -ssl3"
	***REMOVED***
	fmt.Printf("# Generated by\n")
	fmt.Printf("#   %s\n", commandLine)
	fmt.Printf("#\n")
	fmt.Printf("# Note: aead_test's input format splits the ciphertext and tag positions of the sealed\n")
	fmt.Printf("# input. But these legacy AEADs are MAC-then-encrypt and may include padding, so this\n")
	fmt.Printf("# split isn't meaningful. The unencrypted MAC is included in the 'DIGEST' tag above\n")
	fmt.Printf("# each test case.\n")
	fmt.Printf("\n")

	// For CBC-mode ciphers, emit tests for padding flexibility.
	fmt.Printf("# Test with non-minimal padding.\n")
	addTestCase(5, options***REMOVED***extraPadding: true***REMOVED***)

	fmt.Printf("# Test with bad padding values.\n")
	addTestCase(5, options***REMOVED***wrongPadding: true***REMOVED***)

	hash, ok := getHash(*mac)
	if !ok ***REMOVED***
		panic("unknown hash")
	***REMOVED***

	fmt.Printf("# Test with no padding.\n")
	addTestCase(64-hash.Size(), options***REMOVED***noPadding: true***REMOVED***)

	fmt.Printf("# Test with maximal padding.\n")
	addTestCase(64-hash.Size(), options***REMOVED***maximalPadding: true***REMOVED***)

	fmt.Printf("# Test if the unpadded input is too short for a MAC, but not publicly so.\n")
	addTestCase(0, options***REMOVED***omitMAC: true, maximalPadding: true***REMOVED***)

	fmt.Printf("# Test that each byte of incorrect padding is noticed.\n")
	for i := 0; i < 256; i++ ***REMOVED***
		addTestCase(64-hash.Size(), options***REMOVED***
			maximalPadding:     true,
			wrongPadding:       true,
			wrongPaddingOffset: i,
		***REMOVED***)
	***REMOVED***

	// Generate long enough of input to cover a non-zero num_starting_blocks
	// value in the constant-time CBC logic.
	for l := 0; l < 500; l += 5 ***REMOVED***
		addTestCase(l, options***REMOVED******REMOVED***)
	***REMOVED***
***REMOVED***
