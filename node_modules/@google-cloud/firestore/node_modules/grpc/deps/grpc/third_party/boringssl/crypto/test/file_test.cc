/* Copyright (c) 2015, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

#include "file_test.h"

#include <memory>

#include <ctype.h>
#include <errno.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/err.h>

#include "../internal.h"


FileTest::FileTest(const char *path) ***REMOVED***
  file_ = fopen(path, "r");
  if (file_ == nullptr) ***REMOVED***
    fprintf(stderr, "Could not open file %s: %s.\n", path, strerror(errno));
  ***REMOVED***
***REMOVED***

FileTest::~FileTest() ***REMOVED***
  if (file_ != nullptr) ***REMOVED***
    fclose(file_);
  ***REMOVED***
***REMOVED***

// FindDelimiter returns a pointer to the first '=' or ':' in |str| or nullptr
// if there is none.
static const char *FindDelimiter(const char *str) ***REMOVED***
  while (*str) ***REMOVED***
    if (*str == ':' || *str == '=') ***REMOVED***
      return str;
    ***REMOVED***
    str++;
  ***REMOVED***
  return nullptr;
***REMOVED***

// StripSpace returns a string containing up to |len| characters from |str| with
// leading and trailing whitespace removed.
static std::string StripSpace(const char *str, size_t len) ***REMOVED***
  // Remove leading space.
  while (len > 0 && isspace(*str)) ***REMOVED***
    str++;
    len--;
  ***REMOVED***
  while (len > 0 && isspace(str[len-1])) ***REMOVED***
    len--;
  ***REMOVED***
  return std::string(str, len);
***REMOVED***

FileTest::ReadResult FileTest::ReadNext() ***REMOVED***
  // If the previous test had unused attributes, it is an error.
  if (!unused_attributes_.empty()) ***REMOVED***
    for (const std::string &key : unused_attributes_) ***REMOVED***
      PrintLine("Unused attribute: %s", key.c_str());
    ***REMOVED***
    return kReadError;
  ***REMOVED***

  ClearTest();

  static const size_t kBufLen = 64 + 8192*2;
  std::unique_ptr<char[]> buf(new char[kBufLen]);

  while (true) ***REMOVED***
    // Read the next line.
    if (fgets(buf.get(), kBufLen, file_) == nullptr) ***REMOVED***
      if (feof(file_)) ***REMOVED***
        // EOF is a valid terminator for a test.
        return start_line_ > 0 ? kReadSuccess : kReadEOF;
      ***REMOVED***
      fprintf(stderr, "Error reading from input.\n");
      return kReadError;
    ***REMOVED***

    line_++;
    size_t len = strlen(buf.get());
    // Check for truncation.
    if (len > 0 && buf[len - 1] != '\n' && !feof(file_)) ***REMOVED***
      fprintf(stderr, "Line %u too long.\n", line_);
      return kReadError;
    ***REMOVED***

    if (buf[0] == '\n' || buf[0] == '\0') ***REMOVED***
      // Empty lines delimit tests.
      if (start_line_ > 0) ***REMOVED***
        return kReadSuccess;
      ***REMOVED***
    ***REMOVED*** else if (buf[0] != '#') ***REMOVED***  // Comment lines are ignored.
      // Parse the line as an attribute.
      const char *delimiter = FindDelimiter(buf.get());
      if (delimiter == nullptr) ***REMOVED***
        fprintf(stderr, "Line %u: Could not parse attribute.\n", line_);
        return kReadError;
      ***REMOVED***
      std::string key = StripSpace(buf.get(), delimiter - buf.get());
      std::string value = StripSpace(delimiter + 1,
                                     buf.get() + len - delimiter - 1);

      unused_attributes_.insert(key);
      attributes_[key] = value;
      if (start_line_ == 0) ***REMOVED***
        // This is the start of a test.
        type_ = key;
        parameter_ = value;
        start_line_ = line_;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

void FileTest::PrintLine(const char *format, ...) ***REMOVED***
  va_list args;
  va_start(args, format);

  fprintf(stderr, "Line %u: ", start_line_);
  vfprintf(stderr, format, args);
  fprintf(stderr, "\n");

  va_end(args);
***REMOVED***

const std::string &FileTest::GetType() ***REMOVED***
  OnKeyUsed(type_);
  return type_;
***REMOVED***

const std::string &FileTest::GetParameter() ***REMOVED***
  OnKeyUsed(type_);
  return parameter_;
***REMOVED***

bool FileTest::HasAttribute(const std::string &key) ***REMOVED***
  OnKeyUsed(key);
  return attributes_.count(key) > 0;
***REMOVED***

bool FileTest::GetAttribute(std::string *out_value, const std::string &key) ***REMOVED***
  OnKeyUsed(key);
  auto iter = attributes_.find(key);
  if (iter == attributes_.end()) ***REMOVED***
    PrintLine("Missing attribute '%s'.", key.c_str());
    return false;
  ***REMOVED***
  *out_value = iter->second;
  return true;
***REMOVED***

const std::string &FileTest::GetAttributeOrDie(const std::string &key) ***REMOVED***
  if (!HasAttribute(key)) ***REMOVED***
    abort();
  ***REMOVED***
  return attributes_[key];
***REMOVED***

static bool FromHexDigit(uint8_t *out, char c) ***REMOVED***
  if ('0' <= c && c <= '9') ***REMOVED***
    *out = c - '0';
    return true;
  ***REMOVED***
  if ('a' <= c && c <= 'f') ***REMOVED***
    *out = c - 'a' + 10;
    return true;
  ***REMOVED***
  if ('A' <= c && c <= 'F') ***REMOVED***
    *out = c - 'A' + 10;
    return true;
  ***REMOVED***
  return false;
***REMOVED***

bool FileTest::GetBytes(std::vector<uint8_t> *out, const std::string &key) ***REMOVED***
  std::string value;
  if (!GetAttribute(&value, key)) ***REMOVED***
    return false;
  ***REMOVED***

  if (value.size() >= 2 && value[0] == '"' && value[value.size() - 1] == '"') ***REMOVED***
    out->assign(value.begin() + 1, value.end() - 1);
    return true;
  ***REMOVED***

  if (value.size() % 2 != 0) ***REMOVED***
    PrintLine("Error decoding value: %s", value.c_str());
    return false;
  ***REMOVED***
  out->clear();
  out->reserve(value.size() / 2);
  for (size_t i = 0; i < value.size(); i += 2) ***REMOVED***
    uint8_t hi, lo;
    if (!FromHexDigit(&hi, value[i]) || !FromHexDigit(&lo, value[i+1])) ***REMOVED***
      PrintLine("Error decoding value: %s", value.c_str());
      return false;
    ***REMOVED***
    out->push_back((hi << 4) | lo);
  ***REMOVED***
  return true;
***REMOVED***

static std::string EncodeHex(const uint8_t *in, size_t in_len) ***REMOVED***
  static const char kHexDigits[] = "0123456789abcdef";
  std::string ret;
  ret.reserve(in_len * 2);
  for (size_t i = 0; i < in_len; i++) ***REMOVED***
    ret += kHexDigits[in[i] >> 4];
    ret += kHexDigits[in[i] & 0xf];
  ***REMOVED***
  return ret;
***REMOVED***

bool FileTest::ExpectBytesEqual(const uint8_t *expected, size_t expected_len,
                                const uint8_t *actual, size_t actual_len) ***REMOVED***
  if (expected_len == actual_len &&
      OPENSSL_memcmp(expected, actual, expected_len) == 0) ***REMOVED***
    return true;
  ***REMOVED***

  std::string expected_hex = EncodeHex(expected, expected_len);
  std::string actual_hex = EncodeHex(actual, actual_len);
  PrintLine("Expected: %s", expected_hex.c_str());
  PrintLine("Actual:   %s", actual_hex.c_str());
  return false;
***REMOVED***

void FileTest::ClearTest() ***REMOVED***
  start_line_ = 0;
  type_.clear();
  parameter_.clear();
  attributes_.clear();
  unused_attributes_.clear();
***REMOVED***

void FileTest::OnKeyUsed(const std::string &key) ***REMOVED***
  unused_attributes_.erase(key);
***REMOVED***

int FileTestMain(bool (*run_test)(FileTest *t, void *arg), void *arg,
                 const char *path) ***REMOVED***
  FileTest t(path);
  if (!t.is_open()) ***REMOVED***
    return 1;
  ***REMOVED***

  bool failed = false;
  while (true) ***REMOVED***
    FileTest::ReadResult ret = t.ReadNext();
    if (ret == FileTest::kReadError) ***REMOVED***
      return 1;
    ***REMOVED*** else if (ret == FileTest::kReadEOF) ***REMOVED***
      break;
    ***REMOVED***

    bool result = run_test(&t, arg);
    if (t.HasAttribute("Error")) ***REMOVED***
      if (result) ***REMOVED***
        t.PrintLine("Operation unexpectedly succeeded.");
        failed = true;
        continue;
      ***REMOVED***
      uint32_t err = ERR_peek_error();
      if (ERR_reason_error_string(err) != t.GetAttributeOrDie("Error")) ***REMOVED***
        t.PrintLine("Unexpected error; wanted '%s', got '%s'.",
                     t.GetAttributeOrDie("Error").c_str(),
                     ERR_reason_error_string(err));
        failed = true;
        ERR_clear_error();
        continue;
      ***REMOVED***
      ERR_clear_error();
    ***REMOVED*** else if (!result) ***REMOVED***
      // In case the test itself doesn't print output, print something so the
      // line number is reported.
      t.PrintLine("Test failed");
      ERR_print_errors_fp(stderr);
      failed = true;
      continue;
    ***REMOVED***
  ***REMOVED***

  if (failed) ***REMOVED***
    return 1;
  ***REMOVED***

  printf("PASS\n");
  return 0;
***REMOVED***
