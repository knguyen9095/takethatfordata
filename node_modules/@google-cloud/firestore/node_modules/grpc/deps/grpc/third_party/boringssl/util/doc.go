// doc generates HTML files from the comments in header files.
//
// doc expects to be given the path to a JSON file via the --config option.
// From that JSON (which is defined by the Config struct) it reads a list of
// header file locations and generates HTML files for each in the current
// directory.

package main

import (
	"bufio"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// Config describes the structure of the config JSON file.
type Config struct ***REMOVED***
	// BaseDirectory is a path to which other paths in the file are
	// relative.
	BaseDirectory string
	Sections      []ConfigSection
***REMOVED***

type ConfigSection struct ***REMOVED***
	Name string
	// Headers is a list of paths to header files.
	Headers []string
***REMOVED***

// HeaderFile is the internal representation of a header file.
type HeaderFile struct ***REMOVED***
	// Name is the basename of the header file (e.g. "ex_data.html").
	Name string
	// Preamble contains a comment for the file as a whole. Each string
	// is a separate paragraph.
	Preamble []string
	Sections []HeaderSection
	// AllDecls maps all decls to their URL fragments.
	AllDecls map[string]string
***REMOVED***

type HeaderSection struct ***REMOVED***
	// Preamble contains a comment for a group of functions.
	Preamble []string
	Decls    []HeaderDecl
	// Anchor, if non-empty, is the URL fragment to use in anchor tags.
	Anchor string
	// IsPrivate is true if the section contains private functions (as
	// indicated by its name).
	IsPrivate bool
***REMOVED***

type HeaderDecl struct ***REMOVED***
	// Comment contains a comment for a specific function. Each string is a
	// paragraph. Some paragraph may contain \n runes to indicate that they
	// are preformatted.
	Comment []string
	// Name contains the name of the function, if it could be extracted.
	Name string
	// Decl contains the preformatted C declaration itself.
	Decl string
	// Anchor, if non-empty, is the URL fragment to use in anchor tags.
	Anchor string
***REMOVED***

const (
	cppGuard     = "#if defined(__cplusplus)"
	commentStart = "/* "
	commentEnd   = " */"
)

func extractComment(lines []string, lineNo int) (comment []string, rest []string, restLineNo int, err error) ***REMOVED***
	if len(lines) == 0 ***REMOVED***
		return nil, lines, lineNo, nil
	***REMOVED***

	restLineNo = lineNo
	rest = lines

	if !strings.HasPrefix(rest[0], commentStart) ***REMOVED***
		panic("extractComment called on non-comment")
	***REMOVED***
	commentParagraph := rest[0][len(commentStart):]
	rest = rest[1:]
	restLineNo++

	for len(rest) > 0 ***REMOVED***
		i := strings.Index(commentParagraph, commentEnd)
		if i >= 0 ***REMOVED***
			if i != len(commentParagraph)-len(commentEnd) ***REMOVED***
				err = fmt.Errorf("garbage after comment end on line %d", restLineNo)
				return
			***REMOVED***
			commentParagraph = commentParagraph[:i]
			if len(commentParagraph) > 0 ***REMOVED***
				comment = append(comment, commentParagraph)
			***REMOVED***
			return
		***REMOVED***

		line := rest[0]
		if !strings.HasPrefix(line, " *") ***REMOVED***
			err = fmt.Errorf("comment doesn't start with block prefix on line %d: %s", restLineNo, line)
			return
		***REMOVED***
		if len(line) == 2 || line[2] != '/' ***REMOVED***
			line = line[2:]
		***REMOVED***
		if strings.HasPrefix(line, "   ") ***REMOVED***
			/* Identing the lines of a paragraph marks them as
			* preformatted. */
			if len(commentParagraph) > 0 ***REMOVED***
				commentParagraph += "\n"
			***REMOVED***
			line = line[3:]
		***REMOVED***
		if len(line) > 0 ***REMOVED***
			commentParagraph = commentParagraph + line
			if len(commentParagraph) > 0 && commentParagraph[0] == ' ' ***REMOVED***
				commentParagraph = commentParagraph[1:]
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			comment = append(comment, commentParagraph)
			commentParagraph = ""
		***REMOVED***
		rest = rest[1:]
		restLineNo++
	***REMOVED***

	err = errors.New("hit EOF in comment")
	return
***REMOVED***

func extractDecl(lines []string, lineNo int) (decl string, rest []string, restLineNo int, err error) ***REMOVED***
	if len(lines) == 0 || len(lines[0]) == 0 ***REMOVED***
		return "", lines, lineNo, nil
	***REMOVED***

	rest = lines
	restLineNo = lineNo

	var stack []rune
	for len(rest) > 0 ***REMOVED***
		line := rest[0]
		for _, c := range line ***REMOVED***
			switch c ***REMOVED***
			case '(', '***REMOVED***', '[':
				stack = append(stack, c)
			case ')', '***REMOVED***', ']':
				if len(stack) == 0 ***REMOVED***
					err = fmt.Errorf("unexpected %c on line %d", c, restLineNo)
					return
				***REMOVED***
				var expected rune
				switch c ***REMOVED***
				case ')':
					expected = '('
				case '***REMOVED***':
					expected = '***REMOVED***'
				case ']':
					expected = '['
				default:
					panic("internal error")
				***REMOVED***
				if last := stack[len(stack)-1]; last != expected ***REMOVED***
					err = fmt.Errorf("found %c when expecting %c on line %d", c, last, restLineNo)
					return
				***REMOVED***
				stack = stack[:len(stack)-1]
			***REMOVED***
		***REMOVED***
		if len(decl) > 0 ***REMOVED***
			decl += "\n"
		***REMOVED***
		decl += line
		rest = rest[1:]
		restLineNo++

		if len(stack) == 0 && (len(decl) == 0 || decl[len(decl)-1] != '\\') ***REMOVED***
			break
		***REMOVED***
	***REMOVED***

	return
***REMOVED***

func skipLine(s string) string ***REMOVED***
	i := strings.Index(s, "\n")
	if i > 0 ***REMOVED***
		return s[i:]
	***REMOVED***
	return ""
***REMOVED***

func getNameFromDecl(decl string) (string, bool) ***REMOVED***
	for strings.HasPrefix(decl, "#if") || strings.HasPrefix(decl, "#elif") ***REMOVED***
		decl = skipLine(decl)
	***REMOVED***

	if strings.HasPrefix(decl, "typedef ") ***REMOVED***
		return "", false
	***REMOVED***

	for _, prefix := range []string***REMOVED***"struct ", "enum ", "#define "***REMOVED*** ***REMOVED***
		if !strings.HasPrefix(decl, prefix) ***REMOVED***
			continue
		***REMOVED***

		decl = strings.TrimPrefix(decl, prefix)

		for len(decl) > 0 && decl[0] == ' ' ***REMOVED***
			decl = decl[1:]
		***REMOVED***

		// struct and enum types can be the return type of a
		// function.
		if prefix[0] != '#' && strings.Index(decl, "***REMOVED***") == -1 ***REMOVED***
			break
		***REMOVED***

		i := strings.IndexAny(decl, "( ")
		if i < 0 ***REMOVED***
			return "", false
		***REMOVED***
		return decl[:i], true
	***REMOVED***
	decl = strings.TrimPrefix(decl, "OPENSSL_EXPORT ")
	decl = strings.TrimPrefix(decl, "STACK_OF(")
	decl = strings.TrimPrefix(decl, "LHASH_OF(")
	i := strings.Index(decl, "(")
	if i < 0 ***REMOVED***
		return "", false
	***REMOVED***
	j := strings.LastIndex(decl[:i], " ")
	if j < 0 ***REMOVED***
		return "", false
	***REMOVED***
	for j+1 < len(decl) && decl[j+1] == '*' ***REMOVED***
		j++
	***REMOVED***
	return decl[j+1 : i], true
***REMOVED***

func sanitizeAnchor(name string) string ***REMOVED***
	return strings.Replace(name, " ", "-", -1)
***REMOVED***

func isPrivateSection(name string) bool ***REMOVED***
	return strings.HasPrefix(name, "Private functions") || strings.HasPrefix(name, "Private structures") || strings.Contains(name, "(hidden)")
***REMOVED***

func (config *Config) parseHeader(path string) (*HeaderFile, error) ***REMOVED***
	headerPath := filepath.Join(config.BaseDirectory, path)

	headerFile, err := os.Open(headerPath)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	defer headerFile.Close()

	scanner := bufio.NewScanner(headerFile)
	var lines, oldLines []string
	for scanner.Scan() ***REMOVED***
		lines = append(lines, scanner.Text())
	***REMOVED***
	if err := scanner.Err(); err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	lineNo := 1
	found := false
	for i, line := range lines ***REMOVED***
		if line == cppGuard ***REMOVED***
			lines = lines[i+1:]
			lineNo += i + 1
			found = true
			break
		***REMOVED***
	***REMOVED***

	if !found ***REMOVED***
		return nil, errors.New("no C++ guard found")
	***REMOVED***

	if len(lines) == 0 || lines[0] != "extern \"C\" ***REMOVED***" ***REMOVED***
		return nil, errors.New("no extern \"C\" found after C++ guard")
	***REMOVED***
	lineNo += 2
	lines = lines[2:]

	header := &HeaderFile***REMOVED***
		Name:     filepath.Base(path),
		AllDecls: make(map[string]string),
	***REMOVED***

	for i, line := range lines ***REMOVED***
		if len(line) > 0 ***REMOVED***
			lines = lines[i:]
			lineNo += i
			break
		***REMOVED***
	***REMOVED***

	oldLines = lines
	if len(lines) > 0 && strings.HasPrefix(lines[0], commentStart) ***REMOVED***
		comment, rest, restLineNo, err := extractComment(lines, lineNo)
		if err != nil ***REMOVED***
			return nil, err
		***REMOVED***

		if len(rest) > 0 && len(rest[0]) == 0 ***REMOVED***
			if len(rest) < 2 || len(rest[1]) != 0 ***REMOVED***
				return nil, errors.New("preamble comment should be followed by two blank lines")
			***REMOVED***
			header.Preamble = comment
			lineNo = restLineNo + 2
			lines = rest[2:]
		***REMOVED*** else ***REMOVED***
			lines = oldLines
		***REMOVED***
	***REMOVED***

	allAnchors := make(map[string]struct***REMOVED******REMOVED***)

	for ***REMOVED***
		// Start of a section.
		if len(lines) == 0 ***REMOVED***
			return nil, errors.New("unexpected end of file")
		***REMOVED***
		line := lines[0]
		if line == cppGuard ***REMOVED***
			break
		***REMOVED***

		if len(line) == 0 ***REMOVED***
			return nil, fmt.Errorf("blank line at start of section on line %d", lineNo)
		***REMOVED***

		var section HeaderSection

		if strings.HasPrefix(line, commentStart) ***REMOVED***
			comment, rest, restLineNo, err := extractComment(lines, lineNo)
			if err != nil ***REMOVED***
				return nil, err
			***REMOVED***
			if len(rest) > 0 && len(rest[0]) == 0 ***REMOVED***
				anchor := sanitizeAnchor(firstSentence(comment))
				if len(anchor) > 0 ***REMOVED***
					if _, ok := allAnchors[anchor]; ok ***REMOVED***
						return nil, fmt.Errorf("duplicate anchor: %s", anchor)
					***REMOVED***
					allAnchors[anchor] = struct***REMOVED******REMOVED******REMOVED******REMOVED***
				***REMOVED***

				section.Preamble = comment
				section.IsPrivate = len(comment) > 0 && isPrivateSection(comment[0])
				section.Anchor = anchor
				lines = rest[1:]
				lineNo = restLineNo + 1
			***REMOVED***
		***REMOVED***

		for len(lines) > 0 ***REMOVED***
			line := lines[0]
			if len(line) == 0 ***REMOVED***
				lines = lines[1:]
				lineNo++
				break
			***REMOVED***
			if line == cppGuard ***REMOVED***
				return nil, errors.New("hit ending C++ guard while in section")
			***REMOVED***

			var comment []string
			var decl string
			if strings.HasPrefix(line, commentStart) ***REMOVED***
				comment, lines, lineNo, err = extractComment(lines, lineNo)
				if err != nil ***REMOVED***
					return nil, err
				***REMOVED***
			***REMOVED***
			if len(lines) == 0 ***REMOVED***
				return nil, errors.New("expected decl at EOF")
			***REMOVED***
			declLineNo := lineNo
			decl, lines, lineNo, err = extractDecl(lines, lineNo)
			if err != nil ***REMOVED***
				return nil, err
			***REMOVED***
			name, ok := getNameFromDecl(decl)
			if !ok ***REMOVED***
				name = ""
			***REMOVED***
			if last := len(section.Decls) - 1; len(name) == 0 && len(comment) == 0 && last >= 0 ***REMOVED***
				section.Decls[last].Decl += "\n" + decl
			***REMOVED*** else ***REMOVED***
				// As a matter of style, comments should start
				// with the name of the thing that they are
				// commenting on. We make an exception here for
				// #defines (because we often have blocks of
				// them) and collective comments, which are
				// detected by starting with “The” or “These”.
				if len(comment) > 0 &&
					!strings.HasPrefix(comment[0], name) &&
					!strings.HasPrefix(comment[0], "A "+name) &&
					!strings.HasPrefix(comment[0], "An "+name) &&
					!strings.HasPrefix(decl, "#define ") &&
					!strings.HasPrefix(comment[0], "The ") &&
					!strings.HasPrefix(comment[0], "These ") ***REMOVED***
					return nil, fmt.Errorf("Comment for %q doesn't seem to match line %s:%d\n", name, path, declLineNo)
				***REMOVED***
				anchor := sanitizeAnchor(name)
				// TODO(davidben): Enforce uniqueness. This is
				// skipped because #ifdefs currently result in
				// duplicate table-of-contents entries.
				allAnchors[anchor] = struct***REMOVED******REMOVED******REMOVED******REMOVED***

				header.AllDecls[name] = anchor

				section.Decls = append(section.Decls, HeaderDecl***REMOVED***
					Comment: comment,
					Name:    name,
					Decl:    decl,
					Anchor:  anchor,
				***REMOVED***)
			***REMOVED***

			if len(lines) > 0 && len(lines[0]) == 0 ***REMOVED***
				lines = lines[1:]
				lineNo++
			***REMOVED***
		***REMOVED***

		header.Sections = append(header.Sections, section)
	***REMOVED***

	return header, nil
***REMOVED***

func firstSentence(paragraphs []string) string ***REMOVED***
	if len(paragraphs) == 0 ***REMOVED***
		return ""
	***REMOVED***
	s := paragraphs[0]
	i := strings.Index(s, ". ")
	if i >= 0 ***REMOVED***
		return s[:i]
	***REMOVED***
	if lastIndex := len(s) - 1; s[lastIndex] == '.' ***REMOVED***
		return s[:lastIndex]
	***REMOVED***
	return s
***REMOVED***

func markupPipeWords(allDecls map[string]string, s string) template.HTML ***REMOVED***
	ret := ""

	for ***REMOVED***
		i := strings.Index(s, "|")
		if i == -1 ***REMOVED***
			ret += s
			break
		***REMOVED***
		ret += s[:i]
		s = s[i+1:]

		i = strings.Index(s, "|")
		j := strings.Index(s, " ")
		if i > 0 && (j == -1 || j > i) ***REMOVED***
			ret += "<tt>"
			anchor, isLink := allDecls[s[:i]]
			if isLink ***REMOVED***
				ret += fmt.Sprintf("<a href=\"%s\">", template.HTMLEscapeString(anchor))
			***REMOVED***
			ret += s[:i]
			if isLink ***REMOVED***
				ret += "</a>"
			***REMOVED***
			ret += "</tt>"
			s = s[i+1:]
		***REMOVED*** else ***REMOVED***
			ret += "|"
		***REMOVED***
	***REMOVED***

	return template.HTML(ret)
***REMOVED***

func markupFirstWord(s template.HTML) template.HTML ***REMOVED***
	start := 0
again:
	end := strings.Index(string(s[start:]), " ")
	if end > 0 ***REMOVED***
		end += start
		w := strings.ToLower(string(s[start:end]))
		// The first word was already marked up as an HTML tag. Don't
		// mark it up further.
		if strings.ContainsRune(w, '<') ***REMOVED***
			return s
		***REMOVED***
		if w == "a" || w == "an" ***REMOVED***
			start = end + 1
			goto again
		***REMOVED***
		return s[:start] + "<span class=\"first-word\">" + s[start:end] + "</span>" + s[end:]
	***REMOVED***
	return s
***REMOVED***

func newlinesToBR(html template.HTML) template.HTML ***REMOVED***
	s := string(html)
	if !strings.Contains(s, "\n") ***REMOVED***
		return html
	***REMOVED***
	s = strings.Replace(s, "\n", "<br>", -1)
	s = strings.Replace(s, " ", "&nbsp;", -1)
	return template.HTML(s)
***REMOVED***

func generate(outPath string, config *Config) (map[string]string, error) ***REMOVED***
	allDecls := make(map[string]string)

	headerTmpl := template.New("headerTmpl")
	headerTmpl.Funcs(template.FuncMap***REMOVED***
		"firstSentence":   firstSentence,
		"markupPipeWords": func(s string) template.HTML ***REMOVED*** return markupPipeWords(allDecls, s) ***REMOVED***,
		"markupFirstWord": markupFirstWord,
		"newlinesToBR":    newlinesToBR,
	***REMOVED***)
	headerTmpl, err := headerTmpl.Parse(`<!DOCTYPE html>
<html>
  <head>
    <title>BoringSSL - ***REMOVED******REMOVED***.Name***REMOVED******REMOVED***</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="doc.css">
  </head>

  <body>
    <div id="main">
    <div class="title">
      <h2>***REMOVED******REMOVED***.Name***REMOVED******REMOVED***</h2>
      <a href="headers.html">All headers</a>
    </div>

    ***REMOVED******REMOVED***range .Preamble***REMOVED******REMOVED***<p>***REMOVED******REMOVED***. | html | markupPipeWords***REMOVED******REMOVED***</p>***REMOVED******REMOVED***end***REMOVED******REMOVED***

    <ol>
      ***REMOVED******REMOVED***range .Sections***REMOVED******REMOVED***
        ***REMOVED******REMOVED***if not .IsPrivate***REMOVED******REMOVED***
          ***REMOVED******REMOVED***if .Anchor***REMOVED******REMOVED***<li class="header"><a href="#***REMOVED******REMOVED***.Anchor***REMOVED******REMOVED***">***REMOVED******REMOVED***.Preamble | firstSentence | html | markupPipeWords***REMOVED******REMOVED***</a></li>***REMOVED******REMOVED***end***REMOVED******REMOVED***
          ***REMOVED******REMOVED***range .Decls***REMOVED******REMOVED***
            ***REMOVED******REMOVED***if .Anchor***REMOVED******REMOVED***<li><a href="#***REMOVED******REMOVED***.Anchor***REMOVED******REMOVED***"><tt>***REMOVED******REMOVED***.Name***REMOVED******REMOVED***</tt></a></li>***REMOVED******REMOVED***end***REMOVED******REMOVED***
          ***REMOVED******REMOVED***end***REMOVED******REMOVED***
        ***REMOVED******REMOVED***end***REMOVED******REMOVED***
      ***REMOVED******REMOVED***end***REMOVED******REMOVED***
    </ol>

    ***REMOVED******REMOVED***range .Sections***REMOVED******REMOVED***
      ***REMOVED******REMOVED***if not .IsPrivate***REMOVED******REMOVED***
        <div class="section" ***REMOVED******REMOVED***if .Anchor***REMOVED******REMOVED***id="***REMOVED******REMOVED***.Anchor***REMOVED******REMOVED***"***REMOVED******REMOVED***end***REMOVED******REMOVED***>
        ***REMOVED******REMOVED***if .Preamble***REMOVED******REMOVED***
          <div class="sectionpreamble">
          ***REMOVED******REMOVED***range .Preamble***REMOVED******REMOVED***<p>***REMOVED******REMOVED***. | html | markupPipeWords***REMOVED******REMOVED***</p>***REMOVED******REMOVED***end***REMOVED******REMOVED***
          </div>
        ***REMOVED******REMOVED***end***REMOVED******REMOVED***

        ***REMOVED******REMOVED***range .Decls***REMOVED******REMOVED***
          <div class="decl" ***REMOVED******REMOVED***if .Anchor***REMOVED******REMOVED***id="***REMOVED******REMOVED***.Anchor***REMOVED******REMOVED***"***REMOVED******REMOVED***end***REMOVED******REMOVED***>
          ***REMOVED******REMOVED***range .Comment***REMOVED******REMOVED***
            <p>***REMOVED******REMOVED***. | html | markupPipeWords | newlinesToBR | markupFirstWord***REMOVED******REMOVED***</p>
          ***REMOVED******REMOVED***end***REMOVED******REMOVED***
          <pre>***REMOVED******REMOVED***.Decl***REMOVED******REMOVED***</pre>
          </div>
        ***REMOVED******REMOVED***end***REMOVED******REMOVED***
        </div>
      ***REMOVED******REMOVED***end***REMOVED******REMOVED***
    ***REMOVED******REMOVED***end***REMOVED******REMOVED***
    </div>
  </body>
</html>`)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	headerDescriptions := make(map[string]string)
	var headers []*HeaderFile

	for _, section := range config.Sections ***REMOVED***
		for _, headerPath := range section.Headers ***REMOVED***
			header, err := config.parseHeader(headerPath)
			if err != nil ***REMOVED***
				return nil, errors.New("while parsing " + headerPath + ": " + err.Error())
			***REMOVED***
			headerDescriptions[header.Name] = firstSentence(header.Preamble)
			headers = append(headers, header)

			for name, anchor := range header.AllDecls ***REMOVED***
				allDecls[name] = fmt.Sprintf("%s#%s", header.Name+".html", anchor)
			***REMOVED***
		***REMOVED***
	***REMOVED***

	for _, header := range headers ***REMOVED***
		filename := filepath.Join(outPath, header.Name+".html")
		file, err := os.OpenFile(filename, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
		if err != nil ***REMOVED***
			panic(err)
		***REMOVED***
		defer file.Close()
		if err := headerTmpl.Execute(file, header); err != nil ***REMOVED***
			return nil, err
		***REMOVED***
	***REMOVED***

	return headerDescriptions, nil
***REMOVED***

func generateIndex(outPath string, config *Config, headerDescriptions map[string]string) error ***REMOVED***
	indexTmpl := template.New("indexTmpl")
	indexTmpl.Funcs(template.FuncMap***REMOVED***
		"baseName": filepath.Base,
		"headerDescription": func(header string) string ***REMOVED***
			return headerDescriptions[header]
		***REMOVED***,
	***REMOVED***)
	indexTmpl, err := indexTmpl.Parse(`<!DOCTYPE html5>

  <head>
    <title>BoringSSL - Headers</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="doc.css">
  </head>

  <body>
    <div id="main">
      <div class="title">
        <h2>BoringSSL Headers</h2>
      </div>
      <table>
        ***REMOVED******REMOVED***range .Sections***REMOVED******REMOVED***
	  <tr class="header"><td colspan="2">***REMOVED******REMOVED***.Name***REMOVED******REMOVED***</td></tr>
	  ***REMOVED******REMOVED***range .Headers***REMOVED******REMOVED***
	    <tr><td><a href="***REMOVED******REMOVED***. | baseName***REMOVED******REMOVED***.html">***REMOVED******REMOVED***. | baseName***REMOVED******REMOVED***</a></td><td>***REMOVED******REMOVED***. | baseName | headerDescription***REMOVED******REMOVED***</td></tr>
	  ***REMOVED******REMOVED***end***REMOVED******REMOVED***
	***REMOVED******REMOVED***end***REMOVED******REMOVED***
      </table>
    </div>
  </body>
</html>`)

	if err != nil ***REMOVED***
		return err
	***REMOVED***

	file, err := os.OpenFile(filepath.Join(outPath, "headers.html"), os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil ***REMOVED***
		panic(err)
	***REMOVED***
	defer file.Close()

	if err := indexTmpl.Execute(file, config); err != nil ***REMOVED***
		return err
	***REMOVED***

	return nil
***REMOVED***

func copyFile(outPath string, inFilePath string) error ***REMOVED***
	bytes, err := ioutil.ReadFile(inFilePath)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	return ioutil.WriteFile(filepath.Join(outPath, filepath.Base(inFilePath)), bytes, 0666)
***REMOVED***

func main() ***REMOVED***
	var (
		configFlag *string = flag.String("config", "doc.config", "Location of config file")
		outputDir  *string = flag.String("out", ".", "Path to the directory where the output will be written")
		config     Config
	)

	flag.Parse()

	if len(*configFlag) == 0 ***REMOVED***
		fmt.Printf("No config file given by --config\n")
		os.Exit(1)
	***REMOVED***

	if len(*outputDir) == 0 ***REMOVED***
		fmt.Printf("No output directory given by --out\n")
		os.Exit(1)
	***REMOVED***

	configBytes, err := ioutil.ReadFile(*configFlag)
	if err != nil ***REMOVED***
		fmt.Printf("Failed to open config file: %s\n", err)
		os.Exit(1)
	***REMOVED***

	if err := json.Unmarshal(configBytes, &config); err != nil ***REMOVED***
		fmt.Printf("Failed to parse config file: %s\n", err)
		os.Exit(1)
	***REMOVED***

	headerDescriptions, err := generate(*outputDir, &config)
	if err != nil ***REMOVED***
		fmt.Printf("Failed to generate output: %s\n", err)
		os.Exit(1)
	***REMOVED***

	if err := generateIndex(*outputDir, &config, headerDescriptions); err != nil ***REMOVED***
		fmt.Printf("Failed to generate index: %s\n", err)
		os.Exit(1)
	***REMOVED***

	if err := copyFile(*outputDir, "doc.css"); err != nil ***REMOVED***
		fmt.Printf("Failed to copy static file: %s\n", err)
		os.Exit(1)
	***REMOVED***
***REMOVED***
