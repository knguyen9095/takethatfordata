/*
 * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 2015 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */

#include <stdlib.h>
#include <string.h>

#include <string>
#include <vector>

#include <openssl/cipher.h>
#include <openssl/crypto.h>
#include <openssl/err.h>

#include "../test/file_test.h"


static const EVP_CIPHER *GetCipher(const std::string &name) ***REMOVED***
  if (name == "DES-CBC") ***REMOVED***
    return EVP_des_cbc();
  ***REMOVED*** else if (name == "DES-ECB") ***REMOVED***
    return EVP_des_ecb();
  ***REMOVED*** else if (name == "DES-EDE") ***REMOVED***
    return EVP_des_ede();
  ***REMOVED*** else if (name == "DES-EDE-CBC") ***REMOVED***
    return EVP_des_ede_cbc();
  ***REMOVED*** else if (name == "DES-EDE3-CBC") ***REMOVED***
    return EVP_des_ede3_cbc();
  ***REMOVED*** else if (name == "RC4") ***REMOVED***
    return EVP_rc4();
  ***REMOVED*** else if (name == "AES-128-ECB") ***REMOVED***
    return EVP_aes_128_ecb();
  ***REMOVED*** else if (name == "AES-256-ECB") ***REMOVED***
    return EVP_aes_256_ecb();
  ***REMOVED*** else if (name == "AES-128-CBC") ***REMOVED***
    return EVP_aes_128_cbc();
  ***REMOVED*** else if (name == "AES-128-GCM") ***REMOVED***
    return EVP_aes_128_gcm();
  ***REMOVED*** else if (name == "AES-128-OFB") ***REMOVED***
    return EVP_aes_128_ofb();
  ***REMOVED*** else if (name == "AES-192-CBC") ***REMOVED***
    return EVP_aes_192_cbc();
  ***REMOVED*** else if (name == "AES-192-ECB") ***REMOVED***
    return EVP_aes_192_ecb();
  ***REMOVED*** else if (name == "AES-256-CBC") ***REMOVED***
    return EVP_aes_256_cbc();
  ***REMOVED*** else if (name == "AES-128-CTR") ***REMOVED***
    return EVP_aes_128_ctr();
  ***REMOVED*** else if (name == "AES-256-CTR") ***REMOVED***
    return EVP_aes_256_ctr();
  ***REMOVED*** else if (name == "AES-256-GCM") ***REMOVED***
    return EVP_aes_256_gcm();
  ***REMOVED*** else if (name == "AES-256-OFB") ***REMOVED***
    return EVP_aes_256_ofb();
  ***REMOVED***
  return nullptr;
***REMOVED***

static bool TestOperation(FileTest *t,
                          const EVP_CIPHER *cipher,
                          bool encrypt,
                          size_t chunk_size,
                          const std::vector<uint8_t> &key,
                          const std::vector<uint8_t> &iv,
                          const std::vector<uint8_t> &plaintext,
                          const std::vector<uint8_t> &ciphertext,
                          const std::vector<uint8_t> &aad,
                          const std::vector<uint8_t> &tag) ***REMOVED***
  const std::vector<uint8_t> *in, *out;
  if (encrypt) ***REMOVED***
    in = &plaintext;
    out = &ciphertext;
  ***REMOVED*** else ***REMOVED***
    in = &ciphertext;
    out = &plaintext;
  ***REMOVED***

  bool is_aead = EVP_CIPHER_mode(cipher) == EVP_CIPH_GCM_MODE;

  bssl::ScopedEVP_CIPHER_CTX ctx;
  if (!EVP_CipherInit_ex(ctx.get(), cipher, nullptr, nullptr, nullptr,
                         encrypt ? 1 : 0)) ***REMOVED***
    return false;
  ***REMOVED***
  if (t->HasAttribute("IV")) ***REMOVED***
    if (is_aead) ***REMOVED***
      if (!EVP_CIPHER_CTX_ctrl(ctx.get(), EVP_CTRL_GCM_SET_IVLEN,
                               iv.size(), 0)) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED*** else if (iv.size() != EVP_CIPHER_CTX_iv_length(ctx.get())) ***REMOVED***
      t->PrintLine("Bad IV length.");
      return false;
    ***REMOVED***
  ***REMOVED***
  if (is_aead && !encrypt &&
      !EVP_CIPHER_CTX_ctrl(ctx.get(), EVP_CTRL_GCM_SET_TAG, tag.size(),
                           const_cast<uint8_t*>(tag.data()))) ***REMOVED***
    return false;
  ***REMOVED***
  // The ciphers are run with no padding. For each of the ciphers we test, the
  // output size matches the input size.
  std::vector<uint8_t> result(in->size());
  if (in->size() != out->size()) ***REMOVED***
    t->PrintLine("Input/output size mismatch (%u vs %u).", (unsigned)in->size(),
                 (unsigned)out->size());
    return false;
  ***REMOVED***
  // Note: the deprecated |EVP_CIPHER|-based AES-GCM API is sensitive to whether
  // parameters are NULL, so it is important to skip the |in| and |aad|
  // |EVP_CipherUpdate| calls when empty.
  int unused, result_len1 = 0, result_len2;
  if (!EVP_CIPHER_CTX_set_key_length(ctx.get(), key.size()) ||
      !EVP_CipherInit_ex(ctx.get(), nullptr, nullptr, key.data(), iv.data(),
                         -1) ||
      (!aad.empty() &&
       !EVP_CipherUpdate(ctx.get(), nullptr, &unused, aad.data(),
                         aad.size())) ||
      !EVP_CIPHER_CTX_set_padding(ctx.get(), 0)) ***REMOVED***
    t->PrintLine("Operation failed.");
    return false;
  ***REMOVED***
  if (chunk_size != 0) ***REMOVED***
    for (size_t i = 0; i < in->size();) ***REMOVED***
      size_t todo = chunk_size;
      if (i + todo > in->size()) ***REMOVED***
        todo = in->size() - i;
      ***REMOVED***

      int len;
      if (!EVP_CipherUpdate(ctx.get(), result.data() + result_len1, &len,
                            in->data() + i, todo)) ***REMOVED***
        t->PrintLine("Operation failed.");
        return false;
      ***REMOVED***
      result_len1 += len;
      i += todo;
    ***REMOVED***
  ***REMOVED*** else if (!in->empty() &&
             !EVP_CipherUpdate(ctx.get(), result.data(), &result_len1,
                               in->data(), in->size())) ***REMOVED***
    t->PrintLine("Operation failed.");
    return false;
  ***REMOVED***
  if (!EVP_CipherFinal_ex(ctx.get(), result.data() + result_len1,
                          &result_len2)) ***REMOVED***
    t->PrintLine("Operation failed.");
    return false;
  ***REMOVED***
  result.resize(result_len1 + result_len2);
  if (!t->ExpectBytesEqual(out->data(), out->size(), result.data(),
                           result.size())) ***REMOVED***
    return false;
  ***REMOVED***
  if (encrypt && is_aead) ***REMOVED***
    uint8_t rtag[16];
    if (tag.size() > sizeof(rtag)) ***REMOVED***
      t->PrintLine("Bad tag length.");
      return false;
    ***REMOVED***
    if (!EVP_CIPHER_CTX_ctrl(ctx.get(), EVP_CTRL_GCM_GET_TAG, tag.size(),
                             rtag) ||
        !t->ExpectBytesEqual(tag.data(), tag.size(), rtag,
                             tag.size())) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***
  return true;
***REMOVED***

static bool TestCipher(FileTest *t, void *arg) ***REMOVED***
  std::string cipher_str;
  if (!t->GetAttribute(&cipher_str, "Cipher")) ***REMOVED***
    return false;
  ***REMOVED***
  const EVP_CIPHER *cipher = GetCipher(cipher_str);
  if (cipher == nullptr) ***REMOVED***
    t->PrintLine("Unknown cipher: '%s'.", cipher_str.c_str());
    return false;
  ***REMOVED***

  std::vector<uint8_t> key, iv, plaintext, ciphertext, aad, tag;
  if (!t->GetBytes(&key, "Key") ||
      !t->GetBytes(&plaintext, "Plaintext") ||
      !t->GetBytes(&ciphertext, "Ciphertext")) ***REMOVED***
    return false;
  ***REMOVED***
  if (EVP_CIPHER_iv_length(cipher) > 0 &&
      !t->GetBytes(&iv, "IV")) ***REMOVED***
    return false;
  ***REMOVED***
  if (EVP_CIPHER_mode(cipher) == EVP_CIPH_GCM_MODE) ***REMOVED***
    if (!t->GetBytes(&aad, "AAD") ||
        !t->GetBytes(&tag, "Tag")) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  enum ***REMOVED***
    kEncrypt,
    kDecrypt,
    kBoth,
  ***REMOVED*** operation = kBoth;
  if (t->HasAttribute("Operation")) ***REMOVED***
    const std::string &str = t->GetAttributeOrDie("Operation");
    if (str == "ENCRYPT") ***REMOVED***
      operation = kEncrypt;
    ***REMOVED*** else if (str == "DECRYPT") ***REMOVED***
      operation = kDecrypt;
    ***REMOVED*** else ***REMOVED***
      t->PrintLine("Unknown operation: '%s'.", str.c_str());
      return false;
    ***REMOVED***
  ***REMOVED***

  const std::vector<size_t> chunk_sizes = ***REMOVED***0,  1,  2,  5,  7,  8,  9,  15, 16,
                                           17, 31, 32, 33, 63, 64, 65, 512***REMOVED***;

  for (size_t chunk_size : chunk_sizes) ***REMOVED***
    // By default, both directions are run, unless overridden by the operation.
    if (operation != kDecrypt &&
        !TestOperation(t, cipher, true /* encrypt */, chunk_size, key, iv,
                       plaintext, ciphertext, aad, tag)) ***REMOVED***
      return false;
    ***REMOVED***

    if (operation != kEncrypt &&
        !TestOperation(t, cipher, false /* decrypt */, chunk_size, key, iv,
                       plaintext, ciphertext, aad, tag)) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***

int main(int argc, char **argv) ***REMOVED***
  CRYPTO_library_init();

  if (argc != 2) ***REMOVED***
    fprintf(stderr, "%s <test file>\n", argv[0]);
    return 1;
  ***REMOVED***

  return FileTestMain(TestCipher, nullptr, argv[1]);
***REMOVED***
