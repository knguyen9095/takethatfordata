#! /usr/bin/env perl
# Copyright 2007-2016 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the OpenSSL license (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


package x86gas;

*out=\@::out;

$::lbdecor=$::aout?"L":".L";		# local label decoration
$nmdecor=($::aout or $::coff)?"_":"";	# external name decoration

$initseg="";

$align=16;
$align=log($align)/log(2) if ($::aout);
$com_start="#" if ($::aout or $::coff);

sub opsize()
***REMOVED*** my $reg=shift;
    if    ($reg =~ m/^%e/o)		***REMOVED*** "l"; ***REMOVED***
    elsif ($reg =~ m/^%[a-d][hl]$/o)	***REMOVED*** "b"; ***REMOVED***
    elsif ($reg =~ m/^%[yxm]/o)		***REMOVED*** undef; ***REMOVED***
    else				***REMOVED*** "w"; ***REMOVED***
***REMOVED***

# swap arguments;
# expand opcode with size suffix;
# prefix numeric constants with $;
sub ::generic
***REMOVED*** my($opcode,@arg)=@_;
  my($suffix,$dst,$src);

    @arg=reverse(@arg);

    for (@arg)
    ***REMOVED***	s/^(\*?)(e?[a-dsixphl]***REMOVED***2***REMOVED***)$/$1%$2/o;	# gp registers
	s/^([xy]?mm[0-7])$/%$1/o;		# xmm/mmx registers
	s/^(\-?[0-9]+)$/\$$1/o;			# constants
	s/^(\-?0x[0-9a-f]+)$/\$$1/o;		# constants
    ***REMOVED***

    $dst = $arg[$#arg]		if ($#arg>=0);
    $src = $arg[$#arg-1]	if ($#arg>=1);
    if    ($dst =~ m/^%/o)	***REMOVED*** $suffix=&opsize($dst); ***REMOVED***
    elsif ($src =~ m/^%/o)	***REMOVED*** $suffix=&opsize($src); ***REMOVED***
    else			***REMOVED*** $suffix="l";           ***REMOVED***
    undef $suffix if ($dst =~ m/^%[xm]/o || $src =~ m/^%[xm]/o);

    if ($#_==0)				***REMOVED*** &::emit($opcode);		***REMOVED***
    elsif ($#_==1 && $opcode =~ m/^(call|clflush|j|loop|set)/o)
					***REMOVED*** &::emit($opcode,@arg);	***REMOVED***
    else				***REMOVED*** &::emit($opcode.$suffix,@arg);***REMOVED***

  1;
***REMOVED***
#
# opcodes not covered by ::generic above, mostly inconsistent namings...
#
sub ::movzx	***REMOVED*** &::movzb(@_);			***REMOVED***
sub ::pushfd	***REMOVED*** &::pushfl;			***REMOVED***
sub ::popfd	***REMOVED*** &::popfl;			***REMOVED***
sub ::cpuid	***REMOVED*** &::emit(".byte\t0x0f,0xa2");	***REMOVED***
sub ::rdtsc	***REMOVED*** &::emit(".byte\t0x0f,0x31");	***REMOVED***

sub ::call	***REMOVED*** &::emit("call",(&::islabel($_[0]) or "$nmdecor$_[0]")); ***REMOVED***
sub ::call_ptr	***REMOVED*** &::generic("call","*$_[0]");	***REMOVED***
sub ::jmp_ptr	***REMOVED*** &::generic("jmp","*$_[0]");	***REMOVED***

*::bswap = sub	***REMOVED*** &::emit("bswap","%$_[0]");	***REMOVED*** if (!$::i386);

sub ::DWP
***REMOVED*** my($addr,$reg1,$reg2,$idx)=@_;
  my $ret="";

    if (!defined($idx) && 1*$reg2) ***REMOVED*** $idx=$reg2; $reg2=$reg1; undef $reg1; ***REMOVED***

    $addr =~ s/^\s+//;
    # prepend global references with optional underscore
    $addr =~ s/^([^\+\-0-9][^\+\-]*)/&::islabel($1) or "$nmdecor$1"/ige;

    $reg1 = "%$reg1" if ($reg1);
    $reg2 = "%$reg2" if ($reg2);

    $ret .= $addr if (($addr ne "") && ($addr ne 0));

    if ($reg2)
    ***REMOVED***	$idx!= 0 or $idx=1;
	$ret .= "($reg1,$reg2,$idx)";
    ***REMOVED***
    elsif ($reg1)
    ***REMOVED***	$ret .= "($reg1)";	***REMOVED***

  $ret;
***REMOVED***
sub ::QWP	***REMOVED*** &::DWP(@_);	***REMOVED***
sub ::BP	***REMOVED*** &::DWP(@_);	***REMOVED***
sub ::WP	***REMOVED*** &::DWP(@_);	***REMOVED***
sub ::BC	***REMOVED*** @_;		***REMOVED***
sub ::DWC	***REMOVED*** @_;		***REMOVED***

sub ::file
***REMOVED***   push(@out,".file\t\"$_[0].S\"\n.text\n");	***REMOVED***

sub ::function_begin_B
***REMOVED*** my $func=shift;
  my $global=($func !~ /^_/);
  my $begin="$***REMOVED***::lbdecor***REMOVED***_$***REMOVED***func***REMOVED***_begin";

    &::LABEL($func,$global?"$begin":"$nmdecor$func");
    $func=$nmdecor.$func;

    push(@out,".globl\t$func\n")	if ($global);
    if ($::macosx) ***REMOVED***
      push(@out,".private_extern\t$func\n");
    ***REMOVED*** else ***REMOVED***
      push(@out,".hidden\t$func\n");
    ***REMOVED***
    if ($::coff)
    ***REMOVED***	push(@out,".def\t$func;\t.scl\t".(3-$global).";\t.type\t32;\t.endef\n"); ***REMOVED***
    elsif (($::aout and !$::pic) or $::macosx)
    ***REMOVED*** ***REMOVED***
    else
    ***REMOVED***	push(@out,".type	$func,\@function\n"); ***REMOVED***
    push(@out,".align\t$align\n");
    push(@out,"$func:\n");
    push(@out,"$begin:\n")		if ($global);
    $::stack=4;
***REMOVED***

sub ::function_end_B
***REMOVED*** my $func=shift;
    push(@out,".size\t$nmdecor$func,.-".&::LABEL($func)."\n") if ($::elf);
    $::stack=0;
    &::wipe_labels();
***REMOVED***

sub ::comment
	***REMOVED***
	if (!defined($com_start) or $::elf)
		***REMOVED***	# Regarding $::elf above...
			# GNU and SVR4 as'es use different comment delimiters,
		push(@out,"\n");	# so we just skip ELF comments...
		return;
		***REMOVED***
	foreach (@_)
		***REMOVED***
		if (/^\s*$/)
			***REMOVED*** push(@out,"\n"); ***REMOVED***
		else
			***REMOVED*** push(@out,"\t$com_start $_ $com_end\n"); ***REMOVED***
		***REMOVED***
	***REMOVED***

sub ::external_label
***REMOVED***   foreach(@_) ***REMOVED*** &::LABEL($_,$nmdecor.$_); ***REMOVED***   ***REMOVED***

sub ::public_label
***REMOVED***   push(@out,".globl\t".&::LABEL($_[0],$nmdecor.$_[0])."\n");   ***REMOVED***

sub ::file_end
***REMOVED***   if ($::macosx)
    ***REMOVED***	if (%non_lazy_ptr)
    	***REMOVED***   push(@out,".section __IMPORT,__pointers,non_lazy_symbol_pointers\n");
	    foreach $i (keys %non_lazy_ptr)
	    ***REMOVED***	push(@out,"$non_lazy_ptr***REMOVED***$i***REMOVED***:\n.indirect_symbol\t$i\n.long\t0\n");   ***REMOVED***
	***REMOVED***
    ***REMOVED***
    if (0 && grep ***REMOVED***/\b$***REMOVED***nmdecor***REMOVED***OPENSSL_ia32cap_P\b/i***REMOVED*** @out) ***REMOVED***
	my $tmp=".comm\t$***REMOVED***nmdecor***REMOVED***OPENSSL_ia32cap_P,16";
	if ($::macosx)	***REMOVED*** push (@out,"$tmp,2\n"); ***REMOVED***
	elsif ($::elf)	***REMOVED*** push (@out,"$tmp,4\n"); ***REMOVED***
	else		***REMOVED*** push (@out,"$tmp\n"); ***REMOVED***
    ***REMOVED***
    push(@out,$initseg) if ($initseg);
***REMOVED***

sub ::data_byte	***REMOVED***   push(@out,".byte\t".join(',',@_)."\n");   ***REMOVED***
sub ::data_short***REMOVED***   push(@out,".value\t".join(',',@_)."\n");  ***REMOVED***
sub ::data_word ***REMOVED***   push(@out,".long\t".join(',',@_)."\n");   ***REMOVED***

sub ::align
***REMOVED*** my $val=$_[0];
    if ($::aout)
    ***REMOVED***	$val=int(log($val)/log(2));
	$val.=",0x90";
    ***REMOVED***
    push(@out,".align\t$val\n");
***REMOVED***

sub ::picmeup
***REMOVED*** my($dst,$sym,$base,$reflabel)=@_;

    if (($::pic && ($::elf || $::aout)) || $::macosx)
    ***REMOVED***	if (!defined($base))
	***REMOVED***   &::call(&::label("PIC_me_up"));
	    &::set_label("PIC_me_up");
	    &::blindpop($dst);
	    $base=$dst;
	    $reflabel=&::label("PIC_me_up");
	***REMOVED***
	if ($::macosx)
	***REMOVED***   my $indirect=&::static_label("$nmdecor$sym\$non_lazy_ptr");
	    &::mov($dst,&::DWP("$indirect-$reflabel",$base));
	    $non_lazy_ptr***REMOVED***"$nmdecor$sym"***REMOVED***=$indirect;
	***REMOVED***
	elsif ($sym eq "OPENSSL_ia32cap_P" && $::elf>0)
	***REMOVED***   &::lea($dst,&::DWP("$sym-$reflabel",$base));   ***REMOVED***
	else
	***REMOVED***   &::lea($dst,&::DWP("_GLOBAL_OFFSET_TABLE_+[.-$reflabel]",
			    $base));
	    &::mov($dst,&::DWP("$sym\@GOT",$dst));
	***REMOVED***
    ***REMOVED***
    else
    ***REMOVED***	&::lea($dst,&::DWP($sym));	***REMOVED***
***REMOVED***

sub ::initseg
***REMOVED*** my $f=$nmdecor.shift;

    if ($::android)
    ***REMOVED***	$initseg.=<<___;
.section	.init_array
.align	4
.long	$f
___
    ***REMOVED***
    elsif ($::elf)
    ***REMOVED***	$initseg.=<<___;
.section	.init
	call	$f
___
    ***REMOVED***
    elsif ($::coff)
    ***REMOVED***   $initseg.=<<___;	# applies to both Cygwin and Mingw
.section	.ctors
.long	$f
___
    ***REMOVED***
    elsif ($::macosx)
    ***REMOVED***	$initseg.=<<___;
.mod_init_func
.align 2
.long   $f
___
    ***REMOVED***
    elsif ($::aout)
    ***REMOVED***	my $ctor="$***REMOVED***nmdecor***REMOVED***_GLOBAL_\$I\$$f";
	$initseg.=".text\n";
	$initseg.=".type	$ctor,\@function\n" if ($::pic);
	$initseg.=<<___;	# OpenBSD way...
.globl	$ctor
.align	2
$ctor:
	jmp	$f
___
    ***REMOVED***
***REMOVED***

sub ::dataseg
***REMOVED***   push(@out,".data\n");   ***REMOVED***

*::hidden = sub ***REMOVED*** push(@out,".hidden\t$nmdecor$_[0]\n"); ***REMOVED*** if ($::elf);

1;
