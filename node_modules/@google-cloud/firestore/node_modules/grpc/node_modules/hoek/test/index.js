// Load modules

var Fs = require('fs');
var Path = require('path');
var Code = require('code');
var Hoek = require('../lib');
var Lab = require('lab');


// Declare internals

var internals = ***REMOVED******REMOVED***;


// Test shortcuts

var lab = exports.lab = Lab.script();
var describe = lab.experiment;
var it = lab.test;
var expect = Code.expect;


var nestedObj = ***REMOVED***
    v: [7, 8, 9],
    w: /^something$/igm,
    x: ***REMOVED***
        a: [1, 2, 3],
        b: 123456,
        c: new Date(),
        d: /hi/igm,
        e: /hello/
    ***REMOVED***,
    y: 'y',
    z: new Date(1378775452757)
***REMOVED***;

var dupsArray = [nestedObj, ***REMOVED*** z: 'z' ***REMOVED***, nestedObj];
var reducedDupsArray = [nestedObj, ***REMOVED*** z: 'z' ***REMOVED***];

describe('clone()', function () ***REMOVED***

    it('clones a nested object', function (done) ***REMOVED***

        var a = nestedObj;
        var b = Hoek.clone(a);

        expect(a).to.deep.equal(b);
        expect(a.z.getTime()).to.equal(b.z.getTime());
        done();
    ***REMOVED***);

    it('clones a null object', function (done) ***REMOVED***

        var b = Hoek.clone(null);

        expect(b).to.equal(null);
        done();
    ***REMOVED***);

    it('should not convert undefined properties to null', function (done) ***REMOVED***

        var obj = ***REMOVED*** something: undefined ***REMOVED***;
        var b = Hoek.clone(obj);

        expect(typeof b.something).to.equal('undefined');
        done();
    ***REMOVED***);

    it('should not throw on circular reference', function (done) ***REMOVED***

        var a = ***REMOVED******REMOVED***;
        a.x = a;

        var test = function () ***REMOVED***

            var b = Hoek.clone(a);
        ***REMOVED***;

        expect(test).to.not.throw();
        done();
    ***REMOVED***);

    it('clones circular reference', function (done) ***REMOVED***

        var x = ***REMOVED***
            'z': new Date()
        ***REMOVED***;
        x.y = x;

        var b = Hoek.clone(x);
        expect(Object.keys(b.y)).to.deep.equal(Object.keys(x));
        expect(b.z).to.not.equal(x.z);
        expect(b.y).to.not.equal(x.y);
        expect(b.y.z).to.not.equal(x.y.z);
        expect(b.y).to.equal(b);
        expect(b.y.y.y.y).to.equal(b);
        done();
    ***REMOVED***);

    it('clones an object with a null prototype', function (done) ***REMOVED***

        var obj = Object.create(null);
        var b = Hoek.clone(obj);

        expect(b).to.deep.equal(obj);
        done();
    ***REMOVED***);

    it('clones deeply nested object', function (done) ***REMOVED***

        var a = ***REMOVED***
            x: ***REMOVED***
                y: ***REMOVED***
                    a: [1, 2, 3],
                    b: 123456,
                    c: new Date(),
                    d: /hi/igm,
                    e: /hello/
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        var b = Hoek.clone(a);

        expect(a).to.deep.equal(b);
        expect(a.x.y.c.getTime()).to.equal(b.x.y.c.getTime());
        done();
    ***REMOVED***);

    it('clones arrays', function (done) ***REMOVED***

        var a = [1, 2, 3];

        var b = Hoek.clone(a);

        expect(a).to.deep.equal(b);
        done();
    ***REMOVED***);

    it('performs actual copy for shallow keys (no pass by reference)', function (done) ***REMOVED***

        var x = Hoek.clone(nestedObj);
        var y = Hoek.clone(nestedObj);

        // Date
        expect(x.z).to.not.equal(nestedObj.z);
        expect(x.z).to.not.equal(y.z);

        // Regex
        expect(x.w).to.not.equal(nestedObj.w);
        expect(x.w).to.not.equal(y.w);

        // Array
        expect(x.v).to.not.equal(nestedObj.v);
        expect(x.v).to.not.equal(y.v);

        // Immutable(s)
        x.y = 5;
        expect(x.y).to.not.equal(nestedObj.y);
        expect(x.y).to.not.equal(y.y);

        done();
    ***REMOVED***);

    it('performs actual copy for deep keys (no pass by reference)', function (done) ***REMOVED***

        var x = Hoek.clone(nestedObj);
        var y = Hoek.clone(nestedObj);

        expect(x.x.c).to.not.equal(nestedObj.x.c);
        expect(x.x.c).to.not.equal(y.x.c);

        expect(x.x.c.getTime()).to.equal(nestedObj.x.c.getTime());
        expect(x.x.c.getTime()).to.equal(y.x.c.getTime());
        done();
    ***REMOVED***);

    it('copies functions with properties', function (done) ***REMOVED***

        var a = ***REMOVED***
            x: function () ***REMOVED***

                return 1;
            ***REMOVED***,
            y: ***REMOVED******REMOVED***
        ***REMOVED***;
        a.x.z = 'string in function';
        a.x.v = function () ***REMOVED***

            return 2;
        ***REMOVED***;
        a.y.u = a.x;

        var b = Hoek.clone(a);
        expect(b.x()).to.equal(1);
        expect(b.x.v()).to.equal(2);
        expect(b.y.u).to.equal(b.x);
        expect(b.x.z).to.equal('string in function');
        done();
    ***REMOVED***);

    it('should copy a buffer', function (done) ***REMOVED***

        var tls = ***REMOVED***
            key: new Buffer([1, 2, 3, 4, 5]),
            cert: new Buffer([1, 2, 3, 4, 5, 6, 10])
        ***REMOVED***;

        var copiedTls = Hoek.clone(tls);
        expect(Buffer.isBuffer(copiedTls.key)).to.equal(true);
        expect(JSON.stringify(copiedTls.key)).to.equal(JSON.stringify(tls.key));
        expect(Buffer.isBuffer(copiedTls.cert)).to.equal(true);
        expect(JSON.stringify(copiedTls.cert)).to.equal(JSON.stringify(tls.cert));
        done();
    ***REMOVED***);

    it('clones an object with a prototype', function (done) ***REMOVED***

        var Obj = function () ***REMOVED***

            this.a = 5;
        ***REMOVED***;

        Obj.prototype.b = function () ***REMOVED***

            return 'c';
        ***REMOVED***;

        var a = new Obj();
        var b = Hoek.clone(a);

        expect(b.a).to.equal(5);
        expect(b.b()).to.equal('c');
        expect(a).to.deep.equal(b);
        done();
    ***REMOVED***);

    it('reuses cloned Date object', function (done) ***REMOVED***

        var obj = ***REMOVED***
            a: new Date()
        ***REMOVED***;

        obj.b = obj.a;

        var copy = Hoek.clone(obj);
        expect(copy.a).to.equal(copy.b);
        done();
    ***REMOVED***);

    it('shallow copies an object with a prototype and isImmutable flag', function (done) ***REMOVED***

        var Obj = function () ***REMOVED***

            this.value = 5;
        ***REMOVED***;

        Obj.prototype.b = function () ***REMOVED***

            return 'c';
        ***REMOVED***;

        Obj.prototype.isImmutable = true;

        var obj = ***REMOVED***
            a: new Obj()
        ***REMOVED***;

        var copy = Hoek.clone(obj);

        expect(obj.a.value).to.equal(5);
        expect(copy.a.value).to.equal(5);
        expect(copy.a.b()).to.equal('c');
        expect(obj.a).to.equal(copy.a);
        done();
    ***REMOVED***);

    it('clones an object with property getter without executing it', function (done) ***REMOVED***

        var obj = ***REMOVED******REMOVED***;
        var value = 1;
        var execCount = 0;

        Object.defineProperty(obj, 'test', ***REMOVED***
            enumerable: true,
            configurable: true,
            get: function () ***REMOVED***

                ++execCount;
                return value;
            ***REMOVED***
        ***REMOVED***);

        var copy = Hoek.clone(obj);
        expect(execCount).to.equal(0);
        expect(copy.test).to.equal(1);
        expect(execCount).to.equal(1);
        done();
    ***REMOVED***);

    it('clones an object with property getter and setter', function (done) ***REMOVED***

        var obj = ***REMOVED***
            _test: 0
        ***REMOVED***;

        Object.defineProperty(obj, 'test', ***REMOVED***
            enumerable: true,
            configurable: true,
            get: function () ***REMOVED***

                return this._test;
            ***REMOVED***,
            set: function (value) ***REMOVED***

                this._test = value - 1;
            ***REMOVED***
        ***REMOVED***);

        var copy = Hoek.clone(obj);
        expect(copy.test).to.equal(0);
        copy.test = 5;
        expect(copy.test).to.equal(4);
        done();
    ***REMOVED***);

    it('clones an object with only property setter', function (done) ***REMOVED***

        var obj = ***REMOVED***
            _test: 0
        ***REMOVED***;

        Object.defineProperty(obj, 'test', ***REMOVED***
            enumerable: true,
            configurable: true,
            set: function (value) ***REMOVED***

                this._test = value - 1;
            ***REMOVED***
        ***REMOVED***);

        var copy = Hoek.clone(obj);
        expect(copy._test).to.equal(0);
        copy.test = 5;
        expect(copy._test).to.equal(4);
        done();
    ***REMOVED***);

    it('clones an object with non-enumerable properties', function (done) ***REMOVED***

        var obj = ***REMOVED***
            _test: 0
        ***REMOVED***;

        Object.defineProperty(obj, 'test', ***REMOVED***
            enumerable: false,
            configurable: true,
            set: function (value) ***REMOVED***

                this._test = value - 1;
            ***REMOVED***
        ***REMOVED***);

        var copy = Hoek.clone(obj);
        expect(copy._test).to.equal(0);
        copy.test = 5;
        expect(copy._test).to.equal(4);
        done();
    ***REMOVED***);

    it('clones an object where getOwnPropertyDescriptor returns undefined', function (done) ***REMOVED***

        var oldGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var obj = ***REMOVED*** a: 'b' ***REMOVED***;
        Object.getOwnPropertyDescriptor = function () ***REMOVED***

            return undefined;
        ***REMOVED***;

        var copy = Hoek.clone(obj);
        Object.getOwnPropertyDescriptor = oldGetOwnPropertyDescriptor;
        expect(copy).to.deep.equal(obj);
        done();
    ***REMOVED***);
***REMOVED***);

describe('merge()', function () ***REMOVED***

    it('deep copies source items', function (done) ***REMOVED***

        var target = ***REMOVED***
            b: 3,
            d: []
        ***REMOVED***;

        var source = ***REMOVED***
            c: ***REMOVED***
                d: 1
            ***REMOVED***,
            d: [***REMOVED*** e: 1 ***REMOVED***]
        ***REMOVED***;

        Hoek.merge(target, source);
        expect(target.c).to.not.equal(source.c);
        expect(target.c).to.deep.equal(source.c);
        expect(target.d).to.not.equal(source.d);
        expect(target.d[0]).to.not.equal(source.d[0]);
        expect(target.d).to.deep.equal(source.d);
        done();
    ***REMOVED***);

    it('merges array over an object', function (done) ***REMOVED***

        var a = ***REMOVED***
            x: ['n', 'm']
        ***REMOVED***;

        var b = ***REMOVED***
            x: ***REMOVED***
                n: '1',
                m: '2'
            ***REMOVED***
        ***REMOVED***;

        Hoek.merge(b, a);
        expect(a.x[0]).to.equal('n');
        expect(a.x.n).to.not.exist();
        done();
    ***REMOVED***);

    it('merges object over an array', function (done) ***REMOVED***

        var a = ***REMOVED***
            x: ['n', 'm']
        ***REMOVED***;

        var b = ***REMOVED***
            x: ***REMOVED***
                n: '1',
                m: '2'
            ***REMOVED***
        ***REMOVED***;

        Hoek.merge(a, b);
        expect(a.x.n).to.equal('1');
        expect(a.x[0]).to.not.exist();
        done();
    ***REMOVED***);

    it('does not throw if source is null', function (done) ***REMOVED***

        var a = ***REMOVED******REMOVED***;
        var b = null;
        var c = null;

        expect(function () ***REMOVED***

            c = Hoek.merge(a, b);
        ***REMOVED***).to.not.throw();

        expect(c).to.equal(a);
        done();
    ***REMOVED***);

    it('does not throw if source is undefined', function (done) ***REMOVED***

        var a = ***REMOVED******REMOVED***;
        var b;
        var c = null;

        expect(function () ***REMOVED***

            c = Hoek.merge(a, b);
        ***REMOVED***).to.not.throw();

        expect(c).to.equal(a);
        done();
    ***REMOVED***);

    it('throws if source is not an object', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            var a = ***REMOVED******REMOVED***;
            var b = 0;

            Hoek.merge(a, b);
        ***REMOVED***).to.throw('Invalid source value: must be null, undefined, or an object');
        done();
    ***REMOVED***);

    it('throws if target is not an object', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            var a = 0;
            var b = ***REMOVED******REMOVED***;

            Hoek.merge(a, b);
        ***REMOVED***).to.throw('Invalid target value: must be an object');
        done();
    ***REMOVED***);

    it('throws if target is not an array and source is', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            var a = ***REMOVED******REMOVED***;
            var b = [1, 2];

            Hoek.merge(a, b);
        ***REMOVED***).to.throw('Cannot merge array onto an object');
        done();
    ***REMOVED***);

    it('returns the same object when merging arrays', function (done) ***REMOVED***

        var a = [];
        var b = [1, 2];

        expect(Hoek.merge(a, b)).to.equal(a);
        done();
    ***REMOVED***);

    it('combines an empty object with a non-empty object', function (done) ***REMOVED***

        var a = ***REMOVED******REMOVED***;
        var b = nestedObj;

        var c = Hoek.merge(a, b);
        expect(a).to.deep.equal(b);
        expect(c).to.deep.equal(b);
        done();
    ***REMOVED***);

    it('overrides values in target', function (done) ***REMOVED***

        var a = ***REMOVED*** x: 1, y: 2, z: 3, v: 5, t: 'test', m: 'abc' ***REMOVED***;
        var b = ***REMOVED*** x: null, z: 4, v: 0, t: ***REMOVED*** u: 6 ***REMOVED***, m: '123' ***REMOVED***;

        var c = Hoek.merge(a, b);
        expect(c.x).to.equal(null);
        expect(c.y).to.equal(2);
        expect(c.z).to.equal(4);
        expect(c.v).to.equal(0);
        expect(c.m).to.equal('123');
        expect(c.t).to.deep.equal(***REMOVED*** u: 6 ***REMOVED***);
        done();
    ***REMOVED***);

    it('overrides values in target (flip)', function (done) ***REMOVED***

        var a = ***REMOVED*** x: 1, y: 2, z: 3, v: 5, t: 'test', m: 'abc' ***REMOVED***;
        var b = ***REMOVED*** x: null, z: 4, v: 0, t: ***REMOVED*** u: 6 ***REMOVED***, m: '123' ***REMOVED***;

        var d = Hoek.merge(b, a);
        expect(d.x).to.equal(1);
        expect(d.y).to.equal(2);
        expect(d.z).to.equal(3);
        expect(d.v).to.equal(5);
        expect(d.m).to.equal('abc');
        expect(d.t).to.deep.equal('test');
        done();
    ***REMOVED***);

    it('retains Date properties', function (done) ***REMOVED***

        var a = ***REMOVED*** x: new Date(1378776452757) ***REMOVED***;

        var b = Hoek.merge(***REMOVED******REMOVED***, a);
        expect(a.x.getTime()).to.equal(b.x.getTime());
        done();
    ***REMOVED***);

    it('retains Date properties when merging keys', function (done) ***REMOVED***

        var a = ***REMOVED*** x: new Date(1378776452757) ***REMOVED***;

        var b = Hoek.merge(***REMOVED*** x: ***REMOVED******REMOVED*** ***REMOVED***, a);
        expect(a.x.getTime()).to.equal(b.x.getTime());
        done();
    ***REMOVED***);

    it('overrides Buffer', function (done) ***REMOVED***

        var a = ***REMOVED*** x: new Buffer('abc') ***REMOVED***;

        var b = Hoek.merge(***REMOVED*** x: ***REMOVED******REMOVED*** ***REMOVED***, a);
        expect(a.x.toString()).to.equal('abc');
        done();
    ***REMOVED***);
***REMOVED***);

describe('applyToDefaults()', function () ***REMOVED***

    var defaults = ***REMOVED***
        a: 1,
        b: 2,
        c: ***REMOVED***
            d: 3,
            e: [5, 6]
        ***REMOVED***,
        f: 6,
        g: 'test'
    ***REMOVED***;

    it('throws when target is null', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            Hoek.applyToDefaults(null, ***REMOVED******REMOVED***);
        ***REMOVED***).to.throw('Invalid defaults value: must be an object');
        done();
    ***REMOVED***);

    it('returns null if options is false', function (done) ***REMOVED***

        var result = Hoek.applyToDefaults(defaults, false);
        expect(result).to.equal(null);
        done();
    ***REMOVED***);

    it('returns null if options is null', function (done) ***REMOVED***

        var result = Hoek.applyToDefaults(defaults, null);
        expect(result).to.equal(null);
        done();
    ***REMOVED***);

    it('returns null if options is undefined', function (done) ***REMOVED***

        var result = Hoek.applyToDefaults(defaults, undefined);
        expect(result).to.equal(null);
        done();
    ***REMOVED***);

    it('returns a copy of defaults if options is true', function (done) ***REMOVED***

        var result = Hoek.applyToDefaults(defaults, true);
        expect(result).to.deep.equal(defaults);
        done();
    ***REMOVED***);

    it('applies object to defaults', function (done) ***REMOVED***

        var obj = ***REMOVED***
            a: null,
            c: ***REMOVED***
                e: [4]
            ***REMOVED***,
            f: 0,
            g: ***REMOVED***
                h: 5
            ***REMOVED***
        ***REMOVED***;

        var result = Hoek.applyToDefaults(defaults, obj);
        expect(result.c.e).to.deep.equal([4]);
        expect(result.a).to.equal(1);
        expect(result.b).to.equal(2);
        expect(result.f).to.equal(0);
        expect(result.g).to.deep.equal(***REMOVED*** h: 5 ***REMOVED***);
        done();
    ***REMOVED***);

    it('applies object to defaults with null', function (done) ***REMOVED***

        var obj = ***REMOVED***
            a: null,
            c: ***REMOVED***
                e: [4]
            ***REMOVED***,
            f: 0,
            g: ***REMOVED***
                h: 5
            ***REMOVED***
        ***REMOVED***;

        var result = Hoek.applyToDefaults(defaults, obj, true);
        expect(result.c.e).to.deep.equal([4]);
        expect(result.a).to.equal(null);
        expect(result.b).to.equal(2);
        expect(result.f).to.equal(0);
        expect(result.g).to.deep.equal(***REMOVED*** h: 5 ***REMOVED***);
        done();
    ***REMOVED***);
***REMOVED***);

describe('cloneWithShallow()', function () ***REMOVED***

    it('deep clones except for listed keys', function (done) ***REMOVED***

        var source = ***REMOVED***
            a: ***REMOVED***
                b: 5
            ***REMOVED***,
            c: ***REMOVED***
                d: 6
            ***REMOVED***
        ***REMOVED***;

        var copy = Hoek.cloneWithShallow(source, ['c']);
        expect(copy).to.deep.equal(source);
        expect(copy).to.not.equal(source);
        expect(copy.a).to.not.equal(source.a);
        expect(copy.b).to.equal(source.b);
        done();
    ***REMOVED***);

    it('returns immutable value', function (done) ***REMOVED***

        expect(Hoek.cloneWithShallow(5)).to.equal(5);
        done();
    ***REMOVED***);

    it('returns null value', function (done) ***REMOVED***

        expect(Hoek.cloneWithShallow(null)).to.equal(null);
        done();
    ***REMOVED***);

    it('returns undefined value', function (done) ***REMOVED***

        expect(Hoek.cloneWithShallow(undefined)).to.equal(undefined);
        done();
    ***REMOVED***);

    it('deep clones except for listed keys (including missing keys)', function (done) ***REMOVED***

        var source = ***REMOVED***
            a: ***REMOVED***
                b: 5
            ***REMOVED***,
            c: ***REMOVED***
                d: 6
            ***REMOVED***
        ***REMOVED***;

        var copy = Hoek.cloneWithShallow(source, ['c', 'v']);
        expect(copy).to.deep.equal(source);
        expect(copy).to.not.equal(source);
        expect(copy.a).to.not.equal(source.a);
        expect(copy.b).to.equal(source.b);
        done();
    ***REMOVED***);
***REMOVED***);

describe('applyToDefaultsWithShallow()', function () ***REMOVED***

    it('shallow copies the listed keys from options without merging', function (done) ***REMOVED***

        var defaults = ***REMOVED***
            a: ***REMOVED***
                b: 5,
                e: 3
            ***REMOVED***,
            c: ***REMOVED***
                d: 7,
                g: 1
            ***REMOVED***
        ***REMOVED***;

        var options = ***REMOVED***
            a: ***REMOVED***
                b: 4
            ***REMOVED***,
            c: ***REMOVED***
                d: 6,
                f: 7
            ***REMOVED***
        ***REMOVED***;

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['a']);
        expect(merged).to.deep.equal(***REMOVED*** a: ***REMOVED*** b: 4 ***REMOVED***, c: ***REMOVED*** d: 6, g: 1, f: 7 ***REMOVED*** ***REMOVED***);
        expect(merged.a).to.equal(options.a);
        expect(merged.a).to.not.equal(defaults.a);
        expect(merged.c).to.not.equal(options.c);
        expect(merged.c).to.not.equal(defaults.c);
        done();
    ***REMOVED***);

    it('shallow copies the nested keys (override)', function (done) ***REMOVED***

        var defaults = ***REMOVED***
            a: ***REMOVED***
                b: 5
            ***REMOVED***,
            c: ***REMOVED***
                d: 7,
                g: 1
            ***REMOVED***
        ***REMOVED***;

        var options = ***REMOVED***
            a: ***REMOVED***
                b: 4
            ***REMOVED***,
            c: ***REMOVED***
                d: 6,
                g: ***REMOVED***
                    h: 8
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);
        expect(merged).to.deep.equal(***REMOVED*** a: ***REMOVED*** b: 4 ***REMOVED***, c: ***REMOVED*** d: 6, g: ***REMOVED*** h: 8 ***REMOVED*** ***REMOVED*** ***REMOVED***);
        expect(merged.c.g).to.equal(options.c.g);
        done();
    ***REMOVED***);

    it('shallow copies the nested keys (missing)', function (done) ***REMOVED***

        var defaults = ***REMOVED***
            a: ***REMOVED***
                b: 5
            ***REMOVED***
        ***REMOVED***;

        var options = ***REMOVED***
            a: ***REMOVED***
                b: 4
            ***REMOVED***,
            c: ***REMOVED***
                g: ***REMOVED***
                    h: 8
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);
        expect(merged).to.deep.equal(***REMOVED*** a: ***REMOVED*** b: 4 ***REMOVED***, c: ***REMOVED*** g: ***REMOVED*** h: 8 ***REMOVED*** ***REMOVED*** ***REMOVED***);
        expect(merged.c.g).to.equal(options.c.g);
        done();
    ***REMOVED***);

    it('shallow copies the nested keys (override)', function (done) ***REMOVED***

        var defaults = ***REMOVED***
            a: ***REMOVED***
                b: 5
            ***REMOVED***,
            c: ***REMOVED***
                g: ***REMOVED***
                    d: 7
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        var options = ***REMOVED***
            a: ***REMOVED***
                b: 4
            ***REMOVED***,
            c: ***REMOVED***
                g: ***REMOVED***
                    h: 8
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);
        expect(merged).to.deep.equal(***REMOVED*** a: ***REMOVED*** b: 4 ***REMOVED***, c: ***REMOVED*** g: ***REMOVED*** h: 8 ***REMOVED*** ***REMOVED*** ***REMOVED***);
        expect(merged.c.g).to.equal(options.c.g);
        done();
    ***REMOVED***);

    it('shallow copies the nested keys (deeper)', function (done) ***REMOVED***

        var defaults = ***REMOVED***
            a: ***REMOVED***
                b: 5
            ***REMOVED***
        ***REMOVED***;

        var options = ***REMOVED***
            a: ***REMOVED***
                b: 4
            ***REMOVED***,
            c: ***REMOVED***
                g: ***REMOVED***
                    r: ***REMOVED***
                        h: 8
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g.r']);
        expect(merged).to.deep.equal(***REMOVED*** a: ***REMOVED*** b: 4 ***REMOVED***, c: ***REMOVED*** g: ***REMOVED*** r: ***REMOVED*** h: 8 ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***);
        expect(merged.c.g.r).to.equal(options.c.g.r);
        done();
    ***REMOVED***);

    it('shallow copies the nested keys (not present)', function (done) ***REMOVED***

        var defaults = ***REMOVED***
            a: ***REMOVED***
                b: 5
            ***REMOVED***
        ***REMOVED***;

        var options = ***REMOVED***
            a: ***REMOVED***
                b: 4
            ***REMOVED***,
            c: ***REMOVED***
                g: ***REMOVED***
                    r: ***REMOVED***
                        h: 8
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['x.y']);
        expect(merged).to.deep.equal(***REMOVED*** a: ***REMOVED*** b: 4 ***REMOVED***, c: ***REMOVED*** g: ***REMOVED*** r: ***REMOVED*** h: 8 ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***);
        done();
    ***REMOVED***);

    it('shallow copies the listed keys in the defaults', function (done) ***REMOVED***

        var defaults = ***REMOVED***
            a: ***REMOVED***
                b: 1
            ***REMOVED***
        ***REMOVED***;

        var merged = Hoek.applyToDefaultsWithShallow(defaults, ***REMOVED******REMOVED***, ['a']);
        expect(merged.a).to.equal(defaults.a);
        done();
    ***REMOVED***);

    it('shallow copies the listed keys in the defaults (true)', function (done) ***REMOVED***

        var defaults = ***REMOVED***
            a: ***REMOVED***
                b: 1
            ***REMOVED***
        ***REMOVED***;

        var merged = Hoek.applyToDefaultsWithShallow(defaults, true, ['a']);
        expect(merged.a).to.equal(defaults.a);
        done();
    ***REMOVED***);

    it('returns null on false', function (done) ***REMOVED***

        var defaults = ***REMOVED***
            a: ***REMOVED***
                b: 1
            ***REMOVED***
        ***REMOVED***;

        var merged = Hoek.applyToDefaultsWithShallow(defaults, false, ['a']);
        expect(merged).to.equal(null);
        done();
    ***REMOVED***);

    it('throws on missing defaults', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            Hoek.applyToDefaultsWithShallow(null, ***REMOVED******REMOVED***, ['a']);
        ***REMOVED***).to.throw('Invalid defaults value: must be an object');
        done();
    ***REMOVED***);

    it('throws on invalid defaults', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            Hoek.applyToDefaultsWithShallow('abc', ***REMOVED******REMOVED***, ['a']);
        ***REMOVED***).to.throw('Invalid defaults value: must be an object');
        done();
    ***REMOVED***);

    it('throws on invalid options', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            Hoek.applyToDefaultsWithShallow(***REMOVED******REMOVED***, 'abc', ['a']);
        ***REMOVED***).to.throw('Invalid options value: must be true, falsy or an object');
        done();
    ***REMOVED***);

    it('throws on missing keys', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            Hoek.applyToDefaultsWithShallow(***REMOVED******REMOVED***, true);
        ***REMOVED***).to.throw('Invalid keys');
        done();
    ***REMOVED***);

    it('throws on invalid keys', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            Hoek.applyToDefaultsWithShallow(***REMOVED******REMOVED***, true, 'a');
        ***REMOVED***).to.throw('Invalid keys');
        done();
    ***REMOVED***);
***REMOVED***);

describe('deepEqual()', function () ***REMOVED***

    it('compares simple values', function (done) ***REMOVED***

        expect(Hoek.deepEqual('x', 'x')).to.be.true();
        expect(Hoek.deepEqual('x', 'y')).to.be.false();
        expect(Hoek.deepEqual('x1', 'x')).to.be.false();
        expect(Hoek.deepEqual(-0, +0)).to.be.false();
        expect(Hoek.deepEqual(-0, -0)).to.be.true();
        expect(Hoek.deepEqual(+0, +0)).to.be.true();
        expect(Hoek.deepEqual(+0, -0)).to.be.false();
        expect(Hoek.deepEqual(1, 1)).to.be.true();
        expect(Hoek.deepEqual(0, 0)).to.be.true();
        expect(Hoek.deepEqual(-1, 1)).to.be.false();
        expect(Hoek.deepEqual(NaN, 0)).to.be.false();
        expect(Hoek.deepEqual(NaN, NaN)).to.be.true();
        done();
    ***REMOVED***);

    it('compares different types', function (done) ***REMOVED***

        expect(Hoek.deepEqual([], 5)).to.be.false();
        expect(Hoek.deepEqual(5, [])).to.be.false();
        expect(Hoek.deepEqual(***REMOVED******REMOVED***, null)).to.be.false();
        expect(Hoek.deepEqual(null, ***REMOVED******REMOVED***)).to.be.false();
        expect(Hoek.deepEqual('abc', ***REMOVED******REMOVED***)).to.be.false();
        expect(Hoek.deepEqual(***REMOVED******REMOVED***, 'abc')).to.be.false();
        done();
    ***REMOVED***);

    it('compares empty structures', function (done) ***REMOVED***

        expect(Hoek.deepEqual([], [])).to.be.true();
        expect(Hoek.deepEqual(***REMOVED******REMOVED***, ***REMOVED******REMOVED***)).to.be.true();
        expect(Hoek.deepEqual([], ***REMOVED******REMOVED***)).to.be.false();
        done();
    ***REMOVED***);

    it('compares empty arguments object', function (done) ***REMOVED***

        var compare = function () ***REMOVED***

            expect(Hoek.deepEqual([], arguments)).to.be.false();
        ***REMOVED***;

        compare();
        done();
    ***REMOVED***);

    it('compares empty arguments objects', function (done) ***REMOVED***

        var compare = function () ***REMOVED***

            var arg1 = arguments;

            var inner = function () ***REMOVED***

                expect(Hoek.deepEqual(arg1, arguments)).to.be.false(); // callee is not the same
            ***REMOVED***;

            inner();
        ***REMOVED***;

        compare();
        done();
    ***REMOVED***);

    it('compares dates', function (done) ***REMOVED***

        expect(Hoek.deepEqual(new Date(2015, 1, 1), new Date(2015, 1, 1))).to.be.true();
        expect(Hoek.deepEqual(new Date(100), new Date(101))).to.be.false();
        expect(Hoek.deepEqual(new Date(), ***REMOVED******REMOVED***)).to.be.false();
        done();
    ***REMOVED***);

    it('compares regular expressions', function (done) ***REMOVED***

        expect(Hoek.deepEqual(/\s/, new RegExp('\\\s'))).to.be.true();
        expect(Hoek.deepEqual(/\s/g, /\s/g)).to.be.true();
        expect(Hoek.deepEqual(/a/, ***REMOVED******REMOVED***)).to.be.false();
        expect(Hoek.deepEqual(/\s/g, /\s/i)).to.be.false();
        expect(Hoek.deepEqual(/a/g, /b/g)).to.be.false();
        done();
    ***REMOVED***);

    it('compares arrays', function (done) ***REMOVED***

        expect(Hoek.deepEqual([[1]], [[1]])).to.be.true();
        expect(Hoek.deepEqual([1, 2, 3], [1, 2, 3])).to.be.true();
        expect(Hoek.deepEqual([1, 2, 3], [1, 3, 2])).to.be.false();
        expect(Hoek.deepEqual([1, 2, 3], [1, 2])).to.be.false();
        expect(Hoek.deepEqual([1], [1])).to.be.true();
        done();
    ***REMOVED***);

    it('compares buffers', function (done) ***REMOVED***

        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), new Buffer([1, 2, 3]))).to.be.true();
        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), new Buffer([1, 3, 2]))).to.be.false();
        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), new Buffer([1, 2]))).to.be.false();
        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), ***REMOVED******REMOVED***)).to.be.false();
        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), [1, 2, 3])).to.be.false();
        done();
    ***REMOVED***);

    it('compares objects', function (done) ***REMOVED***

        expect(Hoek.deepEqual(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***)).to.be.true();
        expect(Hoek.deepEqual(***REMOVED*** foo: 'bar' ***REMOVED***, ***REMOVED*** foo: 'baz' ***REMOVED***)).to.be.false();
        expect(Hoek.deepEqual(***REMOVED*** foo: ***REMOVED*** bar: 'foo' ***REMOVED*** ***REMOVED***, ***REMOVED*** foo: ***REMOVED*** bar: 'baz' ***REMOVED*** ***REMOVED***)).to.be.false();
        done();
    ***REMOVED***);

    it('handles circular dependency', function (done) ***REMOVED***

        var a = ***REMOVED******REMOVED***;
        a.x = a;

        var b = Hoek.clone(a);
        expect(Hoek.deepEqual(a, b)).to.be.true();
        done();
    ***REMOVED***);

    it('compares an object with property getter without executing it', function (done) ***REMOVED***

        var obj = ***REMOVED******REMOVED***;
        var value = 1;
        var execCount = 0;

        Object.defineProperty(obj, 'test', ***REMOVED***
            enumerable: true,
            configurable: true,
            get: function () ***REMOVED***

                ++execCount;
                return value;
            ***REMOVED***
        ***REMOVED***);

        var copy = Hoek.clone(obj);
        expect(Hoek.deepEqual(obj, copy)).to.be.true();
        expect(execCount).to.equal(0);
        expect(copy.test).to.equal(1);
        expect(execCount).to.equal(1);
        done();
    ***REMOVED***);

    it('compares objects with property getters', function (done) ***REMOVED***

        var obj = ***REMOVED******REMOVED***;
        Object.defineProperty(obj, 'test', ***REMOVED***
            enumerable: true,
            configurable: true,
            get: function () ***REMOVED***

                return 1;
            ***REMOVED***
        ***REMOVED***);

        var ref = ***REMOVED******REMOVED***;
        Object.defineProperty(ref, 'test', ***REMOVED***
            enumerable: true,
            configurable: true,
            get: function () ***REMOVED***

                return 2;
            ***REMOVED***
        ***REMOVED***);

        expect(Hoek.deepEqual(obj, ref)).to.be.false();
        done();
    ***REMOVED***);

    it('compares object prototypes', function (done) ***REMOVED***

        var Obj = function () ***REMOVED***

            this.a = 5;
        ***REMOVED***;

        Obj.prototype.b = function () ***REMOVED***

            return this.a;
        ***REMOVED***;

        var Ref = function () ***REMOVED***

            this.a = 5;
        ***REMOVED***;

        Ref.prototype.b = function () ***REMOVED***

            return this.a;
        ***REMOVED***;

        expect(Hoek.deepEqual(new Obj(), new Ref())).to.be.false();
        expect(Hoek.deepEqual(new Obj(), new Obj())).to.be.true();
        expect(Hoek.deepEqual(new Ref(), new Ref())).to.be.true();
        done();
    ***REMOVED***);

    it('compares plain objects', function (done) ***REMOVED***

        var a = Object.create(null);
        var b = Object.create(null);

        a.b = 'c';
        b.b = 'c';

        expect(Hoek.deepEqual(a, b)).to.be.true();
        expect(Hoek.deepEqual(a, ***REMOVED*** b: 'c' ***REMOVED***)).to.be.false();
        done();
    ***REMOVED***);

    it('compares an object with an empty object', function (done) ***REMOVED***

        var a = ***REMOVED*** a: 1, b: 2 ***REMOVED***;

        expect(Hoek.deepEqual(***REMOVED******REMOVED***, a)).to.be.false();
        expect(Hoek.deepEqual(a, ***REMOVED******REMOVED***)).to.be.false();
        done();
    ***REMOVED***);

    it('compares an object ignoring the prototype', function (done) ***REMOVED***

        var a = Object.create(null);
        var b = ***REMOVED******REMOVED***;

        expect(Hoek.deepEqual(a, b, ***REMOVED*** prototype: false ***REMOVED***)).to.be.true();
        done();
    ***REMOVED***);

    it('compares an object ignoring the prototype recursively', function (done) ***REMOVED***

        var a = [Object.create(null)];
        var b = [***REMOVED******REMOVED***];

        expect(Hoek.deepEqual(a, b, ***REMOVED*** prototype: false ***REMOVED***)).to.be.true();
        done();
    ***REMOVED***);
***REMOVED***);

describe('unique()', function () ***REMOVED***

    it('ensures uniqueness within array of objects based on subkey', function (done) ***REMOVED***

        var a = Hoek.unique(dupsArray, 'x');
        expect(a).to.deep.equal(reducedDupsArray);
        done();
    ***REMOVED***);

    it('removes duplicated without key', function (done) ***REMOVED***

        expect(Hoek.unique([1, 2, 3, 4, 2, 1, 5])).to.deep.equal([1, 2, 3, 4, 5]);
        done();
    ***REMOVED***);
***REMOVED***);

describe('mapToObject()', function () ***REMOVED***

    it('returns null on null array', function (done) ***REMOVED***

        var a = Hoek.mapToObject(null);
        expect(a).to.equal(null);
        done();
    ***REMOVED***);

    it('converts basic array to existential object', function (done) ***REMOVED***

        var keys = [1, 2, 3, 4];
        var a = Hoek.mapToObject(keys);
        for (var i in keys) ***REMOVED***
            expect(a[keys[i]]).to.equal(true);
        ***REMOVED***
        done();
    ***REMOVED***);

    it('converts array of objects to existential object', function (done) ***REMOVED***

        var keys = [***REMOVED*** x: 1 ***REMOVED***, ***REMOVED*** x: 2 ***REMOVED***, ***REMOVED*** x: 3 ***REMOVED***, ***REMOVED*** y: 4 ***REMOVED***];
        var subkey = 'x';
        var a = Hoek.mapToObject(keys, subkey);
        expect(a).to.deep.equal(***REMOVED*** 1: true, 2: true, 3: true ***REMOVED***);
        done();
    ***REMOVED***);
***REMOVED***);

describe('intersect()', function () ***REMOVED***

    it('returns the common objects of two arrays', function (done) ***REMOVED***

        var array1 = [1, 2, 3, 4, 4, 5, 5];
        var array2 = [5, 4, 5, 6, 7];
        var common = Hoek.intersect(array1, array2);
        expect(common.length).to.equal(2);
        done();
    ***REMOVED***);

    it('returns just the first common object of two arrays', function (done) ***REMOVED***

        var array1 = [1, 2, 3, 4, 4, 5, 5];
        var array2 = [5, 4, 5, 6, 7];
        var common = Hoek.intersect(array1, array2, true);
        expect(common).to.equal(5);
        done();
    ***REMOVED***);

    it('returns null when no common and returning just the first common object of two arrays', function (done) ***REMOVED***

        var array1 = [1, 2, 3, 4, 4, 5, 5];
        var array2 = [6, 7];
        var common = Hoek.intersect(array1, array2, true);
        expect(common).to.equal(null);
        done();
    ***REMOVED***);

    it('returns an empty array if either input is null', function (done) ***REMOVED***

        expect(Hoek.intersect([1], null).length).to.equal(0);
        expect(Hoek.intersect(null, [1]).length).to.equal(0);
        done();
    ***REMOVED***);

    it('returns the common objects of object and array', function (done) ***REMOVED***

        var array1 = [1, 2, 3, 4, 4, 5, 5];
        var array2 = [5, 4, 5, 6, 7];
        var common = Hoek.intersect(Hoek.mapToObject(array1), array2);
        expect(common.length).to.equal(2);
        done();
    ***REMOVED***);
***REMOVED***);

describe('contain()', function () ***REMOVED***

    it('tests strings', function (done) ***REMOVED***

        expect(Hoek.contain('abc', 'ab')).to.be.true();
        expect(Hoek.contain('abc', 'abc', ***REMOVED*** only: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain('aaa', 'a', ***REMOVED*** only: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain('abc', 'b', ***REMOVED*** once: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain('abc', ['a', 'c'])).to.be.true();
        expect(Hoek.contain('abc', ['a', 'd'], ***REMOVED*** part: true ***REMOVED***)).to.be.true();

        expect(Hoek.contain('abc', 'ac')).to.be.false();
        expect(Hoek.contain('abcd', 'abc', ***REMOVED*** only: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain('aab', 'a', ***REMOVED*** only: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain('abb', 'b', ***REMOVED*** once: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain('abc', ['a', 'd'])).to.be.false();
        expect(Hoek.contain('abc', ['ab', 'bc'])).to.be.false();                      // Overlapping values not supported
        done();
    ***REMOVED***);

    it('tests arrays', function (done) ***REMOVED***

        expect(Hoek.contain([1, 2, 3], 1)).to.be.true();
        expect(Hoek.contain([***REMOVED*** a: 1 ***REMOVED***], ***REMOVED*** a: 1 ***REMOVED***, ***REMOVED*** deep: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain([1, 2, 3], [1, 2])).to.be.true();
        expect(Hoek.contain([***REMOVED*** a: 1 ***REMOVED***], [***REMOVED*** a: 1 ***REMOVED***], ***REMOVED*** deep: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain([1, 1, 2], [1, 2], ***REMOVED*** only: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain([1, 2], [1, 2], ***REMOVED*** once: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain([1, 2, 3], [1, 4], ***REMOVED*** part: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain([[1], [2]], [[1]], ***REMOVED*** deep: true ***REMOVED***)).to.be.true();

        expect(Hoek.contain([1, 2, 3], 4)).to.be.false();
        expect(Hoek.contain([***REMOVED*** a: 1 ***REMOVED***], ***REMOVED*** a: 2 ***REMOVED***, ***REMOVED*** deep: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain([***REMOVED*** a: 1 ***REMOVED***], ***REMOVED*** a: 1 ***REMOVED***)).to.be.false();
        expect(Hoek.contain([1, 2, 3], [4, 5])).to.be.false();
        expect(Hoek.contain([[3], [2]], [[1]])).to.be.false();
        expect(Hoek.contain([[1], [2]], [[1]])).to.be.false();
        expect(Hoek.contain([***REMOVED*** a: 1 ***REMOVED***], [***REMOVED*** a: 2 ***REMOVED***], ***REMOVED*** deep: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain([1, 3, 2], [1, 2], ***REMOVED*** only: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain([1, 2, 2], [1, 2], ***REMOVED*** once: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain([0, 2, 3], [1, 4], ***REMOVED*** part: true ***REMOVED***)).to.be.false();
        done();
    ***REMOVED***);

    it('tests objects', function (done) ***REMOVED***

        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, 'a')).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ['a', 'c'])).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ['a', 'b', 'c'], ***REMOVED*** only: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 1 ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 1, c: 3 ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 1, d: 4 ***REMOVED***, ***REMOVED*** part: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** only: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: [1], b: [2], c: [3] ***REMOVED***, ***REMOVED*** a: [1], c: [3] ***REMOVED***, ***REMOVED*** deep: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** c: 2 ***REMOVED***, ***REMOVED*** d: 3, e: 4 ***REMOVED***] ***REMOVED***, ***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** d: 3 ***REMOVED***] ***REMOVED***, ***REMOVED*** deep: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** c: 2 ***REMOVED***, ***REMOVED*** d: 3, e: 4 ***REMOVED***] ***REMOVED***, ***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** d: 3 ***REMOVED***] ***REMOVED***, ***REMOVED*** deep: true, part: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** c: 2 ***REMOVED***, ***REMOVED*** d: 3, e: 4 ***REMOVED***] ***REMOVED***, ***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** d: 3 ***REMOVED***] ***REMOVED***, ***REMOVED*** deep: true, part: false ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** c: 2 ***REMOVED***, ***REMOVED*** d: 3, e: 4 ***REMOVED***] ***REMOVED***, ***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** d: 3 ***REMOVED***] ***REMOVED***, ***REMOVED*** deep: true, only: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** c: 2 ***REMOVED***, ***REMOVED*** d: 3, e: 4 ***REMOVED***] ***REMOVED***, ***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, ***REMOVED*** d: 3 ***REMOVED***] ***REMOVED***, ***REMOVED*** deep: true, only: false ***REMOVED***)).to.be.true();

        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, 'd')).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ['a', 'd'])).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3, d: 4 ***REMOVED***, ['a', 'b', 'c'], ***REMOVED*** only: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 2 ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 2, b: 2 ***REMOVED***, ***REMOVED*** part: true ***REMOVED***)).to.be.false();             // part does not ignore bad value
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 1, d: 3 ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 1, d: 4 ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ***REMOVED*** a: 1, b: 2 ***REMOVED***, ***REMOVED*** only: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: [1], b: [2], c: [3] ***REMOVED***, ***REMOVED*** a: [1], c: [3] ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1, d: 2 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1, d: 2 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** deep: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1, d: 2 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** deep: true, only: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1, d: 2 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** deep: true, only: false ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1, d: 2 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** deep: true, part: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1, d: 2 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** deep: true, part: false ***REMOVED***)).to.be.false();

        // Getter check
        var Foo = function (bar) ***REMOVED***

            this.bar = bar;
        ***REMOVED***;

        Object.defineProperty(Foo.prototype, 'baz', ***REMOVED***
            enumerable: true,
            get: function () ***REMOVED***

                return this.bar;
            ***REMOVED***
        ***REMOVED***);

        expect(Hoek.contain(***REMOVED*** a: new Foo('b') ***REMOVED***, ***REMOVED*** a: new Foo('b') ***REMOVED***, ***REMOVED*** deep: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: new Foo('b') ***REMOVED***, ***REMOVED*** a: new Foo('b') ***REMOVED***, ***REMOVED*** deep: true, part: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: new Foo('b') ***REMOVED***, ***REMOVED*** a: ***REMOVED*** baz: 'b' ***REMOVED*** ***REMOVED***, ***REMOVED*** deep: true ***REMOVED***)).to.be.true();
        expect(Hoek.contain(***REMOVED*** a: new Foo('b') ***REMOVED***, ***REMOVED*** a: ***REMOVED*** baz: 'b' ***REMOVED*** ***REMOVED***, ***REMOVED*** deep: true, only: true ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: new Foo('b') ***REMOVED***, ***REMOVED*** a: ***REMOVED*** baz: 'b' ***REMOVED*** ***REMOVED***, ***REMOVED*** deep: true, part: false ***REMOVED***)).to.be.false();
        expect(Hoek.contain(***REMOVED*** a: new Foo('b') ***REMOVED***, ***REMOVED*** a: ***REMOVED*** baz: 'b' ***REMOVED*** ***REMOVED***, ***REMOVED*** deep: true, part: true ***REMOVED***)).to.be.true();

        done();
    ***REMOVED***);
***REMOVED***);

describe('flatten()', function () ***REMOVED***

    it('returns a flat array', function (done) ***REMOVED***

        var result = Hoek.flatten([1, 2, [3, 4, [5, 6], [7], 8], [9], [10, [11, 12]], 13]);
        expect(result.length).to.equal(13);
        expect(result).to.deep.equal([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);
        done();
    ***REMOVED***);
***REMOVED***);

describe('reach()', function () ***REMOVED***

    var obj = ***REMOVED***
        a: ***REMOVED***
            b: ***REMOVED***
                c: ***REMOVED***
                    d: 1,
                    e: 2
                ***REMOVED***,
                f: 'hello'
            ***REMOVED***,
            g: ***REMOVED***
                h: 3
            ***REMOVED***
        ***REMOVED***,
        i: function () ***REMOVED*** ***REMOVED***,
        j: null,
        k: [4, 8, 9, 1]
    ***REMOVED***;

    obj.i.x = 5;

    it('returns object itself', function (done) ***REMOVED***

        expect(Hoek.reach(obj, null)).to.equal(obj);
        expect(Hoek.reach(obj, false)).to.equal(obj);
        expect(Hoek.reach(obj)).to.equal(obj);
        done();
    ***REMOVED***);

    it('returns first value of array', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'k.0')).to.equal(4);
        done();
    ***REMOVED***);

    it('returns last value of array using negative index', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'k.-2')).to.equal(9);
        done();
    ***REMOVED***);

    it('returns a valid member', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'a.b.c.d')).to.equal(1);
        done();
    ***REMOVED***);

    it('returns a valid member with separator override', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'a/b/c/d', '/')).to.equal(1);
        done();
    ***REMOVED***);

    it('returns undefined on null object', function (done) ***REMOVED***

        expect(Hoek.reach(null, 'a.b.c.d')).to.equal(undefined);
        done();
    ***REMOVED***);

    it('returns undefined on missing object member', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'a.b.c.d.x')).to.equal(undefined);
        done();
    ***REMOVED***);

    it('returns undefined on missing function member', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'i.y', ***REMOVED*** functions: true ***REMOVED***)).to.equal(undefined);
        done();
    ***REMOVED***);

    it('throws on missing member in strict mode', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            Hoek.reach(obj, 'a.b.c.o.x', ***REMOVED*** strict: true ***REMOVED***);
        ***REMOVED***).to.throw('Missing segment o in reach path  a.b.c.o.x');

        done();
    ***REMOVED***);

    it('returns undefined on invalid member', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'a.b.c.d-.x')).to.equal(undefined);
        done();
    ***REMOVED***);

    it('returns function member', function (done) ***REMOVED***

        expect(typeof Hoek.reach(obj, 'i')).to.equal('function');
        done();
    ***REMOVED***);

    it('returns function property', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'i.x')).to.equal(5);
        done();
    ***REMOVED***);

    it('returns null', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'j')).to.equal(null);
        done();
    ***REMOVED***);

    it('throws on function property when functions not allowed', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            Hoek.reach(obj, 'i.x', ***REMOVED*** functions: false ***REMOVED***);
        ***REMOVED***).to.throw('Invalid segment x in reach path  i.x');

        done();
    ***REMOVED***);

    it('will return a default value if property is not found', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'a.b.q', ***REMOVED*** default: 'defaultValue' ***REMOVED***)).to.equal('defaultValue');
        done();
    ***REMOVED***);

    it('will return a default value if path is not found', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'q', ***REMOVED*** default: 'defaultValue' ***REMOVED***)).to.equal('defaultValue');
        done();
    ***REMOVED***);

    it('allows a falsey value to be used as the default value', function (done) ***REMOVED***

        expect(Hoek.reach(obj, 'q', ***REMOVED*** default: '' ***REMOVED***)).to.equal('');
        done();
    ***REMOVED***);
***REMOVED***);

describe('reachTemplate()', function () ***REMOVED***

    it('applies object to template', function (done) ***REMOVED***

        var obj = ***REMOVED***
            a: ***REMOVED***
                b: ***REMOVED***
                    c: ***REMOVED***
                        d: 1
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***,
            j: null,
            k: [4, 8, 9, 1]
        ***REMOVED***;

        var template = '***REMOVED***k.0***REMOVED***:***REMOVED***k.-2***REMOVED***:***REMOVED***a.b.c.d***REMOVED***:***REMOVED***x.y***REMOVED***:***REMOVED***j***REMOVED***';

        expect(Hoek.reachTemplate(obj, template)).to.equal('4:9:1::');
        done();
    ***REMOVED***);

    it('applies object to template (options)', function (done) ***REMOVED***

        var obj = ***REMOVED***
            a: ***REMOVED***
                b: ***REMOVED***
                    c: ***REMOVED***
                        d: 1
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***,
            j: null,
            k: [4, 8, 9, 1]
        ***REMOVED***;

        var template = '***REMOVED***k/0***REMOVED***:***REMOVED***k/-2***REMOVED***:***REMOVED***a/b/c/d***REMOVED***:***REMOVED***x/y***REMOVED***:***REMOVED***j***REMOVED***';

        expect(Hoek.reachTemplate(obj, template, '/')).to.equal('4:9:1::');
        done();
    ***REMOVED***);
***REMOVED***);

describe('callStack()', function () ***REMOVED***

    it('returns the full call stack', function (done) ***REMOVED***

        var stack = Hoek.callStack();
        expect(stack[0][0]).to.contain('index.js');
        expect(stack[0][2]).to.equal(26);
        done();
    ***REMOVED***);
***REMOVED***);

describe('displayStack ()', function () ***REMOVED***

    it('returns the full call stack for display', function (done) ***REMOVED***

        var stack = Hoek.displayStack();
        expect(stack[0]).to.contain(Path.normalize('/test/index.js') + ':');
        done();
    ***REMOVED***);

    it('includes constructor functions correctly', function (done) ***REMOVED***

        var Something = function (next) ***REMOVED***

            next();
        ***REMOVED***;

        var something = new Something(function () ***REMOVED***

            var stack = Hoek.displayStack();
            expect(stack[1]).to.contain('new Something');
            done();
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***);

describe('abort()', function () ***REMOVED***

    it('exits process when not in test mode', function (done) ***REMOVED***

        var env = process.env.NODE_ENV;
        var write = process.stdout.write;
        var exit = process.exit;

        process.env.NODE_ENV = 'nottatest';
        process.stdout.write = function () ***REMOVED*** ***REMOVED***;
        process.exit = function (state) ***REMOVED***

            process.exit = exit;
            process.env.NODE_ENV = env;
            process.stdout.write = write;

            expect(state).to.equal(1);
            done();
        ***REMOVED***;

        Hoek.abort('Boom');
    ***REMOVED***);

    it('throws when not in test mode and abortThrow is true', function (done) ***REMOVED***

        var env = process.env.NODE_ENV;
        process.env.NODE_ENV = 'nottatest';
        Hoek.abortThrow = true;

        var fn = function () ***REMOVED***

            Hoek.abort('my error message');
        ***REMOVED***;

        expect(fn).to.throw('my error message');
        Hoek.abortThrow = false;
        process.env.NODE_ENV = env;

        done();
    ***REMOVED***);

    it('respects hideStack argument', function (done) ***REMOVED***

        var env = process.env.NODE_ENV;
        var write = process.stdout.write;
        var exit = process.exit;
        var output = '';

        process.exit = function () ***REMOVED*** ***REMOVED***;
        process.env.NODE_ENV = '';
        process.stdout.write = function (message) ***REMOVED***

            output = message;
        ***REMOVED***;

        Hoek.abort('my error message', true);

        process.env.NODE_ENV = env;
        process.stdout.write = write;
        process.exit = exit;

        expect(output).to.equal('ABORT: my error message\n\t\n');

        done();
    ***REMOVED***);

    it('throws in test mode', function (done) ***REMOVED***

        var env = process.env.NODE_ENV;
        process.env.NODE_ENV = 'test';

        expect(function () ***REMOVED***

            Hoek.abort('my error message', true);
        ***REMOVED***).to.throw('my error message');

        process.env.NODE_ENV = env;
        done();
    ***REMOVED***);

    it('throws in test mode with default message', function (done) ***REMOVED***

        var env = process.env.NODE_ENV;
        process.env.NODE_ENV = 'test';

        expect(function () ***REMOVED***

            Hoek.abort('', true);
        ***REMOVED***).to.throw('Unknown error');

        process.env.NODE_ENV = env;
        done();
    ***REMOVED***);

    it('defaults to showing stack', function (done) ***REMOVED***

        var env = process.env.NODE_ENV;
        var write = process.stdout.write;
        var exit = process.exit;
        var output = '';

        process.exit = function () ***REMOVED*** ***REMOVED***;
        process.env.NODE_ENV = '';
        process.stdout.write = function (message) ***REMOVED***

            output = message;
        ***REMOVED***;

        Hoek.abort('my error message');

        process.env.NODE_ENV = env;
        process.stdout.write = write;
        process.exit = exit;

        expect(output).to.contain('index.js');

        done();
    ***REMOVED***);
***REMOVED***);

describe('assert()', function () ***REMOVED***

    it('throws an Error when using assert in a test', function (done) ***REMOVED***

        var fn = function () ***REMOVED***

            Hoek.assert(false, 'my error message');
        ***REMOVED***;

        expect(fn).to.throw('my error message');
        done();
    ***REMOVED***);

    it('throws an Error when using assert in a test with no message', function (done) ***REMOVED***

        var fn = function () ***REMOVED***

            Hoek.assert(false);
        ***REMOVED***;

        expect(fn).to.throw('Unknown error');
        done();
    ***REMOVED***);

    it('throws an Error when using assert in a test with multipart message', function (done) ***REMOVED***

        var fn = function () ***REMOVED***

            Hoek.assert(false, 'This', 'is', 'my message');
        ***REMOVED***;

        expect(fn).to.throw('This is my message');
        done();
    ***REMOVED***);

    it('throws an Error when using assert in a test with multipart message (empty)', function (done) ***REMOVED***

        var fn = function () ***REMOVED***

            Hoek.assert(false, 'This', 'is', '', 'my message');
        ***REMOVED***;

        expect(fn).to.throw('This is my message');
        done();
    ***REMOVED***);

    it('throws an Error when using assert in a test with object message', function (done) ***REMOVED***

        var fn = function () ***REMOVED***

            Hoek.assert(false, 'This', 'is', ***REMOVED*** spinal: 'tap' ***REMOVED***);
        ***REMOVED***;

        expect(fn).to.throw('This is ***REMOVED***"spinal":"tap"***REMOVED***');
        done();
    ***REMOVED***);

    it('throws an Error when using assert in a test with multipart string and error messages', function (done) ***REMOVED***

        var fn = function () ***REMOVED***

            Hoek.assert(false, 'This', 'is', new Error('spinal'), new Error('tap'));
        ***REMOVED***;

        expect(fn).to.throw('This is spinal tap');
        done();
    ***REMOVED***);

    it('throws an Error when using assert in a test with error object message', function (done) ***REMOVED***

        var fn = function () ***REMOVED***

            Hoek.assert(false, new Error('This is spinal tap'));
        ***REMOVED***;

        expect(fn).to.throw('This is spinal tap');
        done();
    ***REMOVED***);

    it('throws the same Error that is passed to it if there is only one error passed', function (done) ***REMOVED***

        var error = new Error('ruh roh');
        var error2 = new Error('ruh roh');

        var fn = function () ***REMOVED***

            Hoek.assert(false, error);
        ***REMOVED***;

        try ***REMOVED***
            fn();
        ***REMOVED*** catch (err) ***REMOVED***
            expect(error).to.equal(error);  // should be the same reference
            expect(error).to.not.equal(error2); // error with the same message should not match
        ***REMOVED***

        done();
    ***REMOVED***);
***REMOVED***);

describe('Timer', function () ***REMOVED***

    it('returns time elapsed', function (done) ***REMOVED***

        var timer = new Hoek.Timer();
        setTimeout(function () ***REMOVED***

            expect(timer.elapsed()).to.be.above(9);
            done();
        ***REMOVED***, 12);
    ***REMOVED***);
***REMOVED***);

describe('Bench', function () ***REMOVED***

    it('returns time elapsed', function (done) ***REMOVED***

        var timer = new Hoek.Bench();
        setTimeout(function () ***REMOVED***

            expect(timer.elapsed()).to.be.above(9);
            done();
        ***REMOVED***, 12);
    ***REMOVED***);
***REMOVED***);

describe('escapeRegex()', function () ***REMOVED***

    it('escapes all special regular expression characters', function (done) ***REMOVED***

        var a = Hoek.escapeRegex('4^f$s.4*5+-_?%=#!:@|~\\/`"(>)[<]d***REMOVED******REMOVED***s,');
        expect(a).to.equal('4\\^f\\$s\\.4\\*5\\+\\-_\\?%\\=#\\!\\:@\\|~\\\\\\/`"\\(>\\)\\[<\\]d\\***REMOVED***\\***REMOVED***s\\,');
        done();
    ***REMOVED***);
***REMOVED***);

describe('Base64Url', function () ***REMOVED***

    var base64str = 'AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0-P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn-AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq-wsbKztLW2t7i5uru8vb6_wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t_g4eLj5OXm5-jp6uvs7e7v8PHy8_T19vf4-fr7_P3-_w';
    var str = unescape('%00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29*+%2C-./0123456789%3A%3B%3C%3D%3E%3F@ABCDEFGHIJKLMNOPQRSTUVWXYZ%5B%5C%5D%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D%7E%7F%80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF');

    describe('base64urlEncode()', function () ***REMOVED***

        it('should base64 URL-safe a string', function (done) ***REMOVED***

            expect(Hoek.base64urlEncode(str)).to.equal(base64str);
            done();
        ***REMOVED***);

        it('encodes a buffer', function (done) ***REMOVED***

            expect(Hoek.base64urlEncode(new Buffer(str, 'binary'))).to.equal(base64str);
            done();
        ***REMOVED***);

        it('should base64 URL-safe a hex string', function (done) ***REMOVED***

            var buffer = new Buffer(str, 'binary');
            expect(Hoek.base64urlEncode(buffer.toString('hex'), 'hex')).to.equal(base64str);
            done();
        ***REMOVED***);

        it('works on larger input strings', function (done) ***REMOVED***

            var input = Fs.readFileSync(Path.join(__dirname, 'index.js')).toString();
            var encoded = Hoek.base64urlEncode(input);

            expect(encoded).to.not.contain('+');
            expect(encoded).to.not.contain('/');

            var decoded = Hoek.base64urlDecode(encoded);

            expect(decoded).to.equal(input);
            done();
        ***REMOVED***);
    ***REMOVED***);

    describe('base64urlDecode()', function () ***REMOVED***

        it('should un-base64 URL-safe a string', function (done) ***REMOVED***

            expect(Hoek.base64urlDecode(base64str)).to.equal(str);
            done();
        ***REMOVED***);

        it('should un-base64 URL-safe a string into hex', function (done) ***REMOVED***

            expect(Hoek.base64urlDecode(base64str, 'hex')).to.equal(new Buffer(str, 'binary').toString('hex'));
            done();
        ***REMOVED***);

        it('should un-base64 URL-safe a string and return a buffer', function (done) ***REMOVED***

            var buf = Hoek.base64urlDecode(base64str, 'buffer');
            expect(buf instanceof Buffer).to.equal(true);
            expect(buf.toString('binary')).to.equal(str);
            done();
        ***REMOVED***);

        it('returns error on undefined input', function (done) ***REMOVED***

            expect(Hoek.base64urlDecode().message).to.exist();
            done();
        ***REMOVED***);

        it('returns error on invalid input', function (done) ***REMOVED***

            expect(Hoek.base64urlDecode('*').message).to.exist();
            done();
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***);

describe('escapeHeaderAttribute()', function () ***REMOVED***

    it('should not alter ascii values', function (done) ***REMOVED***

        var a = Hoek.escapeHeaderAttribute('My Value');
        expect(a).to.equal('My Value');
        done();
    ***REMOVED***);

    it('escapes all special HTTP header attribute characters', function (done) ***REMOVED***

        var a = Hoek.escapeHeaderAttribute('I said go!!!#"' + String.fromCharCode(92));
        expect(a).to.equal('I said go!!!#\\"\\\\');
        done();
    ***REMOVED***);

    it('throws on large unicode characters', function (done) ***REMOVED***

        var fn = function () ***REMOVED***

            Hoek.escapeHeaderAttribute('this is a test' + String.fromCharCode(500) + String.fromCharCode(300));
        ***REMOVED***;

        expect(fn).to.throw(Error);
        done();
    ***REMOVED***);

    it('throws on CRLF to prevent response splitting', function (done) ***REMOVED***

        var fn = function () ***REMOVED***

            Hoek.escapeHeaderAttribute('this is a test\r\n');
        ***REMOVED***;

        expect(fn).to.throw(Error);
        done();
    ***REMOVED***);
***REMOVED***);

describe('escapeHtml()', function () ***REMOVED***

    it('escapes all special HTML characters', function (done) ***REMOVED***

        var a = Hoek.escapeHtml('&<>"\'`');
        expect(a).to.equal('&amp;&lt;&gt;&quot;&#x27;&#x60;');
        done();
    ***REMOVED***);

    it('returns empty string on falsy input', function (done) ***REMOVED***

        var a = Hoek.escapeHtml('');
        expect(a).to.equal('');
        done();
    ***REMOVED***);

    it('returns unchanged string on no reserved input', function (done) ***REMOVED***

        var a = Hoek.escapeHtml('abc');
        expect(a).to.equal('abc');
        done();
    ***REMOVED***);
***REMOVED***);

describe('nextTick()', function () ***REMOVED***

    it('calls the provided callback on nextTick', function (done) ***REMOVED***

        var a = 0;

        var inc = function (step, next) ***REMOVED***

            a += step;
            next();
        ***REMOVED***;

        var ticked = Hoek.nextTick(inc);

        ticked(5, function () ***REMOVED***

            expect(a).to.equal(6);
            done();
        ***REMOVED***);

        expect(a).to.equal(0);
        inc(1, function () ***REMOVED***

            expect(a).to.equal(1);
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***);

describe('once()', function () ***REMOVED***

    it('allows function to only execute once', function (done) ***REMOVED***

        var gen = 0;
        var add = function (x) ***REMOVED***

            gen += x;
        ***REMOVED***;

        add(5);
        expect(gen).to.equal(5);
        add = Hoek.once(add);
        add(5);
        expect(gen).to.equal(10);
        add(5);
        expect(gen).to.equal(10);
        done();
    ***REMOVED***);

    it('double once wraps one time', function (done) ***REMOVED***

        var method = function () ***REMOVED*** ***REMOVED***;
        method = Hoek.once(method);
        method.x = 1;
        method = Hoek.once(method);
        expect(method.x).to.equal(1);
        done();
    ***REMOVED***);
***REMOVED***);

describe('isAbsoltePath()', function () ***REMOVED***

    it('identifies if path is absolute on Unix without node support', ***REMOVED*** parallel: false ***REMOVED***, function (done) ***REMOVED***

        var orig = Path.isAbsolute;
        Path.isAbsolute = undefined;

        expect(Hoek.isAbsolutePath('')).to.equal(false);
        expect(Hoek.isAbsolutePath('a')).to.equal(false);
        expect(Hoek.isAbsolutePath('./a')).to.equal(false);
        expect(Hoek.isAbsolutePath('/a')).to.equal(true);
        expect(Hoek.isAbsolutePath('/')).to.equal(true);

        Path.isAbsolute = orig;

        done();
    ***REMOVED***);

    it('identifies if path is absolute with fake node support', ***REMOVED*** parallel: false ***REMOVED***, function (done) ***REMOVED***

        var orig = Path.isAbsolute;
        Path.isAbsolute = function (path) ***REMOVED***

            return path[0] === '/';
        ***REMOVED***;

        expect(Hoek.isAbsolutePath('', 'linux')).to.equal(false);
        expect(Hoek.isAbsolutePath('a', 'linux')).to.equal(false);
        expect(Hoek.isAbsolutePath('./a', 'linux')).to.equal(false);
        expect(Hoek.isAbsolutePath('/a', 'linux')).to.equal(true);
        expect(Hoek.isAbsolutePath('/', 'linux')).to.equal(true);

        Path.isAbsolute = orig;

        done();
    ***REMOVED***);

    it('identifies if path is absolute on Windows without node support', ***REMOVED*** parallel: false ***REMOVED***, function (done) ***REMOVED***

        var orig = Path.isAbsolute;
        Path.isAbsolute = undefined;

        expect(Hoek.isAbsolutePath('//server/file', 'win32')).to.equal(true);
        expect(Hoek.isAbsolutePath('//server/file', 'win32')).to.equal(true);
        expect(Hoek.isAbsolutePath('\\\\server\\file', 'win32')).to.equal(true);
        expect(Hoek.isAbsolutePath('C:/Users/', 'win32')).to.equal(true);
        expect(Hoek.isAbsolutePath('C:\\Users\\', 'win32')).to.equal(true);
        expect(Hoek.isAbsolutePath('C:cwd/another', 'win32')).to.equal(false);
        expect(Hoek.isAbsolutePath('C:cwd\\another', 'win32')).to.equal(false);
        expect(Hoek.isAbsolutePath('directory/directory', 'win32')).to.equal(false);
        expect(Hoek.isAbsolutePath('directory\\directory', 'win32')).to.equal(false);

        Path.isAbsolute = orig;

        done();
    ***REMOVED***);
***REMOVED***);

describe('isInteger()', function () ***REMOVED***

    it('validates integers', function (done) ***REMOVED***

        expect(Hoek.isInteger(0)).to.equal(true);
        expect(Hoek.isInteger(1)).to.equal(true);
        expect(Hoek.isInteger(1394035612500)).to.equal(true);
        expect(Hoek.isInteger('0')).to.equal(false);
        expect(Hoek.isInteger(1.0)).to.equal(true);
        expect(Hoek.isInteger(1.1)).to.equal(false);
        done();
    ***REMOVED***);
***REMOVED***);

describe('ignore()', function () ***REMOVED***

    it('exists', function (done) ***REMOVED***

        expect(Hoek.ignore).to.exist();
        expect(typeof Hoek.ignore).to.equal('function');
        done();
    ***REMOVED***);
***REMOVED***);

describe('inherits()', function () ***REMOVED***

    it('exists', function (done) ***REMOVED***

        expect(Hoek.inherits).to.exist();
        expect(typeof Hoek.inherits).to.equal('function');
        done();
    ***REMOVED***);
***REMOVED***);

describe('format()', function () ***REMOVED***

    it('exists', function (done) ***REMOVED***

        expect(Hoek.format).to.exist();
        expect(typeof Hoek.format).to.equal('function');
        done();
    ***REMOVED***);

    it('is a reference to Util.format', function (done) ***REMOVED***

        expect(Hoek.format('hello %s', 'world')).to.equal('hello world');
        done();
    ***REMOVED***);
***REMOVED***);

describe('transform()', function () ***REMOVED***

    var source = ***REMOVED***
        address: ***REMOVED***
            one: '123 main street',
            two: 'PO Box 1234'
        ***REMOVED***,
        zip: ***REMOVED***
            code: 3321232,
            province: null
        ***REMOVED***,
        title: 'Warehouse',
        state: 'CA'
    ***REMOVED***;

    var sourcesArray = [***REMOVED***
        address: ***REMOVED***
            one: '123 main street',
            two: 'PO Box 1234'
        ***REMOVED***,
        zip: ***REMOVED***
            code: 3321232,
            province: null
        ***REMOVED***,
        title: 'Warehouse',
        state: 'CA'
    ***REMOVED***, ***REMOVED***
        address: ***REMOVED***
            one: '456 market street',
            two: 'PO Box 5678'
        ***REMOVED***,
        zip: ***REMOVED***
            code: 9876,
            province: null
        ***REMOVED***,
        title: 'Garage',
        state: 'NY'
    ***REMOVED***];

    it('transforms an object based on the input object', function (done) ***REMOVED***

        var result = Hoek.transform(source, ***REMOVED***
            'person.address.lineOne': 'address.one',
            'person.address.lineTwo': 'address.two',
            'title': 'title',
            'person.address.region': 'state',
            'person.address.zip': 'zip.code',
            'person.address.location': 'zip.province'
        ***REMOVED***);

        expect(result).to.deep.equal(***REMOVED***
            person: ***REMOVED***
                address: ***REMOVED***
                    lineOne: '123 main street',
                    lineTwo: 'PO Box 1234',
                    region: 'CA',
                    zip: 3321232,
                    location: null
                ***REMOVED***
            ***REMOVED***,
            title: 'Warehouse'
        ***REMOVED***);

        done();
    ***REMOVED***);

    it('transforms an array of objects based on the input object', function (done) ***REMOVED***

        var result = Hoek.transform(sourcesArray, ***REMOVED***
            'person.address.lineOne': 'address.one',
            'person.address.lineTwo': 'address.two',
            'title': 'title',
            'person.address.region': 'state',
            'person.address.zip': 'zip.code',
            'person.address.location': 'zip.province'
        ***REMOVED***);

        expect(result).to.deep.equal([
            ***REMOVED***
                person: ***REMOVED***
                    address: ***REMOVED***
                        lineOne: '123 main street',
                        lineTwo: 'PO Box 1234',
                        region: 'CA',
                        zip: 3321232,
                        location: null
                    ***REMOVED***
                ***REMOVED***,
                title: 'Warehouse'
            ***REMOVED***,
            ***REMOVED***
                person: ***REMOVED***
                    address: ***REMOVED***
                        lineOne: '456 market street',
                        lineTwo: 'PO Box 5678',
                        region: 'NY',
                        zip: 9876,
                        location: null
                    ***REMOVED***
                ***REMOVED***,
                title: 'Garage'
            ***REMOVED***
        ]);

        done();
    ***REMOVED***);

    it('uses the reach options passed into it', function (done) ***REMOVED***

        var schema = ***REMOVED***
            'person.address.lineOne': 'address-one',
            'person.address.lineTwo': 'address-two',
            'title': 'title',
            'person.address.region': 'state',
            'person.prefix': 'person-title',
            'person.zip': 'zip-code'
        ***REMOVED***;
        var options = ***REMOVED***
            separator: '-',
            default: 'unknown'
        ***REMOVED***;
        var result = Hoek.transform(source, schema, options);

        expect(result).to.deep.equal(***REMOVED***
            person: ***REMOVED***
                address: ***REMOVED***
                    lineOne: '123 main street',
                    lineTwo: 'PO Box 1234',
                    region: 'CA'
                ***REMOVED***,
                prefix: 'unknown',
                zip: 3321232
            ***REMOVED***,
            title: 'Warehouse'
        ***REMOVED***);

        done();
    ***REMOVED***);

    it('works to create shallow objects', function (done) ***REMOVED***

        var result = Hoek.transform(source, ***REMOVED***
            lineOne: 'address.one',
            lineTwo: 'address.two',
            title: 'title',
            region: 'state',
            province: 'zip.province'
        ***REMOVED***);

        expect(result).to.deep.equal(***REMOVED***
            lineOne: '123 main street',
            lineTwo: 'PO Box 1234',
            title: 'Warehouse',
            region: 'CA',
            province: null
        ***REMOVED***);

        done();
    ***REMOVED***);

    it('only allows strings in the map', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            var result = Hoek.transform(source, ***REMOVED***
                lineOne: ***REMOVED******REMOVED***
            ***REMOVED***);
        ***REMOVED***).to.throw('All mappings must be "." delineated strings');

        done();
    ***REMOVED***);

    it('throws an error on invalid arguments', function (done) ***REMOVED***

        expect(function () ***REMOVED***

            var result = Hoek.transform(NaN, ***REMOVED******REMOVED***);
        ***REMOVED***).to.throw('Invalid source object: must be null, undefined, an object, or an array');

        done();
    ***REMOVED***);

    it('is safe to pass null', function (done) ***REMOVED***

        var result = Hoek.transform(null, ***REMOVED******REMOVED***);
        expect(result).to.deep.equal(***REMOVED******REMOVED***);

        done();
    ***REMOVED***);

    it('is safe to pass undefined', function (done) ***REMOVED***

        var result = Hoek.transform(undefined, ***REMOVED******REMOVED***);
        expect(result).to.deep.equal(***REMOVED******REMOVED***);

        done();
    ***REMOVED***);
***REMOVED***);

describe('uniqueFilename()', function () ***REMOVED***

    it('generates a random file path', function (done) ***REMOVED***

        var result = Hoek.uniqueFilename('./test/modules');

        expect(result).to.exist();
        expect(result).to.be.a.string();
        expect(result).to.contain('test/modules');
        done();
    ***REMOVED***);

    it('is random enough to use in fast loops', function (done) ***REMOVED***

        var results = [];

        for (var i = 0; i < 10; ++i) ***REMOVED***
            results[i] = Hoek.uniqueFilename('./test/modules');
        ***REMOVED***

        var filter = results.filter(function (item, index, array) ***REMOVED***

            return array.indexOf(item) === index;
        ***REMOVED***);

        expect(filter.length).to.equal(10);
        expect(results.length).to.equal(10);
        done();

    ***REMOVED***);

    it('combines the random elements with a supplied character', function (done) ***REMOVED***

        var result = Hoek.uniqueFilename('./test', 'txt');

        expect(result).to.contain('test/');
        expect(result).to.contain('.txt');

        done();
    ***REMOVED***);

    it('accepts extensions with a "." in it', function (done) ***REMOVED***

        var result = Hoek.uniqueFilename('./test', '.mp3');

        expect(result).to.contain('test/');
        expect(result).to.contain('.mp3');

        done();
    ***REMOVED***);
***REMOVED***);

describe('stringify()', function (done) ***REMOVED***

    it('converts object to string', function (done) ***REMOVED***

        var obj = ***REMOVED*** a: 1 ***REMOVED***;
        expect(Hoek.stringify(obj)).to.equal('***REMOVED***"a":1***REMOVED***');
        done();
    ***REMOVED***);

    it('returns error in result string', function (done) ***REMOVED***

        var obj = ***REMOVED*** a: 1 ***REMOVED***;
        obj.b = obj;
        expect(Hoek.stringify(obj)).to.equal('[Cannot display object: Converting circular structure to JSON]');
        done();
    ***REMOVED***);
***REMOVED***);

describe('shallow()', function (done) ***REMOVED***

    it('shallow copies an object', function (done) ***REMOVED***

        var obj = ***REMOVED***
            a: 5,
            b: ***REMOVED***
                c: 6
            ***REMOVED***
        ***REMOVED***;

        var shallow = Hoek.shallow(obj);
        expect(shallow).to.not.equal(obj);
        expect(shallow).to.deep.equal(obj);
        expect(shallow.b).to.equal(obj.b);
        done();
    ***REMOVED***);
***REMOVED***);
