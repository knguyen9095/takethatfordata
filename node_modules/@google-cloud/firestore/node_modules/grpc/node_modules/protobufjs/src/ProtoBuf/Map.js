/**
 * @alias ProtoBuf.Map
 * @expose
 */
ProtoBuf.Map = (function(ProtoBuf, Reflect) ***REMOVED***
    "use strict";

    /**
     * Constructs a new Map. A Map is a container that is used to implement map
     * fields on message objects. It closely follows the ES6 Map API; however,
     * it is distinct because we do not want to depend on external polyfills or
     * on ES6 itself.
     *
     * @exports ProtoBuf.Map
     * @param ***REMOVED***!ProtoBuf.Reflect.Field***REMOVED*** field Map field
     * @param ***REMOVED***Object.<string,*>=***REMOVED*** contents Initial contents
     * @constructor
     */
    var Map = function(field, contents) ***REMOVED***
        if (!field.map)
            throw Error("field is not a map");

        /**
         * The field corresponding to this map.
         * @type ***REMOVED***!ProtoBuf.Reflect.Field***REMOVED***
         */
        this.field = field;

        /**
         * Element instance corresponding to key type.
         * @type ***REMOVED***!ProtoBuf.Reflect.Element***REMOVED***
         */
        this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);

        /**
         * Element instance corresponding to value type.
         * @type ***REMOVED***!ProtoBuf.Reflect.Element***REMOVED***
         */
        this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);

        /**
         * Internal map: stores mapping of (string form of key) -> (key, value)
         * pair.
         *
         * We provide map semantics for arbitrary key types, but we build on top
         * of an Object, which has only string keys. In order to avoid the need
         * to convert a string key back to its native type in many situations,
         * we store the native key value alongside the value. Thus, we only need
         * a one-way mapping from a key type to its string form that guarantees
         * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1
         * === K2).
         *
         * @type ***REMOVED***!Object<string, ***REMOVED***key: *, value: ****REMOVED***>***REMOVED***
         */
        this.map = ***REMOVED******REMOVED***;

        /**
         * Returns the number of elements in the map.
         */
        Object.defineProperty(this, "size", ***REMOVED***
            get: function() ***REMOVED*** return Object.keys(this.map).length; ***REMOVED***
        ***REMOVED***);

        // Fill initial contents from a raw object.
        if (contents) ***REMOVED***
            var keys = Object.keys(contents);
            for (var i = 0; i < keys.length; i++) ***REMOVED***
                var key = this.keyElem.valueFromString(keys[i]);
                var val = this.valueElem.verifyValue(contents[keys[i]]);
                this.map[this.keyElem.valueToString(key)] =
                    ***REMOVED*** key: key, value: val ***REMOVED***;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;

    var MapPrototype = Map.prototype;

    /**
     * Helper: return an iterator over an array.
     * @param ***REMOVED***!Array<*>***REMOVED*** arr the array
     * @returns ***REMOVED***!Object***REMOVED*** an iterator
     * @inner
     */
    function arrayIterator(arr) ***REMOVED***
        var idx = 0;
        return ***REMOVED***
            next: function() ***REMOVED***
                if (idx < arr.length)
                    return ***REMOVED*** done: false, value: arr[idx++] ***REMOVED***;
                return ***REMOVED*** done: true ***REMOVED***;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * Clears the map.
     */
    MapPrototype.clear = function() ***REMOVED***
        this.map = ***REMOVED******REMOVED***;
    ***REMOVED***;

    /**
     * Deletes a particular key from the map.
     * @returns ***REMOVED***boolean***REMOVED*** Whether any entry with this key was deleted.
     */
    MapPrototype["delete"] = function(key) ***REMOVED***
        var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
        var hadKey = keyValue in this.map;
        delete this.map[keyValue];
        return hadKey;
    ***REMOVED***;

    /**
     * Returns an iterator over [key, value] pairs in the map.
     * @returns ***REMOVED***Object***REMOVED*** The iterator
     */
    MapPrototype.entries = function() ***REMOVED***
        var entries = [];
        var strKeys = Object.keys(this.map);
        for (var i = 0, entry; i < strKeys.length; i++)
            entries.push([(entry=this.map[strKeys[i]]).key, entry.value]);
        return arrayIterator(entries);
    ***REMOVED***;

    /**
     * Returns an iterator over keys in the map.
     * @returns ***REMOVED***Object***REMOVED*** The iterator
     */
    MapPrototype.keys = function() ***REMOVED***
        var keys = [];
        var strKeys = Object.keys(this.map);
        for (var i = 0; i < strKeys.length; i++)
            keys.push(this.map[strKeys[i]].key);
        return arrayIterator(keys);
    ***REMOVED***;

    /**
     * Returns an iterator over values in the map.
     * @returns ***REMOVED***!Object***REMOVED*** The iterator
     */
    MapPrototype.values = function() ***REMOVED***
        var values = [];
        var strKeys = Object.keys(this.map);
        for (var i = 0; i < strKeys.length; i++)
            values.push(this.map[strKeys[i]].value);
        return arrayIterator(values);
    ***REMOVED***;

    /**
     * Iterates over entries in the map, calling a function on each.
     * @param ***REMOVED***function(this:*, *, *, *)***REMOVED*** cb The callback to invoke with value, key, and map arguments.
     * @param ***REMOVED***Object=***REMOVED*** thisArg The `this` value for the callback
     */
    MapPrototype.forEach = function(cb, thisArg) ***REMOVED***
        var strKeys = Object.keys(this.map);
        for (var i = 0, entry; i < strKeys.length; i++)
            cb.call(thisArg, (entry=this.map[strKeys[i]]).value, entry.key, this);
    ***REMOVED***;

    /**
     * Sets a key in the map to the given value.
     * @param ***REMOVED*******REMOVED*** key The key
     * @param ***REMOVED*******REMOVED*** value The value
     * @returns ***REMOVED***!ProtoBuf.Map***REMOVED*** The map instance
     */
    MapPrototype.set = function(key, value) ***REMOVED***
        var keyValue = this.keyElem.verifyValue(key);
        var valValue = this.valueElem.verifyValue(value);
        this.map[this.keyElem.valueToString(keyValue)] =
            ***REMOVED*** key: keyValue, value: valValue ***REMOVED***;
        return this;
    ***REMOVED***;

    /**
     * Gets the value corresponding to a key in the map.
     * @param ***REMOVED*******REMOVED*** key The key
     * @returns ***REMOVED****|undefined***REMOVED*** The value, or `undefined` if key not present
     */
    MapPrototype.get = function(key) ***REMOVED***
        var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
        if (!(keyValue in this.map))
            return undefined;
        return this.map[keyValue].value;
    ***REMOVED***;

    /**
     * Determines whether the given key is present in the map.
     * @param ***REMOVED*******REMOVED*** key The key
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the key is present
     */
    MapPrototype.has = function(key) ***REMOVED***
        var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
        return (keyValue in this.map);
    ***REMOVED***;

    return Map;
***REMOVED***)(ProtoBuf, ProtoBuf.Reflect);
