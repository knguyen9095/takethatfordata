/*?
 // --- Scope ------------------
 // T : Reflect.Message instance
 */
var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),
    oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);

/**
 * Constructs a new runtime Message.
 * @name ProtoBuf.Builder.Message
 * @class Barebone of all runtime messages.
 * @param ***REMOVED***!Object.<string,*>|string***REMOVED*** values Preset values
 * @param ***REMOVED***...string***REMOVED*** var_args
 * @constructor
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be created
 */
var Message = function(values, var_args) ***REMOVED***
    ProtoBuf.Builder.Message.call(this);

    // Create virtual oneof properties
    for (var i=0, k=oneofs.length; i<k; ++i)
        this[oneofs[i].name] = null;
    // Create fields and set default values
    for (i=0, k=fields.length; i<k; ++i) ***REMOVED***
        var field = fields[i];
        this[field.name] =
            field.repeated ? [] :
            (field.map ? new ProtoBuf.Map(field) : null);
        if ((field.required || T.syntax === 'proto3') &&
            field.defaultValue !== null)
            this[field.name] = field.defaultValue;
    ***REMOVED***

    if (arguments.length > 0) ***REMOVED***
        var value;
        // Set field values from a values object
        if (arguments.length === 1 && values !== null && typeof values === 'object' &&
            /* not _another_ Message */ (typeof values.encode !== 'function' || values instanceof Message) &&
            /* not a repeated field */ !Array.isArray(values) &&
            /* not a Map */ !(values instanceof ProtoBuf.Map) &&
            /* not a ByteBuffer */ !ByteBuffer.isByteBuffer(values) &&
            /* not an ArrayBuffer */ !(values instanceof ArrayBuffer) &&
            /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) ***REMOVED***
            this.$set(values);
        ***REMOVED*** else // Set field values from arguments, in declaration order
            for (i=0, k=arguments.length; i<k; ++i)
                if (typeof (value = arguments[i]) !== 'undefined')
                    this.$set(fields[i].name, value); // May throw
    ***REMOVED***
***REMOVED***;

/**
 * @alias ProtoBuf.Builder.Message.prototype
 * @inner
 */
var MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);

/**
 * Adds a value to a repeated field.
 * @name ProtoBuf.Builder.Message#add
 * @function
 * @param ***REMOVED***string***REMOVED*** key Field name
 * @param ***REMOVED*******REMOVED*** value Value to add
 * @param ***REMOVED***boolean=***REMOVED*** noAssert Whether to assert the value or not (asserts by default)
 * @returns ***REMOVED***!ProtoBuf.Builder.Message***REMOVED*** this
 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be added
 * @expose
 */
MessagePrototype.add = function(key, value, noAssert) ***REMOVED***
    var field = T._fieldsByName[key];
    if (!noAssert) ***REMOVED***
        if (!field)
            throw Error(this+"#"+key+" is undefined");
        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
            throw Error(this+"#"+key+" is not a field: "+field.toString(true)); // May throw if it's an enum or embedded message
        if (!field.repeated)
            throw Error(this+"#"+key+" is not a repeated field");
        value = field.verifyValue(value, true);
    ***REMOVED***
    if (this[key] === null)
        this[key] = [];
    this[key].push(value);
    return this;
***REMOVED***;

/**
 * Adds a value to a repeated field. This is an alias for ***REMOVED***@link ProtoBuf.Builder.Message#add***REMOVED***.
 * @name ProtoBuf.Builder.Message#$add
 * @function
 * @param ***REMOVED***string***REMOVED*** key Field name
 * @param ***REMOVED*******REMOVED*** value Value to add
 * @param ***REMOVED***boolean=***REMOVED*** noAssert Whether to assert the value or not (asserts by default)
 * @returns ***REMOVED***!ProtoBuf.Builder.Message***REMOVED*** this
 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be added
 * @expose
 */
MessagePrototype.$add = MessagePrototype.add;

/**
 * Sets a field's value.
 * @name ProtoBuf.Builder.Message#set
 * @function
 * @param ***REMOVED***string|!Object.<string,*>***REMOVED*** keyOrObj String key or plain object holding multiple values
 * @param ***REMOVED***(*|boolean)=***REMOVED*** value Value to set if key is a string, otherwise omitted
 * @param ***REMOVED***boolean=***REMOVED*** noAssert Whether to not assert for an actual field / proper value type, defaults to `false`
 * @returns ***REMOVED***!ProtoBuf.Builder.Message***REMOVED*** this
 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be set
 * @expose
 */
MessagePrototype.set = function(keyOrObj, value, noAssert) ***REMOVED***
    if (keyOrObj && typeof keyOrObj === 'object') ***REMOVED***
        noAssert = value;
        for (var ikey in keyOrObj) ***REMOVED***
            // Check if virtual oneof field - don't set these
            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined' && T._oneofsByName[ikey] === undefined)
                this.$set(ikey, value, noAssert);
        ***REMOVED***
        return this;
    ***REMOVED***
    var field = T._fieldsByName[keyOrObj];
    if (!noAssert) ***REMOVED***
        if (!field)
            throw Error(this+"#"+keyOrObj+" is not a field: undefined");
        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
            throw Error(this+"#"+keyOrObj+" is not a field: "+field.toString(true));
        this[field.name] = (value = field.verifyValue(value)); // May throw
    ***REMOVED*** else
        this[keyOrObj] = value;
    if (field && field.oneof) ***REMOVED*** // Field is part of an OneOf (not a virtual OneOf field)
        var currentField = this[field.oneof.name]; // Virtual field references currently set field
        if (value !== null) ***REMOVED***
            if (currentField !== null && currentField !== field.name)
                this[currentField] = null; // Clear currently set field
            this[field.oneof.name] = field.name; // Point virtual field at this field
        ***REMOVED*** else if (/* value === null && */currentField === keyOrObj)
            this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)
    ***REMOVED***
    return this;
***REMOVED***;

/**
 * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set***REMOVED***.
 * @name ProtoBuf.Builder.Message#$set
 * @function
 * @param ***REMOVED***string|!Object.<string,*>***REMOVED*** keyOrObj String key or plain object holding multiple values
 * @param ***REMOVED***(*|boolean)=***REMOVED*** value Value to set if key is a string, otherwise omitted
 * @param ***REMOVED***boolean=***REMOVED*** noAssert Whether to not assert the value, defaults to `false`
 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be set
 * @expose
 */
MessagePrototype.$set = MessagePrototype.set;

/**
 * Gets a field's value.
 * @name ProtoBuf.Builder.Message#get
 * @function
 * @param ***REMOVED***string***REMOVED*** key Key
 * @param ***REMOVED***boolean=***REMOVED*** noAssert Whether to not assert for an actual field, defaults to `false`
 * @return ***REMOVED*******REMOVED*** Value
 * @throws ***REMOVED***Error***REMOVED*** If there is no such field
 * @expose
 */
MessagePrototype.get = function(key, noAssert) ***REMOVED***
    if (noAssert)
        return this[key];
    var field = T._fieldsByName[key];
    if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))
        throw Error(this+"#"+key+" is not a field: undefined");
    if (!(field instanceof ProtoBuf.Reflect.Message.Field))
        throw Error(this+"#"+key+" is not a field: "+field.toString(true));
    return this[field.name];
***REMOVED***;

/**
 * Gets a field's value. This is an alias for ***REMOVED***@link ProtoBuf.Builder.Message#$get***REMOVED***.
 * @name ProtoBuf.Builder.Message#$get
 * @function
 * @param ***REMOVED***string***REMOVED*** key Key
 * @return ***REMOVED*******REMOVED*** Value
 * @throws ***REMOVED***Error***REMOVED*** If there is no such field
 * @expose
 */
MessagePrototype.$get = MessagePrototype.get;

// Getters and setters

for (var i=0; i<fields.length; i++) ***REMOVED***
    var field = fields[i];
    // no setters for extension fields as these are named by their fqn
    if (field instanceof ProtoBuf.Reflect.Message.ExtensionField)
        continue;

    if (T.builder.options['populateAccessors'])
        (function(field) ***REMOVED***
            // set/get[SomeValue]
            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) ***REMOVED***
                return match.toUpperCase().replace('_','');
            ***REMOVED***);
            Name = Name.substring(0,1).toUpperCase() + Name.substring(1);

            // set/get_[some_value] FIXME: Do we really need these?
            var name = field.originalName.replace(/([A-Z])/g, function(match) ***REMOVED***
                return "_"+match;
            ***REMOVED***);

            /**
             * The current field's unbound setter function.
             * @function
             * @param ***REMOVED*******REMOVED*** value
             * @param ***REMOVED***boolean=***REMOVED*** noAssert
             * @returns ***REMOVED***!ProtoBuf.Builder.Message***REMOVED***
             * @inner
             */
            var setter = function(value, noAssert) ***REMOVED***
                this[field.name] = noAssert ? value : field.verifyValue(value);
                return this;
            ***REMOVED***;

            /**
             * The current field's unbound getter function.
             * @function
             * @returns ***REMOVED*******REMOVED***
             * @inner
             */
            var getter = function() ***REMOVED***
                return this[field.name];
            ***REMOVED***;

            if (T.getChild("set"+Name) === null)
                /**
                 * Sets a value. This method is present for each field, but only if there is no name conflict with
                 *  another field.
                 * @name ProtoBuf.Builder.Message#set[SomeField]
                 * @function
                 * @param ***REMOVED*******REMOVED*** value Value to set
                 * @param ***REMOVED***boolean=***REMOVED*** noAssert Whether to not assert the value, defaults to `false`
                 * @returns ***REMOVED***!ProtoBuf.Builder.Message***REMOVED*** this
                 * @abstract
                 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be set
                 */
                MessagePrototype["set"+Name] = setter;

            if (T.getChild("set_"+name) === null)
                /**
                 * Sets a value. This method is present for each field, but only if there is no name conflict with
                 *  another field.
                 * @name ProtoBuf.Builder.Message#set_[some_field]
                 * @function
                 * @param ***REMOVED*******REMOVED*** value Value to set
                 * @param ***REMOVED***boolean=***REMOVED*** noAssert Whether to not assert the value, defaults to `false`
                 * @returns ***REMOVED***!ProtoBuf.Builder.Message***REMOVED*** this
                 * @abstract
                 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be set
                 */
                MessagePrototype["set_"+name] = setter;

            if (T.getChild("get"+Name) === null)
                /**
                 * Gets a value. This method is present for each field, but only if there is no name conflict with
                 *  another field.
                 * @name ProtoBuf.Builder.Message#get[SomeField]
                 * @function
                 * @abstract
                 * @return ***REMOVED*******REMOVED*** The value
                 */
                MessagePrototype["get"+Name] = getter;

            if (T.getChild("get_"+name) === null)
                /**
                 * Gets a value. This method is present for each field, but only if there is no name conflict with
                 *  another field.
                 * @name ProtoBuf.Builder.Message#get_[some_field]
                 * @function
                 * @return ***REMOVED*******REMOVED*** The value
                 * @abstract
                 */
                MessagePrototype["get_"+name] = getter;

        ***REMOVED***)(field);
***REMOVED***

// En-/decoding

/**
 * Encodes the message.
 * @name ProtoBuf.Builder.Message#$encode
 * @function
 * @param ***REMOVED***(!ByteBuffer|boolean)=***REMOVED*** buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
 * @param ***REMOVED***boolean=***REMOVED*** noVerify Whether to not verify field values, defaults to `false`
 * @return ***REMOVED***!ByteBuffer***REMOVED*** Encoded message as a ByteBuffer
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be encoded or if required fields are missing. The later still
 *  returns the encoded ByteBuffer in the `encoded` property on the error.
 * @expose
 * @see ProtoBuf.Builder.Message#encode64
 * @see ProtoBuf.Builder.Message#encodeHex
 * @see ProtoBuf.Builder.Message#encodeAB
 */
MessagePrototype.encode = function(buffer, noVerify) ***REMOVED***
    if (typeof buffer === 'boolean')
        noVerify = buffer,
        buffer = undefined;
    var isNew = false;
    if (!buffer)
        buffer = new ByteBuffer(),
        isNew = true;
    var le = buffer.littleEndian;
    try ***REMOVED***
        T.encode(this, buffer.LE(), noVerify);
        return (isNew ? buffer.flip() : buffer).LE(le);
    ***REMOVED*** catch (e) ***REMOVED***
        buffer.LE(le);
        throw(e);
    ***REMOVED***
***REMOVED***;

/**
 * Encodes a message using the specified data payload.
 * @param ***REMOVED***!Object.<string,*>***REMOVED*** data Data payload
 * @param ***REMOVED***(!ByteBuffer|boolean)=***REMOVED*** buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
 * @param ***REMOVED***boolean=***REMOVED*** noVerify Whether to not verify field values, defaults to `false`
 * @return ***REMOVED***!ByteBuffer***REMOVED*** Encoded message as a ByteBuffer
 * @expose
 */
Message.encode = function(data, buffer, noVerify) ***REMOVED***
    return new Message(data).encode(buffer, noVerify);
***REMOVED***;

/**
 * Calculates the byte length of the message.
 * @name ProtoBuf.Builder.Message#calculate
 * @function
 * @returns ***REMOVED***number***REMOVED*** Byte length
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be calculated or if required fields are missing.
 * @expose
 */
MessagePrototype.calculate = function() ***REMOVED***
    return T.calculate(this);
***REMOVED***;

/**
 * Encodes the varint32 length-delimited message.
 * @name ProtoBuf.Builder.Message#encodeDelimited
 * @function
 * @param ***REMOVED***(!ByteBuffer|boolean)=***REMOVED*** buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
 * @param ***REMOVED***boolean=***REMOVED*** noVerify Whether to not verify field values, defaults to `false`
 * @return ***REMOVED***!ByteBuffer***REMOVED*** Encoded message as a ByteBuffer
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be encoded or if required fields are missing. The later still
 *  returns the encoded ByteBuffer in the `encoded` property on the error.
 * @expose
 */
MessagePrototype.encodeDelimited = function(buffer, noVerify) ***REMOVED***
    var isNew = false;
    if (!buffer)
        buffer = new ByteBuffer(),
        isNew = true;
    var enc = new ByteBuffer().LE();
    T.encode(this, enc, noVerify).flip();
    buffer.writeVarint32(enc.remaining());
    buffer.append(enc);
    return isNew ? buffer.flip() : buffer;
***REMOVED***;

/**
 * Directly encodes the message to an ArrayBuffer.
 * @name ProtoBuf.Builder.Message#encodeAB
 * @function
 * @return ***REMOVED***ArrayBuffer***REMOVED*** Encoded message as ArrayBuffer
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be encoded or if required fields are missing. The later still
 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
 * @expose
 */
MessagePrototype.encodeAB = function() ***REMOVED***
    try ***REMOVED***
        return this.encode().toArrayBuffer();
    ***REMOVED*** catch (e) ***REMOVED***
        if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
        throw(e);
    ***REMOVED***
***REMOVED***;

/**
 * Returns the message as an ArrayBuffer. This is an alias for ***REMOVED***@link ProtoBuf.Builder.Message#encodeAB***REMOVED***.
 * @name ProtoBuf.Builder.Message#toArrayBuffer
 * @function
 * @return ***REMOVED***ArrayBuffer***REMOVED*** Encoded message as ArrayBuffer
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be encoded or if required fields are missing. The later still
 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
 * @expose
 */
MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;

/**
 * Directly encodes the message to a node Buffer.
 * @name ProtoBuf.Builder.Message#encodeNB
 * @function
 * @return ***REMOVED***!Buffer***REMOVED***
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be encoded, not running under node.js or if required fields are
 *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
 * @expose
 */
MessagePrototype.encodeNB = function() ***REMOVED***
    try ***REMOVED***
        return this.encode().toBuffer();
    ***REMOVED*** catch (e) ***REMOVED***
        if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
        throw(e);
    ***REMOVED***
***REMOVED***;

/**
 * Returns the message as a node Buffer. This is an alias for ***REMOVED***@link ProtoBuf.Builder.Message#encodeNB***REMOVED***.
 * @name ProtoBuf.Builder.Message#toBuffer
 * @function
 * @return ***REMOVED***!Buffer***REMOVED***
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be encoded or if required fields are missing. The later still
 *  returns the encoded node Buffer in the `encoded` property on the error.
 * @expose
 */
MessagePrototype.toBuffer = MessagePrototype.encodeNB;

/**
 * Directly encodes the message to a base64 encoded string.
 * @name ProtoBuf.Builder.Message#encode64
 * @function
 * @return ***REMOVED***string***REMOVED*** Base64 encoded string
 * @throws ***REMOVED***Error***REMOVED*** If the underlying buffer cannot be encoded or if required fields are missing. The later
 *  still returns the encoded base64 string in the `encoded` property on the error.
 * @expose
 */
MessagePrototype.encode64 = function() ***REMOVED***
    try ***REMOVED***
        return this.encode().toBase64();
    ***REMOVED*** catch (e) ***REMOVED***
        if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
        throw(e);
    ***REMOVED***
***REMOVED***;

/**
 * Returns the message as a base64 encoded string. This is an alias for ***REMOVED***@link ProtoBuf.Builder.Message#encode64***REMOVED***.
 * @name ProtoBuf.Builder.Message#toBase64
 * @function
 * @return ***REMOVED***string***REMOVED*** Base64 encoded string
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be encoded or if required fields are missing. The later still
 *  returns the encoded base64 string in the `encoded` property on the error.
 * @expose
 */
MessagePrototype.toBase64 = MessagePrototype.encode64;

/**
 * Directly encodes the message to a hex encoded string.
 * @name ProtoBuf.Builder.Message#encodeHex
 * @function
 * @return ***REMOVED***string***REMOVED*** Hex encoded string
 * @throws ***REMOVED***Error***REMOVED*** If the underlying buffer cannot be encoded or if required fields are missing. The later
 *  still returns the encoded hex string in the `encoded` property on the error.
 * @expose
 */
MessagePrototype.encodeHex = function() ***REMOVED***
    try ***REMOVED***
        return this.encode().toHex();
    ***REMOVED*** catch (e) ***REMOVED***
        if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
        throw(e);
    ***REMOVED***
***REMOVED***;

/**
 * Returns the message as a hex encoded string. This is an alias for ***REMOVED***@link ProtoBuf.Builder.Message#encodeHex***REMOVED***.
 * @name ProtoBuf.Builder.Message#toHex
 * @function
 * @return ***REMOVED***string***REMOVED*** Hex encoded string
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be encoded or if required fields are missing. The later still
 *  returns the encoded hex string in the `encoded` property on the error.
 * @expose
 */
MessagePrototype.toHex = MessagePrototype.encodeHex;

/**
 * Clones a message object or field value to a raw object.
 * @param ***REMOVED*******REMOVED*** obj Object to clone
 * @param ***REMOVED***boolean***REMOVED*** binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise
 * @param ***REMOVED***boolean***REMOVED*** longsAsStrings Whether to encode longs as strings
 * @param ***REMOVED***!ProtoBuf.Reflect.T=***REMOVED*** resolvedType The resolved field type if a field
 * @returns ***REMOVED*******REMOVED*** Cloned object
 * @inner
 */
function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) ***REMOVED***
    if (obj === null || typeof obj !== 'object') ***REMOVED***
        // Convert enum values to their respective names
        if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) ***REMOVED***
            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);
            if (name !== null)
                return name;
        ***REMOVED***
        // Pass-through string, number, boolean, null...
        return obj;
    ***REMOVED***
    // Convert ByteBuffers to raw buffer or strings
    if (ByteBuffer.isByteBuffer(obj))
        return binaryAsBase64 ? obj.toBase64() : obj.toBuffer();
    // Convert Longs to proper objects or strings
    if (ProtoBuf.Long.isLong(obj))
        return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);
    var clone;
    // Clone arrays
    if (Array.isArray(obj)) ***REMOVED***
        clone = [];
        obj.forEach(function(v, k) ***REMOVED***
            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);
        ***REMOVED***);
        return clone;
    ***REMOVED***
    clone = ***REMOVED******REMOVED***;
    // Convert maps to objects
    if (obj instanceof ProtoBuf.Map) ***REMOVED***
        var it = obj.entries();
        for (var e = it.next(); !e.done; e = it.next())
            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);
        return clone;
    ***REMOVED***
    // Everything else is a non-null object
    var type = obj.$type,
        field = undefined;
    for (var i in obj)
        if (obj.hasOwnProperty(i)) ***REMOVED***
            if (type && (field = type.getChild(i)))
                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);
            else
                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);
        ***REMOVED***
    return clone;
***REMOVED***

/**
 * Returns the message's raw payload.
 * @param ***REMOVED***boolean=***REMOVED*** binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`
 * @param ***REMOVED***boolean***REMOVED*** longsAsStrings Whether to encode longs as strings
 * @returns ***REMOVED***Object.<string,*>***REMOVED*** Raw payload
 * @expose
 */
MessagePrototype.toRaw = function(binaryAsBase64, longsAsStrings) ***REMOVED***
    return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);
***REMOVED***;

/**
 * Encodes a message to JSON.
 * @returns ***REMOVED***string***REMOVED*** JSON string
 * @expose
 */
MessagePrototype.encodeJSON = function() ***REMOVED***
    return JSON.stringify(
        cloneRaw(this,
             /* binary-as-base64 */ true,
             /* longs-as-strings */ true,
             this.$type
        )
    );
***REMOVED***;

/**
 * Decodes a message from the specified buffer or string.
 * @name ProtoBuf.Builder.Message.decode
 * @function
 * @param ***REMOVED***!ByteBuffer|!ArrayBuffer|!Buffer|string***REMOVED*** buffer Buffer to decode from
 * @param ***REMOVED***(number|string)=***REMOVED*** length Message length. Defaults to decode all the remainig data.
 * @param ***REMOVED***string=***REMOVED*** enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
 * @return ***REMOVED***!ProtoBuf.Builder.Message***REMOVED*** Decoded message
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be decoded or if required fields are missing. The later still
 *  returns the decoded message with missing fields in the `decoded` property on the error.
 * @expose
 * @see ProtoBuf.Builder.Message.decode64
 * @see ProtoBuf.Builder.Message.decodeHex
 */
Message.decode = function(buffer, length, enc) ***REMOVED***
    if (typeof length === 'string')
        enc = length,
        length = -1;
    if (typeof buffer === 'string')
        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
    else if (!ByteBuffer.isByteBuffer(buffer))
        buffer = ByteBuffer.wrap(buffer); // May throw
    var le = buffer.littleEndian;
    try ***REMOVED***
        var msg = T.decode(buffer.LE(), length);
        buffer.LE(le);
        return msg;
    ***REMOVED*** catch (e) ***REMOVED***
        buffer.LE(le);
        throw(e);
    ***REMOVED***
***REMOVED***;

/**
 * Decodes a varint32 length-delimited message from the specified buffer or string.
 * @name ProtoBuf.Builder.Message.decodeDelimited
 * @function
 * @param ***REMOVED***!ByteBuffer|!ArrayBuffer|!Buffer|string***REMOVED*** buffer Buffer to decode from
 * @param ***REMOVED***string=***REMOVED*** enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
 * @return ***REMOVED***ProtoBuf.Builder.Message***REMOVED*** Decoded message or `null` if not enough bytes are available yet
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be decoded or if required fields are missing. The later still
 *  returns the decoded message with missing fields in the `decoded` property on the error.
 * @expose
 */
Message.decodeDelimited = function(buffer, enc) ***REMOVED***
    if (typeof buffer === 'string')
        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
    else if (!ByteBuffer.isByteBuffer(buffer))
        buffer = ByteBuffer.wrap(buffer); // May throw
    if (buffer.remaining() < 1)
        return null;
    var off = buffer.offset,
        len = buffer.readVarint32();
    if (buffer.remaining() < len) ***REMOVED***
        buffer.offset = off;
        return null;
    ***REMOVED***
    try ***REMOVED***
        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
        buffer.offset += len;
        return msg;
    ***REMOVED*** catch (err) ***REMOVED***
        buffer.offset += len;
        throw err;
    ***REMOVED***
***REMOVED***;

/**
 * Decodes the message from the specified base64 encoded string.
 * @name ProtoBuf.Builder.Message.decode64
 * @function
 * @param ***REMOVED***string***REMOVED*** str String to decode from
 * @return ***REMOVED***!ProtoBuf.Builder.Message***REMOVED*** Decoded message
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be decoded or if required fields are missing. The later still
 *  returns the decoded message with missing fields in the `decoded` property on the error.
 * @expose
 */
Message.decode64 = function(str) ***REMOVED***
    return Message.decode(str, "base64");
***REMOVED***;

/**
 * Decodes the message from the specified hex encoded string.
 * @name ProtoBuf.Builder.Message.decodeHex
 * @function
 * @param ***REMOVED***string***REMOVED*** str String to decode from
 * @return ***REMOVED***!ProtoBuf.Builder.Message***REMOVED*** Decoded message
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be decoded or if required fields are missing. The later still
 *  returns the decoded message with missing fields in the `decoded` property on the error.
 * @expose
 */
Message.decodeHex = function(str) ***REMOVED***
    return Message.decode(str, "hex");
***REMOVED***;

/**
 * Decodes the message from a JSON string.
 * @name ProtoBuf.Builder.Message.decodeJSON
 * @function
 * @param ***REMOVED***string***REMOVED*** str String to decode from
 * @return ***REMOVED***!ProtoBuf.Builder.Message***REMOVED*** Decoded message
 * @throws ***REMOVED***Error***REMOVED*** If the message cannot be decoded or if required fields are
 * missing.
 * @expose
 */
Message.decodeJSON = function(str) ***REMOVED***
    return new Message(JSON.parse(str));
***REMOVED***;

// Utility

/**
 * Returns a string representation of this Message.
 * @name ProtoBuf.Builder.Message#toString
 * @function
 * @return ***REMOVED***string***REMOVED*** String representation as of ".Fully.Qualified.MessageName"
 * @expose
 */
MessagePrototype.toString = function() ***REMOVED***
    return T.toString();
***REMOVED***;

// Properties

/**
 * Message options.
 * @name ProtoBuf.Builder.Message.$options
 * @type ***REMOVED***Object.<string,*>***REMOVED***
 * @expose
 */
var $optionsS; // cc needs this

/**
 * Message options.
 * @name ProtoBuf.Builder.Message#$options
 * @type ***REMOVED***Object.<string,*>***REMOVED***
 * @expose
 */
var $options;

/**
 * Reflection type.
 * @name ProtoBuf.Builder.Message.$type
 * @type ***REMOVED***!ProtoBuf.Reflect.Message***REMOVED***
 * @expose
 */
var $typeS;

/**
 * Reflection type.
 * @name ProtoBuf.Builder.Message#$type
 * @type ***REMOVED***!ProtoBuf.Reflect.Message***REMOVED***
 * @expose
 */
var $type;

if (Object.defineProperty)
    Object.defineProperty(Message, '$options', ***REMOVED*** "value": T.buildOpt() ***REMOVED***),
    Object.defineProperty(MessagePrototype, "$options", ***REMOVED*** "value": Message["$options"] ***REMOVED***),
    Object.defineProperty(Message, "$type", ***REMOVED*** "value": T ***REMOVED***),
    Object.defineProperty(MessagePrototype, "$type", ***REMOVED*** "value": T ***REMOVED***);
