/**
 * Constructs a new Namespace.
 * @exports ProtoBuf.Reflect.Namespace
 * @param ***REMOVED***!ProtoBuf.Builder***REMOVED*** builder Builder reference
 * @param ***REMOVED***?ProtoBuf.Reflect.Namespace***REMOVED*** parent Namespace parent
 * @param ***REMOVED***string***REMOVED*** name Namespace name
 * @param ***REMOVED***Object.<string,*>=***REMOVED*** options Namespace options
 * @param ***REMOVED***string?***REMOVED*** syntax The syntax level of this definition (e.g., proto3)
 * @constructor
 * @extends ProtoBuf.Reflect.T
 */
var Namespace = function(builder, parent, name, options, syntax) ***REMOVED***
    T.call(this, builder, parent, name);

    /**
     * @override
     */
    this.className = "Namespace";

    /**
     * Children inside the namespace.
     * @type ***REMOVED***!Array.<ProtoBuf.Reflect.T>***REMOVED***
     */
    this.children = [];

    /**
     * Options.
     * @type ***REMOVED***!Object.<string, *>***REMOVED***
     */
    this.options = options || ***REMOVED******REMOVED***;

    /**
     * Syntax level (e.g., proto2 or proto3).
     * @type ***REMOVED***!string***REMOVED***
     */
    this.syntax = syntax || "proto2";
***REMOVED***;

/**
 * @alias ProtoBuf.Reflect.Namespace.prototype
 * @inner
 */
var NamespacePrototype = Namespace.prototype = Object.create(T.prototype);

/**
 * Returns an array of the namespace's children.
 * @param ***REMOVED***ProtoBuf.Reflect.T=***REMOVED*** type Filter type (returns instances of this type only). Defaults to null (all children).
 * @return ***REMOVED***Array.<ProtoBuf.Reflect.T>***REMOVED***
 * @expose
 */
NamespacePrototype.getChildren = function(type) ***REMOVED***
    type = type || null;
    if (type == null)
        return this.children.slice();
    var children = [];
    for (var i=0, k=this.children.length; i<k; ++i)
        if (this.children[i] instanceof type)
            children.push(this.children[i]);
    return children;
***REMOVED***;

/**
 * Adds a child to the namespace.
 * @param ***REMOVED***ProtoBuf.Reflect.T***REMOVED*** child Child
 * @throws ***REMOVED***Error***REMOVED*** If the child cannot be added (duplicate)
 * @expose
 */
NamespacePrototype.addChild = function(child) ***REMOVED***
    var other;
    if (other = this.getChild(child.name)) ***REMOVED***
        // Try to revert camelcase transformation on collision
        if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null)
            other.name = other.originalName; // Revert previous first (effectively keeps both originals)
        else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null)
            child.name = child.originalName;
        else
            throw Error("Duplicate name in namespace "+this.toString(true)+": "+child.name);
    ***REMOVED***
    this.children.push(child);
***REMOVED***;

/**
 * Gets a child by its name or id.
 * @param ***REMOVED***string|number***REMOVED*** nameOrId Child name or id
 * @return ***REMOVED***?ProtoBuf.Reflect.T***REMOVED*** The child or null if not found
 * @expose
 */
NamespacePrototype.getChild = function(nameOrId) ***REMOVED***
    var key = typeof nameOrId === 'number' ? 'id' : 'name';
    for (var i=0, k=this.children.length; i<k; ++i)
        if (this.children[i][key] === nameOrId)
            return this.children[i];
    return null;
***REMOVED***;

/**
 * Resolves a reflect object inside of this namespace.
 * @param ***REMOVED***string|!Array.<string>***REMOVED*** qn Qualified name to resolve
 * @param ***REMOVED***boolean=***REMOVED*** excludeNonNamespace Excludes non-namespace types, defaults to `false`
 * @return ***REMOVED***?ProtoBuf.Reflect.Namespace***REMOVED*** The resolved type or null if not found
 * @expose
 */
NamespacePrototype.resolve = function(qn, excludeNonNamespace) ***REMOVED***
    var part = typeof qn === 'string' ? qn.split(".") : qn,
        ptr = this,
        i = 0;
    if (part[i] === "") ***REMOVED*** // Fully qualified name, e.g. ".My.Message'
        while (ptr.parent !== null)
            ptr = ptr.parent;
        i++;
    ***REMOVED***
    var child;
    do ***REMOVED***
        do ***REMOVED***
            if (!(ptr instanceof Reflect.Namespace)) ***REMOVED***
                ptr = null;
                break;
            ***REMOVED***
            child = ptr.getChild(part[i]);
            if (!child || !(child instanceof Reflect.T) || (excludeNonNamespace && !(child instanceof Reflect.Namespace))) ***REMOVED***
                ptr = null;
                break;
            ***REMOVED***
            ptr = child; i++;
        ***REMOVED*** while (i < part.length);
        if (ptr != null)
            break; // Found
        // Else search the parent
        if (this.parent !== null)
            return this.parent.resolve(qn, excludeNonNamespace);
    ***REMOVED*** while (ptr != null);
    return ptr;
***REMOVED***;

/**
 * Determines the shortest qualified name of the specified type, if any, relative to this namespace.
 * @param ***REMOVED***!ProtoBuf.Reflect.T***REMOVED*** t Reflection type
 * @returns ***REMOVED***string***REMOVED*** The shortest qualified name or, if there is none, the fqn
 * @expose
 */
NamespacePrototype.qn = function(t) ***REMOVED***
    var part = [], ptr = t;
    do ***REMOVED***
        part.unshift(ptr.name);
        ptr = ptr.parent;
    ***REMOVED*** while (ptr !== null);
    for (var len=1; len <= part.length; len++) ***REMOVED***
        var qn = part.slice(part.length-len);
        if (t === this.resolve(qn, t instanceof Reflect.Namespace))
            return qn.join(".");
    ***REMOVED***
    return t.fqn();
***REMOVED***;

/**
 * Builds the namespace and returns the runtime counterpart.
 * @return ***REMOVED***Object.<string,Function|Object>***REMOVED*** Runtime namespace
 * @expose
 */
NamespacePrototype.build = function() ***REMOVED***
    /** @dict */
    var ns = ***REMOVED******REMOVED***;
    var children = this.children;
    for (var i=0, k=children.length, child; i<k; ++i) ***REMOVED***
        child = children[i];
        if (child instanceof Namespace)
            ns[child.name] = child.build();
    ***REMOVED***
    if (Object.defineProperty)
        Object.defineProperty(ns, "$options", ***REMOVED*** "value": this.buildOpt() ***REMOVED***);
    return ns;
***REMOVED***;

/**
 * Builds the namespace's '$options' property.
 * @return ***REMOVED***Object.<string,*>***REMOVED***
 */
NamespacePrototype.buildOpt = function() ***REMOVED***
    var opt = ***REMOVED******REMOVED***,
        keys = Object.keys(this.options);
    for (var i=0, k=keys.length; i<k; ++i) ***REMOVED***
        var key = keys[i],
            val = this.options[keys[i]];
        // TODO: Options are not resolved, yet.
        // if (val instanceof Namespace) ***REMOVED***
        //     opt[key] = val.build();
        // ***REMOVED*** else ***REMOVED***
        opt[key] = val;
        // ***REMOVED***
    ***REMOVED***
    return opt;
***REMOVED***;

/**
 * Gets the value assigned to the option with the specified name.
 * @param ***REMOVED***string=***REMOVED*** name Returns the option value if specified, otherwise all options are returned.
 * @return ***REMOVED****|Object.<string,*>***REMOVED***null***REMOVED*** Option value or NULL if there is no such option
 */
NamespacePrototype.getOption = function(name) ***REMOVED***
    if (typeof name === 'undefined')
        return this.options;
    return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
***REMOVED***;
