/**
 * The ProtoBuf namespace.
 * @exports ProtoBuf
 * @namespace
 * @expose
 */
var ProtoBuf = ***REMOVED******REMOVED***;

/**
 * @type ***REMOVED***!function(new: ByteBuffer, ...[*])***REMOVED***
 * @expose
 */
ProtoBuf.ByteBuffer = ByteBuffer;

/**
 * @type ***REMOVED***?function(new: Long, ...[*])***REMOVED***
 * @expose
 */
ProtoBuf.Long = ByteBuffer.Long || null;

/**
 * ProtoBuf.js version.
 * @type ***REMOVED***string***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.VERSION = "/*?= VERSION */";

/**
 * Wire types.
 * @type ***REMOVED***Object.<string,number>***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.WIRE_TYPES = ***REMOVED******REMOVED***;

/**
 * Varint wire type.
 * @type ***REMOVED***number***REMOVED***
 * @expose
 */
ProtoBuf.WIRE_TYPES.VARINT = 0;

/**
 * Fixed 64 bits wire type.
 * @type ***REMOVED***number***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.WIRE_TYPES.BITS64 = 1;

/**
 * Length delimited wire type.
 * @type ***REMOVED***number***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.WIRE_TYPES.LDELIM = 2;

/**
 * Start group wire type.
 * @type ***REMOVED***number***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.WIRE_TYPES.STARTGROUP = 3;

/**
 * End group wire type.
 * @type ***REMOVED***number***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.WIRE_TYPES.ENDGROUP = 4;

/**
 * Fixed 32 bits wire type.
 * @type ***REMOVED***number***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.WIRE_TYPES.BITS32 = 5;

/**
 * Packable wire types.
 * @type ***REMOVED***!Array.<number>***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.PACKABLE_WIRE_TYPES = [
    ProtoBuf.WIRE_TYPES.VARINT,
    ProtoBuf.WIRE_TYPES.BITS64,
    ProtoBuf.WIRE_TYPES.BITS32
];

/**
 * Types.
 * @dict
 * @type ***REMOVED***!Object.<string,***REMOVED***name: string, wireType: number, defaultValue: ****REMOVED***>***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.TYPES = ***REMOVED***
    // According to the protobuf spec.
    "int32": ***REMOVED***
        name: "int32",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: 0
    ***REMOVED***,
    "uint32": ***REMOVED***
        name: "uint32",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: 0
    ***REMOVED***,
    "sint32": ***REMOVED***
        name: "sint32",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: 0
    ***REMOVED***,
    "int64": ***REMOVED***
        name: "int64",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
    ***REMOVED***,
    "uint64": ***REMOVED***
        name: "uint64",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
    ***REMOVED***,
    "sint64": ***REMOVED***
        name: "sint64",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
    ***REMOVED***,
    "bool": ***REMOVED***
        name: "bool",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: false
    ***REMOVED***,
    "double": ***REMOVED***
        name: "double",
        wireType: ProtoBuf.WIRE_TYPES.BITS64,
        defaultValue: 0
    ***REMOVED***,
    "string": ***REMOVED***
        name: "string",
        wireType: ProtoBuf.WIRE_TYPES.LDELIM,
        defaultValue: ""
    ***REMOVED***,
    "bytes": ***REMOVED***
        name: "bytes",
        wireType: ProtoBuf.WIRE_TYPES.LDELIM,
        defaultValue: null // overridden in the code, must be a unique instance
    ***REMOVED***,
    "fixed32": ***REMOVED***
        name: "fixed32",
        wireType: ProtoBuf.WIRE_TYPES.BITS32,
        defaultValue: 0
    ***REMOVED***,
    "sfixed32": ***REMOVED***
        name: "sfixed32",
        wireType: ProtoBuf.WIRE_TYPES.BITS32,
        defaultValue: 0
    ***REMOVED***,
    "fixed64": ***REMOVED***
        name: "fixed64",
        wireType: ProtoBuf.WIRE_TYPES.BITS64,
        defaultValue:  ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
    ***REMOVED***,
    "sfixed64": ***REMOVED***
        name: "sfixed64",
        wireType: ProtoBuf.WIRE_TYPES.BITS64,
        defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
    ***REMOVED***,
    "float": ***REMOVED***
        name: "float",
        wireType: ProtoBuf.WIRE_TYPES.BITS32,
        defaultValue: 0
    ***REMOVED***,
    "enum": ***REMOVED***
        name: "enum",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: 0
    ***REMOVED***,
    "message": ***REMOVED***
        name: "message",
        wireType: ProtoBuf.WIRE_TYPES.LDELIM,
        defaultValue: null
    ***REMOVED***,
    "group": ***REMOVED***
        name: "group",
        wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,
        defaultValue: null
    ***REMOVED***
***REMOVED***;

/**
 * Valid map key types.
 * @type ***REMOVED***!Array.<!Object.<string,***REMOVED***name: string, wireType: number, defaultValue: ****REMOVED***>>***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.MAP_KEY_TYPES = [
    ProtoBuf.TYPES["int32"],
    ProtoBuf.TYPES["sint32"],
    ProtoBuf.TYPES["sfixed32"],
    ProtoBuf.TYPES["uint32"],
    ProtoBuf.TYPES["fixed32"],
    ProtoBuf.TYPES["int64"],
    ProtoBuf.TYPES["sint64"],
    ProtoBuf.TYPES["sfixed64"],
    ProtoBuf.TYPES["uint64"],
    ProtoBuf.TYPES["fixed64"],
    ProtoBuf.TYPES["bool"],
    ProtoBuf.TYPES["string"],
    ProtoBuf.TYPES["bytes"]
];

/**
 * Minimum field id.
 * @type ***REMOVED***number***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.ID_MIN = 1;

/**
 * Maximum field id.
 * @type ***REMOVED***number***REMOVED***
 * @const
 * @expose
 */
ProtoBuf.ID_MAX = 0x1FFFFFFF;

/**
 * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
 *  Must be set prior to parsing.
 * @type ***REMOVED***boolean***REMOVED***
 * @expose
 */
ProtoBuf.convertFieldsToCamelCase = false;

/**
 * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by
 *  setting this to `false` prior to building messages.
 * @type ***REMOVED***boolean***REMOVED***
 * @expose
 */
ProtoBuf.populateAccessors = true;

/**
 * By default, messages are populated with default values if a field is not present on the wire. To disable
 *  this behavior, set this setting to `false`.
 * @type ***REMOVED***boolean***REMOVED***
 * @expose
 */
ProtoBuf.populateDefaults = true;

//? include("ProtoBuf/Util.js");

//? include("ProtoBuf/Lang.js");

//? if (DOTPROTO) include("ProtoBuf/DotProto.js");

//? include("ProtoBuf/Reflect.js");

//? include("ProtoBuf/Builder.js");

//? include("ProtoBuf/Map.js");

//? if (DOTPROTO) ***REMOVED***

/**
 * Loads a .proto string and returns the Builder.
 * @param ***REMOVED***string***REMOVED*** proto .proto file contents
 * @param ***REMOVED***(ProtoBuf.Builder|string|***REMOVED***root: string, file: string***REMOVED***)=***REMOVED*** builder Builder to append to. Will create a new one if omitted.
 * @param ***REMOVED***(string|***REMOVED***root: string, file: string***REMOVED***)=***REMOVED*** filename The corresponding file name if known. Must be specified for imports.
 * @return ***REMOVED***ProtoBuf.Builder***REMOVED*** Builder to create new messages
 * @throws ***REMOVED***Error***REMOVED*** If the definition cannot be parsed or built
 * @expose
 */
ProtoBuf.loadProto = function(proto, builder, filename) ***REMOVED***
    if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
        filename = builder,
        builder = undefined;
    return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);
***REMOVED***;

/**
 * Loads a .proto string and returns the Builder. This is an alias of ***REMOVED***@link ProtoBuf.loadProto***REMOVED***.
 * @function
 * @param ***REMOVED***string***REMOVED*** proto .proto file contents
 * @param ***REMOVED***(ProtoBuf.Builder|string)=***REMOVED*** builder Builder to append to. Will create a new one if omitted.
 * @param ***REMOVED***(string|***REMOVED***root: string, file: string***REMOVED***)=***REMOVED*** filename The corresponding file name if known. Must be specified for imports.
 * @return ***REMOVED***ProtoBuf.Builder***REMOVED*** Builder to create new messages
 * @throws ***REMOVED***Error***REMOVED*** If the definition cannot be parsed or built
 * @expose
 */
ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

/**
 * Loads a .proto file and returns the Builder.
 * @param ***REMOVED***string|***REMOVED***root: string, file: string***REMOVED******REMOVED*** filename Path to proto file or an object specifying 'file' with
 *  an overridden 'root' path for all imported files.
 * @param ***REMOVED***function(?Error, !ProtoBuf.Builder=)=***REMOVED*** callback Callback that will receive `null` as the first and
 *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
 *  file will be read synchronously and this function will return the Builder.
 * @param ***REMOVED***ProtoBuf.Builder=***REMOVED*** builder Builder to append to. Will create a new one if omitted.
 * @return ***REMOVED***?ProtoBuf.Builder|undefined***REMOVED*** The Builder if synchronous (no callback specified, will be NULL if the
 *   request has failed), else undefined
 * @expose
 */
ProtoBuf.loadProtoFile = function(filename, callback, builder) ***REMOVED***
    if (callback && typeof callback === 'object')
        builder = callback,
        callback = null;
    else if (!callback || typeof callback !== 'function')
        callback = null;
    if (callback)
        return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) ***REMOVED***
            if (contents === null) ***REMOVED***
                callback(Error("Failed to fetch file"));
                return;
            ***REMOVED***
            try ***REMOVED***
                callback(null, ProtoBuf.loadProto(contents, builder, filename));
            ***REMOVED*** catch (e) ***REMOVED***
                callback(e);
            ***REMOVED***
        ***REMOVED***);
    var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
    return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
***REMOVED***;

/**
 * Loads a .proto file and returns the Builder. This is an alias of ***REMOVED***@link ProtoBuf.loadProtoFile***REMOVED***.
 * @function
 * @param ***REMOVED***string|***REMOVED***root: string, file: string***REMOVED******REMOVED*** filename Path to proto file or an object specifying 'file' with
 *  an overridden 'root' path for all imported files.
 * @param ***REMOVED***function(?Error, !ProtoBuf.Builder=)=***REMOVED*** callback Callback that will receive `null` as the first and
 *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
 *  file will be read synchronously and this function will return the Builder.
 * @param ***REMOVED***ProtoBuf.Builder=***REMOVED*** builder Builder to append to. Will create a new one if omitted.
 * @return ***REMOVED***!ProtoBuf.Builder|undefined***REMOVED*** The Builder if synchronous (no callback specified, will be NULL if the
 *   request has failed), else undefined
 * @expose
 */
ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy

//? ***REMOVED*** // DOTPROTO

/**
 * Constructs a new empty Builder.
 * @param ***REMOVED***Object.<string,*>=***REMOVED*** options Builder options, defaults to global options set on ProtoBuf
 * @return ***REMOVED***!ProtoBuf.Builder***REMOVED*** Builder
 * @expose
 */
ProtoBuf.newBuilder = function(options) ***REMOVED***
    options = options || ***REMOVED******REMOVED***;
    if (typeof options['convertFieldsToCamelCase'] === 'undefined')
        options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;
    if (typeof options['populateAccessors'] === 'undefined')
        options['populateAccessors'] = ProtoBuf.populateAccessors;
    return new ProtoBuf.Builder(options);
***REMOVED***;

/**
 * Loads a .json definition and returns the Builder.
 * @param ***REMOVED***!*|string***REMOVED*** json JSON definition
 * @param ***REMOVED***(ProtoBuf.Builder|string|***REMOVED***root: string, file: string***REMOVED***)=***REMOVED*** builder Builder to append to. Will create a new one if omitted.
 * @param ***REMOVED***(string|***REMOVED***root: string, file: string***REMOVED***)=***REMOVED*** filename The corresponding file name if known. Must be specified for imports.
 * @return ***REMOVED***ProtoBuf.Builder***REMOVED*** Builder to create new messages
 * @throws ***REMOVED***Error***REMOVED*** If the definition cannot be parsed or built
 * @expose
 */
ProtoBuf.loadJson = function(json, builder, filename) ***REMOVED***
    if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
        filename = builder,
        builder = null;
    if (!builder || typeof builder !== 'object')
        builder = ProtoBuf.newBuilder();
    if (typeof json === 'string')
        json = JSON.parse(json);
    builder["import"](json, filename);
    builder.resolveAll();
    return builder;
***REMOVED***;

/**
 * Loads a .json file and returns the Builder.
 * @param ***REMOVED***string|!***REMOVED***root: string, file: string***REMOVED******REMOVED*** filename Path to json file or an object specifying 'file' with
 *  an overridden 'root' path for all imported files.
 * @param ***REMOVED***function(?Error, !ProtoBuf.Builder=)=***REMOVED*** callback Callback that will receive `null` as the first and
 *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
 *  file will be read synchronously and this function will return the Builder.
 * @param ***REMOVED***ProtoBuf.Builder=***REMOVED*** builder Builder to append to. Will create a new one if omitted.
 * @return ***REMOVED***?ProtoBuf.Builder|undefined***REMOVED*** The Builder if synchronous (no callback specified, will be NULL if the
 *   request has failed), else undefined
 * @expose
 */
ProtoBuf.loadJsonFile = function(filename, callback, builder) ***REMOVED***
    if (callback && typeof callback === 'object')
        builder = callback,
        callback = null;
    else if (!callback || typeof callback !== 'function')
        callback = null;
    if (callback)
        return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) ***REMOVED***
            if (contents === null) ***REMOVED***
                callback(Error("Failed to fetch file"));
                return;
            ***REMOVED***
            try ***REMOVED***
                callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
            ***REMOVED*** catch (e) ***REMOVED***
                callback(e);
            ***REMOVED***
        ***REMOVED***);
    var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
    return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
***REMOVED***;
