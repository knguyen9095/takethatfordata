// info about each config option.

var debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG
  ? function () ***REMOVED*** console.error.apply(console, arguments) ***REMOVED***
  : function () ***REMOVED******REMOVED***

var url = require("url")
  , path = require("path")
  , Stream = require("stream").Stream
  , abbrev = require("abbrev")
  , osenv = require("osenv")

module.exports = exports = nopt
exports.clean = clean

exports.typeDefs =
  ***REMOVED*** String  : ***REMOVED*** type: String,  validate: validateString  ***REMOVED***
  , Boolean : ***REMOVED*** type: Boolean, validate: validateBoolean ***REMOVED***
  , url     : ***REMOVED*** type: url,     validate: validateUrl     ***REMOVED***
  , Number  : ***REMOVED*** type: Number,  validate: validateNumber  ***REMOVED***
  , path    : ***REMOVED*** type: path,    validate: validatePath    ***REMOVED***
  , Stream  : ***REMOVED*** type: Stream,  validate: validateStream  ***REMOVED***
  , Date    : ***REMOVED*** type: Date,    validate: validateDate    ***REMOVED***
  ***REMOVED***

function nopt (types, shorthands, args, slice) ***REMOVED***
  args = args || process.argv
  types = types || ***REMOVED******REMOVED***
  shorthands = shorthands || ***REMOVED******REMOVED***
  if (typeof slice !== "number") slice = 2

  debug(types, shorthands, args, slice)

  args = args.slice(slice)
  var data = ***REMOVED******REMOVED***
    , key
    , argv = ***REMOVED***
        remain: [],
        cooked: args,
        original: args.slice(0)
      ***REMOVED***

  parse(args, data, argv.remain, types, shorthands)
  // now data is full
  clean(data, types, exports.typeDefs)
  data.argv = argv
  Object.defineProperty(data.argv, 'toString', ***REMOVED*** value: function () ***REMOVED***
    return this.original.map(JSON.stringify).join(" ")
  ***REMOVED***, enumerable: false ***REMOVED***)
  return data
***REMOVED***

function clean (data, types, typeDefs) ***REMOVED***
  typeDefs = typeDefs || exports.typeDefs
  var remove = ***REMOVED******REMOVED***
    , typeDefault = [false, true, null, String, Array]

  Object.keys(data).forEach(function (k) ***REMOVED***
    if (k === "argv") return
    var val = data[k]
      , isArray = Array.isArray(val)
      , type = types[k]
    if (!isArray) val = [val]
    if (!type) type = typeDefault
    if (type === Array) type = typeDefault.concat(Array)
    if (!Array.isArray(type)) type = [type]

    debug("val=%j", val)
    debug("types=", type)
    val = val.map(function (val) ***REMOVED***
      // if it's an unknown value, then parse false/true/null/numbers/dates
      if (typeof val === "string") ***REMOVED***
        debug("string %j", val)
        val = val.trim()
        if ((val === "null" && ~type.indexOf(null))
            || (val === "true" &&
               (~type.indexOf(true) || ~type.indexOf(Boolean)))
            || (val === "false" &&
               (~type.indexOf(false) || ~type.indexOf(Boolean)))) ***REMOVED***
          val = JSON.parse(val)
          debug("jsonable %j", val)
        ***REMOVED*** else if (~type.indexOf(Number) && !isNaN(val)) ***REMOVED***
          debug("convert to number", val)
          val = +val
        ***REMOVED*** else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) ***REMOVED***
          debug("convert to date", val)
          val = new Date(val)
        ***REMOVED***
      ***REMOVED***

      if (!types.hasOwnProperty(k)) ***REMOVED***
        return val
      ***REMOVED***

      // allow `--no-blah` to set 'blah' to null if null is allowed
      if (val === false && ~type.indexOf(null) &&
          !(~type.indexOf(false) || ~type.indexOf(Boolean))) ***REMOVED***
        val = null
      ***REMOVED***

      var d = ***REMOVED******REMOVED***
      d[k] = val
      debug("prevalidated val", d, val, types[k])
      if (!validate(d, k, val, types[k], typeDefs)) ***REMOVED***
        if (exports.invalidHandler) ***REMOVED***
          exports.invalidHandler(k, val, types[k], data)
        ***REMOVED*** else if (exports.invalidHandler !== false) ***REMOVED***
          debug("invalid: "+k+"="+val, types[k])
        ***REMOVED***
        return remove
      ***REMOVED***
      debug("validated val", d, val, types[k])
      return d[k]
    ***REMOVED***).filter(function (val) ***REMOVED*** return val !== remove ***REMOVED***)

    if (!val.length) delete data[k]
    else if (isArray) ***REMOVED***
      debug(isArray, data[k], val)
      data[k] = val
    ***REMOVED*** else data[k] = val[0]

    debug("k=%s val=%j", k, val, data[k])
  ***REMOVED***)
***REMOVED***

function validateString (data, k, val) ***REMOVED***
  data[k] = String(val)
***REMOVED***

function validatePath (data, k, val) ***REMOVED***
  if (val === true) return false
  if (val === null) return true

  val = String(val)

  var isWin       = process.platform === 'win32'
    , homePattern = isWin ? /^~(\/|\\)/ : /^~\//
    , home        = osenv.home()

  if (home && val.match(homePattern)) ***REMOVED***
    data[k] = path.resolve(home, val.substr(2))
  ***REMOVED*** else ***REMOVED***
    data[k] = path.resolve(val)
  ***REMOVED***
  return true
***REMOVED***

function validateNumber (data, k, val) ***REMOVED***
  debug("validate Number %j %j %j", k, val, isNaN(val))
  if (isNaN(val)) return false
  data[k] = +val
***REMOVED***

function validateDate (data, k, val) ***REMOVED***
  var s = Date.parse(val)
  debug("validate Date %j %j %j", k, val, s)
  if (isNaN(s)) return false
  data[k] = new Date(val)
***REMOVED***

function validateBoolean (data, k, val) ***REMOVED***
  if (val instanceof Boolean) val = val.valueOf()
  else if (typeof val === "string") ***REMOVED***
    if (!isNaN(val)) val = !!(+val)
    else if (val === "null" || val === "false") val = false
    else val = true
  ***REMOVED*** else val = !!val
  data[k] = val
***REMOVED***

function validateUrl (data, k, val) ***REMOVED***
  val = url.parse(String(val))
  if (!val.host) return false
  data[k] = val.href
***REMOVED***

function validateStream (data, k, val) ***REMOVED***
  if (!(val instanceof Stream)) return false
  data[k] = val
***REMOVED***

function validate (data, k, val, type, typeDefs) ***REMOVED***
  // arrays are lists of types.
  if (Array.isArray(type)) ***REMOVED***
    for (var i = 0, l = type.length; i < l; i ++) ***REMOVED***
      if (type[i] === Array) continue
      if (validate(data, k, val, type[i], typeDefs)) return true
    ***REMOVED***
    delete data[k]
    return false
  ***REMOVED***

  // an array of anything?
  if (type === Array) return true

  // NaN is poisonous.  Means that something is not allowed.
  if (type !== type) ***REMOVED***
    debug("Poison NaN", k, val, type)
    delete data[k]
    return false
  ***REMOVED***

  // explicit list of values
  if (val === type) ***REMOVED***
    debug("Explicitly allowed %j", val)
    // if (isArray) (data[k] = data[k] || []).push(val)
    // else data[k] = val
    data[k] = val
    return true
  ***REMOVED***

  // now go through the list of typeDefs, validate against each one.
  var ok = false
    , types = Object.keys(typeDefs)
  for (var i = 0, l = types.length; i < l; i ++) ***REMOVED***
    debug("test type %j %j %j", k, val, types[i])
    var t = typeDefs[types[i]]
    if (t &&
      ((type && type.name && t.type && t.type.name) ? (type.name === t.type.name) : (type === t.type))) ***REMOVED***
      var d = ***REMOVED******REMOVED***
      ok = false !== t.validate(d, k, val)
      val = d[k]
      if (ok) ***REMOVED***
        // if (isArray) (data[k] = data[k] || []).push(val)
        // else data[k] = val
        data[k] = val
        break
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  debug("OK? %j (%j %j %j)", ok, k, val, types[i])

  if (!ok) delete data[k]
  return ok
***REMOVED***

function parse (args, data, remain, types, shorthands) ***REMOVED***
  debug("parse", args, data, remain)

  var key = null
    , abbrevs = abbrev(Object.keys(types))
    , shortAbbr = abbrev(Object.keys(shorthands))

  for (var i = 0; i < args.length; i ++) ***REMOVED***
    var arg = args[i]
    debug("arg", arg)

    if (arg.match(/^-***REMOVED***2,***REMOVED***$/)) ***REMOVED***
      // done with keys.
      // the rest are args.
      remain.push.apply(remain, args.slice(i + 1))
      args[i] = "--"
      break
    ***REMOVED***
    var hadEq = false
    if (arg.charAt(0) === "-" && arg.length > 1) ***REMOVED***
      var at = arg.indexOf('=')
      if (at > -1) ***REMOVED***
        hadEq = true
        var v = arg.substr(at + 1)
        arg = arg.substr(0, at)
        args.splice(i, 1, arg, v)
      ***REMOVED***

      // see if it's a shorthand
      // if so, splice and back up to re-parse it.
      var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs)
      debug("arg=%j shRes=%j", arg, shRes)
      if (shRes) ***REMOVED***
        debug(arg, shRes)
        args.splice.apply(args, [i, 1].concat(shRes))
        if (arg !== shRes[0]) ***REMOVED***
          i --
          continue
        ***REMOVED***
      ***REMOVED***
      arg = arg.replace(/^-+/, "")
      var no = null
      while (arg.toLowerCase().indexOf("no-") === 0) ***REMOVED***
        no = !no
        arg = arg.substr(3)
      ***REMOVED***

      if (abbrevs[arg]) arg = abbrevs[arg]

      var argType = types[arg]
      var isTypeArray = Array.isArray(argType)
      if (isTypeArray && argType.length === 1) ***REMOVED***
        isTypeArray = false
        argType = argType[0]
      ***REMOVED***

      var isArray = argType === Array ||
        isTypeArray && argType.indexOf(Array) !== -1

      // allow unknown things to be arrays if specified multiple times.
      if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) ***REMOVED***
        if (!Array.isArray(data[arg]))
          data[arg] = [data[arg]]
        isArray = true
      ***REMOVED***

      var val
        , la = args[i + 1]

      var isBool = typeof no === 'boolean' ||
        argType === Boolean ||
        isTypeArray && argType.indexOf(Boolean) !== -1 ||
        (typeof argType === 'undefined' && !hadEq) ||
        (la === "false" &&
         (argType === null ||
          isTypeArray && ~argType.indexOf(null)))

      if (isBool) ***REMOVED***
        // just set and move along
        val = !no
        // however, also support --bool true or --bool false
        if (la === "true" || la === "false") ***REMOVED***
          val = JSON.parse(la)
          la = null
          if (no) val = !val
          i ++
        ***REMOVED***

        // also support "foo":[Boolean, "bar"] and "--foo bar"
        if (isTypeArray && la) ***REMOVED***
          if (~argType.indexOf(la)) ***REMOVED***
            // an explicit type
            val = la
            i ++
          ***REMOVED*** else if ( la === "null" && ~argType.indexOf(null) ) ***REMOVED***
            // null allowed
            val = null
            i ++
          ***REMOVED*** else if ( !la.match(/^-***REMOVED***2,***REMOVED***[^-]/) &&
                      !isNaN(la) &&
                      ~argType.indexOf(Number) ) ***REMOVED***
            // number
            val = +la
            i ++
          ***REMOVED*** else if ( !la.match(/^-[^-]/) && ~argType.indexOf(String) ) ***REMOVED***
            // string
            val = la
            i ++
          ***REMOVED***
        ***REMOVED***

        if (isArray) (data[arg] = data[arg] || []).push(val)
        else data[arg] = val

        continue
      ***REMOVED***

      if (argType === String) ***REMOVED***
        if (la === undefined) ***REMOVED***
          la = ""
        ***REMOVED*** else if (la.match(/^-***REMOVED***1,2***REMOVED***[^-]+/)) ***REMOVED***
          la = ""
          i --
        ***REMOVED***
      ***REMOVED***

      if (la && la.match(/^-***REMOVED***2,***REMOVED***$/)) ***REMOVED***
        la = undefined
        i --
      ***REMOVED***

      val = la === undefined ? true : la
      if (isArray) (data[arg] = data[arg] || []).push(val)
      else data[arg] = val

      i ++
      continue
    ***REMOVED***
    remain.push(arg)
  ***REMOVED***
***REMOVED***

function resolveShort (arg, shorthands, shortAbbr, abbrevs) ***REMOVED***
  // handle single-char shorthands glommed together, like
  // npm ls -glp, but only if there is one dash, and only if
  // all of the chars are single-char shorthands, and it's
  // not a match to some other abbrev.
  arg = arg.replace(/^-+/, '')

  // if it's an exact known option, then don't go any further
  if (abbrevs[arg] === arg)
    return null

  // if it's an exact known shortopt, same deal
  if (shorthands[arg]) ***REMOVED***
    // make it an array, if it's a list of words
    if (shorthands[arg] && !Array.isArray(shorthands[arg]))
      shorthands[arg] = shorthands[arg].split(/\s+/)

    return shorthands[arg]
  ***REMOVED***

  // first check to see if this arg is a set of single-char shorthands
  var singles = shorthands.___singles
  if (!singles) ***REMOVED***
    singles = Object.keys(shorthands).filter(function (s) ***REMOVED***
      return s.length === 1
    ***REMOVED***).reduce(function (l,r) ***REMOVED***
      l[r] = true
      return l
    ***REMOVED***, ***REMOVED******REMOVED***)
    shorthands.___singles = singles
    debug('shorthand singles', singles)
  ***REMOVED***

  var chrs = arg.split("").filter(function (c) ***REMOVED***
    return singles[c]
  ***REMOVED***)

  if (chrs.join("") === arg) return chrs.map(function (c) ***REMOVED***
    return shorthands[c]
  ***REMOVED***).reduce(function (l, r) ***REMOVED***
    return l.concat(r)
  ***REMOVED***, [])


  // if it's an arg abbrev, and not a literal shorthand, then prefer the arg
  if (abbrevs[arg] && !shorthands[arg])
    return null

  // if it's an abbr for a shorthand, then use that
  if (shortAbbr[arg])
    arg = shortAbbr[arg]

  // make it an array, if it's a list of words
  if (shorthands[arg] && !Array.isArray(shorthands[arg]))
    shorthands[arg] = shorthands[arg].split(/\s+/)

  return shorthands[arg]
***REMOVED***
