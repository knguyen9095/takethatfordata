'use strict';

var has = Object.prototype.hasOwnProperty;

var hexTable = (function () ***REMOVED***
    var array = [];
    for (var i = 0; i < 256; ++i) ***REMOVED***
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    ***REMOVED***

    return array;
***REMOVED***());

exports.arrayToObject = function (source, options) ***REMOVED***
    var obj = options && options.plainObjects ? Object.create(null) : ***REMOVED******REMOVED***;
    for (var i = 0; i < source.length; ++i) ***REMOVED***
        if (typeof source[i] !== 'undefined') ***REMOVED***
            obj[i] = source[i];
        ***REMOVED***
    ***REMOVED***

    return obj;
***REMOVED***;

exports.merge = function (target, source, options) ***REMOVED***
    if (!source) ***REMOVED***
        return target;
    ***REMOVED***

    if (typeof source !== 'object') ***REMOVED***
        if (Array.isArray(target)) ***REMOVED***
            target.push(source);
        ***REMOVED*** else if (typeof target === 'object') ***REMOVED***
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) ***REMOVED***
                target[source] = true;
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            return [target, source];
        ***REMOVED***

        return target;
    ***REMOVED***

    if (typeof target !== 'object') ***REMOVED***
        return [target].concat(source);
    ***REMOVED***

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) ***REMOVED***
        mergeTarget = exports.arrayToObject(target, options);
    ***REMOVED***

    if (Array.isArray(target) && Array.isArray(source)) ***REMOVED***
        source.forEach(function (item, i) ***REMOVED***
            if (has.call(target, i)) ***REMOVED***
                if (target[i] && typeof target[i] === 'object') ***REMOVED***
                    target[i] = exports.merge(target[i], item, options);
                ***REMOVED*** else ***REMOVED***
                    target.push(item);
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                target[i] = item;
            ***REMOVED***
        ***REMOVED***);
        return target;
    ***REMOVED***

    return Object.keys(source).reduce(function (acc, key) ***REMOVED***
        var value = source[key];

        if (Object.prototype.hasOwnProperty.call(acc, key)) ***REMOVED***
            acc[key] = exports.merge(acc[key], value, options);
        ***REMOVED*** else ***REMOVED***
            acc[key] = value;
        ***REMOVED***
        return acc;
    ***REMOVED***, mergeTarget);
***REMOVED***;

exports.decode = function (str) ***REMOVED***
    try ***REMOVED***
        return decodeURIComponent(str.replace(/\+/g, ' '));
    ***REMOVED*** catch (e) ***REMOVED***
        return str;
    ***REMOVED***
***REMOVED***;

exports.encode = function (str) ***REMOVED***
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) ***REMOVED***
        return str;
    ***REMOVED***

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) ***REMOVED***
        var c = string.charCodeAt(i);

        if (
            c === 0x2D || // -
            c === 0x2E || // .
            c === 0x5F || // _
            c === 0x7E || // ~
            (c >= 0x30 && c <= 0x39) || // 0-9
            (c >= 0x41 && c <= 0x5A) || // a-z
            (c >= 0x61 && c <= 0x7A) // A-Z
        ) ***REMOVED***
            out += string.charAt(i);
            continue;
        ***REMOVED***

        if (c < 0x80) ***REMOVED***
            out = out + hexTable[c];
            continue;
        ***REMOVED***

        if (c < 0x800) ***REMOVED***
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        ***REMOVED***

        if (c < 0xD800 || c >= 0xE000) ***REMOVED***
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        ***REMOVED***

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]; // eslint-disable-line max-len
    ***REMOVED***

    return out;
***REMOVED***;

exports.compact = function (obj, references) ***REMOVED***
    if (typeof obj !== 'object' || obj === null) ***REMOVED***
        return obj;
    ***REMOVED***

    var refs = references || [];
    var lookup = refs.indexOf(obj);
    if (lookup !== -1) ***REMOVED***
        return refs[lookup];
    ***REMOVED***

    refs.push(obj);

    if (Array.isArray(obj)) ***REMOVED***
        var compacted = [];

        for (var i = 0; i < obj.length; ++i) ***REMOVED***
            if (obj[i] && typeof obj[i] === 'object') ***REMOVED***
                compacted.push(exports.compact(obj[i], refs));
            ***REMOVED*** else if (typeof obj[i] !== 'undefined') ***REMOVED***
                compacted.push(obj[i]);
            ***REMOVED***
        ***REMOVED***

        return compacted;
    ***REMOVED***

    var keys = Object.keys(obj);
    keys.forEach(function (key) ***REMOVED***
        obj[key] = exports.compact(obj[key], refs);
    ***REMOVED***);

    return obj;
***REMOVED***;

exports.isRegExp = function (obj) ***REMOVED***
    return Object.prototype.toString.call(obj) === '[object RegExp]';
***REMOVED***;

exports.isBuffer = function (obj) ***REMOVED***
    if (obj === null || typeof obj === 'undefined') ***REMOVED***
        return false;
    ***REMOVED***

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
***REMOVED***;
