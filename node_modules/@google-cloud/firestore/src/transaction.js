/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const is = require('is');

const validate = require('./validate')();

/*!
 * Injected.
 *
 * @see DocumentReference
 */
let DocumentReference;

/*!
 * Injected.
 *
 * @see Query
 */
let Query;

/**
 * A reference to a transaction.
 *
 * The Transaction object passed to a transaction's updateFunction provides
 * the methods to read and write data within the transaction context. See
 * [runTransaction()]***REMOVED***@link Firestore#runTransaction***REMOVED***.
 *
 * @class
 */
class Transaction ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***Firestore***REMOVED*** firestore - The Firestore Database client.
   * @param ***REMOVED***Transaction=***REMOVED*** previousTransaction - If
   * available, the failed transaction that is being retried.
   */
  constructor(firestore, previousTransaction) ***REMOVED***
    this._firestore = firestore;
    this._api = firestore.api;
    this._previousTransaction = previousTransaction;
    this._writeBatch = firestore.batch();
  ***REMOVED***

  /**
   * Retrieve a document or a query result from the database. Holds a
   * pessimistic lock on all returned documents.
   *
   * @param ***REMOVED***DocumentReference|Query***REMOVED*** refOrQuery - The
   * document or query to return.
   * @returns ***REMOVED***Promise***REMOVED*** A Promise that resolves with a DocumentSnapshot or
   * QuerySnapshot for the returned documents.
   *
   * @example
   * firestore.runTransaction(transaction => ***REMOVED***
   *   let documentRef = firestore.doc('col/doc');
   *   return transaction.get(documentRef).then(doc => ***REMOVED***
   *     if (doc.exists) ***REMOVED***
   *       transaction.update(documentRef, ***REMOVED*** count: doc.get('count') + 1 ***REMOVED***);
   *     ***REMOVED*** else ***REMOVED***
   *       transaction.create(documentRef, ***REMOVED*** count: 1 ***REMOVED***);
   *     ***REMOVED***
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  get(refOrQuery) ***REMOVED***
    if (!this._writeBatch.isEmpty) ***REMOVED***
      throw new Error(
        'Firestore transactions require all reads to be ' +
          'executed before all writes.'
      );
    ***REMOVED***

    if (is.instance(refOrQuery, DocumentReference)) ***REMOVED***
      return this._firestore
        .getAll_([refOrQuery], ***REMOVED***transactionId: this._transactionId***REMOVED***)
        .then(res => ***REMOVED***
          return Promise.resolve(res[0]);
        ***REMOVED***);
    ***REMOVED***

    if (is.instance(refOrQuery, Query)) ***REMOVED***
      return refOrQuery._get(***REMOVED***transactionId: this._transactionId***REMOVED***);
    ***REMOVED***

    throw new Error('Argument "refOrQuery" must be a DocumentRef or a Query.');
  ***REMOVED***

  /**
   * Create the document referred to by the provided
   * [DocumentReference]***REMOVED***@link DocumentReference***REMOVED***. The operation will
   * fail the transaction if a document exists at the specified location.
   *
   * @param ***REMOVED***DocumentReference***REMOVED*** documentRef - A reference to the
   * document to be created.
   * @param ***REMOVED***DocumentData***REMOVED*** data - The object data to serialize as the document.
   * @returns ***REMOVED***Transaction***REMOVED*** This Transaction instance. Used for
   * chaining method calls.
   *
   * @example
   * firestore.runTransaction(transaction => ***REMOVED***
   *   let documentRef = firestore.doc('col/doc');
   *   return transaction.get(documentRef).then(doc => ***REMOVED***
   *     if (!doc.exists) ***REMOVED***
   *       transaction.create(documentRef, ***REMOVED*** foo: 'bar' ***REMOVED***);
   *     ***REMOVED***
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  create(documentRef, data) ***REMOVED***
    this._writeBatch.create(documentRef, data);
    return this;
  ***REMOVED***

  /**
   * Writes to the document referred to by the provided
   * [DocumentReference]***REMOVED***@link DocumentReference***REMOVED***. If the document
   * does not exist yet, it will be created. If you pass
   * [SetOptions]***REMOVED***@link SetOptions***REMOVED***, the provided data can be merged into the
   * existing document.
   *
   * @param ***REMOVED***DocumentReference***REMOVED*** documentRef - A reference to the
   * document to be set.
   * @param ***REMOVED***DocumentData***REMOVED*** data - The object to serialize as the document.
   * @param ***REMOVED***SetOptions=***REMOVED*** options - An object to configure the set behavior.
   * @param ***REMOVED***boolean=***REMOVED*** options.merge - If true, set() only replaces the
   * values specified in its data argument. Fields omitted from this set() call
   * remain untouched.
   * @returns ***REMOVED***Transaction***REMOVED*** This Transaction instance. Used for
   * chaining method calls.
   *
   * @example
   * firestore.runTransaction(transaction => ***REMOVED***
   *   let documentRef = firestore.doc('col/doc');
   *   transaction.set(documentRef, ***REMOVED*** foo: 'bar' ***REMOVED***);
   *   return Promise.resolve();
   * ***REMOVED***);
   */
  set(documentRef, data, options) ***REMOVED***
    this._writeBatch.set(documentRef, data, options);
    return this;
  ***REMOVED***

  /**
   * Updates fields in the document referred to by the provided
   * [DocumentReference]***REMOVED***@link DocumentReference***REMOVED***. The update will
   * fail if applied to a document that does not exist.
   *
   * The update() method accepts either an object with field paths encoded as
   * keys and field values encoded as values, or a variable number of arguments
   * that alternate between field paths and field values. Nested fields can be
   * updated by providing dot-separated field path strings or by providing
   * FieldPath objects.
   *
   * A Precondition restricting this update can be specified as the last
   * argument.
   *
   * @param ***REMOVED***DocumentReference***REMOVED*** documentRef - A reference to the
   * document to be updated.
   * @param ***REMOVED***UpdateData|string|FieldPath***REMOVED*** dataOrField - An object
   * containing the fields and values with which to update the document
   * or the path of the first field to update.
   * @param ***REMOVED***
   * ...(Precondition|*|string|FieldPath)***REMOVED*** preconditionOrValues -
   * An alternating list of field paths and values to update or a Precondition
   * to to enforce on this update.
   * @returns ***REMOVED***Transaction***REMOVED*** This Transaction instance. Used for
   * chaining method calls.
   *
   * @example
   * firestore.runTransaction(transaction => ***REMOVED***
   *   let documentRef = firestore.doc('col/doc');
   *   return transaction.get(documentRef).then(doc => ***REMOVED***
   *     if (doc.exists) ***REMOVED***
   *       transaction.update(documentRef, ***REMOVED*** count: doc.get('count') + 1 ***REMOVED***);
   *     ***REMOVED*** else ***REMOVED***
   *       transaction.create(documentRef, ***REMOVED*** count: 1 ***REMOVED***);
   *     ***REMOVED***
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  update(documentRef, dataOrField, preconditionOrValues) ***REMOVED***
    validate.minNumberOfArguments('update', arguments, 2);

    preconditionOrValues = Array.prototype.slice.call(arguments, 2);
    this._writeBatch.update.apply(
      this._writeBatch,
      [documentRef, dataOrField].concat(preconditionOrValues)
    );
    return this;
  ***REMOVED***

  /**
   * Deletes the document referred to by the provided [DocumentReference]
   * ***REMOVED***@link DocumentReference***REMOVED***.
   *
   * @param ***REMOVED***DocumentReference***REMOVED*** documentRef - A reference to the
   * document to be deleted.
   * @param ***REMOVED***Precondition=***REMOVED*** precondition - A precondition to enforce for this
   * delete.
   * @param ***REMOVED***string=***REMOVED*** precondition.lastUpdateTime If set, enforces that the
   * document was last updated at lastUpdateTime (as ISO 8601 string). Fails the
   * transaction if the document doesn't exist or was last updated at a
   * different time.
   * @returns ***REMOVED***Transaction***REMOVED*** This Transaction instance. Used for
   * chaining method calls.
   *
   * @example
   * firestore.runTransaction(transaction => ***REMOVED***
   *   let documentRef = firestore.doc('col/doc');
   *   transaction.delete(documentRef);
   *   return Promise.resolve();
   * ***REMOVED***);
   */
  delete(documentRef, precondition) ***REMOVED***
    this._writeBatch.delete(documentRef, precondition);
    return this;
  ***REMOVED***

  /**
   * Starts a transaction and obtains the transaction id from the server.
   *
   * @private
   * @returns ***REMOVED***Promise***REMOVED*** An empty Promise.
   */
  begin() ***REMOVED***
    let request = ***REMOVED***
      database: this._firestore.formattedName,
    ***REMOVED***;

    if (this._previousTransaction) ***REMOVED***
      request.options = ***REMOVED***
        readWrite: ***REMOVED***
          retryTransaction: this._previousTransaction._transactionId,
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***

    return this._firestore
      .request(
        this._api.Firestore.beginTransaction.bind(this._api.Firestore),
        request,
        /* allowRetries= */ true
      )
      .then(resp => ***REMOVED***
        this._transactionId = resp.transaction;
      ***REMOVED***);
  ***REMOVED***

  /**
   * Commits all queued-up changes in this transaction and releases all locks.
   *
   * @private
   * @returns ***REMOVED***Promise***REMOVED*** An empty Promise.
   */
  commit() ***REMOVED***
    return this._writeBatch.commit_(***REMOVED***transactionId: this._transactionId***REMOVED***);
  ***REMOVED***

  /**
   * Releases all locks and rolls back this transaction.
   *
   * @private
   * @returns ***REMOVED***Promise***REMOVED*** An empty Promise.
   */
  rollback() ***REMOVED***
    let request = ***REMOVED***
      database: this._firestore.formattedName,
      transaction: this._transactionId,
    ***REMOVED***;

    return this._firestore.request(
      this._api.Firestore.rollback.bind(this._api.Firestore),
      request
    );
  ***REMOVED***
***REMOVED***

module.exports = FirestoreType => ***REMOVED***
  let reference = require('./reference')(FirestoreType);
  DocumentReference = reference.DocumentReference;
  Query = reference.Query;
  let document = require('./document')(DocumentReference);
  require('./validate')(***REMOVED***
    Document: document.validateDocumentData,
    DocumentReference: reference.validateDocumentReference,
    Precondition: document.validatePrecondition,
  ***REMOVED***);
  return Transaction;
***REMOVED***;
