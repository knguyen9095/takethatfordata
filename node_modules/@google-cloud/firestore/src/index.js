/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const bun = require('bun');
const common = require('@google-cloud/common');
const commonGrpc = require('@google-cloud/common-grpc');
const extend = require('extend');
const is = require('is');
const through = require('through2');
const util = require('util');

const v1beta1 = require('./v1beta1');
const libVersion = require('../package.json').version;

const path = require('./path');
const convert = require('./convert');

/*!
 * DO NOT REMOVE THE FOLLOWING NAMESPACE DEFINITIONS
 */

/**
 * @namespace google.protobuf
 */

/**
 * @namespace google.rpc
 */

/**
 * @namespace google.firestore.v1beta1
 */

/*!
 * @see ResourcePath
 */
const ResourcePath = path.ResourcePath;

/*!
 * @see ResourcePath
 */
const FieldPath = path.FieldPath;

/*!
 * @see FieldValue
 */
const FieldValue = require('./field-value');

/*!
 * @see CollectionReference
 */
let CollectionReference;

/*!
 * @see DocumentReference
 */
let DocumentReference;

/*!
 * @see DocumentSnapshot
 */
let DocumentSnapshot;

/*!
 * @see GeoPoint
 */
let GeoPoint;

/*! Injected. */
let validate;

/*!
 * @see WriteBatch
 */
let WriteBatch;

/*!
 * @see Transaction
 */
let Transaction;

/*!
 * HTTP header for the resource prefix to improve routing and project isolation
 * by the backend.
 * @type ***REMOVED***string***REMOVED***
 */
const CLOUD_RESOURCE_HEADER = 'google-cloud-resource-prefix';

/*!
 * The maximum number of times to retry idempotent requests.
 * @type ***REMOVED***number***REMOVED***
 */
const MAX_REQUEST_RETRIES = 5;

/*!
 * GRPC Error code for 'UNAVAILABLE'.
 * @type ***REMOVED***number***REMOVED***
 */
const GRPC_UNAVAILABLE = 14;

/**
 * Document data (e.g. for use with
 * [set()]***REMOVED***@link DocumentReference#set***REMOVED***) consisting of fields mapped
 * to values.
 *
 * @typedef ***REMOVED***Object.<string, *>***REMOVED*** DocumentData
 */

/**
 * Update data (for use with [update]***REMOVED***@link DocumentReference#update***REMOVED***)
 * that contains paths (e.g. 'foo' or 'foo.baz') mapped to values. Fields that
 * contain dots reference nested fields within the document.
 *
 * @typedef ***REMOVED***Object.<string, *>***REMOVED*** UpdateData
 */

/**
 * An options object that configures conditional behavior of
 * [update()]***REMOVED***@link DocumentReference#update***REMOVED*** and
 * [delete()]***REMOVED***@link DocumentReference#delete***REMOVED*** calls in
 * [DocumentReference]***REMOVED***@link DocumentReference***REMOVED***,
 * [WriteBatch]***REMOVED***@link WriteBatch***REMOVED***, and
 * [Transaction]***REMOVED***@link Transaction***REMOVED***. Using Preconditions, these calls
 * can be restricted to only apply to documents that match the specified
 * conditions.
 *
 * @property ***REMOVED***string***REMOVED*** lastUpdateTime - The update time to enforce (specified as
 * an ISO 8601 string).
 * @typedef ***REMOVED***Object***REMOVED*** Precondition
 */

/**
 * An options object that configures the behavior of
 * [set()]***REMOVED***@link DocumentReference#set***REMOVED*** calls in
 * [DocumentReference]***REMOVED***@link DocumentReference***REMOVED***,
 * [WriteBatch]***REMOVED***@link WriteBatch***REMOVED***, and
 * [Transaction]***REMOVED***@link Transaction***REMOVED***. These calls can be
 * configured to perform granular merges instead of overwriting the target
 * documents in their entirety by providing a SetOptions object with
 * ***REMOVED*** merge : true ***REMOVED***.
 *
 * @property ***REMOVED***boolean***REMOVED*** merge - Changes the behavior of a set() call to only
 * replace the values specified in its data argument. Fields omitted from the
 * set() call remain untouched.
 * @typedef ***REMOVED***Object***REMOVED*** SetOptions
 */

/**
 * The Firestore client represents a Firestore Database and is the entry point
 * for all Firestore operations.
 *
 * @see [Firestore Documentation]***REMOVED***@link https://firebase.google.com/docs/firestore/***REMOVED***
 *
 * @class
 *
 * @example <caption>Install the client library with <a href="https://www.npmjs.com/">npm</a>:</caption>
 * npm install --save @google-cloud/firestore
 *
 * @example <caption>Import the client library</caption>
 * var Firestore = require('@google-cloud/firestore');
 *
 * @example <caption>Create a client that uses <a href="https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application">Application Default Credentials (ADC)</a>:</caption>
 * var firestore = new Firestore();
 *
 * @example <caption>Create a client with <a href="https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually">explicit credentials</a>:</caption>
 * var firestore = new Firestore(***REMOVED***
 *   projectId: 'your-project-id',
 *   keyFilename: '/path/to/keyfile.json'
 * ***REMOVED***);
 *
 * @example <caption>include:samples/quickstart.js</caption>
 * region_tag:firestore_quickstart
 * Full quickstart example:
 */
class Firestore extends commonGrpc.Service ***REMOVED***
  /**
   * @param ***REMOVED***Object=***REMOVED*** options - [Configuration object](#/docs).
   */
  constructor(options) ***REMOVED***
    let config = ***REMOVED***
      service: 'firestore',
      apiVersion: 'v1beta1',
      protoServices: ***REMOVED******REMOVED***,
      packageJson: require('../package.json'),
    ***REMOVED***;

    options = extend(***REMOVED******REMOVED***, options, ***REMOVED***
      libName: 'gccl',
      libVersion: libVersion,
    ***REMOVED***);

    super(config, options);

    // GCF currently tears down idle connections after two minutes. Requests
    // that are issued after this period may fail. On GCF, we therefore issue
    // these requests as part of a transaction so that we can safely retry until
    // the network link is reestablished.
    //
    // The environment variable FUNCTION_TRIGGER_TYPE is used to detect the GCF
    // environment.
    this._preferTransactions = is.defined(process.env.FUNCTION_TRIGGER_TYPE);
    this._lastSuccessfulRequest = null;

    if (this._preferTransactions) ***REMOVED***
      Firestore.log('Firestore', 'Detected GCF environment');
    ***REMOVED***

    /**
     * @private
     * @type ***REMOVED***object***REMOVED***
     * @property ***REMOVED***FirestoreClient***REMOVED*** Firestore The Firestore GAPIC client.
     */
    this.api = ***REMOVED***
      Firestore: v1beta1(options).firestoreClient(options),
    ***REMOVED***;

    this._referencePath = new ResourcePath('***REMOVED******REMOVED***projectId***REMOVED******REMOVED***', '(default)');

    if (options) ***REMOVED***
      if (options.projectId) ***REMOVED***
        validate.isString('options.projectId', options.projectId);
        this._referencePath = new ResourcePath(options.projectId, '(default)');
      ***REMOVED***
    ***REMOVED***

    Firestore.log('Firestore', 'Initialized Firestore');
  ***REMOVED***

  /**
   * The root path to the database.
   *
   * @private
   * @type ***REMOVED***string***REMOVED***
   */
  get formattedName() ***REMOVED***
    return this._referencePath.formattedName;
  ***REMOVED***

  /**
   * Gets a [DocumentReference]***REMOVED***@link DocumentReference***REMOVED*** instance that
   * refers to the document at the specified path.
   *
   * @param ***REMOVED***string***REMOVED*** documentPath - A slash-separated path to a document.
   * @returns ***REMOVED***DocumentReference***REMOVED*** The
   * [DocumentReference]***REMOVED***@link DocumentReference***REMOVED*** instance.
   *
   * @example
   * let documentRef = firestore.doc('collection/document');
   * console.log(`Path of document is $***REMOVED***documentRef.path***REMOVED***`);
   */
  doc(documentPath) ***REMOVED***
    validate.isResourcePath('documentPath', documentPath);

    let path = this._referencePath.append(documentPath);
    if (!path.isDocument) ***REMOVED***
      throw new Error(
        `Argument "documentPath" must point to a document, but was "$***REMOVED***documentPath***REMOVED***". Your path does not contain an even number of components.`
      );
    ***REMOVED***

    return new DocumentReference(this, path);
  ***REMOVED***

  /**
   * Gets a [CollectionReference]***REMOVED***@link CollectionReference***REMOVED*** instance
   * that refers to the collection at the specified path.
   *
   * @param ***REMOVED***string***REMOVED*** collectionPath - A slash-separated path to a collection.
   * @returns ***REMOVED***CollectionReference***REMOVED*** The
   * [CollectionReference]***REMOVED***@link CollectionReference***REMOVED*** instance.
   *
   * @example
   * let collectionRef = firestore.collection('collection');
   *
   * // Add a document with an auto-generated ID.
   * collectionRef.add(***REMOVED***foo: 'bar'***REMOVED***).then((documentRef) => ***REMOVED***
   *   console.log(`Added document at $***REMOVED***documentRef.path***REMOVED***)`);
   * ***REMOVED***);
   */
  collection(collectionPath) ***REMOVED***
    validate.isResourcePath('collectionPath', collectionPath);

    let path = this._referencePath.append(collectionPath);
    if (!path.isCollection) ***REMOVED***
      throw new Error(
        `Argument "collectionPath" must point to a collection, but was "$***REMOVED***collectionPath***REMOVED***". Your path does not contain an odd number of components.`
      );
    ***REMOVED***

    return new CollectionReference(this, path);
  ***REMOVED***

  /**
   * Creates a [WriteBatch]***REMOVED***@link WriteBatch***REMOVED***, used for performing
   * multiple writes as a single atomic operation.
   *
   * @returns ***REMOVED***WriteBatch***REMOVED*** A WriteBatch that operates on this Firestore
   * client.
   *
   * @example
   * let writeBatch = firestore.batch();
   *
   * // Add two documents in an atomic batch.
   * let data = ***REMOVED*** foo: 'bar' ***REMOVED***;
   * writeBatch.set(firestore.doc('col/doc1'), data);
   * writeBatch.set(firestore.doc('col/doc2'), data);
   *
   * writeBatch.commit().then(res => ***REMOVED***
   *   console.log(`Added document at $***REMOVED***res.writeResults[0].updateTime***REMOVED***`);
   * ***REMOVED***);
   */
  batch() ***REMOVED***
    return new WriteBatch(this);
  ***REMOVED***

  /**
   * Creates a [DocumentSnapshot]***REMOVED***@link DocumentSnapshot***REMOVED*** or a
   * [QueryDocumentSnapshot]***REMOVED***@link QueryDocumentSnapshot***REMOVED*** from a
   * `firestore.v1beta1.Document` proto (or from a resource name for missing
   * documents).
   *
   * This API is used by Google Cloud Functions and can be called with both
   * 'Proto3 JSON' and 'Protobuf JS' encoded data.
   *
   * @private
   * @param ***REMOVED***object|string***REMOVED*** documentOrName - The Firestore 'Document' proto or
   * the resource name of a missing document.
   * @param ***REMOVED***object=***REMOVED*** readTime - A 'Timestamp' proto indicating the time this
   * document was read.
   * @param ***REMOVED***string=***REMOVED*** encoding - One of 'json' or 'protobufJS'. Applies to both
   * the 'document' Proto and 'readTime'. Defaults to 'protobufJS'.
   * @returns ***REMOVED***DocumentSnapshot|QueryDocumentSnapshot***REMOVED*** - A QueryDocumentSnapshot
   * for existing documents, otherwise a DocumentSnapshot.
   */
  snapshot_(documentOrName, readTime, encoding) ***REMOVED***
    let convertTimestamp;
    let convertDocument;

    if (!is.defined(encoding) || encoding === 'protobufJS') ***REMOVED***
      convertTimestamp = data => data;
      convertDocument = data => data;
    ***REMOVED*** else if (encoding === 'json') ***REMOVED***
      // Google Cloud Functions calls us with Proto3 JSON format data, which we
      // must convert to Protobuf JS.
      convertTimestamp = convert.timestampFromJson;
      convertDocument = convert.documentFromJson;
    ***REMOVED*** else ***REMOVED***
      throw new Error(
        `Unsupported encoding format. Expected 'json' or 'protobufJS', ` +
          `but was '$***REMOVED***encoding***REMOVED***'.`
      );
    ***REMOVED***

    const document = new DocumentSnapshot.Builder();

    if (is.string(documentOrName)) ***REMOVED***
      document.ref = new DocumentReference(
        this,
        ResourcePath.fromSlashSeparatedString(documentOrName)
      );
    ***REMOVED*** else ***REMOVED***
      document.ref = new DocumentReference(
        this,
        ResourcePath.fromSlashSeparatedString(documentOrName.name)
      );
      document.fieldsProto = documentOrName.fields
        ? convertDocument(documentOrName.fields)
        : ***REMOVED******REMOVED***;
      document.createTime = DocumentSnapshot.toISOTime(
        convertTimestamp(documentOrName.createTime, 'documentOrName.createTime')
      );
      document.updateTime = DocumentSnapshot.toISOTime(
        convertTimestamp(documentOrName.updateTime, 'documentOrName.updateTime')
      );
    ***REMOVED***

    document.readTime = DocumentSnapshot.toISOTime(
      convertTimestamp(readTime, 'readTime')
    );

    return document.build();
  ***REMOVED***

  /**
   * Executes the given updateFunction and commits the changes applied within
   * the transaction.
   *
   * You can use the transaction object passed to 'updateFunction' to read and
   * modify Firestore documents under lock. Transactions are committed once
   * 'updateFunction' resolves and attempted up to five times on failure.
   *
   * @param ***REMOVED***function(Transaction)***REMOVED*** updateFunction - The
   * function to execute within the transaction
   * context.
   * @param ***REMOVED***object=***REMOVED*** transactionOptions - Transaction options.
   * @param ***REMOVED***number=***REMOVED*** transactionOptions.maxAttempts - The maximum number of
   * attempts for this transaction.
   * @returns ***REMOVED***Promise***REMOVED*** If the transaction completed successfully or was
   * explicitly aborted (by the updateFunction returning a failed Promise), the
   * Promise returned by the updateFunction will be returned here. Else if the
   * transaction failed, a rejected Promise with the corresponding failure
   * error will be returned.
   *
   * @example
   * let counterTransaction = firestore.runTransaction(transaction => ***REMOVED***
   *   let documentRef = firestore.doc('col/doc');
   *   return transaction.get(documentRef).then(doc => ***REMOVED***
   *     if (doc.exists) ***REMOVED***
   *       let count =  doc.get('count') || 0;
   *       if (count > 10) ***REMOVED***
   *         return Promise.reject('Reached maximum count');
   *       ***REMOVED***
   *       transaction.update(documentRef, ***REMOVED*** count: ++count ***REMOVED***);
   *       return Promise.resolve(count);
   *     ***REMOVED***
   *
   *     transaction.create(documentRef, ***REMOVED*** count: 1 ***REMOVED***);
   *     return Promise.resolve(1);
   *   ***REMOVED***);
   * ***REMOVED***);
   *
   * counterTransaction.then(res => ***REMOVED***
   *   console.log(`Count updated to $***REMOVED***res***REMOVED***`);
   * ***REMOVED***);
   */
  runTransaction(updateFunction, transactionOptions) ***REMOVED***
    validate.isFunction('updateFunction', updateFunction);

    const defaultAttempts = 5;

    let attemptsRemaining = defaultAttempts;
    let previousTransaction;

    if (is.defined(transactionOptions)) ***REMOVED***
      validate.isObject('transactionOptions', transactionOptions);
      validate.isOptionalInteger(
        'transactionOptions.maxAttempts',
        transactionOptions.maxAttempts,
        1
      );

      attemptsRemaining = transactionOptions.maxAttempts || attemptsRemaining;
      previousTransaction = transactionOptions.previousTransaction;
    ***REMOVED***

    let transaction = new Transaction(this, previousTransaction);
    let result;

    --attemptsRemaining;

    return transaction
      .begin()
      .then(() => ***REMOVED***
        let promise = updateFunction(transaction);
        result = is.instanceof(promise, Promise)
          ? promise
          : Promise.reject(
              new Error(
                'You must return a Promise in your transaction()-callback.'
              )
            );
        return result.catch(err => ***REMOVED***
          Firestore.log(
            'Firestore.runTransaction',
            'Rolling back transaction after callback error:',
            err
          );
          // Rollback the transaction and return the failed result.
          return transaction.rollback().then(() => ***REMOVED***
            return result;
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***)
      .then(() => ***REMOVED***
        return transaction
          .commit()
          .then(() => result)
          .catch(err => ***REMOVED***
            if (attemptsRemaining > 0) ***REMOVED***
              Firestore.log(
                'Firestore.runTransaction',
                `Retrying transaction after error: $***REMOVED***JSON.stringify(err)***REMOVED***.`
              );
              return this.runTransaction(updateFunction, ***REMOVED***
                previousTransaction: transaction,
                maxAttempts: attemptsRemaining,
              ***REMOVED***);
            ***REMOVED***
            Firestore.log(
              'Firestore.runTransaction',
              'Exhausted transaction retries, returning error: %s',
              err
            );
            return Promise.reject(err);
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***

  /**
   * Fetches the root collections that are associated with this Firestore
   * database.
   *
   * @returns ***REMOVED***Promise.<Array.<CollectionReference>>***REMOVED*** A Promise that resolves
   * with an array of CollectionReferences.
   *
   * @example
   * firestore.getCollections().then(collections => ***REMOVED***
   *   for (let collection of collections) ***REMOVED***
   *     console.log(`Found collection with id: $***REMOVED***collection.id***REMOVED***`);
   *   ***REMOVED***
   * ***REMOVED***);
   */
  getCollections() ***REMOVED***
    let rootDocument = new DocumentReference(this, this._referencePath);
    return rootDocument.getCollections();
  ***REMOVED***

  /**
   * Retrieves multiple documents from Firestore.
   *
   * @param ***REMOVED***...DocumentReference***REMOVED*** documents - The document references
   * to receive.
   * @returns ***REMOVED***Promise<Array.<DocumentSnapshot>>***REMOVED*** A Promise that
   * contains an array with the resulting document snapshots.
   *
   * @example
   * let documentRef1 = firestore.doc('col/doc1');
   * let documentRef2 = firestore.doc('col/doc2');
   *
   * firestore.getAll(documentRef1, documentRef2).then(docs => ***REMOVED***
   *   console.log(`First document: $***REMOVED***JSON.stringify(docs[0])***REMOVED***`);
   *   console.log(`Second document: $***REMOVED***JSON.stringify(docs[1])***REMOVED***`);
   * ***REMOVED***);
   */
  getAll(documents) ***REMOVED***
    documents = is.array(arguments[0])
      ? arguments[0].slice()
      : Array.prototype.slice.call(arguments);

    for (let i = 0; i < documents.length; ++i) ***REMOVED***
      validate.isDocumentReference(i, documents[i]);
    ***REMOVED***

    return this.getAll_(documents, null);
  ***REMOVED***

  /**
   * Internal method to retrieve multiple documents from Firestore, optionally
   * as part of a transaction.
   *
   * @private
   * @param ***REMOVED***Array.<DocumentReference>***REMOVED*** docRefs - The documents
   * to receive.
   * @param ***REMOVED***object=***REMOVED*** readOptions - The options to use for this request.
   * @param ***REMOVED***bytes|null***REMOVED*** readOptions.transactionId - The transaction ID to use
   * for this read.
   * @returns ***REMOVED***Array.<DocumentSnapshot>***REMOVED*** A Promise that contains an array with
   * the resulting documents.
   */
  getAll_(docRefs, readOptions) ***REMOVED***
    const requestedDocuments = new Set();
    const retrievedDocuments = new Map();

    let request = ***REMOVED***
      database: this.formattedName,
    ***REMOVED***;

    for (let docRef of docRefs) ***REMOVED***
      requestedDocuments.add(docRef.formattedName);
    ***REMOVED***
    request.documents = Array.from(requestedDocuments);

    if (readOptions && readOptions.transactionId) ***REMOVED***
      request.transaction = readOptions.transactionId;
    ***REMOVED***

    let self = this;

    return self
      .readStream(
        this.api.Firestore.batchGetDocuments.bind(this.api.Firestore),
        request,
        /* allowRetries= */ true
      )
      .then(stream => ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
          stream
            .on('error', err => ***REMOVED***
              Firestore.log(
                'Firestore.getAll_',
                'GetAll failed with error:',
                err
              );
              reject(err);
            ***REMOVED***)
            .on('data', response => ***REMOVED***
              try ***REMOVED***
                let document;

                if (response.found) ***REMOVED***
                  Firestore.log(
                    'Firestore.getAll_',
                    'Received document: %s',
                    response.found.name
                  );
                  document = self.snapshot_(response.found, response.readTime);
                ***REMOVED*** else ***REMOVED***
                  Firestore.log(
                    'Firestore.getAll_',
                    'Document missing: %s',
                    response.missing
                  );
                  document = self.snapshot_(
                    response.missing,
                    response.readTime
                  );
                ***REMOVED***

                let path = document.ref.path;
                retrievedDocuments.set(path, document);
              ***REMOVED*** catch (err) ***REMOVED***
                Firestore.log(
                  'Firestore.getAll_',
                  'GetAll failed with exception:',
                  err
                );
                reject(err);
              ***REMOVED***
            ***REMOVED***)
            .on('end', () => ***REMOVED***
              Firestore.log(
                'Firestore.getAll_',
                'Received %d results',
                retrievedDocuments.size
              );

              // BatchGetDocuments doesn't preserve document order. We use the
              // request order to sort the resulting documents.
              const orderedDocuments = [];
              for (let docRef of docRefs) ***REMOVED***
                let document = retrievedDocuments.get(docRef.path);
                if (!is.defined(document)) ***REMOVED***
                  reject(
                    new Error(`Did not receive document for "$***REMOVED***docRef.path***REMOVED***".`)
                  );
                ***REMOVED***
                orderedDocuments.push(document);
              ***REMOVED***
              resolve(orderedDocuments);
            ***REMOVED***);
          stream.resume();
        ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***

  /**
   * Generate a unique client-side identifier.
   *
   * Used for the creation of new documents.
   *
   * @private
   * @returns ***REMOVED***string***REMOVED*** A unique 20-character wide identifier.
   */
  static autoId() ***REMOVED***
    let chars =
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let autoId = '';
    for (let i = 0; i < 20; i++) ***REMOVED***
      autoId += chars.charAt(Math.floor(Math.random() * chars.length));
    ***REMOVED***
    return autoId;
  ***REMOVED***

  /**
   * Decorate all request options before being sent with to an API request. This
   * is used to replace any `***REMOVED******REMOVED***projectId***REMOVED******REMOVED***` placeholders with the value detected
   * from the user's environment, if one wasn't provided manually.
   *
   * @private
   */
  _decorateRequest(request) ***REMOVED***
    let self = this;

    function decorate() ***REMOVED***
      return new Promise(resolve => ***REMOVED***
        let decoratedRequest = extend(true, ***REMOVED******REMOVED***, request);
        decoratedRequest = common.util.replaceProjectIdToken(
          decoratedRequest,
          self._referencePath.projectId
        );

        let decoratedGax = ***REMOVED***otherArgs: ***REMOVED***headers: ***REMOVED******REMOVED******REMOVED******REMOVED***;
        decoratedGax.otherArgs.headers[CLOUD_RESOURCE_HEADER] =
          self.formattedName;

        resolve(***REMOVED***request: decoratedRequest, gax: decoratedGax***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

    if (this._referencePath.projectId !== '***REMOVED******REMOVED***projectId***REMOVED******REMOVED***') ***REMOVED***
      return decorate();
    ***REMOVED***

    return new Promise((resolve, reject) => ***REMOVED***
      this.api.Firestore.getProjectId((err, projectId) => ***REMOVED***
        if (err) ***REMOVED***
          Firestore.log(
            'Firestore._decorateRequest',
            'Failed to detect project ID: %s',
            err
          );
          reject(err);
        ***REMOVED*** else ***REMOVED***
          Firestore.log(
            'Firestore._decorateRequest',
            'Detected project ID: %s',
            projectId
          );
          self._referencePath = new ResourcePath(
            projectId,
            self._referencePath.databaseId
          );
          decorate()
            .then(resolve)
            .catch(reject);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * A function returning a Promise that can be retried.
   *
   * @private
   * @callback retryFunction
   * @returns ***REMOVED***Promise***REMOVED*** A Promise indicating the function's success.
   */

  /**
   * Helper method that retries failed Promises.
   *
   * If 'delayMs' is specified, waits 'delayMs' between invocations. Otherwise,
   * schedules the first attempt immediately, and then waits 100 milliseconds
   * for further attempts.
   *
   * @private
   * @param ***REMOVED***number***REMOVED*** attemptsRemaining - The number of available attempts.
   * @param ***REMOVED***retryFunction***REMOVED*** func - Method returning a Promise than can be
   * retried.
   * @param ***REMOVED***number=***REMOVED*** delayMs - How long to wait before issuing a this retry.
   * Defaults to zero.
   * @returns ***REMOVED***Promise***REMOVED*** - A Promise with the function's result if successful
   * within `attemptsRemaining`. Otherwise, returns the last rejected Promise.
   */
  _retry(attemptsRemaining, func, delayMs) ***REMOVED***
    let self = this;

    let currentDelay = delayMs || 0;
    let nextDelay = delayMs || 100;

    --attemptsRemaining;

    return new Promise(resolve => ***REMOVED***
      setTimeout(resolve, currentDelay);
    ***REMOVED***)
      .then(func)
      .then(result => ***REMOVED***
        self._lastSuccessfulRequest = new Date().getTime();
        return result;
      ***REMOVED***)
      .catch(err => ***REMOVED***
        if (is.defined(err.code) && err.code !== GRPC_UNAVAILABLE) ***REMOVED***
          Firestore.log(
            'Firestore._retry',
            'Request failed with unrecoverable error:',
            err
          );
          return Promise.reject(err);
        ***REMOVED***
        if (attemptsRemaining === 0) ***REMOVED***
          Firestore.log('Firestore._retry', 'Request failed with error:', err);
          return Promise.reject(err);
        ***REMOVED***
        Firestore.log(
          'Firestore._retry',
          'Retrying request that failed with error:',
          err
        );
        return self._retry(attemptsRemaining, func, nextDelay);
      ***REMOVED***);
  ***REMOVED***

  /**
   * Opens the provided stream and waits for it to become healthy. If an error
   * occurs before the first byte is read, the method rejects the returned
   * Promise.
   *
   * @private
   * @param ***REMOVED***Stream***REMOVED*** resultStream - The Node stream to monitor.
   * @param ***REMOVED***Object=***REMOVED*** request - If specified, the request that should be written
   * to the stream after it opened.
   * @returns ***REMOVED***Promise.<Stream>***REMOVED*** The given Stream once it is considered healthy.
   */
  _initializeStream(resultStream, request) ***REMOVED***
    /** The last error we received and have not forwarded yet. */
    let errorReceived = null;

    /**
     * Whether we have resolved the Promise and returned the stream to the
     * caller.
     */
    let streamReleased = false;

    /**
     * Whether the stream end has been reached. This has to be forwarded to the
     * caller..
     */
    let endCalled = false;

    return new Promise((resolve, reject) => ***REMOVED***
      const releaseStream = () => ***REMOVED***
        if (errorReceived) ***REMOVED***
          Firestore.log(
            'Firestore._initializeStream',
            'Emit error:',
            errorReceived
          );
          resultStream.emit('error', errorReceived);
          errorReceived = null;
        ***REMOVED*** else if (!streamReleased) ***REMOVED***
          Firestore.log('Firestore._initializeStream', 'Releasing stream');
          streamReleased = true;
          resultStream.pause();

          // Calling 'stream.pause()' only holds up 'data' events and not the
          // 'end' event we intend to forward here. We therefore need to wait
          // until the API consumer registers their listeners (in the .then()
          // call) before emitting any further events.
          resolve(resultStream);

          // We execute the forwarding of the 'end' event via setTimeout() as
          // V8 guarantees that the above the Promise chain is resolved before
          // any calls invoked via setTimeout().
          setTimeout(() => ***REMOVED***
            if (endCalled) ***REMOVED***
              Firestore.log(
                'Firestore._initializeStream',
                'Forwarding stream close'
              );
              resultStream.emit('end');
            ***REMOVED***
          ***REMOVED***, 0);
        ***REMOVED***
      ***REMOVED***;

      // We capture any errors received and buffer them until the caller has
      // registered a listener. We register our event handler as early as
      // possible to avoid the default stream behavior (which is just to log and
      // continue).
      resultStream.on('readable', () => ***REMOVED***
        releaseStream();
      ***REMOVED***);

      resultStream.on('end', () => ***REMOVED***
        Firestore.log('Firestore._initializeStream', 'Received stream end');
        endCalled = true;
        releaseStream();
      ***REMOVED***);

      resultStream.on('error', err => ***REMOVED***
        Firestore.log(
          'Firestore._initializeStream',
          'Received stream error:',
          err
        );
        // If we receive an error before we were able to receive any data,
        // reject this stream.
        if (!streamReleased) ***REMOVED***
          Firestore.log(
            'Firestore._initializeStream',
            'Received initial error:',
            err
          );
          streamReleased = true;
          reject(err);
        ***REMOVED*** else ***REMOVED***
          errorReceived = err;
        ***REMOVED***
      ***REMOVED***);

      if (is.defined(request)) ***REMOVED***
        Firestore.log(
          'Firestore._initializeStream',
          'Sending request: %j',
          request
        );
        resultStream.write(request, 'utf-8', () => ***REMOVED***
          Firestore.log(
            'Firestore._initializeStream',
            'Marking stream as healthy'
          );
          releaseStream();
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  /**
   * A funnel for all non-streaming API requests, assigning a project ID where
   * necessary within the request options.
   *
   * @private
   * @param ***REMOVED***function***REMOVED*** method - Veneer API endpoint that takes a request and
   * GAX options.
   * @param ***REMOVED***Object***REMOVED*** request - The Protobuf request to send.
   * @param ***REMOVED***boolean***REMOVED*** allowRetries - Whether this is an idempotent request that
   * can be retried.
   * @returns ***REMOVED***Promise.<Object>***REMOVED*** A Promise with the request result.
   */
  request(method, request, allowRetries) ***REMOVED***
    let attempts = allowRetries ? MAX_REQUEST_RETRIES : 1;

    return this._decorateRequest(request).then(decorated => ***REMOVED***
      return this._retry(attempts, () => ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
          Firestore.log(
            'Firestore.request',
            'Sending request: %j',
            decorated.request
          );
          method(decorated.request, decorated.gax, (err, result) => ***REMOVED***
            if (err) ***REMOVED***
              Firestore.log('Firestore.request', 'Received error:', err);
              reject(err);
            ***REMOVED*** else ***REMOVED***
              Firestore.log(
                'Firestore.request',
                'Received response: %j',
                result
              );
              resolve(result);
            ***REMOVED***
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * A funnel for read-only streaming API requests, assigning a project ID where
   * necessary within the request options.
   *
   * The stream is returned in paused state and needs to be resumed once all
   * listeners are attached.
   *
   * @private
   * @param ***REMOVED***function***REMOVED*** method - Streaming Veneer API endpoint that takes a
   * request and GAX options.
   * @param ***REMOVED***Object***REMOVED*** request - The Protobuf request to send.
   * @param ***REMOVED***boolean***REMOVED*** allowRetries - Whether this is an idempotent request that
   * can be retried.
   * @returns ***REMOVED***Promise.<Stream>***REMOVED*** A Promise with the resulting read-only stream.
   */
  readStream(method, request, allowRetries) ***REMOVED***
    let attempts = allowRetries ? MAX_REQUEST_RETRIES : 1;

    return this._decorateRequest(request).then(decorated => ***REMOVED***
      return this._retry(attempts, () => ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
          try ***REMOVED***
            Firestore.log(
              'Firestore.readStream',
              'Sending request: %j',
              decorated.request
            );
            let stream = method(decorated.request, decorated.gax);
            let logger = through.obj(function(chunk, enc, callback) ***REMOVED***
              Firestore.log(
                'Firestore.readStream',
                'Received response: %j',
                chunk
              );
              this.push(chunk);
              callback();
            ***REMOVED***);
            resolve(bun([stream, logger]));
          ***REMOVED*** catch (err) ***REMOVED***
            Firestore.log('Firestore.readStream', 'Received error:', err);
            reject(err);
          ***REMOVED***
        ***REMOVED***).then(stream => this._initializeStream(stream));
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * A funnel for read-write streaming API requests, assigning a project ID
   * where necessary for all writes.
   *
   * The stream is returned in paused state and needs to be resumed once all
   * listeners are attached.
   *
   * @private
   * @param ***REMOVED***function***REMOVED*** method - Streaming Veneer API endpoint that takes GAX
   * options.
   * @param ***REMOVED***Object***REMOVED*** request - The Protobuf request to send as the first stream
   * message.
   * @param ***REMOVED***boolean***REMOVED*** allowRetries - Whether this is an idempotent request that
   * can be retried.
   * @returns ***REMOVED***Promise.<Stream>***REMOVED*** A Promise with the resulting read/write stream.
   */
  readWriteStream(method, request, allowRetries) ***REMOVED***
    let self = this;
    let attempts = allowRetries ? MAX_REQUEST_RETRIES : 1;

    return this._decorateRequest(***REMOVED******REMOVED***).then(decorated => ***REMOVED***
      return this._retry(attempts, () => ***REMOVED***
        return Promise.resolve().then(() => ***REMOVED***
          Firestore.log('Firestore.readWriteStream', 'Opening stream');
          // The generated bi-directional streaming API takes the list of GAX
          // headers as its second argument.
          let requestStream = method(***REMOVED******REMOVED***, decorated.gax);

          // The transform stream to assign the project ID.
          let transform = through.obj(function(chunk, encoding, callback) ***REMOVED***
            let decoratedChunk = extend(true, ***REMOVED******REMOVED***, chunk);
            common.util.replaceProjectIdToken(
              decoratedChunk,
              self._referencePath.projectId
            );
            Firestore.log(
              'Firestore.readWriteStream',
              'Streaming request: %j',
              decoratedChunk
            );
            requestStream.write(decoratedChunk, encoding, callback);
          ***REMOVED***);

          let logger = through.obj(function(chunk, enc, callback) ***REMOVED***
            Firestore.log(
              'Firestore.readWriteStream',
              'Received response: %j',
              chunk
            );
            this.push(chunk);
            callback();
          ***REMOVED***);

          let resultStream = bun([transform, requestStream, logger]);
          return this._initializeStream(resultStream, request);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * A logging function that takes a single string.
 *
 * @callback Firestore~logFunction
 * @param ***REMOVED***string***REMOVED*** Log message
 */

/**
 * Log function to use for debug output. By default, we don't perform any
 * logging.
 *
 * @private
 * @type ***REMOVED***Firestore~logFunction***REMOVED***
 */
Firestore.log = function() ***REMOVED******REMOVED***;

/**
 * Sets the log function for all active Firestore instances.
 *
 * @method Firestore.setLogFunction
 * @param ***REMOVED***Firestore~logFunction***REMOVED*** logger - A log function that takes a single
 * string.
 */
Firestore.setLogFunction = function(logger) ***REMOVED***
  validate.isFunction('logger', logger);

  Firestore.log = function(methodName, varargs) ***REMOVED***
    varargs = Array.prototype.slice.call(arguments, 1);

    let formattedMessage = util.format.apply(null, varargs);
    let time = new Date().toISOString();
    logger(
      `Firestore ($***REMOVED***libVersion***REMOVED***) $***REMOVED***time***REMOVED*** [$***REMOVED***methodName***REMOVED***]: ` + formattedMessage
    );
  ***REMOVED***;
***REMOVED***;

// Initializing dependencies that require that Firestore class type.
let reference = require('./reference')(Firestore);
CollectionReference = reference.CollectionReference;
DocumentReference = reference.DocumentReference;
let document = require('./document')(DocumentReference);
DocumentSnapshot = document.DocumentSnapshot;
GeoPoint = document.GeoPoint;
validate = require('./validate')(***REMOVED***
  DocumentReference: reference.validateDocumentReference,
  ResourcePath: ResourcePath.validateResourcePath,
***REMOVED***);
WriteBatch = require('./write-batch')(Firestore, DocumentReference).WriteBatch;
Transaction = require('./transaction')(Firestore);

/**
 * The default export of the `@google-cloud/firestore` package is the
 * ***REMOVED***@link Firestore***REMOVED*** class.
 *
 * See ***REMOVED***@link Firestore***REMOVED*** and ***REMOVED***@link ClientConfig***REMOVED*** for client methods and
 * configuration options.
 *
 * @module ***REMOVED***Firestore***REMOVED*** @google-cloud/firestore
 * @alias nodejs-firestore
 *
 * @example <caption>Install the client library with <a href="https://www.npmjs.com/">npm</a>:</caption>
 * npm install --save @google-cloud/firestore
 *
 * @example <caption>Import the client library</caption>
 * var Firestore = require('@google-cloud/firestore');
 *
 * @example <caption>Create a client that uses <a href="https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application">Application Default Credentials (ADC)</a>:</caption>
 * var firestore = new Firestore();
 *
 * @example <caption>Create a client with <a href="https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually">explicit credentials</a>:</caption>
 * var firestore = new Firestore(***REMOVED***
 *   projectId: 'your-project-id',
 *   keyFilename: '/path/to/keyfile.json'
 * ***REMOVED***);
 *
 * @example <caption>include:samples/quickstart.js</caption>
 * region_tag:firestore_quickstart
 * Full quickstart example:
 */
module.exports = Firestore;
module.exports.default = Firestore;
module.exports.Firestore = Firestore;

/**
 * ***REMOVED***@link v1beta1***REMOVED*** factory function.
 *
 * @name Firestore.v1beta1
 * @see v1beta1
 * @type ***REMOVED***function***REMOVED***
 */
module.exports.v1beta1 = v1beta1;

/**
 * ***REMOVED***@link FieldPath***REMOVED*** class.
 *
 * @name Firestore.FieldPath
 * @see FieldPath
 * @type ***REMOVED***Constructor***REMOVED***
 */
module.exports.FieldPath = FieldPath;

/**
 * ***REMOVED***@link FieldValue***REMOVED*** class.
 *
 * @name Firestore.FieldValue
 * @see FieldValue
 * @type ***REMOVED***Constructor***REMOVED***
 */
module.exports.FieldValue = FieldValue;

/**
 * ***REMOVED***@link GeoPoint***REMOVED*** class.
 *
 * @name Firestore.GeoPoint
 * @see GeoPoint
 * @type ***REMOVED***Constructor***REMOVED***
 */
module.exports.GeoPoint = GeoPoint;
