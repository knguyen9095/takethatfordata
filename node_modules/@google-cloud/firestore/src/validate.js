/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const is = require('is');

/**
 * Formats the given word as plural conditionally given the preceding number.
 *
 * @private
 */
function formatPlural(num, str) ***REMOVED***
  return `$***REMOVED***num***REMOVED*** $***REMOVED***str***REMOVED***` + (num === 1 ? '' : 's');
***REMOVED***

/**
 * Provides argument validation for the Firestore Public API. Exposes validators
 * for strings, integers, numbers, objects and functions by default and can be
 * extended to provide custom validators.
 *
 * The exported validation functions follow the naming convention is***REMOVED***Type***REMOVED*** and
 * isOptional***REMOVED***Type***REMOVED***, such as "isString" and "isOptionalString".
 *
 * To register custom validators, provide an object with a mapping from a type
 * name to a validation function. Validation functions return 'true' for valid
 * inputs and may throw errors with custom validation messages for easier
 * diagnosis.
 *
 * @param ***REMOVED***Object.<string, function>***REMOVED*** validators Mapping from types to
 * validator validators.
 * @returns ***REMOVED***Object.<string, function>***REMOVED*** Map with validators following the naming
 * convention is***REMOVED***Type***REMOVED*** and isOptional***REMOVED***Type***REMOVED***.
 */
module.exports = validators => ***REMOVED***
  validators = Object.assign(
    ***REMOVED***
      function: is.function,
      integer: (value, min, max) => ***REMOVED***
        min = is.defined(min) ? min : -Infinity;
        max = is.defined(max) ? max : Infinity;
        return is.integer(value) && value >= min && value <= max;
      ***REMOVED***,
      number: (value, min, max) => ***REMOVED***
        min = is.defined(min) ? min : -Infinity;
        max = is.defined(max) ? max : Infinity;
        return is.number(value) && value >= min && value <= max;
      ***REMOVED***,
      object: is.object,
      string: is.string,
    ***REMOVED***,
    validators
  );

  let exports = ***REMOVED******REMOVED***;

  let register = type => ***REMOVED***
    let camelCase = type.substring(0, 1).toUpperCase() + type.substring(1);
    exports[`is$***REMOVED***camelCase***REMOVED***`] = function(argumentName, value) ***REMOVED***
      let valid = false;
      let message = is.number(argumentName)
        ? `Argument at index $***REMOVED***argumentName***REMOVED*** is not a valid $***REMOVED***type***REMOVED***.`
        : `Argument "$***REMOVED***argumentName***REMOVED***" is not a valid $***REMOVED***type***REMOVED***.`;

      try ***REMOVED***
        value = [].slice.call(arguments, 1);
        valid = validators[type].apply(null, value);
      ***REMOVED*** catch (err) ***REMOVED***
        message += ` $***REMOVED***err.message***REMOVED***`;
      ***REMOVED***

      if (valid !== true) ***REMOVED***
        throw new Error(message);
      ***REMOVED***
    ***REMOVED***;
    exports[`isOptional$***REMOVED***camelCase***REMOVED***`] = function(argumentName, value) ***REMOVED***
      if (is.defined(value)) ***REMOVED***
        exports[`is$***REMOVED***camelCase***REMOVED***`].apply(null, arguments);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***;

  for (let type in validators) ***REMOVED***
    if (validators.hasOwnProperty(type)) ***REMOVED***
      register(type);
    ***REMOVED***
  ***REMOVED***

  /**
   * Verifies that 'args' has at least 'minSize' elements.
   *
   * @param ***REMOVED***string***REMOVED*** funcName - The function name to use in the error message.
   * @param ***REMOVED***Array.<*>***REMOVED*** args - The array (or array-like structure) to verify.
   * @param ***REMOVED***number***REMOVED*** minSize - The minimum number of elements to enforce.
   * @throws if the expectation is not met.
   * @returns ***REMOVED***boolean***REMOVED*** 'true' when the minimum number of elements is available.
   */
  exports.minNumberOfArguments = (funcName, args, minSize) => ***REMOVED***
    if (args.length < minSize) ***REMOVED***
      throw new Error(
        `Function '$***REMOVED***funcName***REMOVED***()' requires at least ` +
          `$***REMOVED***formatPlural(minSize, 'argument')***REMOVED***.`
      );
    ***REMOVED***

    return true;
  ***REMOVED***;

  /**
   * Verifies that 'args' has at most 'maxSize' elements.
   *
   * @param ***REMOVED***string***REMOVED*** funcName - The function name to use in the error message.
   * @param ***REMOVED***Array.<*>***REMOVED*** args - The array (or array-like structure) to verify.
   * @param ***REMOVED***number***REMOVED*** maxSize - The maximum number of elements to enforce.
   * @throws if the expectation is not met.
   * @returns ***REMOVED***boolean***REMOVED*** 'true' when only the maximum number of elements is
   * specified.
   */
  exports.maxNumberOfArguments = (funcName, args, maxSize) => ***REMOVED***
    if (args.length > maxSize) ***REMOVED***
      throw new Error(
        `Function '$***REMOVED***funcName***REMOVED***()' accepts at most ` +
          `$***REMOVED***formatPlural(maxSize, 'argument')***REMOVED***.`
      );
    ***REMOVED***

    return true;
  ***REMOVED***;

  return exports;
***REMOVED***;
