/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const assert = require('assert');
const is = require('is');

const path = require('./path');
const timestampFromJson = require('./convert').timestampFromJson;

/*!
 * @see ***REMOVED***ResourcePath***REMOVED***
 */
const ResourcePath = path.ResourcePath;

/*!
 * @see ***REMOVED***FieldPath***REMOVED***
 */
const FieldPath = path.FieldPath;

/*!
 * @see ***REMOVED***FieldValue***REMOVED***
 */
const FieldValue = require('./field-value');

/*!
 * Injected.
 *
 * @see ***REMOVED***DocumentReference***REMOVED***
 */
let DocumentReference;

/*! Injected. */
let validate;

/*!
 * The maximum depth of a Firestore object.
 *
 * @type ***REMOVED***number***REMOVED***
 */
const MAX_DEPTH = 20;

/*!
 * Number of nanoseconds in a millisecond.
 *
 * @type ***REMOVED***number***REMOVED***
 */
const MS_TO_NANOS = 1000000;

/*!
 * Protocol constant for the ServerTimestamp transform.
 *
 * @type ***REMOVED***string***REMOVED***
 */
const SERVER_TIMESTAMP = 'REQUEST_TIME';

/**
 * An immutable object representing a geographic location in Firestore. The
 * location is represented as a latitude/longitude pair.
 *
 * @class
 */
class GeoPoint ***REMOVED***
  /**
   * Creates a [GeoPoint]***REMOVED***@link GeoPoint***REMOVED***.
   *
   * @param ***REMOVED***number***REMOVED*** latitude The latitude as a number between -90 and 90.
   * @param ***REMOVED***number***REMOVED*** longitude The longitude as a number between -180 and 180.
   *
   * @example
   * let data = ***REMOVED***
   *   google: new Firestore.GeoPoint(37.422, 122.084)
   * ***REMOVED***;
   *
   * firestore.doc('col/doc').set(data).then(() => ***REMOVED***
   *   console.log(`Location is $***REMOVED***data.google.latitude***REMOVED***, ` +
   *     `$***REMOVED***data.google.longitude***REMOVED***`);
   * ***REMOVED***);
   */
  constructor(latitude, longitude) ***REMOVED***
    validate.isNumber('latitude', latitude);
    validate.isNumber('longitude', longitude);

    this._latitude = latitude;
    this._longitude = longitude;
  ***REMOVED***

  /**
   * The latitude as a number between -90 and 90.
   *
   * @type ***REMOVED***number***REMOVED***
   * @name GeoPoint#latitude
   * @readonly
   */
  get latitude() ***REMOVED***
    return this._latitude;
  ***REMOVED***

  /**
   * The longitude as a number between -180 and 180.
   *
   * @type ***REMOVED***number***REMOVED***
   * @name GeoPoint#longitude
   * @readonly
   */
  get longitude() ***REMOVED***
    return this._longitude;
  ***REMOVED***

  /**
   * Returns a string representation for this GeoPoint.
   *
   * @return ***REMOVED***string***REMOVED*** The string representation.
   */
  toString() ***REMOVED***
    return `GeoPoint ***REMOVED*** latitude: $***REMOVED***this.latitude***REMOVED***, longitude: $***REMOVED***
      this.longitude
    ***REMOVED*** ***REMOVED***`;
  ***REMOVED***

  /**
   * Converts the GeoPoint to a google.type.LatLng proto.
   * @private
   */
  toProto() ***REMOVED***
    return ***REMOVED***
      latitude: this._latitude,
      longitude: this._longitude,
    ***REMOVED***;
  ***REMOVED***

  /**
   * Converts a google.type.LatLng proto to its GeoPoint representation.
   * @private
   */
  static fromProto(proto) ***REMOVED***
    return new GeoPoint(proto.latitude, proto.longitude);
  ***REMOVED***
***REMOVED***

/**
 * A DocumentSnapshot is an immutable representation for a document in a
 * Firestore database. The data can be extracted with
 * [data()]***REMOVED***@link DocumentSnapshot#data***REMOVED*** or
 * [get(fieldPath)]***REMOVED***@link DocumentSnapshot#get***REMOVED*** to get a
 * specific field.
 *
 * <p>For a DocumentSnapshot that points to a non-existing document, any data
 * access will return 'undefined'. You can use the
 * [exists]***REMOVED***@link DocumentSnapshot#exists***REMOVED*** property to explicitly verify a
 * document's existence.
 *
 * @class
 */
class DocumentSnapshot ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***firestore/DocumentReference***REMOVED*** ref - The reference to the
   * document.
   * @param ***REMOVED***object=***REMOVED*** fieldsProto - The fields of the Firestore `Document`
   * Protobuf backing this document (or undefined if the document does not
   * exist).
   * @param ***REMOVED***string***REMOVED*** readTime - The ISO 8601 time when this snapshot was read.
   * @param ***REMOVED***string=***REMOVED*** createTime - The ISO 8601 time when the document was
   * created (or undefined if the document does not exist).
   * @param ***REMOVED***string=***REMOVED*** updateTime - The ISO 8601 time when the document was last
   * updated (or undefined if the document does not exist).
   */
  constructor(ref, fieldsProto, readTime, createTime, updateTime) ***REMOVED***
    this._ref = ref;
    this._fieldsProto = fieldsProto;
    this._readTime = readTime;
    this._createTime = createTime;
    this._updateTime = updateTime;
  ***REMOVED***

  /**
   * Creates a DocumentSnapshot from an object.
   *
   * @private
   * @param ***REMOVED***firestore/DocumentReference***REMOVED*** ref - The reference to the document.
   * @param ***REMOVED***Object***REMOVED*** obj - The object to store in the DocumentSnapshot.
   * @return ***REMOVED***firestore.DocumentSnapshot***REMOVED*** The created DocumentSnapshot.
   */
  static fromObject(ref, obj) ***REMOVED***
    return new DocumentSnapshot(ref, DocumentSnapshot.encodeFields(obj));
  ***REMOVED***

  /**
   * Creates a DocumentSnapshot from an UpdateMap.
   *
   * This methods expands the top-level field paths in a JavaScript map and
   * turns ***REMOVED*** foo.bar : foobar ***REMOVED*** into ***REMOVED*** foo ***REMOVED*** bar : foobar ***REMOVED******REMOVED***
   *
   * @private
   * @param ***REMOVED***firestore/DocumentReference***REMOVED*** ref - The reference to the document.
   * @param ***REMOVED***Map.<FieldPath, *>***REMOVED*** data - The field/value map to expand.
   * @return ***REMOVED***firestore.DocumentSnapshot***REMOVED*** The created DocumentSnapshot.
   */
  static fromUpdateMap(ref, data) ***REMOVED***
    /**
     * Merges 'value' at the field path specified by the path array into
     * 'target'.
     */
    function merge(target, value, path, pos) ***REMOVED***
      let key = path[pos];
      let isLast = pos === path.length - 1;

      if (!is.defined(target[key])) ***REMOVED***
        if (isLast) ***REMOVED***
          if (DocumentTransform.isTransformSentinel(value)) ***REMOVED***
            // If there is already data at this path, we need to retain it.
            // Otherwise, we don't include it in the DocumentSnapshot.
            return !is.empty(target) ? target : null;
          ***REMOVED***
          // The merge is done.
          const leafNode = DocumentSnapshot.encodeValue(value);
          if (leafNode) ***REMOVED***
            target[key] = leafNode;
          ***REMOVED***
          return target;
        ***REMOVED*** else ***REMOVED***
          // We need to expand the target object.
          const childNode = ***REMOVED***
            valueType: 'mapValue',
            mapValue: ***REMOVED***
              fields: ***REMOVED******REMOVED***,
            ***REMOVED***,
          ***REMOVED***;

          const nestedValue = merge(
            childNode.mapValue.fields,
            value,
            path,
            pos + 1
          );

          if (nestedValue) ***REMOVED***
            childNode.mapValue.fields = nestedValue;
            target[key] = childNode;
            return target;
          ***REMOVED*** else ***REMOVED***
            return null;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        assert(!isLast, "Can't merge current value into a nested object");
        target[key].mapValue.fields = merge(
          target[key].mapValue.fields,
          value,
          path,
          pos + 1
        );
        return target;
      ***REMOVED***
    ***REMOVED***

    let res = ***REMOVED******REMOVED***;

    data.forEach((value, key) => ***REMOVED***
      let components = key.toArray();
      merge(res, value, components, 0);
    ***REMOVED***);

    return new DocumentSnapshot(ref, res);
  ***REMOVED***

  /**
   * True if the document exists.
   *
   * @type ***REMOVED***boolean***REMOVED***
   * @name DocumentSnapshot#exists
   * @readonly
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.get().then((documentSnapshot) => ***REMOVED***
   *   if (documentSnapshot.exists) ***REMOVED***
   *     console.log(`Data: $***REMOVED***JSON.stringify(documentSnapshot.data())***REMOVED***`);
   *   ***REMOVED***
   * ***REMOVED***);
   */
  get exists() ***REMOVED***
    return this._fieldsProto !== undefined;
  ***REMOVED***

  /**
   * A [DocumentReference]***REMOVED***@link DocumentReference***REMOVED*** for the document
   * stored in this snapshot.
   *
   * @type ***REMOVED***DocumentReference***REMOVED***
   * @name DocumentSnapshot#ref
   * @readonly
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.get().then((documentSnapshot) => ***REMOVED***
   *   if (documentSnapshot.exists) ***REMOVED***
   *     console.log(`Found document at '$***REMOVED***documentSnapshot.ref.path***REMOVED***'`);
   *   ***REMOVED***
   * ***REMOVED***);
   */
  get ref() ***REMOVED***
    return this._ref;
  ***REMOVED***

  /**
   * The ID of the document for which this DocumentSnapshot contains data.
   *
   * @type ***REMOVED***string***REMOVED***
   * @name DocumentSnapshot#id
   * @readonly
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.get().then((documentSnapshot) => ***REMOVED***
   *   if (documentSnapshot.exists) ***REMOVED***
   *     console.log(`Document found with name '$***REMOVED***documentSnapshot.id***REMOVED***'`);
   *   ***REMOVED***
   * ***REMOVED***);
   */
  get id() ***REMOVED***
    return this._ref.id;
  ***REMOVED***

  /**
   * The time the document was created. Undefined for documents that don't
   * exist.
   *
   * @type ***REMOVED***string|undefined***REMOVED***
   * @name DocumentSnapshot#createTime
   * @readonly
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.get().then((documentSnapshot) => ***REMOVED***
   *   if (documentSnapshot.exists) ***REMOVED***
   *     console.log(`Document created at '$***REMOVED***documentSnapshot.createTime***REMOVED***'`);
   *   ***REMOVED***
   * ***REMOVED***);
   */
  get createTime() ***REMOVED***
    return this._createTime;
  ***REMOVED***

  /**
   * The time the document was last updated (at the time the snapshot was
   * generated). Undefined for documents that don't exist.
   *
   * @type ***REMOVED***string|undefined***REMOVED***
   * @name DocumentSnapshot#updateTime
   * @readonly
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.get().then((documentSnapshot) => ***REMOVED***
   *   if (documentSnapshot.exists) ***REMOVED***
   *     console.log(`Document updated at '$***REMOVED***documentSnapshot.updateTime***REMOVED***'`);
   *   ***REMOVED***
   * ***REMOVED***);
   */
  get updateTime() ***REMOVED***
    return this._updateTime;
  ***REMOVED***

  /**
   * The time this snapshot was read.
   *
   * @type ***REMOVED***string***REMOVED***
   * @name DocumentSnapshot#readTime
   * @readonly
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.get().then((documentSnapshot) => ***REMOVED***
   *   console.log(`Document read at '$***REMOVED***documentSnapshot.readTime***REMOVED***'`);
   * ***REMOVED***);
   */
  get readTime() ***REMOVED***
    return this._readTime;
  ***REMOVED***

  /**
   * Retrieves all fields in the document as an object. Returns 'undefined' if
   * the document doesn't exist.
   *
   * @returns ***REMOVED***DocumentData|undefined***REMOVED*** An object containing all fields in the
   * document or 'undefined' if the document doesn't exist.
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.get().then(documentSnapshot => ***REMOVED***
   *   let data = documentSnapshot.data();
   *   console.log(`Retrieved data: $***REMOVED***JSON.stringify(data)***REMOVED***`);
   * ***REMOVED***);
   */
  data() ***REMOVED***
    let fields = this.protoFields();

    if (is.undefined(fields)) ***REMOVED***
      return undefined;
    ***REMOVED***

    let obj = ***REMOVED******REMOVED***;
    for (let prop in fields) ***REMOVED***
      if (fields.hasOwnProperty(prop)) ***REMOVED***
        obj[prop] = this._decodeValue(fields[prop]);
      ***REMOVED***
    ***REMOVED***
    return obj;
  ***REMOVED***

  /**
   * Returns the underlying Firestore 'Fields' Protobuf in Protobuf JS format.
   *
   * @private
   * @returns ***REMOVED***Object***REMOVED*** The Protobuf encoded document.
   */
  protoFields() ***REMOVED***
    return this._fieldsProto;
  ***REMOVED***

  /**
   * Retrieves the field specified by `field`.
   *
   * @param ***REMOVED***string|FieldPath***REMOVED*** field - The field path
   * (e.g. 'foo' or 'foo.bar') to a specific field.
   * @returns ***REMOVED*******REMOVED*** The data at the specified field location or undefined if no
   * such field exists.
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.set(***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED******REMOVED***).then(() => ***REMOVED***
   *   return documentRef.get();
   * ***REMOVED***).then(documentSnapshot => ***REMOVED***
   *   let field = documentSnapshot.get('a.b');
   *   console.log(`Retrieved field value: $***REMOVED***field***REMOVED***`);
   * ***REMOVED***);
   */
  get(field) ***REMOVED***
    validate.isFieldPath('field', field);

    let protoField = this.protoField(field);

    if (protoField === undefined) ***REMOVED***
      return undefined;
    ***REMOVED***

    return this._decodeValue(protoField);
  ***REMOVED***

  /**
   * Retrieves the field specified by 'fieldPath' in its Protobuf JS
   * representation.
   *
   * @private
   * @param ***REMOVED***string|FieldPath***REMOVED*** field - The path (e.g. 'foo' or
   * 'foo.bar') to a specific field.
   * @returns ***REMOVED*******REMOVED*** The Protobuf-encoded data at the specified field location or
   * undefined if no such field exists.
   */
  protoField(field) ***REMOVED***
    let fields = this.protoFields();

    if (is.undefined(fields)) ***REMOVED***
      return undefined;
    ***REMOVED***

    let components = FieldPath.fromArgument(field).toArray();
    while (components.length > 1) ***REMOVED***
      fields = fields[components.shift()];

      if (!fields || !fields.mapValue) ***REMOVED***
        return undefined;
      ***REMOVED***

      fields = fields.mapValue.fields;
    ***REMOVED***

    return fields[components[0]];
  ***REMOVED***

  /**
   * Decodes a single Firestore 'Value' Protobuf.
   *
   * @private
   * @param proto - A Firestore 'Value' Protobuf.
   * @returns ***REMOVED*******REMOVED*** The converted JS type.
   */
  _decodeValue(proto) ***REMOVED***
    switch (proto.valueType) ***REMOVED***
      case 'stringValue': ***REMOVED***
        return proto.stringValue;
      ***REMOVED***
      case 'booleanValue': ***REMOVED***
        return proto.booleanValue;
      ***REMOVED***
      case 'integerValue': ***REMOVED***
        return parseInt(proto.integerValue, 10);
      ***REMOVED***
      case 'doubleValue': ***REMOVED***
        return parseFloat(proto.doubleValue, 10);
      ***REMOVED***
      case 'timestampValue': ***REMOVED***
        return new Date(
          (proto.timestampValue.seconds || 0) * 1000 +
            (proto.timestampValue.nanos || 0) / MS_TO_NANOS
        );
      ***REMOVED***
      case 'referenceValue': ***REMOVED***
        return new DocumentReference(
          this.ref.firestore,
          ResourcePath.fromSlashSeparatedString(proto.referenceValue)
        );
      ***REMOVED***
      case 'arrayValue': ***REMOVED***
        let array = [];
        if (is.array(proto.arrayValue.values)) ***REMOVED***
          for (let value of proto.arrayValue.values) ***REMOVED***
            array.push(this._decodeValue(value));
          ***REMOVED***
        ***REMOVED***
        return array;
      ***REMOVED***
      case 'nullValue': ***REMOVED***
        return null;
      ***REMOVED***
      case 'mapValue': ***REMOVED***
        let obj = ***REMOVED******REMOVED***;
        let fields = proto.mapValue.fields;

        for (let prop in fields) ***REMOVED***
          if (fields.hasOwnProperty(prop)) ***REMOVED***
            obj[prop] = this._decodeValue(fields[prop]);
          ***REMOVED***
        ***REMOVED***

        return obj;
      ***REMOVED***
      case 'geoPointValue': ***REMOVED***
        return GeoPoint.fromProto(proto.geoPointValue);
      ***REMOVED***
      case 'bytesValue': ***REMOVED***
        return proto.bytesValue;
      ***REMOVED***
      default: ***REMOVED***
        throw new Error(
          'Cannot decode type from Firestore Value: ' + JSON.stringify(proto)
        );
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /**
   * Checks whether this DocumentSnapshot contains any fields.
   *
   * @private
   * @return ***REMOVED***boolean***REMOVED***
   */
  get isEmpty() ***REMOVED***
    return is.undefined(this._fieldsProto) || is.empty(this._fieldsProto);
  ***REMOVED***

  /**
   * Convert a document snapshot to the Firestore 'Document' Protobuf.
   *
   * @private
   * @returns ***REMOVED***Object***REMOVED*** - The document in the format the API expects.
   */
  toProto() ***REMOVED***
    return ***REMOVED***
      update: ***REMOVED***
        name: this._ref.formattedName,
        fields: this._fieldsProto,
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***

  /**
   * Converts a Google Protobuf timestamp to an ISO 8601 string.
   *
   * @private
   * @param ***REMOVED******REMOVED***seconds:number=,nanos:number=***REMOVED***=***REMOVED*** timestamp The Google Protobuf
   * timestamp.
   * @returns ***REMOVED***string|undefined***REMOVED*** The representation in ISO 8601 or undefined if
   * the input is empty.
   */
  static toISOTime(timestamp) ***REMOVED***
    if (timestamp) ***REMOVED***
      let isoSubstring = new Date(
        (timestamp.seconds || 0) * 1000
      ).toISOString();

      // Strip milliseconds from JavaScript ISO representation
      // (YYYY-MM-DDTHH:mm:ss.sssZ or ±YYYYYY-MM-DDTHH:mm:ss.sssZ)
      isoSubstring = isoSubstring.substr(0, isoSubstring.length - 4);

      // Append nanoseconds as per ISO 8601
      let nanoString = (timestamp.nanos || '') + '';
      while (nanoString.length < 9) ***REMOVED***
        nanoString = '0' + nanoString;
      ***REMOVED***

      return isoSubstring + nanoString + 'Z';
    ***REMOVED***

    return undefined;
  ***REMOVED***

  /**
   * Encodes a JavaScrip object into the Firestore 'Fields' representation.
   *
   * @private
   * @param ***REMOVED***Object***REMOVED*** obj The object to encode.
   * @returns ***REMOVED***Object***REMOVED*** The Firestore 'Fields' representation
   */
  static encodeFields(obj) ***REMOVED***
    let fields = ***REMOVED******REMOVED***;

    for (let prop in obj) ***REMOVED***
      if (obj.hasOwnProperty(prop)) ***REMOVED***
        let val = DocumentSnapshot.encodeValue(obj[prop]);

        if (val) ***REMOVED***
          fields[prop] = val;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    return fields;
  ***REMOVED***

  /**
   * Encodes a JavaScript value into the Firestore 'Value' representation.
   *
   * @private
   * @param ***REMOVED***Object***REMOVED*** val The object to encode
   * @returns ***REMOVED***object|null***REMOVED*** The Firestore Proto or null if we are deleting a
   * field.
   */
  static encodeValue(val) ***REMOVED***
    if (DocumentTransform.isTransformSentinel(val)) ***REMOVED***
      return null;
    ***REMOVED***

    if (is.string(val)) ***REMOVED***
      return ***REMOVED***
        valueType: 'stringValue',
        stringValue: val,
      ***REMOVED***;
    ***REMOVED***

    if (is.boolean(val)) ***REMOVED***
      return ***REMOVED***
        valueType: 'booleanValue',
        booleanValue: val,
      ***REMOVED***;
    ***REMOVED***

    if (is.integer(val)) ***REMOVED***
      return ***REMOVED***
        valueType: 'integerValue',
        integerValue: val,
      ***REMOVED***;
    ***REMOVED***

    // Integers are handled above, the remaining numbers are treated as doubles
    if (is.number(val)) ***REMOVED***
      return ***REMOVED***
        valueType: 'doubleValue',
        doubleValue: val,
      ***REMOVED***;
    ***REMOVED***

    if (is.date(val)) ***REMOVED***
      let epochSeconds = Math.floor(val.getTime() / 1000);
      let timestamp = ***REMOVED***
        seconds: epochSeconds,
        nanos: (val.getTime() - epochSeconds * 1000) * MS_TO_NANOS,
      ***REMOVED***;
      return ***REMOVED***
        valueType: 'timestampValue',
        timestampValue: timestamp,
      ***REMOVED***;
    ***REMOVED***

    if (is.array(val)) ***REMOVED***
      let encodedElements = [];
      for (let i = 0; i < val.length; ++i) ***REMOVED***
        let enc = DocumentSnapshot.encodeValue(val[i]);
        if (enc) ***REMOVED***
          encodedElements.push(enc);
        ***REMOVED***
      ***REMOVED***
      return ***REMOVED***
        valueType: 'arrayValue',
        arrayValue: ***REMOVED***
          values: encodedElements,
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***

    if (is.nil(val)) ***REMOVED***
      return ***REMOVED***
        valueType: 'nullValue',
        nullValue: 'NULL_VALUE',
      ***REMOVED***;
    ***REMOVED***

    if (is.instance(val, DocumentReference) || is.instance(val, ResourcePath)) ***REMOVED***
      return ***REMOVED***
        valueType: 'referenceValue',
        referenceValue: val.formattedName,
      ***REMOVED***;
    ***REMOVED***

    if (is.instance(val, GeoPoint)) ***REMOVED***
      return ***REMOVED***
        valueType: 'geoPointValue',
        geoPointValue: val.toProto(),
      ***REMOVED***;
    ***REMOVED***

    if (is.instanceof(val, Buffer) || is.instanceof(val, Uint8Array)) ***REMOVED***
      return ***REMOVED***
        valueType: 'bytesValue',
        bytesValue: val,
      ***REMOVED***;
    ***REMOVED***

    if (isPlainObject(val)) ***REMOVED***
      const map = ***REMOVED***
        valueType: 'mapValue',
        mapValue: ***REMOVED***
          fields: ***REMOVED******REMOVED***,
        ***REMOVED***,
      ***REMOVED***;

      // If we encounter an empty object, we always need to send it to make sure
      // the server creates a map entry.
      if (!is.empty(val)) ***REMOVED***
        map.mapValue.fields = DocumentSnapshot.encodeFields(val);
        if (is.empty(map.mapValue.fields)) ***REMOVED***
          return null;
        ***REMOVED***
      ***REMOVED***

      return map;
    ***REMOVED***

    throw new Error(
      'Cannot encode type (' +
        Object.prototype.toString.call(val) +
        ') to a Firestore Value'
    );
  ***REMOVED***
***REMOVED***

/**
 * A QueryDocumentSnapshot contains data read from a document in your
 * Firestore database as part of a query. The document is guaranteed to exist
 * and its data can be extracted with [data()]***REMOVED***@link QueryDocumentSnapshot#data***REMOVED***
 * or [get()]***REMOVED***@link DocumentSnapshot#get***REMOVED*** to get a specific field.
 *
 * A QueryDocumentSnapshot offers the same API surface as a
 * ***REMOVED***#link DocumentSnapshot***REMOVED***. Since query results contain only existing
 * documents, the [exists]***REMOVED***@link DocumentSnapshot#exists***REMOVED*** property will
 * always be true and [data()]***REMOVED***@link QueryDocumentSnapshot#data***REMOVED*** will never
 * return 'undefined'.
 *
 * @class
 * @extends DocumentSnapshot
 */
class QueryDocumentSnapshot extends DocumentSnapshot ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***firestore/DocumentReference***REMOVED*** ref - The reference to the document.
   * @param ***REMOVED***object***REMOVED*** fieldsProto - The fields of the Firestore `Document`
   * Protobuf backing this document.
   * @param ***REMOVED***string***REMOVED*** readTime - The ISO 8601 time when this snapshot was read.
   * @param ***REMOVED***string***REMOVED*** createTime - The ISO 8601 time when the document was
   * created.
   * @param ***REMOVED***string***REMOVED*** updateTime - The ISO 8601 time when the document was last
   * updated.
   */
  constructor(ref, fieldsProto, readTime, createTime, updateTime) ***REMOVED***
    super(ref, fieldsProto, readTime, createTime, updateTime);
  ***REMOVED***

  /**
   * The time the document was created.
   *
   * @type ***REMOVED***string***REMOVED***
   * @name QueryDocumentSnapshot#createTime
   * @readonly
   * @override
   *
   * @example
   * let query = firestore.collection('col');
   *
   * query.get().forEach(documentSnapshot => ***REMOVED***
   *   console.log(`Document created at '$***REMOVED***documentSnapshot.createTime***REMOVED***'`);
   * ***REMOVED***);
   */
  get createTime() ***REMOVED***
    return super.createTime;
  ***REMOVED***

  /**
   * The time the document was last updated (at the time the snapshot was
   * generated).
   *
   * @type ***REMOVED***string***REMOVED***
   * @name QueryDocumentSnapshot#updateTime
   * @readonly
   * @override
   *
   * @example
   * let query = firestore.collection('col');
   *
   * query.get().forEach(documentSnapshot => ***REMOVED***
   *   console.log(`Document updated at '$***REMOVED***documentSnapshot.updateTime***REMOVED***'`);
   * ***REMOVED***);
   */
  get updateTime() ***REMOVED***
    return super.updateTime;
  ***REMOVED***

  /**
   * Retrieves all fields in the document as an object.
   *
   * @override
   *
   * @returns ***REMOVED***DocumentData***REMOVED*** An object containing all fields in the document.
   *
   * @example
   * let query = firestore.collection('col');
   *
   * query.get().forEach(documentSnapshot => ***REMOVED***
   *   let data = documentSnapshot.data();
   *   console.log(`Retrieved data: $***REMOVED***JSON.stringify(data)***REMOVED***`);
   * ***REMOVED***);
   */
  data() ***REMOVED***
    let data = super.data();
    assert(
      is.defined(data),
      'The data in a QueryDocumentSnapshot should always exist.'
    );
    return data;
  ***REMOVED***
***REMOVED***

/**
 * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.
 * Invoke `.build()' to assemble the final snapshot.
 *
 * @private
 * @class
 */
class DocumentSnapshotBuilder ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***DocumentSnapshot=***REMOVED*** snapshot An optional snapshot to base this
   * builder on.
   */
  constructor(snapshot) ***REMOVED***
    snapshot = snapshot || ***REMOVED******REMOVED***;

    /**
     * The reference to the document.
     *
     * @type ***REMOVED***DocumentReference***REMOVED***
     */
    this.ref = snapshot._ref;

    /**
     * The fields of the Firestore `Document` Protobuf backing this document.
     *
     * @type ***REMOVED***object***REMOVED***
     */
    this.fieldsProto = snapshot._fieldsProto;

    /**
     * The ISO 8601 time when this document was read.
     *
     * @type ***REMOVED***string***REMOVED***
     */
    this.readTime = snapshot._readTime;

    /**
     * The ISO 8601 time when this document was created.
     *
     * @type ***REMOVED***string***REMOVED***
     */
    this.createTime = snapshot._createTime;

    /**
     * The ISO 8601 time when this document was last updated.
     *
     * @type ***REMOVED***string***REMOVED***
     */
    this.updateTime = snapshot._updateTime;
  ***REMOVED***

  /**
   * Builds the DocumentSnapshot.
   *
   * @private
   * @returns ***REMOVED***QueryDocumentSnapshot|DocumentSnapshot***REMOVED*** Returns either a
   * QueryDocumentSnapshot (if `fieldsProto` was provided) or a
   * DocumentSnapshot.
   */
  build() ***REMOVED***
    assert(
      is.defined(this.fieldsProto) === is.defined(this.createTime),
      'Create time should be set iff document exists.'
    );
    assert(
      is.defined(this.fieldsProto) === is.defined(this.updateTime),
      'Update time should be set iff document exists.'
    );
    return this.fieldsProto
      ? new QueryDocumentSnapshot(
          this.ref,
          this.fieldsProto,
          this.readTime,
          this.createTime,
          this.updateTime
        )
      : new DocumentSnapshot(this.ref, undefined, this.readTime);
  ***REMOVED***
***REMOVED***

/**
 * @private
 * @name DocumentSnapshot.DocumentSnapshotBuilder
 * @see DocumentSnapshotBuilder
 */
DocumentSnapshot.Builder = DocumentSnapshotBuilder;

/**
 * A Firestore Document Mask contains the field paths affected by an update.
 *
 * @class
 * @private
 */
class DocumentMask ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***Array.<string>***REMOVED*** fieldPaths - The canonical representation of field
   * paths in this mask.
   */
  constructor(fieldPaths) ***REMOVED***
    this._fieldPaths = fieldPaths;
  ***REMOVED***

  /**
   * Creates a document mask with the field paths of a document.
   *
   * @private
   * @param ***REMOVED***Map.<string|FieldPath, *>***REMOVED*** data A map with
   * fields to modify. Only the keys are used to extract the document mask.
   * @returns ***REMOVED***DocumentMask***REMOVED***
   */
  static fromUpdateMap(data) ***REMOVED***
    let fieldPaths = [];

    data.forEach((value, key) => ***REMOVED***
      if (value !== FieldValue.SERVER_TIMESTAMP_SENTINEL) ***REMOVED***
        fieldPaths.push(FieldPath.fromArgument(key).formattedName);
      ***REMOVED***
    ***REMOVED***);

    // Required for testing.
    fieldPaths.sort();

    return new DocumentMask(fieldPaths);
  ***REMOVED***

  /**
   * Creates a document mask with the field names of a document.
   *
   * @private
   * @param ***REMOVED***DocumentData***REMOVED*** data An object with fields to modify. Only the keys
   * are used to extract the document mask.
   * @returns ***REMOVED***DocumentMask***REMOVED***
   */
  static fromObject(data) ***REMOVED***
    let fieldPaths = [];

    const extractFieldPaths = function(currentData, currentPath) ***REMOVED***
      let isEmpty = true;

      for (let key in currentData) ***REMOVED***
        if (currentData.hasOwnProperty(key)) ***REMOVED***
          isEmpty = false;

          // We don't split on dots since fromObject is called with
          // DocumentData.
          const childSegment = new FieldPath(key);
          const childPath = currentPath
            ? currentPath.append(childSegment)
            : childSegment;
          const value = currentData[key];
          if (value === FieldValue.SERVER_TIMESTAMP_SENTINEL) ***REMOVED***
            // Ignore.
          ***REMOVED*** else if (value === FieldValue.DELETE_SENTINEL) ***REMOVED***
            fieldPaths.push(childPath.formattedName);
          ***REMOVED*** else if (isPlainObject(value)) ***REMOVED***
            extractFieldPaths(value, childPath);
          ***REMOVED*** else ***REMOVED***
            fieldPaths.push(childPath.formattedName);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      // Add a field path for an explicitly updated empty map.
      if (currentPath && isEmpty) ***REMOVED***
        fieldPaths.push(currentPath.formattedName);
      ***REMOVED***
    ***REMOVED***;

    extractFieldPaths(data);

    // Required for testing.
    fieldPaths.sort();

    return new DocumentMask(fieldPaths);
  ***REMOVED***

  /**
   * Returns true if this document mask contains no fields.
   *
   * @private
   * @return ***REMOVED***boolean***REMOVED*** Whether this document mask is empty.
   */
  get isEmpty() ***REMOVED***
    return this._fieldPaths.length === 0;
  ***REMOVED***

  /**
   * Converts a document mask to the Firestore 'DocumentMask' Proto.
   *
   * @private
   * @returns ***REMOVED***Object***REMOVED*** A Firestore 'DocumentMask' Proto.
   */
  toProto() ***REMOVED***
    return ***REMOVED***
      fieldPaths: this._fieldPaths,
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

/**
 * A Firestore Document Transform.
 *
 * A DocumentTransform contains pending server-side transforms and their
 * corresponding field paths.
 *
 * @private
 * @class
 */
class DocumentTransform ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***DocumentReference***REMOVED*** ref The DocumentReference for this
   * transform.
   * @param ***REMOVED***Array.<Object>***REMOVED*** transforms A array with 'FieldTransform' Protobuf
   * messages.
   */
  constructor(ref, transforms) ***REMOVED***
    this._ref = ref;
    this._transforms = transforms;
  ***REMOVED***
  /**
   * Generates a DocumentTransform from a JavaScript object.
   *
   * @private
   * @param ***REMOVED***firestore/DocumentReference***REMOVED*** ref The `DocumentReference` to
   * use for the DocumentTransform.
   * @param ***REMOVED***Object***REMOVED*** obj The object to extract the transformations from.
   * @returns ***REMOVED***firestore.DocumentTransform***REMOVED*** The Document Transform.
   */
  static fromObject(ref, obj) ***REMOVED***
    let updateMap = new Map();

    for (let prop in obj) ***REMOVED***
      if (obj.hasOwnProperty(prop)) ***REMOVED***
        updateMap.set(new FieldPath(prop), obj[prop]);
      ***REMOVED***
    ***REMOVED***

    return DocumentTransform.fromUpdateMap(ref, updateMap);
  ***REMOVED***

  /**
   * Generates a DocumentTransform from an Update Map.
   *
   * @private
   * @param ***REMOVED***firestore/DocumentReference***REMOVED*** ref The `DocumentReference` to
   * use for the DocumentTransform.
   * @param ***REMOVED***Map***REMOVED*** data The map to extract the transformations from.
   * @returns ***REMOVED***firestore.DocumentTransform***REMOVED******REMOVED*** The Document Transform.
   */
  static fromUpdateMap(ref, data) ***REMOVED***
    let transforms = [];

    function encode_(val, path, allowTransforms) ***REMOVED***
      if (val === FieldValue.SERVER_TIMESTAMP_SENTINEL) ***REMOVED***
        if (allowTransforms) ***REMOVED***
          transforms.push(***REMOVED***
            fieldPath: path.formattedName,
            setToServerValue: SERVER_TIMESTAMP,
          ***REMOVED***);
        ***REMOVED*** else ***REMOVED***
          throw new Error(
            'Server timestamps are not supported as array ' + 'values.'
          );
        ***REMOVED***
      ***REMOVED*** else if (is.array(val)) ***REMOVED***
        for (let i = 0; i < val.length; ++i) ***REMOVED***
          // We need to verify that no array value contains a document transform
          encode_(val[i], path.append(String(i)), false);
        ***REMOVED***
      ***REMOVED*** else if (isPlainObject(val)) ***REMOVED***
        for (let prop in val) ***REMOVED***
          if (val.hasOwnProperty(prop)) ***REMOVED***
            encode_(
              val[prop],
              path.append(new FieldPath(prop)),
              allowTransforms
            );
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    data.forEach((value, key) => ***REMOVED***
      encode_(value, FieldPath.fromArgument(key), true);
    ***REMOVED***);

    return new DocumentTransform(ref, transforms);
  ***REMOVED***

  /**
   * Returns true if the field value is a .delete() or .serverTimestamp()
   * sentinel.
   *
   * @private
   * @param ***REMOVED*******REMOVED*** val The field value to check.
   * @return ***REMOVED***boolean***REMOVED*** Whether we encountered a transform sentinel.
   */
  static isTransformSentinel(val) ***REMOVED***
    return (
      val === FieldValue.SERVER_TIMESTAMP_SENTINEL ||
      val === FieldValue.DELETE_SENTINEL
    );
  ***REMOVED***

  /**
   * Whether this DocumentTransform contains any actionable transformations.
   *
   * @private
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get isEmpty() ***REMOVED***
    return this._transforms.length === 0;
  ***REMOVED***

  /**
   * Converts a document transform to the Firestore 'DocumentTransform' Proto.
   *
   * @private
   * @returns ***REMOVED***Object***REMOVED*** A Firestore 'DocumentTransform' Proto.
   */
  toProto() ***REMOVED***
    return ***REMOVED***
      transform: ***REMOVED***
        document: this._ref.formattedName,
        fieldTransforms: this._transforms,
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

/*!
 * A Firestore Precondition encapsulates options for database writes.
 *
 * @private
 * @class
 */
class Precondition ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***boolean=***REMOVED*** options.exists - Whether the referenced document should
   * exist in Firestore,
   * @param ***REMOVED***string=***REMOVED*** options.lastUpdateTime - The last update time
   * of the referenced document in Firestore (as ISO 8601 string).
   * @param options
   */
  constructor(options) ***REMOVED***
    if (is.object(options)) ***REMOVED***
      this._exists = options.exists;
      this._lastUpdateTime = options.lastUpdateTime;
    ***REMOVED***
  ***REMOVED***

  /**
   * Generates the Protobuf `Preconditon` object for this precondition.
   *
   * @returns ***REMOVED***Object***REMOVED*** The `Preconditon` Protobuf object.
   */
  toProto() ***REMOVED***
    let proto = ***REMOVED******REMOVED***;

    if (is.defined(this._lastUpdateTime)) ***REMOVED***
      proto.updateTime = timestampFromJson(
        this._lastUpdateTime,
        'lastUpdateTime'
      );
    ***REMOVED*** else if (is.defined(this._exists)) ***REMOVED***
      proto.exists = this._exists;
    ***REMOVED***

    return proto;
  ***REMOVED***

  /**
   * Whether this DocumentTransform contains any enforcement.
   *
   * @private
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get isEmpty() ***REMOVED***
    return this._exists === undefined && !this._lastUpdateTime;
  ***REMOVED***
***REMOVED***

/*!
 * Validates a JavaScript object for usage as a Firestore document.
 *
 * @param ***REMOVED***Object***REMOVED*** obj JavaScript object to validate.
 * @param ***REMOVED***boolean=***REMOVED*** options.allowDeletes Whether field deletes are supported
 * at the top level (e.g. for document updates).
 * @param ***REMOVED***boolean=***REMOVED*** options.allowNestedDeletes Whether field deletes are supported
 * at any level (e.g. for document merges).
 * @param ***REMOVED***boolean=***REMOVED*** options.allowEmpty Whether empty documents are support.
 * Defaults to true.
 * @returns ***REMOVED***boolean***REMOVED*** 'true' when the object is valid.
 * @throws ***REMOVED***Error***REMOVED*** when the object is invalid.
 */
function validateDocumentData(obj, options) ***REMOVED***
  if (!isPlainObject(obj)) ***REMOVED***
    throw new Error('Input is not a plain JavaScript object.');
  ***REMOVED***

  options = options || ***REMOVED******REMOVED***;

  let isEmpty = true;

  for (let prop in obj) ***REMOVED***
    if (obj.hasOwnProperty(prop)) ***REMOVED***
      isEmpty = false;
      validateFieldValue(obj[prop], options, /* depth= */ 1);
    ***REMOVED***
  ***REMOVED***

  if (options.allowEmpty === false && isEmpty) ***REMOVED***
    throw new Error('At least one field must be updated.');
  ***REMOVED***

  return true;
***REMOVED***

/*!
 * Validates a JavaScript value for usage as a Firestore value.
 *
 * @param ***REMOVED***Object***REMOVED*** obj JavaScript value to validate.
 * @param ***REMOVED***boolean=***REMOVED*** options.allowDeletes Whether field deletes are supported
 * at the top level (e.g. for document updates).
 * @param ***REMOVED***boolean=***REMOVED*** options.allowNestedDeletes Whether field deletes are supported
 * at any level (e.g. for document merges).
 * @param ***REMOVED***number=***REMOVED*** depth The current depth of the traversal.
 * @returns ***REMOVED***boolean***REMOVED*** 'true' when the object is valid.
 * @throws ***REMOVED***Error***REMOVED*** when the object is invalid.
 */
function validateFieldValue(obj, options, depth) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  if (!depth) ***REMOVED***
    depth = 1;
  ***REMOVED*** else if (depth > MAX_DEPTH) ***REMOVED***
    throw new Error(
      `Input object is deeper than $***REMOVED***MAX_DEPTH***REMOVED*** levels or contains a cycle.`
    );
  ***REMOVED***

  if (obj === FieldValue.DELETE_SENTINEL) ***REMOVED***
    if (!options.allowNestedDeletes && (!options.allowDeletes || depth > 1)) ***REMOVED***
      throw new Error(
        'Deletes must appear at the top-level and can only be used in update() or set() with ***REMOVED***merge:true***REMOVED***.'
      );
    ***REMOVED***
  ***REMOVED***

  if (isPlainObject(obj)) ***REMOVED***
    for (let prop in obj) ***REMOVED***
      if (obj.hasOwnProperty(prop)) ***REMOVED***
        validateFieldValue(obj[prop], options, depth + 1);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if (is.array(obj)) ***REMOVED***
    for (let prop of obj) ***REMOVED***
      validateFieldValue(obj[prop], options, depth + 1);
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***

/*!
 * Validates the use of 'options' as a Precondition and enforces that 'exists'
 * and 'lastUpdateTime' use valid types.
 *
 * @param ***REMOVED***boolean=***REMOVED*** options.exists - Whether the referenced document
 * should exist.
 * @param ***REMOVED***string=***REMOVED*** options.lastUpdateTime - The last update time
 * of the referenced document in Firestore (as ISO 8601 string).
 * @param ***REMOVED***boolean***REMOVED*** allowExist Whether to allow the 'exists' preconditions.
 * @returns ***REMOVED***boolean***REMOVED*** 'true' if the input is a valid Precondition.
 */
function validatePrecondition(precondition, allowExist) ***REMOVED***
  if (!is.object(precondition)) ***REMOVED***
    throw new Error('Input is not an object.');
  ***REMOVED***

  let conditions = 0;

  if (is.defined(precondition.exists)) ***REMOVED***
    ++conditions;
    if (!allowExist) ***REMOVED***
      throw new Error('"exists" is not an allowed condition.');
    ***REMOVED***
    if (!is.boolean(precondition.exists)) ***REMOVED***
      throw new Error('"exists" is not a boolean.');
    ***REMOVED***
  ***REMOVED***

  if (is.defined(precondition.lastUpdateTime)) ***REMOVED***
    ++conditions;
    if (!is.string(precondition.lastUpdateTime)) ***REMOVED***
      throw new Error('"lastUpdateTime" is not a string.');
    ***REMOVED***
  ***REMOVED***

  if (conditions > 1) ***REMOVED***
    throw new Error('Input contains more than one condition.');
  ***REMOVED***

  return true;
***REMOVED***

/*!
 * Validates the use of 'options' as SetOptions and enforces that 'merge' is a
 * boolean.
 *
 * @param ***REMOVED***boolean=***REMOVED*** options.merge - Whether set() should merge the provided
 * data into an existing document.
 * @returns ***REMOVED***boolean***REMOVED*** 'true' if the input is a valid SetOptions object.
 */
function validateSetOptions(options) ***REMOVED***
  if (!is.object(options)) ***REMOVED***
    throw new Error('Input is not an object.');
  ***REMOVED***

  if (is.defined(options.merge) && !is.boolean(options.merge)) ***REMOVED***
    throw new Error('"merge" is not a boolean.');
  ***REMOVED***

  return true;
***REMOVED***

/*!
 * Verifies that 'obj' is a plain JavaScript object that can be encoded as a
 * 'Map' in Firestore.
 *
 * @param ***REMOVED*******REMOVED*** input - The argument to verify.
 * @returns ***REMOVED***boolean***REMOVED*** 'true' if the input can be a treated as a plain object.
 */
function isPlainObject(input) ***REMOVED***
  return (
    typeof input === 'object' &&
    input !== null &&
    Object.getPrototypeOf(input) === Object.prototype
  );
***REMOVED***

module.exports = DocumentRefType => ***REMOVED***
  DocumentReference = DocumentRefType;
  validate = require('./validate')(***REMOVED***
    FieldPath: FieldPath.validateFieldPath,
    PlainObject: isPlainObject,
  ***REMOVED***);
  return ***REMOVED***
    DocumentMask,
    DocumentSnapshot,
    DocumentTransform,
    Precondition,
    GeoPoint,
    QueryDocumentSnapshot,
    validateFieldValue,
    validateDocumentData,
    validatePrecondition,
    validateSetOptions,
  ***REMOVED***;
***REMOVED***;
