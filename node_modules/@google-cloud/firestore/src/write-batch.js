/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const assert = require('assert');
const is = require('is');

/*!
 * Injected.
 *
 * @see DocumentSnapshot
 */
let DocumentSnapshot;

/*!
 * Injected.
 *
 * @see DocumentMask
 */
let DocumentMask;

/*!
 * Injected.
 *
 * @see DocumentTransform
 */
let DocumentTransform;

/*
 * @see FieldPath
 */
const FieldPath = require('./path').FieldPath;

/*!
 * Injected.
 *
 * @see Firestore
 */
let Firestore;

/*!
 * Injected.
 *
 * @see Precondition
 */
let Precondition;

/*! Injected. */
let validate;

/*!
 * Google Cloud Functions terminates idle connections after two minutes. After
 * longer periods of idleness, we issue transactional commits to allow for
 * retries.
 *
 * @type ***REMOVED***number***REMOVED***
 */
const GCF_IDLE_TIMEOUT_MS = 110 * 1000;

/**
 * A WriteResult wraps the write time set by the Firestore servers on sets(),
 * updates(), and creates().
 *
 * @class
 */
class WriteResult ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***string***REMOVED*** writeTime - The ISO 8601 write time.
   */
  constructor(writeTime) ***REMOVED***
    this._writeTime = writeTime;
  ***REMOVED***

  /**
   * The write time as set by the Firestore servers. Formatted as an ISO-8601
   * string.
   *
   * @type ***REMOVED***string***REMOVED***
   * @name WriteResult#writeTime
   * @readonly
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.set(***REMOVED***foo: 'bar'***REMOVED***).then(writeResult => ***REMOVED***
   *   console.log(`Document written at: $***REMOVED***writeResult.writeTime***REMOVED***`);
   * ***REMOVED***);
   */
  get writeTime() ***REMOVED***
    return this._writeTime;
  ***REMOVED***
***REMOVED***

/**
 * A Firestore WriteBatch that can be used to atomically commit multiple write
 * operations at once.
 *
 * @class
 */
class WriteBatch ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***Firestore***REMOVED*** firestore - The Firestore Database client.
   */
  constructor(firestore) ***REMOVED***
    this._firestore = firestore;
    this._api = firestore.api;
    this._writes = [];
    this._committed = false;
  ***REMOVED***

  /**
   * Checks if this write batch has any pending operations.
   *
   * @private
   * @returns ***REMOVED***boolean***REMOVED***
   */
  get isEmpty() ***REMOVED***
    return this._writes.length === 0;
  ***REMOVED***

  /**
   * Throws an error if this batch has already been committed.
   *
   * @private
   */
  verifyNotCommitted() ***REMOVED***
    if (this._committed) ***REMOVED***
      throw new Error('Cannot modify a WriteBatch that has been committed.');
    ***REMOVED***
  ***REMOVED***

  /**
   * Create a document with the provided object values. This will fail the batch
   * if a document exists at its location.
   *
   * @param ***REMOVED***DocumentReference***REMOVED*** documentRef - A reference to the
   * document to be created.
   * @param ***REMOVED***DocumentData***REMOVED*** data - The object to serialize as the document.
   * @returns ***REMOVED***WriteBatch***REMOVED*** This WriteBatch instance. Used for chaining
   * method calls.
   *
   * @example
   * let writeBatch = firestore.batch();
   * let documentRef = firestore.collection('col').doc();
   *
   * writeBatch.create(documentRef, ***REMOVED***foo: 'bar'***REMOVED***);
   *
   * writeBatch.commit().then(() => ***REMOVED***
   *   console.log('Successfully executed batch.');
   * ***REMOVED***);
   */
  create(documentRef, data) ***REMOVED***
    validate.isDocumentReference('documentRef', documentRef);
    validate.isDocument('data', data);

    this.verifyNotCommitted();

    const document = DocumentSnapshot.fromObject(documentRef, data);
    const transform = DocumentTransform.fromObject(documentRef, data);
    const precondition = new Precondition(***REMOVED***exists: false***REMOVED***);

    this._writes.push(***REMOVED***
      write: !document.isEmpty || transform.isEmpty ? document.toProto() : null,
      transform: transform.isEmpty ? null : transform.toProto(),
      precondition: precondition.toProto(),
    ***REMOVED***);

    return this;
  ***REMOVED***

  /**
   * Deletes a document from the database.
   *
   * @param ***REMOVED***DocumentReference***REMOVED*** documentRef - A reference to the
   * document to be deleted.
   * @param ***REMOVED***Precondition=***REMOVED*** precondition - A precondition to enforce for this
   * delete.
   * @param ***REMOVED***string=***REMOVED*** precondition.lastUpdateTime If set, enforces that the
   * document was last updated at lastUpdateTime (as ISO 8601 string). Fails the
   * batch if the document doesn't exist or was last updated at a different
   * time.
   * @returns ***REMOVED***WriteBatch***REMOVED*** This WriteBatch instance. Used for chaining
   * method calls.
   *
   * @example
   * let writeBatch = firestore.batch();
   * let documentRef = firestore.doc('col/doc');
   *
   * writeBatch.delete(documentRef);
   *
   * writeBatch.commit().then(() => ***REMOVED***
   *   console.log('Successfully executed batch.');
   * ***REMOVED***);
   */
  delete(documentRef, precondition) ***REMOVED***
    validate.isDocumentReference('documentRef', documentRef);
    validate.isOptionalDeletePrecondition('precondition', precondition);

    this.verifyNotCommitted();

    const conditions = new Precondition(precondition);

    this._writes.push(***REMOVED***
      write: ***REMOVED***
        delete: documentRef.formattedName,
      ***REMOVED***,
      precondition: conditions.isEmpty ? null : conditions.toProto(),
    ***REMOVED***);

    return this;
  ***REMOVED***

  /**
   * Write to the document referred to by the provided
   * [DocumentReference]***REMOVED***@link DocumentReference***REMOVED***.
   * If the document does not exist yet, it will be created. If you pass
   * [SetOptions]***REMOVED***@link SetOptions***REMOVED***., the provided data can be merged
   * into the existing document.
   *
   * @param ***REMOVED***DocumentReference***REMOVED*** documentRef - A reference to the
   * document to be set.
   * @param ***REMOVED***DocumentData***REMOVED*** data - The object to serialize as the document.
   * @param ***REMOVED***SetOptions=***REMOVED*** options - An object to configure the set behavior.
   * @param ***REMOVED***boolean=***REMOVED*** options.merge - If true, set() only replaces the
   * values specified in its data argument. Fields omitted from this set() call
   * remain untouched.
   * @returns ***REMOVED***WriteBatch***REMOVED*** This WriteBatch instance. Used for chaining
   * method calls.
   *
   * @example
   * let writeBatch = firestore.batch();
   * let documentRef = firestore.doc('col/doc');
   *
   * writeBatch.set(documentRef, ***REMOVED***foo: 'bar'***REMOVED***);
   *
   * writeBatch.commit().then(() => ***REMOVED***
   *   console.log('Successfully executed batch.');
   * ***REMOVED***);
   */
  set(documentRef, data, options) ***REMOVED***
    const merge = options && options.merge;

    validate.isDocumentReference('documentRef', documentRef);
    validate.isDocument('data', data, ***REMOVED***
      allowNestedDeletes: merge,
      allowEmpty: !merge,
    ***REMOVED***);
    validate.isOptionalSetOptions('options', options);

    this.verifyNotCommitted();

    const document = DocumentSnapshot.fromObject(documentRef, data);
    const transform = DocumentTransform.fromObject(documentRef, data);
    const documentMask = DocumentMask.fromObject(data);

    let write;

    if (!merge) ***REMOVED***
      write = document.toProto();
    ***REMOVED*** else if (!document.isEmpty || !documentMask.isEmpty) ***REMOVED***
      write = document.toProto();
      write.updateMask = documentMask.toProto();
    ***REMOVED***

    this._writes.push(***REMOVED***
      write,
      transform: transform.isEmpty ? null : transform.toProto(),
    ***REMOVED***);

    return this;
  ***REMOVED***

  /**
   * Update fields of the document referred to by the provided
   * [DocumentReference]***REMOVED***@link DocumentReference***REMOVED***. If the document
   * doesn't yet exist, the update fails and the entire batch will be rejected.
   *
   * The update() method accepts either an object with field paths encoded as
   * keys and field values encoded as values, or a variable number of arguments
   * that alternate between field paths and field values. Nested fields can be
   * updated by providing dot-separated field path strings or by providing
   * FieldPath objects.
   *
   * A Precondition restricting this update can be specified as the last
   * argument.
   *
   * @param ***REMOVED***DocumentReference***REMOVED*** documentRef - A reference to the
   * document to be updated.
   * @param ***REMOVED***UpdateData|string|FieldPath***REMOVED*** dataOrField - An object
   * containing the fields and values with which to update the document
   * or the path of the first field to update.
   * @param ***REMOVED***
   * ...(Precondition|*|string|FieldPath)***REMOVED*** preconditionOrValues -
   * An alternating list of field paths and values to update or a Precondition
   * to restrict this update.
   * @returns ***REMOVED***WriteBatch***REMOVED*** This WriteBatch instance. Used for chaining
   * method calls.
   *
   * @example
   * let writeBatch = firestore.batch();
   * let documentRef = firestore.doc('col/doc');
   *
   * writeBatch.update(documentRef, ***REMOVED***foo: 'bar'***REMOVED***);
   *
   * writeBatch.commit().then(() => ***REMOVED***
   *   console.log('Successfully executed batch.');
   * ***REMOVED***);
   */
  update(documentRef, dataOrField, preconditionOrValues) ***REMOVED***
    validate.minNumberOfArguments('update', arguments, 2);
    validate.isDocumentReference('documentRef', documentRef);

    this.verifyNotCommitted();

    const updateMap = new Map();
    let precondition = new Precondition(***REMOVED***exists: true***REMOVED***);

    const argumentError =
      'Update() requires either a single JavaScript ' +
      'object or an alternating list of field/value pairs that can be ' +
      'followed by an optional precondition.';

    let usesVarargs =
      is.string(dataOrField) || is.instance(dataOrField, FieldPath);

    if (usesVarargs) ***REMOVED***
      try ***REMOVED***
        for (let i = 1; i < arguments.length; i += 2) ***REMOVED***
          if (is.string(arguments[i]) || is.instance(arguments[i], FieldPath)) ***REMOVED***
            validate.isFieldPath(i, arguments[i]);
            validate.minNumberOfArguments('update', arguments, i + 1);
            validate.isFieldValue(i, arguments[i + 1], ***REMOVED***
              allowDeletes: true,
            ***REMOVED***);
            updateMap.set(
              FieldPath.fromArgument(arguments[i]),
              arguments[i + 1]
            );
          ***REMOVED*** else ***REMOVED***
            validate.isUpdatePrecondition(i, arguments[i]);
            validate.maxNumberOfArguments('update', arguments, i + 1);
            precondition = new Precondition(arguments[i]);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** catch (err) ***REMOVED***
        Firestore.log('WriteBatch.update', 'Varargs validation failed:', err);
        // We catch the validation error here and re-throw to provide a better
        // error message.
        throw new Error(`$***REMOVED***argumentError***REMOVED*** $***REMOVED***err.message***REMOVED***`);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      try ***REMOVED***
        validate.isDocument('dataOrField', dataOrField, ***REMOVED***
          allowDeletes: true,
          allowEmpty: false,
        ***REMOVED***);
        validate.maxNumberOfArguments('update', arguments, 3);

        Object.keys(dataOrField).forEach(key => ***REMOVED***
          validate.isFieldPath(key, key);
          validate.isFieldValue(key, dataOrField[key], ***REMOVED***
            allowDeletes: true,
          ***REMOVED***);
          updateMap.set(FieldPath.fromArgument(key), dataOrField[key]);
        ***REMOVED***);

        if (is.defined(preconditionOrValues)) ***REMOVED***
          validate.isUpdatePrecondition(
            'preconditionOrValues',
            preconditionOrValues
          );
          precondition = new Precondition(preconditionOrValues);
        ***REMOVED***
      ***REMOVED*** catch (err) ***REMOVED***
        Firestore.log(
          'WriteBatch.update',
          'Non-varargs validation failed:',
          err
        );
        // We catch the validation error here and prefix the error with a custom
        // message to describe the usage of update() better.
        throw new Error(`$***REMOVED***argumentError***REMOVED*** $***REMOVED***err.message***REMOVED***`);
      ***REMOVED***
    ***REMOVED***

    validate.isUpdateMap('dataOrField', updateMap);

    let document = DocumentSnapshot.fromUpdateMap(documentRef, updateMap);
    let documentMask = DocumentMask.fromUpdateMap(updateMap);

    let write = null;

    if (!document.isEmpty || !documentMask.isEmpty) ***REMOVED***
      write = document.toProto();
      write.updateMask = documentMask.toProto();
    ***REMOVED***

    let transform = DocumentTransform.fromUpdateMap(documentRef, updateMap);

    this._writes.push(***REMOVED***
      write: write,
      transform: transform.isEmpty ? null : transform.toProto(),
      precondition: precondition.toProto(),
    ***REMOVED***);

    return this;
  ***REMOVED***

  /**
   * Atomically commits all pending operations to the database and verifies all
   * preconditions. Fails the entire write if any precondition is not met.
   *
   * @returns ***REMOVED***Promise.<Array.<WriteResult>>***REMOVED*** A Promise that resolves
   * when this batch completes.
   *
   * @example
   * let writeBatch = firestore.batch();
   * let documentRef = firestore.doc('col/doc');
   *
   * writeBatch.set(documentRef, ***REMOVED***foo: 'bar'***REMOVED***);
   *
   * writeBatch.commit().then(() => ***REMOVED***
   *   console.log('Successfully executed batch.');
   * ***REMOVED***);
   */
  commit() ***REMOVED***
    return this.commit_();
  ***REMOVED***

  /**
   * Commit method that takes an optional transaction ID.
   *
   * @private
   * @param ***REMOVED***object=***REMOVED*** commitOptions Options to use for this commit.
   * @param ***REMOVED***bytes=***REMOVED*** commitOptions.transactionId The transaction ID of this
   * commit.
   * @returns ***REMOVED***Promise.<Array.<WriteResult>>***REMOVED*** A Promise that resolves
   * when this batch completes.
   */
  commit_(commitOptions) ***REMOVED***
    // Note: We don't call `verifyNotCommitted()` to allow for retries.

    let explicitTransaction = commitOptions && commitOptions.transactionId;

    let request = ***REMOVED***
      database: this._firestore.formattedName,
    ***REMOVED***;

    // On GCF, we periodically force transactional commits to allow for
    // request retries in case GCF closes our backend connection.
    if (!explicitTransaction && this._shouldCreateTransaction()) ***REMOVED***
      Firestore.log('WriteBatch.commit', 'Using transaction for commit');
      return this._firestore
        .request(
          this._api.Firestore.beginTransaction.bind(this._api.Firestore),
          request,
          /* allowRetries= */ true
        )
        .then(resp => ***REMOVED***
          return this.commit_(***REMOVED***transactionId: resp.transaction***REMOVED***);
        ***REMOVED***);
    ***REMOVED***

    request.writes = [];

    for (let req of this._writes) ***REMOVED***
      assert(
        req.write || req.transform,
        'Either a write or transform must be set'
      );

      if (req.precondition) ***REMOVED***
        (req.write || req.transform).currentDocument = req.precondition;
      ***REMOVED***

      if (req.write) ***REMOVED***
        request.writes.push(req.write);
      ***REMOVED***

      if (req.transform) ***REMOVED***
        request.writes.push(req.transform);
      ***REMOVED***
    ***REMOVED***

    Firestore.log(
      'WriteBatch.commit',
      'Sending %d writes',
      request.writes.length
    );

    if (explicitTransaction) ***REMOVED***
      request.transaction = explicitTransaction;
    ***REMOVED***

    this._committed = true;

    return this._firestore
      .request(this._api.Firestore.commit.bind(this._api.Firestore), request)
      .then(resp => ***REMOVED***
        const commitTime = DocumentSnapshot.toISOTime(resp.commitTime);
        const writeResults = [];

        if (resp.writeResults) ***REMOVED***
          assert(
            request.writes.length === resp.writeResults.length,
            `Expected one write result per operation, but got $***REMOVED***
              resp.writeResults.length
            ***REMOVED*** results for $***REMOVED***request.writes.length***REMOVED*** operations.`
          );

          let offset = 0;

          for (let i = 0; i < this._writes.length; ++i) ***REMOVED***
            let writeRequest = this._writes[i];

            // Don't return two write results for a write that contains a
            // transform, as the fact that we have to split one write operation
            // into two distinct write requests is an implementation detail.
            if (writeRequest.write && writeRequest.transform) ***REMOVED***
              // The document transform is always sent last and produces the
              // latest update time.
              ++offset;
            ***REMOVED***

            let writeResult = resp.writeResults[i + offset];

            writeResults.push(
              new WriteResult(
                DocumentSnapshot.toISOTime(writeResult.updateTime) || commitTime
              )
            );
          ***REMOVED***
        ***REMOVED***

        return writeResults;
      ***REMOVED***);
  ***REMOVED***

  /**
   * Determines whether we should issue a transactional commit. On GCF, this
   * happens after two minutes of idleness.
   *
   * @private
   * @returns ***REMOVED***boolean***REMOVED*** Whether to use a transaction.
   */
  _shouldCreateTransaction() ***REMOVED***
    if (!this._firestore._preferTransactions) ***REMOVED***
      return false;
    ***REMOVED***

    if (this._firestore._lastSuccessfulRequest) ***REMOVED***
      let now = new Date().getTime();
      return now - this._firestore._lastSuccessfulRequest > GCF_IDLE_TIMEOUT_MS;
    ***REMOVED***

    return true;
  ***REMOVED***
***REMOVED***

/*!
 * Validates that the update data does not contain any ambiguous field
 * definitions (such as 'a.b' and 'a').
 *
 * @param ***REMOVED***Map.<FieldPath, *>***REMOVED*** data - An update map with field/value pairs.
 * @returns ***REMOVED***boolean***REMOVED*** 'true' if the input is a valid update map.
 */
function validateUpdateMap(data) ***REMOVED***
  const fields = [];
  data.forEach((value, key) => ***REMOVED***
    fields.push(key);
  ***REMOVED***);

  fields.sort((left, right) => left.compareTo(right));

  for (let i = 1; i < fields.length; ++i) ***REMOVED***
    if (fields[i - 1].isPrefixOf(fields[i])) ***REMOVED***
      throw new Error(`Field "$***REMOVED***fields[i - 1]***REMOVED***" has conflicting definitions.`);
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***

module.exports = (
  FirestoreType,
  DocumentReferenceType,
  validateDocumentReference
) => ***REMOVED***
  let document = require('./document')(DocumentReferenceType);
  Firestore = FirestoreType;
  DocumentMask = document.DocumentMask;
  DocumentSnapshot = document.DocumentSnapshot;
  DocumentTransform = document.DocumentTransform;
  Precondition = document.Precondition;
  validate = require('./validate')(***REMOVED***
    Document: document.validateDocumentData,
    DocumentReference: validateDocumentReference,
    FieldValue: document.validateFieldValue,
    FieldPath: FieldPath.validateFieldPath,
    UpdatePrecondition: precondition =>
      document.validatePrecondition(precondition, /* allowExists= */ false),
    DeletePrecondition: precondition =>
      document.validatePrecondition(precondition, /* allowExists= */ true),
    SetOptions: document.validateSetOptions,
    UpdateMap: validateUpdateMap,
  ***REMOVED***);
  return ***REMOVED***
    WriteBatch,
    WriteResult,
  ***REMOVED***;
***REMOVED***;
