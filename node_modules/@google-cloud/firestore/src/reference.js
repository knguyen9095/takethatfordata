/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const bun = require('bun');
const extend = require('extend');
const is = require('is');
const order = require('./order');
const through = require('through2');

/*!
 * Injected.
 *
 * @see Firestore
 */
let Firestore;

/*!
 * Injected.
 *
 * @see DocumentSnapshot
 */
let DocumentSnapshot;

/*!
 * Injected.
 *
 * @see DocumentTransform
 */
let DocumentTransform;

/*!
 * Injected.
 */
let validate;

/*!
 * Injected.
 *
 * @see Watch
 */
let Watch;

/*!
 * Injected.
 *
 * @see WriteBatch
 */
let WriteBatch;

const path = require('./path');

/*!
 * @private
 * @see ResourcePath
 */
const ResourcePath = path.ResourcePath;

/*!
 * @private
 * @see FieldPath
 */
const FieldPath = path.FieldPath;

/*!
 * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'
 * (descending or ascending).
 *
 * @private
 */
const directionOperators = ***REMOVED***
  asc: 'ASCENDING',
  ASC: 'ASCENDING',
  desc: 'DESCENDING',
  DESC: 'DESCENDING',
***REMOVED***;

/*!
 * Filter conditions in a `Query.where()` clause are specified using the
 * strings '<', '<=', '==', '>=', and '>'.
 *
 * @private
 */
const comparisonOperators = ***REMOVED***
  '<': 'LESS_THAN',
  '<=': 'LESS_THAN_OR_EQUAL',
  '=': 'EQUAL',
  '==': 'EQUAL',
  '>': 'GREATER_THAN',
  '>=': 'GREATER_THAN_OR_EQUAL',
***REMOVED***;

/**
 * onSnapshot() callback that receives a QuerySnapshot.
 *
 * @callback querySnapshotCallback
 * @param ***REMOVED***QuerySnapshot***REMOVED*** snapshot - A query snapshot.
 */

/**
 * onSnapshot() callback that receives a DocumentSnapshot.
 *
 * @callback documentSnapshotCallback
 * @param ***REMOVED***DocumentSnapshot***REMOVED*** snapshot - A document snapshot.
 */

/**
 * onSnapshot() callback that receives an error.
 *
 * @callback errorCallback
 * @param ***REMOVED***Error***REMOVED*** err - An error from a listen.
 */

/**
 * A DocumentReference refers to a document location in a Firestore database
 * and can be used to write, read, or listen to the location. The document at
 * the referenced location may or may not exist. A DocumentReference can
 * also be used to create a
 * [CollectionReference]***REMOVED***@link CollectionReference***REMOVED*** to a
 * subcollection.
 *
 * @class
 */
class DocumentReference ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***Firestore***REMOVED*** firestore - The Firestore Database client.
   * @param ***REMOVED***ResourcePath***REMOVED*** path - The Path of this reference.
   */
  constructor(firestore, path) ***REMOVED***
    this._firestore = firestore;
    this._referencePath = path;
  ***REMOVED***

  /**
   * The string representation of the DocumentReference's location.
   * @private
   * @type ***REMOVED***string***REMOVED***
   * @name DocumentReference#formattedName
   */
  get formattedName() ***REMOVED***
    return this._referencePath.formattedName;
  ***REMOVED***

  /**
   * The [Firestore]***REMOVED***@link Firestore***REMOVED*** instance for the Firestore
   * database (useful for performing transactions, etc.).
   *
   * @type ***REMOVED***Firestore***REMOVED***
   * @name DocumentReference#firestore
   * @readonly
   *
   * @example
   * let collectionRef = firestore.collection('col');
   *
   * collectionRef.add(***REMOVED***foo: 'bar'***REMOVED***).then(documentReference => ***REMOVED***
   *   let firestore = documentReference.firestore;
   *   console.log(`Root location for document is $***REMOVED***firestore.formattedName***REMOVED***`);
   * ***REMOVED***);
   */
  get firestore() ***REMOVED***
    return this._firestore;
  ***REMOVED***

  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   *
   * @type ***REMOVED***string***REMOVED***
   * @name DocumentReference#path
   * @readonly
   *
   * @example
   * let collectionRef = firestore.collection('col');
   *
   * collectionRef.add(***REMOVED***foo: 'bar'***REMOVED***).then(documentReference => ***REMOVED***
   *   console.log(`Added document at '$***REMOVED***documentReference.path***REMOVED***'`);
   * ***REMOVED***);
   */
  get path() ***REMOVED***
    return this._referencePath.relativeName;
  ***REMOVED***

  /**
   * The last path document of the referenced document.
   *
   * @type ***REMOVED***string***REMOVED***
   * @name DocumentReference#id
   * @readonly
   *
   * @example
   * let collectionRef = firestore.collection('col');
   *
   * collectionRef.add(***REMOVED***foo: 'bar'***REMOVED***).then(documentReference => ***REMOVED***
   *   console.log(`Added document with name '$***REMOVED***documentReference.id***REMOVED***'`);
   * ***REMOVED***);
   */
  get id() ***REMOVED***
    return this._referencePath.id;
  ***REMOVED***

  /**
   * A reference to the collection to which this DocumentReference belongs.
   *
   * @name DocumentReference#parent
   * @type ***REMOVED***CollectionReference***REMOVED***
   * @readonly
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   * let collectionRef = documentRef.parent;
   *
   * collectionRef.where('foo', '==', 'bar').get().then(results => ***REMOVED***
   *   console.log(`Found $***REMOVED***results.size***REMOVED*** matches in parent collection`);
   * ***REMOVED***):
   */
  get parent() ***REMOVED***
    return createCollectionReference(
      this._firestore,
      this._referencePath.parent()
    );
  ***REMOVED***

  /**
   * Returns the [ResourcePath]***REMOVED***@link ResourcePath***REMOVED*** for this
   * DocumentReference.
   *
   * @private
   * @type ***REMOVED***ResourcePath***REMOVED***
   * @readonly
   */
  get ref() ***REMOVED***
    return this._referencePath;
  ***REMOVED***

  /**
   * Retrieve a document from the database. Fails the Promise if the document is
   * not found.
   *
   * @returns ***REMOVED***Promise.<DocumentSnapshot>***REMOVED*** A Promise resolved with a
   * DocumentSnapshot for the retrieved document on success. For missing
   * documents, DocumentSnapshot.exists will be false. If the get() fails for
   * other reasons, the Promise will be rejected.
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.get().then(documentSnapshot => ***REMOVED***
   *   if (documentSnapshot.exists) ***REMOVED***
   *     console.log('Document retrieved successfully.');
   *   ***REMOVED***
   * ***REMOVED***);
   */
  get() ***REMOVED***
    return this._firestore.getAll_([this]).then(result => ***REMOVED***
      return result[0];
    ***REMOVED***);
  ***REMOVED***

  /**
   * Gets a [CollectionReference]***REMOVED***@link CollectionReference***REMOVED*** instance
   * that refers to the collection at the specified path.
   *
   * @param ***REMOVED***string***REMOVED*** collectionPath - A slash-separated path to a collection.
   * @returns ***REMOVED***CollectionReference***REMOVED*** A reference to the new
   * subcollection.
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   * let subcollection = documentRef.collection('subcollection');
   * console.log(`Path to subcollection: $***REMOVED***subcollection.path***REMOVED***`);
   */
  collection(collectionPath) ***REMOVED***
    validate.isResourcePath('collectionPath', collectionPath);

    let path = this._referencePath.append(collectionPath);
    if (!path.isCollection) ***REMOVED***
      throw new Error(
        `Argument "collectionPath" must point to a collection, but was "$***REMOVED***collectionPath***REMOVED***". Your path does not contain an odd number of components.`
      );
    ***REMOVED***

    return createCollectionReference(this._firestore, path);
  ***REMOVED***

  /**
   * Fetches the subcollections that are direct children of this document.
   *
   * @returns ***REMOVED***Promise.<Array.<CollectionReference>>***REMOVED*** A Promise that resolves
   * with an array of CollectionReferences.
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.getCollections().then(collections => ***REMOVED***
   *   for (let collection of collections) ***REMOVED***
   *     console.log(`Found subcollection with id: $***REMOVED***collection.id***REMOVED***`);
   *   ***REMOVED***
   * ***REMOVED***);
   */
  getCollections() ***REMOVED***
    let request = ***REMOVED***
      parent: this._referencePath.formattedName,
    ***REMOVED***;

    let api = this._firestore.api.Firestore;

    return this._firestore
      .request(api.listCollectionIds.bind(api), request)
      .then(collectionIds => ***REMOVED***
        let collections = [];

        // We can just sort this list using the default comparator since it will
        // only contain collection ids.
        collectionIds.sort();

        for (let collectionId of collectionIds) ***REMOVED***
          collections.push(this.collection(collectionId));
        ***REMOVED***

        return collections;
      ***REMOVED***);
  ***REMOVED***

  /**
   * Create a document with the provided object values. This will fail the write
   * if a document exists at its location.
   *
   * @param ***REMOVED***DocumentData***REMOVED*** data - An object that contains the fields and data to
   * serialize as the document.
   * @returns ***REMOVED***Promise.<WriteResult>***REMOVED*** A Promise that resolves with the
   * write time of this create.
   *
   * @example
   * let documentRef = firestore.collection('col').doc();
   *
   * documentRef.create(***REMOVED***foo: 'bar'***REMOVED***).then((res) => ***REMOVED***
   *   console.log(`Document created at $***REMOVED***res.updateTime***REMOVED***`);
   * ***REMOVED***).catch((err) => ***REMOVED***
   *   console.log(`Failed to create document: $***REMOVED***err***REMOVED***`);
   * ***REMOVED***);
   */
  create(data) ***REMOVED***
    let writeBatch = new WriteBatch(this._firestore);
    return writeBatch
      .create(this, data)
      .commit()
      .then(writeResults => ***REMOVED***
        return Promise.resolve(writeResults[0]);
      ***REMOVED***);
  ***REMOVED***

  /**
   * Deletes the document referred to by this `DocumentReference`.
   *
   * A delete for a non-existing document is treated as a success (unless
   * lastUptimeTime is provided).
   *
   * @param ***REMOVED***Precondition=***REMOVED*** precondition - A precondition to enforce for this
   * delete.
   * @param ***REMOVED***string=***REMOVED*** precondition.lastUpdateTime If set, enforces that the
   * document was last updated at lastUpdateTime (as ISO 8601 string). Fails the
   * delete if the document was last updated at a different time.
   * @returns ***REMOVED***Promise.<WriteResult>***REMOVED*** A Promise that resolves with the
   * delete time.
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.delete().then(() => ***REMOVED***
   *   console.log('Document successfully deleted.');
   * ***REMOVED***);
   */
  delete(precondition) ***REMOVED***
    let writeBatch = new WriteBatch(this._firestore);
    return writeBatch
      .delete(this, precondition)
      .commit()
      .then(writeResults => ***REMOVED***
        return Promise.resolve(writeResults[0]);
      ***REMOVED***);
  ***REMOVED***

  /**
   * Writes to the document referred to by this DocumentReference. If the
   * document does not yet exist, it will be created. If you pass
   * [SetOptions]***REMOVED***@link SetOptions***REMOVED***, the provided data can be merged into an
   * existing document.
   *
   * @param ***REMOVED***DocumentData***REMOVED*** data - A map of the fields and values for the
   * document.
   * @param ***REMOVED***SetOptions=***REMOVED*** options - An object to configure the set behavior.
   * @param ***REMOVED***boolean=***REMOVED*** options.merge - If true, set() only replaces the
   * values specified in its data argument. Fields omitted from this set() call
   * remain untouched.
   * @returns ***REMOVED***Promise.<WriteResult>***REMOVED*** A Promise that resolves with the
   * write time of this set.
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.set(***REMOVED***foo: 'bar'***REMOVED***).then(res => ***REMOVED***
   *   console.log(`Document written at $***REMOVED***res.updateTime***REMOVED***`);
   * ***REMOVED***);
   */
  set(data, options) ***REMOVED***
    let writeBatch = new WriteBatch(this._firestore);
    return writeBatch
      .set(this, data, options)
      .commit()
      .then(writeResults => ***REMOVED***
        return Promise.resolve(writeResults[0]);
      ***REMOVED***);
  ***REMOVED***

  /**
   * Updates fields in the document referred to by this DocumentReference.
   * If the document doesn't yet exist, the update fails and the returned
   * Promise will be rejected.
   *
   * The update() method accepts either an object with field paths encoded as
   * keys and field values encoded as values, or a variable number of arguments
   * that alternate between field paths and field values.
   *
   * A Precondition restricting this update can be specified as the last
   * argument.
   *
   * @param ***REMOVED***UpdateData|string|FieldPath***REMOVED*** dataOrField - An object
   * containing the fields and values with which to update the document
   * or the path of the first field to update.
   * @param ***REMOVED***
   * ...(*|string|FieldPath|Precondition)***REMOVED*** preconditionOrValues -
   * An alternating list of field paths and values to update or a Precondition
   * to restrict this update.
   * @returns Promise.<WriteResult> A Promise that resolves once the
   * data has been successfully written to the backend.
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * documentRef.update(***REMOVED***foo: 'bar'***REMOVED***).then(res => ***REMOVED***
   *   console.log(`Document updated at $***REMOVED***res.updateTime***REMOVED***`);
   * ***REMOVED***);
   */
  update(dataOrField, preconditionOrValues) ***REMOVED***
    validate.minNumberOfArguments('update', arguments, 1);

    let writeBatch = new WriteBatch(this._firestore);
    preconditionOrValues = Array.prototype.slice.call(arguments, 1);
    return writeBatch.update
      .apply(writeBatch, [this, dataOrField].concat(preconditionOrValues))
      .commit()
      .then(writeResults => ***REMOVED***
        return Promise.resolve(writeResults[0]);
      ***REMOVED***);
  ***REMOVED***

  /**
   * Attaches a listener for DocumentSnapshot events.
   *
   * @param ***REMOVED***documentSnapshotCallback***REMOVED*** onNext - A callback to be called every
   * time a new `DocumentSnapshot` is available.
   * @param ***REMOVED***errorCallback=***REMOVED*** onError - A callback to be called if the listen
   * fails or is cancelled. No further callbacks will occur. If unset, errors
   * will be logged to the console.
   *
   * @returns ***REMOVED***function()***REMOVED*** An unsubscribe function that can be called to cancel
   * the snapshot listener.
   *
   * @example
   * let documentRef = firestore.doc('col/doc');
   *
   * let unsubscribe = documentRef.onSnapshot(documentSnapshot => ***REMOVED***
   *   if (documentSnapshot.exists) ***REMOVED***
   *     console.log(documentSnapshot.data());
   *   ***REMOVED***
   * ***REMOVED***, err => ***REMOVED***
   *   console.log(`Encountered error: $***REMOVED***err***REMOVED***`);
   * ***REMOVED***);
   *
   * // Remove this listener.
   * unsubscribe();
   */
  onSnapshot(onNext, onError) ***REMOVED***
    validate.isFunction('onNext', onNext);
    validate.isOptionalFunction('onError', onError);

    if (!is.defined(onError)) ***REMOVED***
      onError = console.error; // eslint-disable-line no-console
    ***REMOVED***

    let watch = Watch.forDocument(this);

    return watch.onSnapshot((readTime, docs) => ***REMOVED***
      for (let document of docs()) ***REMOVED***
        if (document.ref.path === this.path) ***REMOVED***
          onNext(document);
          return;
        ***REMOVED***
      ***REMOVED***

      // The document is missing.
      let document = new DocumentSnapshot.Builder();
      document.ref = this._referencePath;
      document.readTime = readTime;
      onNext(document.build());
    ***REMOVED***, onError);
  ***REMOVED***
***REMOVED***

/**
 * A DocumentChange represents a change to the documents matching a query.
 * It contains the document affected and the type of change that occurred.
 *
 * @class
 */
class DocumentChange ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***string***REMOVED*** type - 'added' | 'removed' | 'modified'.
   * @param ***REMOVED***QueryDocumentSnapshot***REMOVED*** document - The document.
   * @param ***REMOVED***number***REMOVED*** oldIndex - The index in the documents array prior to this
   * change.
   * @param ***REMOVED***number***REMOVED*** newIndex - The index in the documents array after this
   * change.
   */
  constructor(type, document, oldIndex, newIndex) ***REMOVED***
    this._type = type;
    this._document = document;
    this._oldIndex = oldIndex;
    this._newIndex = newIndex;
  ***REMOVED***

  /**
   * The type of change ('added', 'modified', or 'removed').
   *
   * @type ***REMOVED***string***REMOVED***
   * @name DocumentChange#type
   * @readonly
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   * let docsArray = [];
   *
   * let unsubscribe = query.onSnapshot(querySnapshot => ***REMOVED***
   *   for (let change of querySnapshot.docChanges) ***REMOVED***
   *     console.log(`Type of change is $***REMOVED***change.type***REMOVED***`);
   *   ***REMOVED***
   * ***REMOVED***);
   *
   * // Remove this listener.
   * unsubscribe();
   */
  get type() ***REMOVED***
    return this._type;
  ***REMOVED***

  /**
   * The document affected by this change.
   *
   * @type ***REMOVED***QueryDocumentSnapshot***REMOVED***
   * @name DocumentChange#doc
   * @readonly
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * let unsubscribe = query.onSnapshot(querySnapshot => ***REMOVED***
   *   for (let change of querySnapshot.docChanges) ***REMOVED***
   *     console.log(change.doc.data());
   *   ***REMOVED***
   * ***REMOVED***);
   *
   * // Remove this listener.
   * unsubscribe();
   */
  get doc() ***REMOVED***
    return this._document;
  ***REMOVED***

  /**
   * The index of the changed document in the result set immediately prior to
   * this DocumentChange (i.e. supposing that all prior DocumentChange objects
   * have been applied). Is -1 for 'added' events.
   *
   * @type ***REMOVED***number***REMOVED***
   * @name DocumentChange#oldIndex
   * @readonly
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   * let docsArray = [];
   *
   * let unsubscribe = query.onSnapshot(querySnapshot => ***REMOVED***
   *   for (let change of querySnapshot.docChanges) ***REMOVED***
   *     if (change.oldIndex !== -1) ***REMOVED***
   *       docsArray.splice(change.oldIndex, 1);
   *     ***REMOVED***
   *     if (change.newIndex !== -1) ***REMOVED***
   *       docsArray.splice(change.newIndex, 0, change.doc);
   *     ***REMOVED***
   *   ***REMOVED***
   * ***REMOVED***);
   *
   * // Remove this listener.
   * unsubscribe();
   */
  get oldIndex() ***REMOVED***
    return this._oldIndex;
  ***REMOVED***

  /**
   * The index of the changed document in the result set immediately after
   * this DocumentChange (i.e. supposing that all prior DocumentChange
   * objects and the current DocumentChange object have been applied).
   * Is -1 for 'removed' events.
   *
   * @type ***REMOVED***number***REMOVED***
   * @name DocumentChange#newIndex
   * @readonly
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   * let docsArray = [];
   *
   * let unsubscribe = query.onSnapshot(querySnapshot => ***REMOVED***
   *   for (let change of querySnapshot.docChanges) ***REMOVED***
   *     if (change.oldIndex !== -1) ***REMOVED***
   *       docsArray.splice(change.oldIndex, 1);
   *     ***REMOVED***
   *     if (change.newIndex !== -1) ***REMOVED***
   *       docsArray.splice(change.newIndex, 0, change.doc);
   *     ***REMOVED***
   *   ***REMOVED***
   * ***REMOVED***);
   *
   * // Remove this listener.
   * unsubscribe();
   */
  get newIndex() ***REMOVED***
    return this._newIndex;
  ***REMOVED***
***REMOVED***

/**
 * A Query order-by field.
 *
 * @private
 * @class
 */
class FieldOrder ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***FieldPath***REMOVED*** field - The name of a document field (member)
   * on which to order query results.
   * @param ***REMOVED***string=***REMOVED*** direction One of 'ASCENDING' (default) or 'DESCENDING' to
   * set the ordering direction to ascending or descending, respectively.
   */
  constructor(field, direction) ***REMOVED***
    this._field = field;
    this._direction = direction || directionOperators.ASC;
  ***REMOVED***

  /**
   * The path of the field on which to order query results.
   *
   * @private
   * @type ***REMOVED***FieldPath***REMOVED***
   */
  get field() ***REMOVED***
    return this._field;
  ***REMOVED***

  /**
   * One of 'ASCENDING' (default) or 'DESCENDING'.
   *
   * @private
   * @type ***REMOVED***string***REMOVED***
   */
  get direction() ***REMOVED***
    return this._direction;
  ***REMOVED***

  /**
   * Generates the proto representation for this field order.
   *
   * @private
   * @returns ***REMOVED***Object***REMOVED***
   */
  toProto() ***REMOVED***
    return ***REMOVED***
      field: ***REMOVED***
        fieldPath: this._field.formattedName,
      ***REMOVED***,
      direction: this._direction,
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

/*!
 * A field constraint for a Query where clause.
 *
 * @private
 * @class
 */
class FieldFilter ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***FieldPath***REMOVED*** field - The path of the property value to
   * compare.
   * @param ***REMOVED***string***REMOVED*** opString - A comparison operation.
   * @param ***REMOVED*******REMOVED*** value The value to which to compare the
   * field for inclusion in a query.
   */
  constructor(field, opString, value) ***REMOVED***
    this._field = field;
    this._opString = opString;
    this._value = value;
  ***REMOVED***

  /**
   * Returns the field path of this filter.
   *
   * @private
   * @return ***REMOVED***FieldPath***REMOVED***
   */
  get field() ***REMOVED***
    return this._field;
  ***REMOVED***

  /**
   * Returns whether this FieldFilter uses an equals comparison.
   *
   * @private
   * @return ***REMOVED***boolean***REMOVED***
   */
  isEqualsFilter() ***REMOVED***
    return this._opString === 'EQUAL';
  ***REMOVED***

  /**
   * Generates the proto representation for this field filter.
   *
   * @private
   * @returns ***REMOVED***Object***REMOVED***
   */
  toProto() ***REMOVED***
    if (typeof this._value === 'number' && isNaN(this._value)) ***REMOVED***
      return ***REMOVED***
        unaryFilter: ***REMOVED***
          field: ***REMOVED***
            fieldPath: this._field.formattedName,
          ***REMOVED***,
          op: 'IS_NAN',
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***

    if (this._value === null) ***REMOVED***
      return ***REMOVED***
        unaryFilter: ***REMOVED***
          field: ***REMOVED***
            fieldPath: this._field.formattedName,
          ***REMOVED***,
          op: 'IS_NULL',
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***

    return ***REMOVED***
      fieldFilter: ***REMOVED***
        field: ***REMOVED***
          fieldPath: this._field.formattedName,
        ***REMOVED***,
        op: this._opString,
        value: DocumentSnapshot.encodeValue(this._value),
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

/**
 * A QuerySnapshot contains zero or more
 * [QueryDocumentSnapshot]***REMOVED***@link QueryDocumentSnapshot***REMOVED*** objects
 * representing the results of a query. The documents can be accessed as an
 * array via the [documents]***REMOVED***@link QuerySnapshot#documents***REMOVED*** property
 * or enumerated using the [forEach]***REMOVED***@link QuerySnapshot#forEach***REMOVED***
 * method. The number of documents can be determined via the
 * [empty]***REMOVED***@link QuerySnapshot#empty***REMOVED*** and
 * [size]***REMOVED***@link QuerySnapshot#size***REMOVED*** properties.
 *
 * @class QuerySnapshot
 */
class QuerySnapshot ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***Query***REMOVED*** query - The originating query.
   * @param ***REMOVED***string***REMOVED*** readTime - The ISO 8601 time when this query snapshot was
   * current.
   *
   * @param ***REMOVED***function***REMOVED*** docs - A callback returning a sorted array of documents
   * matching this query
   * @param ***REMOVED***function***REMOVED*** changes - A callback returning a sorted array of
   * document change events for this snapshot.
   */
  constructor(query, readTime, docs, changes) ***REMOVED***
    this._query = query;
    this._comparator = query.comparator();
    this._readTime = readTime;
    this._docs = docs;
    this._changes = changes;
  ***REMOVED***

  /**
   * The query on which you called get() or onSnapshot() in order to get this
   * QuerySnapshot.
   *
   * @type ***REMOVED***Query***REMOVED***
   * @name QuerySnapshot#query
   * @readonly
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * query.limit(10).get().then(querySnapshot => ***REMOVED***
   *   console.log(`Returned first batch of results`);
   *   let query = querySnapshot.query;
   *   return query.offset(10).get();
   * ***REMOVED***).then(() => ***REMOVED***
   *   console.log(`Returned second batch of results`);
   * ***REMOVED***);
   */
  get query() ***REMOVED***
    return this._query;
  ***REMOVED***

  /**
   * An array of all the documents in this QuerySnapshot.
   *
   * @type ***REMOVED***Array.<QueryDocumentSnapshot>***REMOVED***
   * @name QuerySnapshot#docs
   * @readonly
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * query.get().then(querySnapshot => ***REMOVED***
   *   let docs = querySnapshot.docs;
   *   for (let doc of docs) ***REMOVED***
   *     console.log(`Document found at path: $***REMOVED***doc.ref.path***REMOVED***`);
   *   ***REMOVED***
   * ***REMOVED***);
   */
  get docs() ***REMOVED***
    if (this._materializedDocs) ***REMOVED***
      return this._materializedDocs;
    ***REMOVED***
    this._materializedDocs = this._docs();
    return this._materializedDocs;
  ***REMOVED***

  /**
   * An array of all changes in this QuerySnapshot.
   *
   * @type ***REMOVED***Array.<DocumentChange>***REMOVED***
   * @name QuerySnapshot#docChanges
   * @readonly
   */
  get docChanges() ***REMOVED***
    if (this._materializedChanges) ***REMOVED***
      return this._materializedChanges;
    ***REMOVED***
    this._materializedChanges = this._changes();
    return this._materializedChanges;
  ***REMOVED***

  /**
   * True if there are no documents in the QuerySnapshot.
   *
   * @type ***REMOVED***boolean***REMOVED***
   * @name QuerySnapshot#empty
   * @readonly
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * query.get().then(querySnapshot => ***REMOVED***
   *   if (querySnapshot.empty) ***REMOVED***
   *     console.log('No documents found.');
   *   ***REMOVED***
   * ***REMOVED***);
   */
  get empty() ***REMOVED***
    return this.docs.length === 0;
  ***REMOVED***

  /**
   * The number of documents in the QuerySnapshot.
   *
   * @type ***REMOVED***number***REMOVED***
   * @name QuerySnapshot#size
   * @readonly
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * query.get().then(querySnapshot => ***REMOVED***
   *   console.log(`Found $***REMOVED***querySnapshot.size***REMOVED*** documents.`);
   * ***REMOVED***);
   */
  get size() ***REMOVED***
    return this.docs.length;
  ***REMOVED***

  /**
   * The time this query snapshot was obtained.
   *
   * @type ***REMOVED***string***REMOVED***
   * @name QuerySnapshot#readTime
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * query.get().then((querySnapshot) => ***REMOVED***
   *   console.log(`Query results returned at '$***REMOVED***querySnapshot.readTime***REMOVED***'`);
   * ***REMOVED***);
   */
  get readTime() ***REMOVED***
    return this._readTime;
  ***REMOVED***

  /**
   * Enumerates all of the documents in the QuerySnapshot.
   *
   * @param ***REMOVED***function***REMOVED*** callback - A callback to be called with a
   * [QueryDocumentSnapshot]***REMOVED***@link QueryDocumentSnapshot***REMOVED*** for each document in
   * the snapshot.
   * @param ***REMOVED****=***REMOVED*** thisArg The `this` binding for the callback..
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * query.get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Document found at path: $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  forEach(callback, thisArg) ***REMOVED***
    validate.isFunction('callback', callback);

    for (let doc of this.docs) ***REMOVED***
      callback.call(thisArg, doc);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * A Query refers to a query which you can read or stream from. You can also
 * construct refined Query objects by adding filters and ordering.
 *
 * @class Query
 */
class Query ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***Firestore***REMOVED*** firestore - The Firestore Database client.
   * @param ***REMOVED***ResourcePath***REMOVED*** path Path of the collection to be queried.
   * @param ***REMOVED***Array.<FieldOrder>=***REMOVED*** fieldOrders - Sequence of fields to
   * control the order of results.
   * @param ***REMOVED***Array.<FieldFilter>=***REMOVED*** fieldFilters - Sequence of fields
   * constraining the results of the query.
   * @param ***REMOVED***object=***REMOVED*** queryOptions Additional query options.
   */
  constructor(firestore, path, fieldFilters, fieldOrders, queryOptions) ***REMOVED***
    this._firestore = firestore;
    this._api = firestore.api;
    this._referencePath = path;
    this._fieldFilters = fieldFilters || [];
    this._fieldOrders = fieldOrders || [];
    this._queryOptions = queryOptions || ***REMOVED******REMOVED***;
  ***REMOVED***

  /**
   * Detects the argument type for Firestore cursors.
   *
   * @private
   * @param ***REMOVED***Array.<DocumentSnapshot|*>***REMOVED*** fieldValuesOrDocumentSnapshot - A
   * snapshot of the document or a set of field values.
   * @returns ***REMOVED***boolean***REMOVED*** 'true' if the input is a single DocumentSnapshot..
   */
  static _isDocumentSnapshot(fieldValuesOrDocumentSnapshot) ***REMOVED***
    return (
      fieldValuesOrDocumentSnapshot.length === 1 &&
      is.instance(fieldValuesOrDocumentSnapshot[0], DocumentSnapshot)
    );
  ***REMOVED***

  /**
   * Extracts field values from the DocumentSnapshot based on the provided
   * field order.
   *
   * @private
   * @param ***REMOVED***DocumentSnapshot***REMOVED*** documentSnapshot - The document to extract the
   * fields from.
   * @param ***REMOVED***Array.<FieldOrder>***REMOVED*** fieldOrders - The field order that defines what
   * fields we should extract.
   * @return ***REMOVED***Array.<*>***REMOVED*** The field values to use.
   * @private
   */
  static _extractFieldValues(documentSnapshot, fieldOrders) ***REMOVED***
    let fieldValues = [];

    for (let fieldOrder of fieldOrders) ***REMOVED***
      if (fieldOrder.field === FieldPath._DOCUMENT_ID) ***REMOVED***
        fieldValues.push(documentSnapshot.ref);
      ***REMOVED*** else ***REMOVED***
        let fieldValue = documentSnapshot.get(fieldOrder.field);
        if (is.undefined(fieldValue)) ***REMOVED***
          throw new Error(
            `Field '$***REMOVED***
              fieldOrder.field
            ***REMOVED***' is missing in the provided DocumentSnapshot. Please provide a ` +
              'document that contains values for all specified orderBy() and ' +
              'where() constraints.'
          );
        ***REMOVED*** else ***REMOVED***
          fieldValues.push(fieldValue);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    return fieldValues;
  ***REMOVED***

  /**
   * The string representation of the Query's location.
   * @private
   * @type ***REMOVED***string***REMOVED***
   * @name Query#formattedName
   */
  get formattedName() ***REMOVED***
    return this._referencePath.formattedName;
  ***REMOVED***

  /**
   * The [Firestore]***REMOVED***@link Firestore***REMOVED*** instance for the Firestore
   * database (useful for performing transactions, etc.).
   *
   * @type ***REMOVED***Firestore***REMOVED***
   * @name Query#firestore
   * @readonly
   *
   * @example
   * let collectionRef = firestore.collection('col');
   *
   * collectionRef.add(***REMOVED***foo: 'bar'***REMOVED***).then(documentReference => ***REMOVED***
   *   let firestore = documentReference.firestore;
   *   console.log(`Root location for document is $***REMOVED***firestore.formattedName***REMOVED***`);
   * ***REMOVED***);
   */
  get firestore() ***REMOVED***
    return this._firestore;
  ***REMOVED***

  /**
   * Creates and returns a new [Query]***REMOVED***@link Query***REMOVED*** with the additional filter
   * that documents must contain the specified field and that its value should
   * satisfy the relation constraint provided.
   *
   * Returns a new Query that constrains the value of a Document property.
   *
   * This function returns a new (immutable) instance of the Query (rather than
   * modify the existing instance) to impose the filter.
   *
   * @param ***REMOVED***string|FieldPath***REMOVED*** fieldPath - The name of a property
   * value to compare.
   * @param ***REMOVED***string***REMOVED*** opStr - A comparison operation in the form of a string
   * (e.g., "<").
   * @param ***REMOVED*******REMOVED*** value - The value to which to compare the field for inclusion in
   * a query.
   * @returns ***REMOVED***Query***REMOVED*** The created Query.
   *
   * @example
   * let collectionRef = firestore.collection('col');
   *
   * collectionRef.where('foo', '==', 'bar').get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  where(fieldPath, opStr, value) ***REMOVED***
    validate.isFieldPath('fieldPath', fieldPath);
    validate.isFieldComparison('opStr', opStr, value);

    if (this._queryOptions.startAt || this._queryOptions.endAt) ***REMOVED***
      throw new Error(
        'Cannot specify a where() filter after calling startAt(), ' +
          'startAfter(), endBefore() or endAt().'
      );
    ***REMOVED***

    let newFilter = new FieldFilter(
      FieldPath.fromArgument(fieldPath),
      comparisonOperators[opStr],
      value
    );
    let combinedFilters = this._fieldFilters.concat(newFilter);
    return new Query(
      this._firestore,
      this._referencePath,
      combinedFilters,
      this._fieldOrders,
      this._queryOptions
    );
  ***REMOVED***

  /**
   * Creates and returns a new [Query]***REMOVED***@link Query***REMOVED*** instance that applies a
   * field mask to the result and returns only the specified subset of fields.
   * You can specify a list of field paths to return, or use an empty list to
   * only return the references of matching documents.
   *
   * This function returns a new (immutable) instance of the Query (rather than
   * modify the existing instance) to impose the field mask.
   *
   * @param ***REMOVED***...(string|FieldPath)***REMOVED*** fieldPaths - The field paths to
   * return.
   * @returns ***REMOVED***Query***REMOVED*** The created Query.
   *
   * @example
   * let collectionRef = firestore.collection('col');
   * let documentRef = collectionRef.doc('doc');
   *
   * return documentRef.set(***REMOVED***x:10, y:5***REMOVED***).then(() => ***REMOVED***
   *   return collectionRef.where('x', '>', 5).select('y').get();
   * ***REMOVED***).then((res) => ***REMOVED***
   *   console.log(`y is $***REMOVED***res.docs[0].get('y')***REMOVED***.`);
   * ***REMOVED***);
   */
  select(fieldPaths) ***REMOVED***
    fieldPaths = [].slice.call(arguments);

    let result = [];

    if (fieldPaths.length === 0) ***REMOVED***
      result.push(***REMOVED***fieldPath: FieldPath._DOCUMENT_ID.formattedName***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      for (let i = 0; i < fieldPaths.length; ++i) ***REMOVED***
        validate.isFieldPath(i, fieldPaths[i]);
        result.push(***REMOVED***
          fieldPath: FieldPath.fromArgument(fieldPaths[i]).formattedName,
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    let options = extend(true, ***REMOVED******REMOVED***, this._queryOptions);
    options.selectFields = ***REMOVED***fields: result***REMOVED***;

    return new Query(
      this._firestore,
      this._referencePath,
      this._fieldFilters,
      this._fieldOrders,
      options
    );
  ***REMOVED***

  /**
   * Creates and returns a new [Query]***REMOVED***@link Query***REMOVED*** that's additionally sorted
   * by the specified field, optionally in descending order instead of
   * ascending.
   *
   * This function returns a new (immutable) instance of the Query (rather than
   * modify the existing instance) to impose the field mask.
   *
   * @param ***REMOVED***string|FieldPath***REMOVED*** fieldPath - The field to sort by.
   * @param ***REMOVED***string=***REMOVED*** directionStr - Optional direction to sort by ('asc' or
   * 'desc'). If not specified, order will be ascending.
   * @returns ***REMOVED***Query***REMOVED*** The created Query.
   *
   * @example
   * let query = firestore.collection('col').where('foo', '>', 42);
   *
   * query.orderBy('foo', 'desc').get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  orderBy(fieldPath, directionStr) ***REMOVED***
    validate.isFieldPath('fieldPath', fieldPath);
    validate.isOptionalFieldOrder('directionStr', directionStr);

    if (this._queryOptions.startAt || this._queryOptions.endAt) ***REMOVED***
      throw new Error(
        'Cannot specify an orderBy() constraint after calling ' +
          'startAt(), startAfter(), endBefore() or endAt().'
      );
    ***REMOVED***

    let newOrder = new FieldOrder(
      FieldPath.fromArgument(fieldPath),
      directionOperators[directionStr]
    );
    let combinedOrders = this._fieldOrders.concat(newOrder);
    return new Query(
      this._firestore,
      this._referencePath,
      this._fieldFilters,
      combinedOrders,
      this._queryOptions
    );
  ***REMOVED***

  /**
   * Creates and returns a new [Query]***REMOVED***@link Query***REMOVED*** that's additionally limited
   * to only return up to the specified number of documents.
   *
   * This function returns a new (immutable) instance of the Query (rather than
   * modify the existing instance) to impose the limit.
   *
   * @param ***REMOVED***number***REMOVED*** limit - The maximum number of items to return.
   * @returns ***REMOVED***Query***REMOVED*** The created Query.
   *
   * @example
   * let query = firestore.collection('col').where('foo', '>', 42);
   *
   * query.limit(1).get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  limit(limit) ***REMOVED***
    validate.isInteger('limit', limit);

    let options = extend(true, ***REMOVED******REMOVED***, this._queryOptions);
    options.limit = limit;
    return new Query(
      this._firestore,
      this._referencePath,
      this._fieldFilters,
      this._fieldOrders,
      options
    );
  ***REMOVED***

  /**
   * Specifies the offset of the returned results.
   *
   * This function returns a new (immutable) instance of the
   * [Query]***REMOVED***@link Query***REMOVED*** (rather than modify the existing instance)
   * to impose the offset.
   *
   * @param ***REMOVED***number***REMOVED*** offset - The offset to apply to the Query results
   * @returns ***REMOVED***Query***REMOVED*** The created Query.
   *
   * @example
   * let query = firestore.collection('col').where('foo', '>', 42);
   *
   * query.limit(10).offset(20).get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  offset(offset) ***REMOVED***
    validate.isInteger('offset', offset);

    let options = extend(true, ***REMOVED******REMOVED***, this._queryOptions);
    options.offset = offset;
    return new Query(
      this._firestore,
      this._referencePath,
      this._fieldFilters,
      this._fieldOrders,
      options
    );
  ***REMOVED***

  /**
   * Computes the backend ordering semantics for DocumentSnapshot cursors.
   *
   * @private
   * @param ***REMOVED***Array.<DocumentSnapshot|*>***REMOVED*** cursorValuesOrDocumentSnapshot - The
   * snapshot of the document or the set of field values to use as the boundary.
   * @returns ***REMOVED***Array.<FieldOrder>***REMOVED*** The implicit ordering semantics.
   */
  _createImplicitOrderBy(cursorValuesOrDocumentSnapshot) ***REMOVED***
    if (!Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) ***REMOVED***
      return this._fieldOrders;
    ***REMOVED***

    let fieldOrders = this._fieldOrders.slice();
    let hasDocumentId = false;

    if (fieldOrders.length === 0) ***REMOVED***
      // If no explicit ordering is specified, use the first inequality to
      // define an implicit order.
      for (let fieldFilter of this._fieldFilters) ***REMOVED***
        if (!fieldFilter.isEqualsFilter()) ***REMOVED***
          fieldOrders.push(new FieldOrder(fieldFilter.field, 'ASCENDING'));
          break;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      for (let fieldOrder of fieldOrders) ***REMOVED***
        if (fieldOrder.field === FieldPath._DOCUMENT_ID) ***REMOVED***
          hasDocumentId = true;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (!hasDocumentId) ***REMOVED***
      // Add implicit sorting by name, using the last specified direction.
      let lastDirection =
        fieldOrders.length === 0
          ? directionOperators.ASC
          : fieldOrders[fieldOrders.length - 1].direction;

      fieldOrders.push(new FieldOrder(FieldPath.documentId(), lastDirection));
    ***REMOVED***

    return fieldOrders;
  ***REMOVED***

  /**
   * Builds a Firestore 'Position' proto message.
   *
   * @private
   * @param ***REMOVED***Array.<FieldOrder>***REMOVED*** fieldOrders - The field orders to use for this
   * cursor.
   * @param ***REMOVED***Array.<DocumentSnapshot|*>***REMOVED*** cursorValuesOrDocumentSnapshot - The
   * snapshot of the document or the set of field values to use as the
   * boundary.
   * @param before - Whether the query boundary lies just before or after the
   * provided data.
   * @returns ***REMOVED***Object***REMOVED*** The proto message.
   */
  _createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) ***REMOVED***
    let fieldValues;

    if (Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) ***REMOVED***
      fieldValues = Query._extractFieldValues(
        cursorValuesOrDocumentSnapshot[0],
        fieldOrders
      );
    ***REMOVED*** else ***REMOVED***
      fieldValues = cursorValuesOrDocumentSnapshot;
    ***REMOVED***

    if (fieldValues.length > fieldOrders.length) ***REMOVED***
      throw new Error(
        'Too many cursor values specified. The specified ' +
          'values must match the orderBy() constraints of the query.'
      );
    ***REMOVED***

    let options = ***REMOVED***
      values: [],
    ***REMOVED***;

    if (before) ***REMOVED***
      options.before = true;
    ***REMOVED***

    for (let i = 0; i < fieldValues.length; ++i) ***REMOVED***
      let fieldValue = fieldValues[i];

      if (fieldOrders[i].field === FieldPath._DOCUMENT_ID) ***REMOVED***
        if (is.string(fieldValue)) ***REMOVED***
          fieldValue = new DocumentReference(
            this._firestore,
            this._referencePath.append(fieldValue)
          );
        ***REMOVED*** else if (is.instance(fieldValue, DocumentReference)) ***REMOVED***
          if (!this._referencePath.isPrefixOf(fieldValue.ref)) ***REMOVED***
            throw new Error(
              `'$***REMOVED***fieldValue.path***REMOVED***' is not part of the query ` +
                'result set and cannot be used as a query boundary.'
            );
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          throw new Error(
            'The corresponding value for FieldPath.documentId() must be a ' +
              'string or a DocumentReference.'
          );
        ***REMOVED***

        if (fieldValue.ref.parent().compareTo(this._referencePath) !== 0) ***REMOVED***
          throw new Error(
            'Only a direct child can be used as a query boundary. ' +
              `Found: '$***REMOVED***fieldValue.path***REMOVED***'.`
          );
        ***REMOVED***
      ***REMOVED***

      if (DocumentTransform.isTransformSentinel(fieldValue)) ***REMOVED***
        throw new Error(
          `Cannot use FieldValue.delete() or FieldValue.serverTimestamp() in ` +
            `a query boundary. Found at index $***REMOVED***i***REMOVED***.`
        );
      ***REMOVED***

      options.values.push(DocumentSnapshot.encodeValue(fieldValue));
    ***REMOVED***

    return options;
  ***REMOVED***

  /**
   * Creates and returns a new [Query]***REMOVED***@link Query***REMOVED*** that starts at the provided
   * set of field values relative to the order of the query. The order of the
   * provided values must match the order of the order by clauses of the query.
   *
   * @param ***REMOVED***...*|DocumentSnapshot***REMOVED*** fieldValuesOrDocumentSnapshot - The snapshot
   * of the document the query results should start at or the field values to
   * start this query at, in order of the query's order by.
   * @returns ***REMOVED***Query***REMOVED*** A query with the new starting point.
   *
   * @example
   * let query = firestore.collection('col');
   *
   * query.orderBy('foo').startAt(42).get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  startAt(fieldValuesOrDocumentSnapshot) ***REMOVED***
    let options = extend(true, ***REMOVED******REMOVED***, this._queryOptions);

    fieldValuesOrDocumentSnapshot = [].slice.call(arguments);

    let fieldOrders = this._createImplicitOrderBy(
      fieldValuesOrDocumentSnapshot
    );
    options.startAt = this._createCursor(
      fieldOrders,
      fieldValuesOrDocumentSnapshot,
      true
    );

    return new Query(
      this._firestore,
      this._referencePath,
      this._fieldFilters,
      fieldOrders,
      options
    );
  ***REMOVED***

  /**
   * Creates and returns a new [Query]***REMOVED***@link Query***REMOVED*** that starts after the
   * provided set of field values relative to the order of the query. The order
   * of the provided values must match the order of the order by clauses of the
   * query.
   *
   * @param ***REMOVED***...*|DocumentSnapshot***REMOVED*** fieldValuesOrDocumentSnapshot - The snapshot
   * of the document the query results should start after or the field values to
   * start this query after, in order of the query's order by.
   * @returns ***REMOVED***Query***REMOVED*** A query with the new starting point.
   *
   * @example
   * let query = firestore.collection('col');
   *
   * query.orderBy('foo').startAfter(42).get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  startAfter(fieldValuesOrDocumentSnapshot) ***REMOVED***
    let options = extend(true, ***REMOVED******REMOVED***, this._queryOptions);

    fieldValuesOrDocumentSnapshot = [].slice.call(arguments);

    let fieldOrders = this._createImplicitOrderBy(
      fieldValuesOrDocumentSnapshot
    );
    options.startAt = this._createCursor(
      fieldOrders,
      fieldValuesOrDocumentSnapshot,
      false
    );

    return new Query(
      this._firestore,
      this._referencePath,
      this._fieldFilters,
      fieldOrders,
      options
    );
  ***REMOVED***

  /**
   * Creates and returns a new [Query]***REMOVED***@link Query***REMOVED*** that ends before the set of
   * field values relative to the order of the query. The order of the provided
   * values must match the order of the order by clauses of the query.
   *
   * @param ***REMOVED***...*|DocumentSnapshot***REMOVED*** fieldValuesOrDocumentSnapshot - The snapshot
   * of the document the query results should end before or the field values to
   * end this query before, in order of the query's order by.
   * @returns ***REMOVED***Query***REMOVED*** A query with the new ending point.
   *
   * @example
   * let query = firestore.collection('col');
   *
   * query.orderBy('foo').endBefore(42).get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  endBefore(fieldValuesOrDocumentSnapshot) ***REMOVED***
    let options = extend(true, ***REMOVED******REMOVED***, this._queryOptions);

    fieldValuesOrDocumentSnapshot = [].slice.call(arguments);

    let fieldOrders = this._createImplicitOrderBy(
      fieldValuesOrDocumentSnapshot
    );
    options.endAt = this._createCursor(
      fieldOrders,
      fieldValuesOrDocumentSnapshot,
      true
    );

    return new Query(
      this._firestore,
      this._referencePath,
      this._fieldFilters,
      fieldOrders,
      options
    );
  ***REMOVED***

  /**
   * Creates and returns a new [Query]***REMOVED***@link Query***REMOVED*** that ends at the provided
   * set of field values relative to the order of the query. The order of the
   * provided values must match the order of the order by clauses of the query.
   *
   * @param ***REMOVED***...*|DocumentSnapshot***REMOVED*** fieldValuesOrDocumentSnapshot - The snapshot
   * of the document the query results should end at or the field values to end
   * this query at, in order of the query's order by.
   * @returns ***REMOVED***Query***REMOVED*** A query with the new ending point.
   *
   * @example
   * let query = firestore.collection('col');
   *
   * query.orderBy('foo').endAt(42).get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  endAt(fieldValuesOrDocumentSnapshot) ***REMOVED***
    let options = extend(true, ***REMOVED******REMOVED***, this._queryOptions);

    fieldValuesOrDocumentSnapshot = [].slice.call(arguments);

    let fieldOrders = this._createImplicitOrderBy(
      fieldValuesOrDocumentSnapshot
    );
    options.endAt = this._createCursor(
      fieldOrders,
      fieldValuesOrDocumentSnapshot,
      false
    );

    return new Query(
      this._firestore,
      this._referencePath,
      this._fieldFilters,
      fieldOrders,
      options
    );
  ***REMOVED***

  /**
   * Executes the query and returns the results as a
   * [QuerySnapshot]***REMOVED***@link QuerySnapshot***REMOVED***.
   *
   * @returns ***REMOVED***Promise.<QuerySnapshot>***REMOVED*** A Promise that resolves with the results
   * of the Query.
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * query.get().then(querySnapshot => ***REMOVED***
   *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
   *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path***REMOVED***`);
   *   ***REMOVED***);
   * ***REMOVED***);
   */
  get() ***REMOVED***
    return this._get();
  ***REMOVED***

  /**
   * Internal get() method that accepts an optional transaction id.
   *
   * @private
   * @param ***REMOVED***bytes=***REMOVED*** queryOptions.transactionId - A transaction ID.
   */
  _get(queryOptions) ***REMOVED***
    let self = this;
    let docs = [];
    let changes = [];

    return new Promise((resolve, reject) => ***REMOVED***
      let readTime;

      self
        ._stream(queryOptions)
        .on('error', err => ***REMOVED***
          reject(err);
        ***REMOVED***)
        .on('data', result => ***REMOVED***
          readTime = result.readTime;
          if (result.document) ***REMOVED***
            let document = result.document;
            changes.push(
              new DocumentChange(
                DocumentChange.ADDED,
                document,
                -1,
                docs.length
              )
            );
            docs.push(document);
          ***REMOVED***
        ***REMOVED***)
        .on('end', () => ***REMOVED***
          resolve(new QuerySnapshot(this, readTime, () => docs, () => changes));
        ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Executes the query and streams the results as
   * [QueryDocumentSnapshots]***REMOVED***@link QueryDocumentSnapshot***REMOVED***.
   *
   * @returns ***REMOVED***Stream.<QueryDocumentSnapshot>***REMOVED*** A stream of
   * QueryDocumentSnapshots.
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * let count = 0;
   *
   * query.stream().on('data', (documentSnapshot) => ***REMOVED***
   *   console.log(`Found document with name '$***REMOVED***documentSnapshot.id***REMOVED***'`);
   *   ++count;
   * ***REMOVED***).on('end', () => ***REMOVED***
   *   console.log(`Total count is $***REMOVED***count***REMOVED***`);
   * ***REMOVED***);
   */
  stream() ***REMOVED***
    let responseStream = this._stream();

    let transform = through.obj(function(chunk, encoding, callback) ***REMOVED***
      // Only send chunks with documents.
      if (chunk.document) ***REMOVED***
        this.push(chunk.document);
      ***REMOVED***
      callback();
    ***REMOVED***);

    return bun([responseStream, transform]);
  ***REMOVED***

  /**
   * Internal method for serializing a query to its RunQuery proto
   * representation with an optional transaction id.
   *
   * @param ***REMOVED***bytes=***REMOVED*** queryOptions.transactionId - A transaction ID.
   * @private
   * @returns Serialized JSON for the query.
   */
  toProto(queryOptions) ***REMOVED***
    let reqOpts = ***REMOVED***
      parent: this._referencePath.parent().formattedName,
      structuredQuery: ***REMOVED***
        from: [
          ***REMOVED***
            collectionId: this._referencePath.id,
          ***REMOVED***,
        ],
      ***REMOVED***,
    ***REMOVED***;

    let structuredQuery = reqOpts.structuredQuery;

    if (this._fieldFilters.length === 1) ***REMOVED***
      structuredQuery.where = this._fieldFilters[0].toProto();
    ***REMOVED*** else if (this._fieldFilters.length > 1) ***REMOVED***
      let filters = [];
      for (let fieldFilter of this._fieldFilters) ***REMOVED***
        filters.push(fieldFilter.toProto());
      ***REMOVED***
      structuredQuery.where = ***REMOVED***
        compositeFilter: ***REMOVED***
          op: 'AND',
          filters: filters,
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***

    if (this._fieldOrders.length) ***REMOVED***
      let orderBy = [];
      for (let fieldOrder of this._fieldOrders) ***REMOVED***
        orderBy.push(fieldOrder.toProto());
      ***REMOVED***
      structuredQuery.orderBy = orderBy;
    ***REMOVED***

    if (this._queryOptions.limit) ***REMOVED***
      structuredQuery.limit = ***REMOVED***value: this._queryOptions.limit***REMOVED***;
    ***REMOVED***

    if (this._queryOptions.offset) ***REMOVED***
      structuredQuery.offset = this._queryOptions.offset;
    ***REMOVED***

    if (this._queryOptions.startAt) ***REMOVED***
      structuredQuery.startAt = this._queryOptions.startAt;
    ***REMOVED***

    if (this._queryOptions.endAt) ***REMOVED***
      structuredQuery.endAt = this._queryOptions.endAt;
    ***REMOVED***

    if (this._queryOptions.selectFields) ***REMOVED***
      structuredQuery.select = this._queryOptions.selectFields;
    ***REMOVED***

    if (queryOptions && queryOptions.transactionId) ***REMOVED***
      reqOpts.transaction = queryOptions.transactionId;
    ***REMOVED***

    return reqOpts;
  ***REMOVED***

  /**
   * Internal streaming method that accepts an optional transaction id.
   *
   * @param ***REMOVED***bytes=***REMOVED*** queryOptions.transactionId - A transaction ID.
   * @private
   * @returns ***REMOVED***stream***REMOVED*** A stream of document results.
   */
  _stream(queryOptions) ***REMOVED***
    let request = this.toProto(queryOptions);
    let self = this;

    let stream = through.obj(function(proto, enc, callback) ***REMOVED***
      let readTime = DocumentSnapshot.toISOTime(proto.readTime);
      if (proto.document) ***REMOVED***
        let document = self.firestore.snapshot_(proto.document, proto.readTime);
        this.push(***REMOVED***document, readTime***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        this.push(***REMOVED***readTime***REMOVED***);
      ***REMOVED***
      callback();
    ***REMOVED***);

    this._firestore
      .readStream(
        this._api.Firestore.runQuery.bind(this._api.Firestore),
        request,
        /* allowRetries= */ true
      )
      .then(backendStream => ***REMOVED***
        backendStream.on('error', err => ***REMOVED***
          Firestore.log(
            'Query._stream',
            'Query failed with stream error:',
            err
          );
          stream.destroy(err);
        ***REMOVED***);
        backendStream.resume();
        backendStream.pipe(stream);
      ***REMOVED***)
      .catch(err => ***REMOVED***
        stream.destroy(err);
      ***REMOVED***);

    return stream;
  ***REMOVED***

  /**
   * Attaches a listener for QuerySnapshot events.
   *
   * @param ***REMOVED***querySnapshotCallback***REMOVED*** onNext - A callback to be called every time
   * a new [QuerySnapshot]***REMOVED***@link QuerySnapshot***REMOVED*** is available.
   * @param ***REMOVED***errorCallback=***REMOVED*** onError - A callback to be called if the listen
   * fails or is cancelled. No further callbacks will occur.
   *
   * @returns ***REMOVED***function()***REMOVED*** An unsubscribe function that can be called to cancel
   * the snapshot listener.
   *
   * @example
   * let query = firestore.collection('col').where('foo', '==', 'bar');
   *
   * let unsubscribe = query.onSnapshot(querySnapshot => ***REMOVED***
   *   console.log(`Received query snapshot of size $***REMOVED***querySnapshot.size***REMOVED***`);
   * ***REMOVED***, err => ***REMOVED***
   *   console.log(`Encountered error: $***REMOVED***err***REMOVED***`);
   * ***REMOVED***);
   *
   * // Remove this listener.
   * unsubscribe();
   */
  onSnapshot(onNext, onError) ***REMOVED***
    validate.isFunction('onNext', onNext);
    validate.isOptionalFunction('onError', onError);

    if (!is.defined(onError)) ***REMOVED***
      onError = console.error; // eslint-disable-line no-console
    ***REMOVED***

    let watch = Watch.forQuery(this);

    return watch.onSnapshot((readTime, docs, changes) => ***REMOVED***
      onNext(new QuerySnapshot(this, readTime, docs, changes));
    ***REMOVED***, onError);
  ***REMOVED***

  /**
   * Returns a function that can be used to sort QueryDocumentSnapshots
   * according to the sort criteria of this query.
   *
   * @private
   */
  comparator() ***REMOVED***
    return (doc1, doc2) => ***REMOVED***
      // Add implicit sorting by name, using the last specified direction.
      let lastDirection =
        this._fieldOrders.length === 0
          ? directionOperators.ASC
          : this._fieldOrders[this._fieldOrders.length - 1].direction;
      let orderBys = this._fieldOrders.concat(
        new FieldOrder(FieldPath._DOCUMENT_ID, lastDirection)
      );

      for (let orderBy of orderBys) ***REMOVED***
        let comp;
        if (orderBy.field === FieldPath._DOCUMENT_ID) ***REMOVED***
          comp = doc1.ref._referencePath.compareTo(doc2.ref._referencePath);
        ***REMOVED*** else ***REMOVED***
          const v1 = doc1.protoField(orderBy.field);
          const v2 = doc2.protoField(orderBy.field);
          if (!is.defined(v1) || !is.defined(v2)) ***REMOVED***
            throw new Error(
              'Trying to compare documents on fields that ' +
                "don't exist. Please include the fields you are ordering on " +
                'in your select() call.'
            );
          ***REMOVED***
          comp = order.compare(v1, v2);
        ***REMOVED***

        if (comp !== 0) ***REMOVED***
          const direction =
            orderBy.direction === directionOperators.ASC ? 1 : -1;
          return direction * comp;
        ***REMOVED***
      ***REMOVED***

      return 0;
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

/**
 * A CollectionReference object can be used for adding documents, getting
 * document references, and querying for documents (using the methods
 * inherited from [Query]***REMOVED***@link Query***REMOVED***).
 *
 * @class
 * @extends Query
 */
class CollectionReference extends Query ***REMOVED***
  /**
   * @private
   * @hideconstructor
   *
   * @param ***REMOVED***Firestore***REMOVED*** firestore - The Firestore Database client.
   * @param ***REMOVED***ResourcePath***REMOVED*** path - The Path of this collection.
   */
  constructor(firestore, path) ***REMOVED***
    super(firestore, path);
  ***REMOVED***

  /**
   * ID of the referenced collection.
   *
   * @type ***REMOVED***string***REMOVED***
   * @name CollectionReference#id
   * @readonly
   *
   * @example
   * let collectionRef = firestore.collection('col/doc/subcollection');
   * console.log(`ID of the subcollection: $***REMOVED***collectionRef.id***REMOVED***`);
   */
  get id() ***REMOVED***
    return this._referencePath.id;
  ***REMOVED***

  /**
   * A reference to the containing Document if this is a subcollection, else
   * null.
   *
   * @type ***REMOVED***DocumentReference***REMOVED***
   * @name CollectionReference#parent
   * @readonly
   *
   * @example
   * let collectionRef = firestore.collection('col/doc/subcollection');
   * let documentRef = collectionRef.parent;
   * console.log(`Parent name: $***REMOVED***documentRef.path***REMOVED***`);
   */
  get parent() ***REMOVED***
    return new DocumentReference(this._firestore, this._referencePath.parent());
  ***REMOVED***

  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   *
   * @type ***REMOVED***string***REMOVED***
   * @name CollectionReference#path
   * @readonly
   *
   * @example
   * let collectionRef = firestore.collection('col/doc/subcollection');
   * console.log(`Path of the subcollection: $***REMOVED***collectionRef.path***REMOVED***`);
   */
  get path() ***REMOVED***
    return this._referencePath.relativeName;
  ***REMOVED***

  /**
   * Gets a [DocumentReference]***REMOVED***@link DocumentReference***REMOVED*** instance that
   * refers to the document at the specified path. If no path is specified, an
   * automatically-generated unique ID will be used for the returned
   * DocumentReference.
   *
   * @param ***REMOVED***string=***REMOVED*** documentPath - A slash-separated path to a document.
   * @returns ***REMOVED***DocumentReference***REMOVED*** The `DocumentReference`
   * instance.
   *
   * @example
   * let collectionRef = firestore.collection('col');
   * let documentRefWithName = collectionRef.doc('doc');
   * let documentRefWithAutoId = collectionRef.doc();
   * console.log(`Reference with name: $***REMOVED***documentRefWithName.path***REMOVED***`);
   * console.log(`Reference with auto-id: $***REMOVED***documentRefWithAutoId.path***REMOVED***`);
   */
  doc(documentPath) ***REMOVED***
    if (arguments.length === 0) ***REMOVED***
      documentPath = Firestore.autoId();
    ***REMOVED*** else ***REMOVED***
      validate.isResourcePath('documentPath', documentPath);
    ***REMOVED***

    let path = this._referencePath.append(documentPath);
    if (!path.isDocument) ***REMOVED***
      throw new Error(
        `Argument "documentPath" must point to a document, but was "$***REMOVED***documentPath***REMOVED***". Your path does not contain an even number of components.`
      );
    ***REMOVED***

    return new DocumentReference(this._firestore, path);
  ***REMOVED***

  /**
   * Add a new document to this collection with the specified data, assigning
   * it a document ID automatically.
   *
   * @param ***REMOVED***DocumentData***REMOVED*** data - An Object containing the data for the new
   * document.
   * @returns ***REMOVED***Promise.<DocumentReference>***REMOVED*** A Promise resolved with a
   * [DocumentReference]***REMOVED***@link DocumentReference***REMOVED*** pointing to the
   * newly created document.
   *
   * @example
   * let collectionRef = firestore.collection('col');
   * collectionRef.add(***REMOVED***foo: 'bar'***REMOVED***).then(documentReference => ***REMOVED***
   *   console.log(`Added document with name: $***REMOVED***documentReference.id***REMOVED***`);
   * ***REMOVED***);
   */
  add(data) ***REMOVED***
    validate.isDocument('data', data);

    let documentRef = this.doc();
    return documentRef.create(data).then(() => ***REMOVED***
      return Promise.resolve(documentRef);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***
/*!
 * Creates a new CollectionReference. Invoked by DocumentReference to avoid
 * invalid declaration order.
 *
 * @param ***REMOVED***Firestore***REMOVED*** firestore - The Firestore Database client.
 * @param ***REMOVED***ResourcePath***REMOVED*** path - The path of this collection.
 * @returns ***REMOVED***CollectionReference***REMOVED***
 */
function createCollectionReference(firestore, path) ***REMOVED***
  return new CollectionReference(firestore, path);
***REMOVED***

/*!
 * Validates the input string as a field order direction.
 *
 * @param ***REMOVED***string=***REMOVED*** str Order direction to validate.
 * @throws ***REMOVED***Error***REMOVED*** when the direction is invalid
 */
function validateFieldOrder(str) ***REMOVED***
  if (!is.string(str) || !is.defined(directionOperators[str])) ***REMOVED***
    throw new Error('Order must be one of "asc" or "desc".');
  ***REMOVED***

  return true;
***REMOVED***

/*!
 * Validates the input string as a field comparison operator.
 *
 * @param ***REMOVED***string***REMOVED*** str Field comparison operator to validate.
 * @param ***REMOVED*******REMOVED*** val Value that is used in the filter.
 * @throws ***REMOVED***Error***REMOVED*** when the comparison operation is invalid
 */
function validateComparisonOperator(str, val) ***REMOVED***
  if (is.string(str) && comparisonOperators[str]) ***REMOVED***
    let op = comparisonOperators[str];

    if (typeof val === 'number' && isNaN(val) && op !== 'EQUAL') ***REMOVED***
      throw new Error(
        'Invalid query. You can only perform equals ' + 'comparisons on NaN.'
      );
    ***REMOVED***

    if (val === null && op !== 'EQUAL') ***REMOVED***
      throw new Error(
        'Invalid query. You can only perform equals ' + 'comparisons on Null.'
      );
    ***REMOVED***

    return true;
  ***REMOVED***

  throw new Error('Operator must be one of "<", "<=", "==", ">", or ">=".');
***REMOVED***

/*!
 * Validates that 'value' is a DocumentReference.
 *
 * @param ***REMOVED*******REMOVED*** value The argument to validate.
 * @returns 'true' is value is an instance of DocumentReference.
 */
function validateDocumentReference(value) ***REMOVED***
  return is.instanceof(value, DocumentReference);
***REMOVED***

module.exports = FirestoreType => ***REMOVED***
  Firestore = FirestoreType;
  let document = require('./document')(DocumentReference);
  DocumentSnapshot = document.DocumentSnapshot;
  DocumentTransform = document.DocumentTransform;
  Watch = require('./watch')(
    FirestoreType,
    DocumentChange,
    DocumentReference,
    DocumentSnapshot
  );
  WriteBatch = require('./write-batch')(
    FirestoreType,
    DocumentReference,
    validateDocumentReference
  ).WriteBatch;
  validate = require('./validate')(***REMOVED***
    Document: document.validateDocumentData,
    FieldPath: FieldPath.validateFieldPath,
    FieldComparison: validateComparisonOperator,
    FieldOrder: validateFieldOrder,
    Precondition: document.validatePrecondition,
    ResourcePath: ResourcePath.validateResourcePath,
  ***REMOVED***);
  return ***REMOVED***
    CollectionReference,
    DocumentReference,
    Query,
    QuerySnapshot,
    validateDocumentReference,
  ***REMOVED***;
***REMOVED***;
