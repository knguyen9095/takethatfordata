/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const is = require('is');

/*!
 * @see ResourcePath
 */
const ResourcePath = require('./path').ResourcePath;

/*!
 * The type order as defined by the backend.
 */
const types = ***REMOVED***
  NULL: 0,
  BOOLEAN: 1,
  NUMBER: 2,
  TIMESTAMP: 3,
  STRING: 4,
  BLOB: 5,
  REF: 6,
  GEOPOINT: 7,
  ARRAY: 8,
  OBJECT: 9,
***REMOVED***;

/*!
 * @private
 */
function typeOrder(val) ***REMOVED***
  switch (val.valueType) ***REMOVED***
    case 'nullValue': ***REMOVED***
      return types.NULL;
    ***REMOVED***
    case 'integerValue': ***REMOVED***
      return types.NUMBER;
    ***REMOVED***
    case 'doubleValue': ***REMOVED***
      return types.NUMBER;
    ***REMOVED***
    case 'stringValue': ***REMOVED***
      return types.STRING;
    ***REMOVED***
    case 'booleanValue': ***REMOVED***
      return types.BOOLEAN;
    ***REMOVED***
    case 'arrayValue': ***REMOVED***
      return types.ARRAY;
    ***REMOVED***
    case 'timestampValue': ***REMOVED***
      return types.TIMESTAMP;
    ***REMOVED***
    case 'geoPointValue': ***REMOVED***
      return types.GEOPOINT;
    ***REMOVED***
    case 'bytesValue': ***REMOVED***
      return types.BLOB;
    ***REMOVED***
    case 'referenceValue': ***REMOVED***
      return types.REF;
    ***REMOVED***
    case 'mapValue': ***REMOVED***
      return types.OBJECT;
    ***REMOVED***
    default: ***REMOVED***
      throw new Error(
        'Cannot use type (' +
          val +
          ': ' +
          JSON.stringify(val) +
          ') as a Firestore value.'
      );
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/*!
 * @private
 */
function primitiveComparator(left, right) ***REMOVED***
  if (left < right) ***REMOVED***
    return -1;
  ***REMOVED***
  if (left > right) ***REMOVED***
    return 1;
  ***REMOVED***
  return 0;
***REMOVED***

/*!
 * Utility function to compare doubles (using Firestore semantics for NaN).
 * @private
 */
function compareNumbers(left, right) ***REMOVED***
  if (left < right) ***REMOVED***
    return -1;
  ***REMOVED***
  if (left > right) ***REMOVED***
    return 1;
  ***REMOVED***
  if (left === right) ***REMOVED***
    return 0;
  ***REMOVED***
  // one or both are NaN.
  if (isNaN(left)) ***REMOVED***
    return isNaN(right) ? 0 : -1;
  ***REMOVED***
  return 1;
***REMOVED***

/*!
 * @private
 */
function compareNumberProtos(left, right) ***REMOVED***
  let leftValue, rightValue;
  if (left.valueType === 'integerValue') ***REMOVED***
    leftValue = parseInt(left.integerValue, 10);
  ***REMOVED*** else ***REMOVED***
    leftValue = parseFloat(left.doubleValue, 10);
  ***REMOVED***
  if (right.valueType === 'integerValue') ***REMOVED***
    rightValue = parseInt(right.integerValue, 10);
  ***REMOVED*** else ***REMOVED***
    rightValue = parseFloat(right.doubleValue, 10);
  ***REMOVED***
  return compareNumbers(leftValue, rightValue);
***REMOVED***

/*!
 * @private
 */
function compareTimestamps(left, right) ***REMOVED***
  let seconds = primitiveComparator(left.seconds || 0, right.seconds || 0);
  if (seconds !== 0) ***REMOVED***
    return seconds;
  ***REMOVED***
  return primitiveComparator(left.nanos || 0, right.nanos || 0);
***REMOVED***

/*!
 * @private
 */
function compareBlobs(left, right) ***REMOVED***
  if (!is.instanceof(left, Buffer) || !is.instanceof(right, Buffer)) ***REMOVED***
    throw new Error('Blobs can only be compared if they are Buffers.');
  ***REMOVED***
  return Buffer.compare(left, right);
***REMOVED***

/*!
 * @private
 */
function compareReferenceProtos(left, right) ***REMOVED***
  const leftPath = ResourcePath.fromSlashSeparatedString(left.referenceValue);
  const rightPath = ResourcePath.fromSlashSeparatedString(right.referenceValue);
  return leftPath.compareTo(rightPath);
***REMOVED***

/*!
 * @private
 */
function compareGeoPoints(left, right) ***REMOVED***
  return (
    primitiveComparator(left.latitude, right.latitude) ||
    primitiveComparator(left.longitude, right.longitude)
  );
***REMOVED***

/*!
 * @private
 */
function compareArrays(left, right) ***REMOVED***
  for (let i = 0; i < left.length && i < right.length; i++) ***REMOVED***
    const valueComparison = compare(left[i], right[i]);
    if (valueComparison !== 0) ***REMOVED***
      return valueComparison;
    ***REMOVED***
  ***REMOVED***
  // If all the values matched so far, just check the length.
  return primitiveComparator(left.length, right.length);
***REMOVED***

/*!
 * @private
 */
function compareObjects(left, right) ***REMOVED***
  // This requires iterating over the keys in the object in order and doing a
  // deep comparison.
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  leftKeys.sort();
  rightKeys.sort();
  for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) ***REMOVED***
    const keyComparison = primitiveComparator(leftKeys[i], rightKeys[i]);
    if (keyComparison !== 0) ***REMOVED***
      return keyComparison;
    ***REMOVED***
    const key = leftKeys[i];
    const valueComparison = compare(left[key], right[key]);
    if (valueComparison !== 0) ***REMOVED***
      return valueComparison;
    ***REMOVED***
  ***REMOVED***
  // If all the keys matched so far, just check the length.
  return primitiveComparator(leftKeys.length, rightKeys.length);
***REMOVED***

/*!
 * @private
 */
function compare(left, right) ***REMOVED***
  // First compare the types.
  const leftType = typeOrder(left);
  const rightType = typeOrder(right);
  const typeComparison = primitiveComparator(leftType, rightType);
  if (typeComparison !== 0) ***REMOVED***
    return typeComparison;
  ***REMOVED***

  // So they are the same type.
  switch (leftType) ***REMOVED***
    case types.NULL: ***REMOVED***
      // Nulls are all equal.
      return 0;
    ***REMOVED***
    case types.BOOLEAN: ***REMOVED***
      return primitiveComparator(left.booleanValue, right.booleanValue);
    ***REMOVED***
    case types.STRING: ***REMOVED***
      return primitiveComparator(left.stringValue, right.stringValue);
    ***REMOVED***
    case types.NUMBER: ***REMOVED***
      return compareNumberProtos(left, right);
    ***REMOVED***
    case types.TIMESTAMP: ***REMOVED***
      return compareTimestamps(left.timestampValue, right.timestampValue);
    ***REMOVED***
    case types.BLOB: ***REMOVED***
      return compareBlobs(left.bytesValue, right.bytesValue);
    ***REMOVED***
    case types.REF: ***REMOVED***
      return compareReferenceProtos(left, right);
    ***REMOVED***
    case types.GEOPOINT: ***REMOVED***
      return compareGeoPoints(left.geoPointValue, right.geoPointValue);
    ***REMOVED***
    case types.ARRAY: ***REMOVED***
      return compareArrays(left.arrayValue.values, right.arrayValue.values);
    ***REMOVED***
    case types.OBJECT: ***REMOVED***
      return compareObjects(left.mapValue.fields, right.mapValue.fields);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

module.exports = ***REMOVED***compare, primitiveComparator***REMOVED***;
