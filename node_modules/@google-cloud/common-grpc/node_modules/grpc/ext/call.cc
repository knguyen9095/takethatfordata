/*
 *
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <map>
#include <memory>
#include <vector>

#include <node.h>

#include "byte_buffer.h"
#include "call.h"
#include "call_credentials.h"
#include "channel.h"
#include "completion_queue.h"
#include "grpc/grpc.h"
#include "grpc/grpc_security.h"
#include "grpc/support/alloc.h"
#include "grpc/support/log.h"
#include "grpc/support/time.h"
#include "slice.h"
#include "timeval.h"

using std::unique_ptr;
using std::shared_ptr;
using std::vector;

namespace grpc ***REMOVED***
namespace node ***REMOVED***

using Nan::Callback;
using Nan::EscapableHandleScope;
using Nan::HandleScope;
using Nan::Maybe;
using Nan::MaybeLocal;
using Nan::ObjectWrap;
using Nan::Persistent;
using Nan::Utf8String;

using v8::Array;
using v8::Boolean;
using v8::Exception;
using v8::External;
using v8::Function;
using v8::FunctionTemplate;
using v8::Integer;
using v8::Local;
using v8::Number;
using v8::Object;
using v8::ObjectTemplate;
using v8::Uint32;
using v8::String;
using v8::Value;

Callback *Call::constructor;
Persistent<FunctionTemplate> Call::fun_tpl;

/**
 * Helper function for throwing errors with a grpc_call_error value.
 * Modified from the answer by Gus Goose to
 * http://stackoverflow.com/questions/31794200.
 */
Local<Value> nanErrorWithCode(const char *msg, grpc_call_error code) ***REMOVED***
  EscapableHandleScope scope;
  Local<Object> err = Nan::Error(msg).As<Object>();
  Nan::Set(err, Nan::New("code").ToLocalChecked(), Nan::New<Uint32>(code));
  return scope.Escape(err);
***REMOVED***

bool CreateMetadataArray(Local<Object> metadata, grpc_metadata_array *array) ***REMOVED***
  HandleScope scope;
  Local<Array> keys = Nan::GetOwnPropertyNames(metadata).ToLocalChecked();
  for (unsigned int i = 0; i < keys->Length(); i++) ***REMOVED***
    Local<String> current_key =
        Nan::To<String>(Nan::Get(keys, i).ToLocalChecked()).ToLocalChecked();
    Local<Value> value_array = Nan::Get(metadata, current_key).ToLocalChecked();
    if (!value_array->IsArray()) ***REMOVED***
      return false;
    ***REMOVED***
    array->capacity += Local<Array>::Cast(value_array)->Length();
  ***REMOVED***
  array->metadata = reinterpret_cast<grpc_metadata *>(
      gpr_zalloc(array->capacity * sizeof(grpc_metadata)));
  for (unsigned int i = 0; i < keys->Length(); i++) ***REMOVED***
    Local<String> current_key(Nan::To<String>(keys->Get(i)).ToLocalChecked());
    Local<Array> values =
        Local<Array>::Cast(Nan::Get(metadata, current_key).ToLocalChecked());
    grpc_slice key_slice = CreateSliceFromString(current_key);
    grpc_slice key_intern_slice = grpc_slice_intern(key_slice);
    grpc_slice_unref(key_slice);
    for (unsigned int j = 0; j < values->Length(); j++) ***REMOVED***
      Local<Value> value = Nan::Get(values, j).ToLocalChecked();
      grpc_metadata *current = &array->metadata[array->count];
      current->key = key_intern_slice;
      // Only allow binary headers for "-bin" keys
      if (grpc_is_binary_header(key_intern_slice)) ***REMOVED***
        if (::node::Buffer::HasInstance(value)) ***REMOVED***
          current->value = CreateSliceFromBuffer(value);
        ***REMOVED*** else ***REMOVED***
          return false;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        if (value->IsString()) ***REMOVED***
          Local<String> string_value = Nan::To<String>(value).ToLocalChecked();
          current->value = CreateSliceFromString(string_value);
        ***REMOVED*** else ***REMOVED***
          return false;
        ***REMOVED***
      ***REMOVED***
      array->count += 1;
    ***REMOVED***
  ***REMOVED***
  return true;
***REMOVED***

void DestroyMetadataArray(grpc_metadata_array *array) ***REMOVED***
  for (size_t i = 0; i < array->count; i++) ***REMOVED***
    // Don't unref keys because they are interned
    grpc_slice_unref(array->metadata[i].value);
  ***REMOVED***
  grpc_metadata_array_destroy(array);
***REMOVED***

Local<Value> ParseMetadata(const grpc_metadata_array *metadata_array) ***REMOVED***
  EscapableHandleScope scope;
  grpc_metadata *metadata_elements = metadata_array->metadata;
  size_t length = metadata_array->count;
  Local<Object> metadata_object = Nan::New<Object>();
  for (unsigned int i = 0; i < length; i++) ***REMOVED***
    grpc_metadata *elem = &metadata_elements[i];
    // TODO(murgatroid99): Use zero-copy string construction instead
    Local<String> key_string = CopyStringFromSlice(elem->key);
    Local<Array> array;
    MaybeLocal<Value> maybe_array = Nan::Get(metadata_object, key_string);
    if (maybe_array.IsEmpty() || !maybe_array.ToLocalChecked()->IsArray()) ***REMOVED***
      array = Nan::New<Array>(0);
      Nan::Set(metadata_object, key_string, array);
    ***REMOVED*** else ***REMOVED***
      array = Local<Array>::Cast(maybe_array.ToLocalChecked());
    ***REMOVED***
    if (grpc_is_binary_header(elem->key)) ***REMOVED***
      Nan::Set(array, array->Length(), CreateBufferFromSlice(elem->value));
    ***REMOVED*** else ***REMOVED***
      // TODO(murgatroid99): Use zero-copy string construction instead
      Nan::Set(array, array->Length(), CopyStringFromSlice(elem->value));
    ***REMOVED***
  ***REMOVED***
  return scope.Escape(metadata_object);
***REMOVED***

Local<Value> Op::GetOpType() const ***REMOVED***
  EscapableHandleScope scope;
  return scope.Escape(Nan::New(GetTypeString()).ToLocalChecked());
***REMOVED***

Op::~Op() ***REMOVED******REMOVED***

class SendMetadataOp : public Op ***REMOVED***
 public:
  SendMetadataOp() ***REMOVED*** grpc_metadata_array_init(&send_metadata); ***REMOVED***
  ~SendMetadataOp() ***REMOVED*** DestroyMetadataArray(&send_metadata); ***REMOVED***
  Local<Value> GetNodeValue() const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(Nan::True());
  ***REMOVED***
  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED***
    if (!value->IsObject()) ***REMOVED***
      return false;
    ***REMOVED***
    MaybeLocal<Object> maybe_metadata = Nan::To<Object>(value);
    if (maybe_metadata.IsEmpty()) ***REMOVED***
      return false;
    ***REMOVED***
    if (!CreateMetadataArray(maybe_metadata.ToLocalChecked(), &send_metadata)) ***REMOVED***
      return false;
    ***REMOVED***
    out->data.send_initial_metadata.count = send_metadata.count;
    out->data.send_initial_metadata.metadata = send_metadata.metadata;
    return true;
  ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return false; ***REMOVED***
  void OnComplete(bool success) ***REMOVED******REMOVED***

 protected:
  std::string GetTypeString() const ***REMOVED*** return "send_metadata"; ***REMOVED***

 private:
  grpc_metadata_array send_metadata;
***REMOVED***;

class SendMessageOp : public Op ***REMOVED***
 public:
  SendMessageOp() ***REMOVED*** send_message = NULL; ***REMOVED***
  ~SendMessageOp() ***REMOVED***
    if (send_message != NULL) ***REMOVED***
      grpc_byte_buffer_destroy(send_message);
    ***REMOVED***
  ***REMOVED***
  Local<Value> GetNodeValue() const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(Nan::True());
  ***REMOVED***
  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED***
    if (!::node::Buffer::HasInstance(value)) ***REMOVED***
      return false;
    ***REMOVED***
    Local<Object> object_value = Nan::To<Object>(value).ToLocalChecked();
    MaybeLocal<Value> maybe_flag_value =
        Nan::Get(object_value, Nan::New("grpcWriteFlags").ToLocalChecked());
    if (!maybe_flag_value.IsEmpty()) ***REMOVED***
      Local<Value> flag_value = maybe_flag_value.ToLocalChecked();
      if (flag_value->IsUint32()) ***REMOVED***
        Maybe<uint32_t> maybe_flag = Nan::To<uint32_t>(flag_value);
        out->flags = maybe_flag.FromMaybe(0) & GRPC_WRITE_USED_MASK;
      ***REMOVED***
    ***REMOVED***
    send_message = BufferToByteBuffer(value);
    out->data.send_message.send_message = send_message;
    return true;
  ***REMOVED***

  bool IsFinalOp() ***REMOVED*** return false; ***REMOVED***
  void OnComplete(bool success) ***REMOVED******REMOVED***

 protected:
  std::string GetTypeString() const ***REMOVED*** return "send_message"; ***REMOVED***

 private:
  grpc_byte_buffer *send_message;
***REMOVED***;

class SendClientCloseOp : public Op ***REMOVED***
 public:
  Local<Value> GetNodeValue() const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(Nan::True());
  ***REMOVED***

  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED*** return true; ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return false; ***REMOVED***
  void OnComplete(bool success) ***REMOVED******REMOVED***

 protected:
  std::string GetTypeString() const ***REMOVED*** return "client_close"; ***REMOVED***
***REMOVED***;

class SendServerStatusOp : public Op ***REMOVED***
 public:
  SendServerStatusOp() ***REMOVED***
    details = grpc_empty_slice();
    grpc_metadata_array_init(&status_metadata);
  ***REMOVED***
  ~SendServerStatusOp() ***REMOVED***
    grpc_slice_unref(details);
    DestroyMetadataArray(&status_metadata);
  ***REMOVED***
  Local<Value> GetNodeValue() const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(Nan::True());
  ***REMOVED***
  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED***
    if (!value->IsObject()) ***REMOVED***
      return false;
    ***REMOVED***
    Local<Object> server_status = Nan::To<Object>(value).ToLocalChecked();
    MaybeLocal<Value> maybe_metadata =
        Nan::Get(server_status, Nan::New("metadata").ToLocalChecked());
    if (maybe_metadata.IsEmpty()) ***REMOVED***
      return false;
    ***REMOVED***
    if (!maybe_metadata.ToLocalChecked()->IsObject()) ***REMOVED***
      return false;
    ***REMOVED***
    Local<Object> metadata =
        Nan::To<Object>(maybe_metadata.ToLocalChecked()).ToLocalChecked();
    MaybeLocal<Value> maybe_code =
        Nan::Get(server_status, Nan::New("code").ToLocalChecked());
    if (maybe_code.IsEmpty()) ***REMOVED***
      return false;
    ***REMOVED***
    if (!maybe_code.ToLocalChecked()->IsUint32()) ***REMOVED***
      return false;
    ***REMOVED***
    uint32_t code = Nan::To<uint32_t>(maybe_code.ToLocalChecked()).FromJust();
    MaybeLocal<Value> maybe_details =
        Nan::Get(server_status, Nan::New("details").ToLocalChecked());
    if (maybe_details.IsEmpty()) ***REMOVED***
      return false;
    ***REMOVED***
    if (!maybe_details.ToLocalChecked()->IsString()) ***REMOVED***
      return false;
    ***REMOVED***
    Local<String> details =
        Nan::To<String>(maybe_details.ToLocalChecked()).ToLocalChecked();
    if (!CreateMetadataArray(metadata, &status_metadata)) ***REMOVED***
      return false;
    ***REMOVED***
    out->data.send_status_from_server.trailing_metadata_count =
        status_metadata.count;
    out->data.send_status_from_server.trailing_metadata =
        status_metadata.metadata;
    out->data.send_status_from_server.status =
        static_cast<grpc_status_code>(code);
    this->details = CreateSliceFromString(details);
    out->data.send_status_from_server.status_details = &this->details;
    return true;
  ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return true; ***REMOVED***
  void OnComplete(bool success) ***REMOVED******REMOVED***

 protected:
  std::string GetTypeString() const ***REMOVED*** return "send_status"; ***REMOVED***

 private:
  grpc_slice details;
  grpc_metadata_array status_metadata;
***REMOVED***;

class GetMetadataOp : public Op ***REMOVED***
 public:
  GetMetadataOp() ***REMOVED*** grpc_metadata_array_init(&recv_metadata); ***REMOVED***

  ~GetMetadataOp() ***REMOVED*** grpc_metadata_array_destroy(&recv_metadata); ***REMOVED***

  Local<Value> GetNodeValue() const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(ParseMetadata(&recv_metadata));
  ***REMOVED***

  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED***
    out->data.recv_initial_metadata.recv_initial_metadata = &recv_metadata;
    return true;
  ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return false; ***REMOVED***
  void OnComplete(bool success) ***REMOVED******REMOVED***

 protected:
  std::string GetTypeString() const ***REMOVED*** return "metadata"; ***REMOVED***

 private:
  grpc_metadata_array recv_metadata;
***REMOVED***;

class ReadMessageOp : public Op ***REMOVED***
 public:
  ReadMessageOp() ***REMOVED*** recv_message = NULL; ***REMOVED***
  ~ReadMessageOp() ***REMOVED***
    if (recv_message != NULL) ***REMOVED***
      grpc_byte_buffer_destroy(recv_message);
    ***REMOVED***
  ***REMOVED***
  Local<Value> GetNodeValue() const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(ByteBufferToBuffer(recv_message));
  ***REMOVED***

  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED***
    out->data.recv_message.recv_message = &recv_message;
    return true;
  ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return false; ***REMOVED***
  void OnComplete(bool success) ***REMOVED******REMOVED***

 protected:
  std::string GetTypeString() const ***REMOVED*** return "read"; ***REMOVED***

 private:
  grpc_byte_buffer *recv_message;
***REMOVED***;

class ClientStatusOp : public Op ***REMOVED***
 public:
  ClientStatusOp() ***REMOVED***
    grpc_metadata_array_init(&metadata_array);
    status_details = grpc_empty_slice();
  ***REMOVED***

  ~ClientStatusOp() ***REMOVED***
    grpc_metadata_array_destroy(&metadata_array);
    grpc_slice_unref(status_details);
  ***REMOVED***

  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED***
    out->data.recv_status_on_client.trailing_metadata = &metadata_array;
    out->data.recv_status_on_client.status = &status;
    out->data.recv_status_on_client.status_details = &status_details;
    return true;
  ***REMOVED***

  Local<Value> GetNodeValue() const ***REMOVED***
    EscapableHandleScope scope;
    Local<Object> status_obj = Nan::New<Object>();
    Nan::Set(status_obj, Nan::New("code").ToLocalChecked(),
             Nan::New<Number>(status));
    Nan::Set(status_obj, Nan::New("details").ToLocalChecked(),
             CopyStringFromSlice(status_details));
    Nan::Set(status_obj, Nan::New("metadata").ToLocalChecked(),
             ParseMetadata(&metadata_array));
    return scope.Escape(status_obj);
  ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return true; ***REMOVED***
  void OnComplete(bool success) ***REMOVED******REMOVED***

 protected:
  std::string GetTypeString() const ***REMOVED*** return "status"; ***REMOVED***

 private:
  grpc_metadata_array metadata_array;
  grpc_status_code status;
  grpc_slice status_details;
***REMOVED***;

class ServerCloseResponseOp : public Op ***REMOVED***
 public:
  Local<Value> GetNodeValue() const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(Nan::New<Boolean>(cancelled));
  ***REMOVED***

  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED***
    out->data.recv_close_on_server.cancelled = &cancelled;
    return true;
  ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return false; ***REMOVED***
  void OnComplete(bool success) ***REMOVED******REMOVED***

 protected:
  std::string GetTypeString() const ***REMOVED*** return "cancelled"; ***REMOVED***

 private:
  int cancelled;
***REMOVED***;

tag::tag(Callback *callback, OpVec *ops, Call *call, Local<Value> call_value)
    : callback(callback), ops(ops), call(call) ***REMOVED***
  HandleScope scope;
  call_persist.Reset(call_value);
***REMOVED***

tag::~tag() ***REMOVED***
  delete callback;
  delete ops;
***REMOVED***

void CompleteTag(void *tag, const char *error_message) ***REMOVED***
  HandleScope scope;
  struct tag *tag_struct = reinterpret_cast<struct tag *>(tag);
  Callback *callback = tag_struct->callback;
  if (error_message == NULL) ***REMOVED***
    Local<Object> tag_obj = Nan::New<Object>();
    for (vector<unique_ptr<Op> >::iterator it = tag_struct->ops->begin();
         it != tag_struct->ops->end(); ++it) ***REMOVED***
      Op *op_ptr = it->get();
      Nan::Set(tag_obj, op_ptr->GetOpType(), op_ptr->GetNodeValue());
    ***REMOVED***
    Local<Value> argv[] = ***REMOVED***Nan::Null(), tag_obj***REMOVED***;
    callback->Call(2, argv);
  ***REMOVED*** else ***REMOVED***
    Local<Value> argv[] = ***REMOVED***Nan::Error(error_message)***REMOVED***;
    callback->Call(1, argv);
  ***REMOVED***
  bool success = (error_message == NULL);
  bool is_final_op = false;
  for (vector<unique_ptr<Op> >::iterator it = tag_struct->ops->begin();
       it != tag_struct->ops->end(); ++it) ***REMOVED***
    Op *op_ptr = it->get();
    op_ptr->OnComplete(success);
    if (op_ptr->IsFinalOp()) ***REMOVED***
      is_final_op = true;
    ***REMOVED***
  ***REMOVED***
  if (tag_struct->call == NULL) ***REMOVED***
    return;
  ***REMOVED***
  tag_struct->call->CompleteBatch(is_final_op);
***REMOVED***

void DestroyTag(void *tag) ***REMOVED***
  struct tag *tag_struct = reinterpret_cast<struct tag *>(tag);
  delete tag_struct;
***REMOVED***

void Call::DestroyCall() ***REMOVED***
  if (this->wrapped_call != NULL) ***REMOVED***
    grpc_call_unref(this->wrapped_call);
    this->wrapped_call = NULL;
  ***REMOVED***
***REMOVED***

Call::Call(grpc_call *call)
    : wrapped_call(call), pending_batches(0), has_final_op_completed(false) ***REMOVED***
  peer = grpc_call_get_peer(call);
***REMOVED***

Call::~Call() ***REMOVED***
  DestroyCall();
  gpr_free(peer);
***REMOVED***

void Call::Init(Local<Object> exports) ***REMOVED***
  HandleScope scope;
  Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(New);
  tpl->SetClassName(Nan::New("Call").ToLocalChecked());
  tpl->InstanceTemplate()->SetInternalFieldCount(1);
  Nan::SetPrototypeMethod(tpl, "startBatch", StartBatch);
  Nan::SetPrototypeMethod(tpl, "cancel", Cancel);
  Nan::SetPrototypeMethod(tpl, "cancelWithStatus", CancelWithStatus);
  Nan::SetPrototypeMethod(tpl, "getPeer", GetPeer);
  Nan::SetPrototypeMethod(tpl, "setCredentials", SetCredentials);
  fun_tpl.Reset(tpl);
  Local<Function> ctr = Nan::GetFunction(tpl).ToLocalChecked();
  Nan::Set(exports, Nan::New("Call").ToLocalChecked(), ctr);
  constructor = new Callback(ctr);
***REMOVED***

bool Call::HasInstance(Local<Value> val) ***REMOVED***
  HandleScope scope;
  return Nan::New(fun_tpl)->HasInstance(val);
***REMOVED***

Local<Value> Call::WrapStruct(grpc_call *call) ***REMOVED***
  EscapableHandleScope scope;
  if (call == NULL) ***REMOVED***
    return scope.Escape(Nan::Null());
  ***REMOVED***
  const int argc = 1;
  Local<Value> argv[argc] = ***REMOVED***
      Nan::New<External>(reinterpret_cast<void *>(call))***REMOVED***;
  MaybeLocal<Object> maybe_instance =
      Nan::NewInstance(constructor->GetFunction(), argc, argv);
  if (maybe_instance.IsEmpty()) ***REMOVED***
    return scope.Escape(Nan::Null());
  ***REMOVED*** else ***REMOVED***
    return scope.Escape(maybe_instance.ToLocalChecked());
  ***REMOVED***
***REMOVED***

void Call::CompleteBatch(bool is_final_op) ***REMOVED***
  if (is_final_op) ***REMOVED***
    this->has_final_op_completed = true;
  ***REMOVED***
  this->pending_batches--;
  if (this->has_final_op_completed && this->pending_batches == 0) ***REMOVED***
    this->DestroyCall();
  ***REMOVED***
***REMOVED***

NAN_METHOD(Call::New) ***REMOVED***
  /* Arguments:
   * 0: Channel to make the call on
   * 1: Method
   * 2: Deadline
   * 3: host
   * 4: parent Call
   * 5: propagation flags
   */
  if (info.IsConstructCall()) ***REMOVED***
    Call *call;
    if (info[0]->IsExternal()) ***REMOVED***
      Local<External> ext = info[0].As<External>();
      // This option is used for wrapping an existing call
      grpc_call *call_value = reinterpret_cast<grpc_call *>(ext->Value());
      call = new Call(call_value);
    ***REMOVED*** else ***REMOVED***
      if (!Channel::HasInstance(info[0])) ***REMOVED***
        return Nan::ThrowTypeError("Call's first argument must be a Channel");
      ***REMOVED***
      if (!info[1]->IsString()) ***REMOVED***
        return Nan::ThrowTypeError("Call's second argument must be a string");
      ***REMOVED***
      if (!(info[2]->IsNumber() || info[2]->IsDate())) ***REMOVED***
        return Nan::ThrowTypeError(
            "Call's third argument must be a date or a number");
      ***REMOVED***
      // These arguments are at the end because they are optional
      grpc_call *parent_call = NULL;
      if (Call::HasInstance(info[4])) ***REMOVED***
        Call *parent_obj =
            ObjectWrap::Unwrap<Call>(Nan::To<Object>(info[4]).ToLocalChecked());
        parent_call = parent_obj->wrapped_call;
      ***REMOVED*** else if (!(info[4]->IsUndefined() || info[4]->IsNull())) ***REMOVED***
        return Nan::ThrowTypeError(
            "Call's fifth argument must be another call, if provided");
      ***REMOVED***
      uint32_t propagate_flags = GRPC_PROPAGATE_DEFAULTS;
      if (info[5]->IsUint32()) ***REMOVED***
        propagate_flags = Nan::To<uint32_t>(info[5]).FromJust();
      ***REMOVED*** else if (!(info[5]->IsUndefined() || info[5]->IsNull())) ***REMOVED***
        return Nan::ThrowTypeError(
            "Call's sixth argument must be propagate flags, if provided");
      ***REMOVED***
      Local<Object> channel_object = Nan::To<Object>(info[0]).ToLocalChecked();
      Channel *channel = ObjectWrap::Unwrap<Channel>(channel_object);
      if (channel->GetWrappedChannel() == NULL) ***REMOVED***
        return Nan::ThrowError("Call cannot be created from a closed channel");
      ***REMOVED***
      double deadline = Nan::To<double>(info[2]).FromJust();
      grpc_channel *wrapped_channel = channel->GetWrappedChannel();
      grpc_call *wrapped_call;
      grpc_slice method =
          CreateSliceFromString(Nan::To<String>(info[1]).ToLocalChecked());
      if (info[3]->IsString()) ***REMOVED***
        grpc_slice *host = new grpc_slice;
        *host =
            CreateSliceFromString(Nan::To<String>(info[3]).ToLocalChecked());
        wrapped_call = grpc_channel_create_call(
            wrapped_channel, parent_call, propagate_flags, GetCompletionQueue(),
            method, host, MillisecondsToTimespec(deadline), NULL);
        delete host;
      ***REMOVED*** else if (info[3]->IsUndefined() || info[3]->IsNull()) ***REMOVED***
        wrapped_call = grpc_channel_create_call(
            wrapped_channel, parent_call, propagate_flags, GetCompletionQueue(),
            method, NULL, MillisecondsToTimespec(deadline), NULL);
      ***REMOVED*** else ***REMOVED***
        return Nan::ThrowTypeError("Call's fourth argument must be a string");
      ***REMOVED***
      grpc_slice_unref(method);
      call = new Call(wrapped_call);
      Nan::Set(info.This(), Nan::New("channel_").ToLocalChecked(),
               channel_object);
    ***REMOVED***
    call->Wrap(info.This());
    info.GetReturnValue().Set(info.This());
  ***REMOVED*** else ***REMOVED***
    const int argc = 4;
    Local<Value> argv[argc] = ***REMOVED***info[0], info[1], info[2], info[3]***REMOVED***;
    MaybeLocal<Object> maybe_instance =
        Nan::NewInstance(constructor->GetFunction(), argc, argv);
    if (maybe_instance.IsEmpty()) ***REMOVED***
      // There's probably a pending exception
      return;
    ***REMOVED*** else ***REMOVED***
      info.GetReturnValue().Set(maybe_instance.ToLocalChecked());
    ***REMOVED***
  ***REMOVED***
***REMOVED***

NAN_METHOD(Call::StartBatch) ***REMOVED***
  if (!Call::HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError("startBatch can only be called on Call objects");
  ***REMOVED***
  if (!info[0]->IsObject()) ***REMOVED***
    return Nan::ThrowError("startBatch's first argument must be an object");
  ***REMOVED***
  if (!info[1]->IsFunction()) ***REMOVED***
    return Nan::ThrowError("startBatch's second argument must be a callback");
  ***REMOVED***
  Local<Function> callback_func = info[1].As<Function>();
  Call *call = ObjectWrap::Unwrap<Call>(info.This());
  if (call->wrapped_call == NULL) ***REMOVED***
    /* This implies that the call has completed and has been destroyed. To
     * emulate
     * previous behavior, we should call the callback immediately with an error,
     * as though the batch had failed in core */
    Local<Value> argv[] = ***REMOVED***
        Nan::Error("The async function failed because the call has completed")***REMOVED***;
    Nan::Call(callback_func, Nan::New<Object>(), 1, argv);
    return;
  ***REMOVED***
  Local<Object> obj = Nan::To<Object>(info[0]).ToLocalChecked();
  Local<Array> keys = Nan::GetOwnPropertyNames(obj).ToLocalChecked();
  size_t nops = keys->Length();
  vector<grpc_op> ops(nops);
  unique_ptr<OpVec> op_vector(new OpVec());
  for (unsigned int i = 0; i < nops; i++) ***REMOVED***
    unique_ptr<Op> op;
    MaybeLocal<Value> maybe_key = Nan::Get(keys, i);
    if (maybe_key.IsEmpty() || (!maybe_key.ToLocalChecked()->IsUint32())) ***REMOVED***
      return Nan::ThrowError(
          "startBatch's first argument's keys must be integers");
    ***REMOVED***
    uint32_t type = Nan::To<uint32_t>(maybe_key.ToLocalChecked()).FromJust();
    ops[i].op = static_cast<grpc_op_type>(type);
    ops[i].flags = 0;
    ops[i].reserved = NULL;
    switch (type) ***REMOVED***
      case GRPC_OP_SEND_INITIAL_METADATA:
        op.reset(new SendMetadataOp());
        break;
      case GRPC_OP_SEND_MESSAGE:
        op.reset(new SendMessageOp());
        break;
      case GRPC_OP_SEND_CLOSE_FROM_CLIENT:
        op.reset(new SendClientCloseOp());
        break;
      case GRPC_OP_SEND_STATUS_FROM_SERVER:
        op.reset(new SendServerStatusOp());
        break;
      case GRPC_OP_RECV_INITIAL_METADATA:
        op.reset(new GetMetadataOp());
        break;
      case GRPC_OP_RECV_MESSAGE:
        op.reset(new ReadMessageOp());
        break;
      case GRPC_OP_RECV_STATUS_ON_CLIENT:
        op.reset(new ClientStatusOp());
        break;
      case GRPC_OP_RECV_CLOSE_ON_SERVER:
        op.reset(new ServerCloseResponseOp());
        break;
      default:
        return Nan::ThrowError("Argument object had an unrecognized key");
    ***REMOVED***
    if (!op->ParseOp(obj->Get(type), &ops[i])) ***REMOVED***
      return Nan::ThrowTypeError("Incorrectly typed arguments to startBatch");
    ***REMOVED***
    op_vector->push_back(std::move(op));
  ***REMOVED***
  Callback *callback = new Callback(callback_func);
  grpc_call_error error = grpc_call_start_batch(
      call->wrapped_call, &ops[0], nops,
      new struct tag(callback, op_vector.release(), call, info.This()), NULL);
  if (error != GRPC_CALL_OK) ***REMOVED***
    return Nan::ThrowError(nanErrorWithCode("startBatch failed", error));
  ***REMOVED***
  call->pending_batches++;
  CompletionQueueNext();
***REMOVED***

NAN_METHOD(Call::Cancel) ***REMOVED***
  if (!Call::HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError("cancel can only be called on Call objects");
  ***REMOVED***
  Call *call = ObjectWrap::Unwrap<Call>(info.This());
  if (call->wrapped_call == NULL) ***REMOVED***
    /* Cancel is supposed to be idempotent. If the call has already finished,
     * cancel should just complete silently */
    return;
  ***REMOVED***
  grpc_call_error error = grpc_call_cancel(call->wrapped_call, NULL);
  if (error != GRPC_CALL_OK) ***REMOVED***
    return Nan::ThrowError(nanErrorWithCode("cancel failed", error));
  ***REMOVED***
***REMOVED***

NAN_METHOD(Call::CancelWithStatus) ***REMOVED***
  Nan::HandleScope scope;
  if (!HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError("cancel can only be called on Call objects");
  ***REMOVED***
  if (!info[0]->IsUint32()) ***REMOVED***
    return Nan::ThrowTypeError(
        "cancelWithStatus's first argument must be a status code");
  ***REMOVED***
  if (!info[1]->IsString()) ***REMOVED***
    return Nan::ThrowTypeError(
        "cancelWithStatus's second argument must be a string");
  ***REMOVED***
  Call *call = ObjectWrap::Unwrap<Call>(info.This());
  if (call->wrapped_call == NULL) ***REMOVED***
    /* Cancel is supposed to be idempotent. If the call has already finished,
     * cancel should just complete silently */
    return;
  ***REMOVED***
  grpc_status_code code =
      static_cast<grpc_status_code>(Nan::To<uint32_t>(info[0]).FromJust());
  if (code == GRPC_STATUS_OK) ***REMOVED***
    return Nan::ThrowRangeError(
        "cancelWithStatus cannot be called with OK status");
  ***REMOVED***
  Utf8String details(info[1]);
  grpc_call_cancel_with_status(call->wrapped_call, code, *details, NULL);
***REMOVED***

NAN_METHOD(Call::GetPeer) ***REMOVED***
  Nan::HandleScope scope;
  if (!HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError("getPeer can only be called on Call objects");
  ***REMOVED***
  Call *call = ObjectWrap::Unwrap<Call>(info.This());
  Local<Value> peer_value = Nan::New(call->peer).ToLocalChecked();
  info.GetReturnValue().Set(peer_value);
***REMOVED***

NAN_METHOD(Call::SetCredentials) ***REMOVED***
  Nan::HandleScope scope;
  if (!HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError(
        "setCredentials can only be called on Call objects");
  ***REMOVED***
  if (!CallCredentials::HasInstance(info[0])) ***REMOVED***
    return Nan::ThrowTypeError(
        "setCredentials' first argument must be a CallCredentials");
  ***REMOVED***
  Call *call = ObjectWrap::Unwrap<Call>(info.This());
  if (call->wrapped_call == NULL) ***REMOVED***
    return Nan::ThrowError(
        "Cannot set credentials on a call that has already started");
  ***REMOVED***
  CallCredentials *creds_object = ObjectWrap::Unwrap<CallCredentials>(
      Nan::To<Object>(info[0]).ToLocalChecked());
  grpc_call_credentials *creds = creds_object->GetWrappedCredentials();
  grpc_call_error error = GRPC_CALL_ERROR;
  if (creds) ***REMOVED***
    error = grpc_call_set_credentials(call->wrapped_call, creds);
  ***REMOVED***
  info.GetReturnValue().Set(Nan::New<Uint32>(error));
***REMOVED***

***REMOVED***  // namespace node
***REMOVED***  // namespace grpc
