/**
 * @license
 * Copyright 2017 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/**
 * @module
 * @private
 */

'use strict';

var _ = require('lodash');
var client = require('./client');

/**
 * Get a function that deserializes a specific type of protobuf.
 * @param ***REMOVED***function()***REMOVED*** cls The constructor of the message type to deserialize
 * @param ***REMOVED***bool=***REMOVED*** binaryAsBase64 Deserialize bytes fields as base64 strings
 *     instead of Buffers. Defaults to false
 * @param ***REMOVED***bool=***REMOVED*** longsAsStrings Deserialize long values as strings instead of
 *     objects. Defaults to true
 * @return ***REMOVED***function(Buffer):cls***REMOVED*** The deserialization function
 */
exports.deserializeCls = function deserializeCls(cls, options) ***REMOVED***
  /**
   * Deserialize a buffer to a message object
   * @param ***REMOVED***Buffer***REMOVED*** arg_buf The buffer to deserialize
   * @return ***REMOVED***cls***REMOVED*** The resulting object
   */
  return function deserialize(arg_buf) ***REMOVED***
    // Convert to a native object with binary fields as Buffers (first argument)
    // and longs as strings (second argument)
    return cls.decode(arg_buf).toRaw(options.binaryAsBase64,
                                     options.longsAsStrings);
  ***REMOVED***;
***REMOVED***;

var deserializeCls = exports.deserializeCls;

/**
 * Get a function that serializes objects to a buffer by protobuf class.
 * @param ***REMOVED***function()***REMOVED*** Cls The constructor of the message type to serialize
 * @return ***REMOVED***function(Cls):Buffer***REMOVED*** The serialization function
 */
exports.serializeCls = function serializeCls(Cls) ***REMOVED***
  /**
   * Serialize an object to a Buffer
   * @param ***REMOVED***Object***REMOVED*** arg The object to serialize
   * @return ***REMOVED***Buffer***REMOVED*** The serialized object
   */
  return function serialize(arg) ***REMOVED***
    return new Buffer(new Cls(arg).encode().toBuffer());
  ***REMOVED***;
***REMOVED***;

var serializeCls = exports.serializeCls;

/**
 * Get the fully qualified (dotted) name of a ProtoBuf.Reflect value.
 * @param ***REMOVED***ProtoBuf.Reflect.Namespace***REMOVED*** value The value to get the name of
 * @return ***REMOVED***string***REMOVED*** The fully qualified name of the value
 */
exports.fullyQualifiedName = function fullyQualifiedName(value) ***REMOVED***
  if (value === null || value === undefined) ***REMOVED***
    return '';
  ***REMOVED***
  var name = value.name;
  var parent_name = fullyQualifiedName(value.parent);
  if (parent_name !== '') ***REMOVED***
    name = parent_name + '.' + name;
  ***REMOVED***
  return name;
***REMOVED***;

var fullyQualifiedName = exports.fullyQualifiedName;

/**
 * Return a map from method names to method attributes for the service.
 * @param ***REMOVED***ProtoBuf.Reflect.Service***REMOVED*** service The service to get attributes for
 * @param ***REMOVED***Object=***REMOVED*** options Options to apply to these attributes
 * @return ***REMOVED***Object***REMOVED*** The attributes map
 */
exports.getProtobufServiceAttrs = function getProtobufServiceAttrs(service,
                                                                   options) ***REMOVED***
  var prefix = '/' + fullyQualifiedName(service) + '/';
  var binaryAsBase64, longsAsStrings;
  if (options) ***REMOVED***
    binaryAsBase64 = options.binaryAsBase64;
    longsAsStrings = options.longsAsStrings;
  ***REMOVED***
  /* This slightly awkward construction is used to make sure we only use
     lodash@3.10.1-compatible functions. A previous version used
     _.fromPairs, which would be cleaner, but was introduced in lodash
     version 4 */
  return _.zipObject(_.map(service.children, function(method) ***REMOVED***
    return _.camelCase(method.name);
  ***REMOVED***), _.map(service.children, function(method) ***REMOVED***
    return ***REMOVED***
      originalName: method.name,
      path: prefix + method.name,
      requestStream: method.requestStream,
      responseStream: method.responseStream,
      requestType: method.resolvedRequestType,
      responseType: method.resolvedResponseType,
      requestSerialize: serializeCls(method.resolvedRequestType.build()),
      requestDeserialize: deserializeCls(method.resolvedRequestType.build(),
                                         options),
      responseSerialize: serializeCls(method.resolvedResponseType.build()),
      responseDeserialize: deserializeCls(method.resolvedResponseType.build(),
                                          options)
    ***REMOVED***;
  ***REMOVED***));
***REMOVED***;

var getProtobufServiceAttrs = exports.getProtobufServiceAttrs;

/**
 * Load a gRPC object from an existing ProtoBuf.Reflect object.
 * @param ***REMOVED***ProtoBuf.Reflect.Namespace***REMOVED*** value The ProtoBuf object to load.
 * @param ***REMOVED***Object=***REMOVED*** options Options to apply to the loaded object
 * @return ***REMOVED***Object<string, *>***REMOVED*** The resulting gRPC object
 */
exports.loadObject = function loadObject(value, options) ***REMOVED***
  var result = ***REMOVED******REMOVED***;
  if (!value) ***REMOVED***
    return value;
  ***REMOVED***
  if (value.hasOwnProperty('ns')) ***REMOVED***
    return loadObject(value.ns, options);
  ***REMOVED***
  if (value.className === 'Namespace') ***REMOVED***
    _.each(value.children, function(child) ***REMOVED***
      result[child.name] = loadObject(child, options);
    ***REMOVED***);
    return result;
  ***REMOVED*** else if (value.className === 'Service') ***REMOVED***
    return client.makeClientConstructor(getProtobufServiceAttrs(value, options),
                                        options);
  ***REMOVED*** else if (value.className === 'Message' || value.className === 'Enum') ***REMOVED***
    return value.build();
  ***REMOVED*** else ***REMOVED***
    return value;
  ***REMOVED***
***REMOVED***;

/**
 * The primary purpose of this method is to distinguish between reflection
 * objects from different versions of ProtoBuf.js. This is just a heuristic,
 * checking for properties that are (currently) specific to this version of
 * ProtoBuf.js
 * @param ***REMOVED***Object***REMOVED*** obj The object to check
 * @return ***REMOVED***boolean***REMOVED*** Whether the object appears to be a Protobuf.js 5
 *   ReflectionObject
 */
exports.isProbablyProtobufJs5 = function isProbablyProtobufJs5(obj) ***REMOVED***
  return _.isArray(obj.children) && (typeof obj.build === 'function');
***REMOVED***;
