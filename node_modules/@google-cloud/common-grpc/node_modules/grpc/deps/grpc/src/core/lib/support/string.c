/*
 *
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include "src/core/lib/support/string.h"

#include <ctype.h>
#include <limits.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include <grpc/support/alloc.h>
#include <grpc/support/log.h>
#include <grpc/support/port_platform.h>
#include <grpc/support/useful.h>

char *gpr_strdup(const char *src) ***REMOVED***
  char *dst;
  size_t len;

  if (!src) ***REMOVED***
    return NULL;
  ***REMOVED***

  len = strlen(src) + 1;
  dst = (char *)gpr_malloc(len);

  memcpy(dst, src, len);

  return dst;
***REMOVED***

typedef struct ***REMOVED***
  size_t capacity;
  size_t length;
  char *data;
***REMOVED*** dump_out;

static dump_out dump_out_create(void) ***REMOVED***
  dump_out r = ***REMOVED***0, 0, NULL***REMOVED***;
  return r;
***REMOVED***

static void dump_out_append(dump_out *out, char c) ***REMOVED***
  if (out->length == out->capacity) ***REMOVED***
    out->capacity = GPR_MAX(8, 2 * out->capacity);
    out->data = (char *)gpr_realloc(out->data, out->capacity);
  ***REMOVED***
  out->data[out->length++] = c;
***REMOVED***

static void hexdump(dump_out *out, const char *buf, size_t len) ***REMOVED***
  static const char *hex = "0123456789abcdef";

  const uint8_t *const beg = (const uint8_t *)buf;
  const uint8_t *const end = beg + len;
  const uint8_t *cur;

  for (cur = beg; cur != end; ++cur) ***REMOVED***
    if (cur != beg) dump_out_append(out, ' ');
    dump_out_append(out, hex[*cur >> 4]);
    dump_out_append(out, hex[*cur & 0xf]);
  ***REMOVED***
***REMOVED***

static void asciidump(dump_out *out, const char *buf, size_t len) ***REMOVED***
  const uint8_t *const beg = (const uint8_t *)buf;
  const uint8_t *const end = beg + len;
  const uint8_t *cur;
  int out_was_empty = (out->length == 0);
  if (!out_was_empty) ***REMOVED***
    dump_out_append(out, ' ');
    dump_out_append(out, '\'');
  ***REMOVED***
  for (cur = beg; cur != end; ++cur) ***REMOVED***
    dump_out_append(out, (char)(isprint(*cur) ? *(char *)cur : '.'));
  ***REMOVED***
  if (!out_was_empty) ***REMOVED***
    dump_out_append(out, '\'');
  ***REMOVED***
***REMOVED***

char *gpr_dump(const char *buf, size_t len, uint32_t flags) ***REMOVED***
  dump_out out = dump_out_create();
  if (flags & GPR_DUMP_HEX) ***REMOVED***
    hexdump(&out, buf, len);
  ***REMOVED***
  if (flags & GPR_DUMP_ASCII) ***REMOVED***
    asciidump(&out, buf, len);
  ***REMOVED***
  dump_out_append(&out, 0);
  return out.data;
***REMOVED***

int gpr_parse_bytes_to_uint32(const char *buf, size_t len, uint32_t *result) ***REMOVED***
  uint32_t out = 0;
  uint32_t new_val;
  size_t i;

  if (len == 0) return 0; /* must have some bytes */

  for (i = 0; i < len; i++) ***REMOVED***
    if (buf[i] < '0' || buf[i] > '9') return 0; /* bad char */
    new_val = 10 * out + (uint32_t)(buf[i] - '0');
    if (new_val < out) return 0; /* overflow */
    out = new_val;
  ***REMOVED***

  *result = out;
  return 1;
***REMOVED***

void gpr_reverse_bytes(char *str, int len) ***REMOVED***
  char *p1, *p2;
  for (p1 = str, p2 = str + len - 1; p2 > p1; ++p1, --p2) ***REMOVED***
    char temp = *p1;
    *p1 = *p2;
    *p2 = temp;
  ***REMOVED***
***REMOVED***

int gpr_ltoa(long value, char *string) ***REMOVED***
  long sign;
  int i = 0;

  if (value == 0) ***REMOVED***
    string[0] = '0';
    string[1] = 0;
    return 1;
  ***REMOVED***

  sign = value < 0 ? -1 : 1;
  while (value) ***REMOVED***
    string[i++] = (char)('0' + sign * (value % 10));
    value /= 10;
  ***REMOVED***
  if (sign < 0) string[i++] = '-';
  gpr_reverse_bytes(string, i);
  string[i] = 0;
  return i;
***REMOVED***

int int64_ttoa(int64_t value, char *string) ***REMOVED***
  int64_t sign;
  int i = 0;

  if (value == 0) ***REMOVED***
    string[0] = '0';
    string[1] = 0;
    return 1;
  ***REMOVED***

  sign = value < 0 ? -1 : 1;
  while (value) ***REMOVED***
    string[i++] = (char)('0' + sign * (value % 10));
    value /= 10;
  ***REMOVED***
  if (sign < 0) string[i++] = '-';
  gpr_reverse_bytes(string, i);
  string[i] = 0;
  return i;
***REMOVED***

int gpr_parse_nonnegative_int(const char *value) ***REMOVED***
  char *end;
  long result = strtol(value, &end, 0);
  if (*end != '\0' || result < 0 || result > INT_MAX) return -1;
  return (int)result;
***REMOVED***

char *gpr_leftpad(const char *str, char flag, size_t length) ***REMOVED***
  const size_t str_length = strlen(str);
  const size_t out_length = str_length > length ? str_length : length;
  char *out = (char *)gpr_malloc(out_length + 1);
  memset(out, flag, out_length - str_length);
  memcpy(out + out_length - str_length, str, str_length);
  out[out_length] = 0;
  return out;
***REMOVED***

char *gpr_strjoin(const char **strs, size_t nstrs, size_t *final_length) ***REMOVED***
  return gpr_strjoin_sep(strs, nstrs, "", final_length);
***REMOVED***

char *gpr_strjoin_sep(const char **strs, size_t nstrs, const char *sep,
                      size_t *final_length) ***REMOVED***
  const size_t sep_len = strlen(sep);
  size_t out_length = 0;
  size_t i;
  char *out;
  for (i = 0; i < nstrs; i++) ***REMOVED***
    out_length += strlen(strs[i]);
  ***REMOVED***
  out_length += 1; /* null terminator */
  if (nstrs > 0) ***REMOVED***
    out_length += sep_len * (nstrs - 1); /* separators */
  ***REMOVED***
  out = (char *)gpr_malloc(out_length);
  out_length = 0;
  for (i = 0; i < nstrs; i++) ***REMOVED***
    const size_t slen = strlen(strs[i]);
    if (i != 0) ***REMOVED***
      memcpy(out + out_length, sep, sep_len);
      out_length += sep_len;
    ***REMOVED***
    memcpy(out + out_length, strs[i], slen);
    out_length += slen;
  ***REMOVED***
  out[out_length] = 0;
  if (final_length != NULL) ***REMOVED***
    *final_length = out_length;
  ***REMOVED***
  return out;
***REMOVED***

void gpr_strvec_init(gpr_strvec *sv) ***REMOVED*** memset(sv, 0, sizeof(*sv)); ***REMOVED***

void gpr_strvec_destroy(gpr_strvec *sv) ***REMOVED***
  size_t i;
  for (i = 0; i < sv->count; i++) ***REMOVED***
    gpr_free(sv->strs[i]);
  ***REMOVED***
  gpr_free(sv->strs);
***REMOVED***

void gpr_strvec_add(gpr_strvec *sv, char *str) ***REMOVED***
  if (sv->count == sv->capacity) ***REMOVED***
    sv->capacity = GPR_MAX(sv->capacity + 8, sv->capacity * 2);
    sv->strs = (char **)gpr_realloc(sv->strs, sizeof(char *) * sv->capacity);
  ***REMOVED***
  sv->strs[sv->count++] = str;
***REMOVED***

char *gpr_strvec_flatten(gpr_strvec *sv, size_t *final_length) ***REMOVED***
  return gpr_strjoin((const char **)sv->strs, sv->count, final_length);
***REMOVED***

int gpr_stricmp(const char *a, const char *b) ***REMOVED***
  int ca, cb;
  do ***REMOVED***
    ca = tolower(*a);
    cb = tolower(*b);
    ++a;
    ++b;
  ***REMOVED*** while (ca == cb && ca && cb);
  return ca - cb;
***REMOVED***

static void add_string_to_split(const char *beg, const char *end, char ***strs,
                                size_t *nstrs, size_t *capstrs) ***REMOVED***
  char *out = (char *)gpr_malloc((size_t)(end - beg) + 1);
  memcpy(out, beg, (size_t)(end - beg));
  out[end - beg] = 0;
  if (*nstrs == *capstrs) ***REMOVED***
    *capstrs = GPR_MAX(8, 2 * *capstrs);
    *strs = (char **)gpr_realloc(*strs, sizeof(*strs) * *capstrs);
  ***REMOVED***
  (*strs)[*nstrs] = out;
  ++*nstrs;
***REMOVED***

void gpr_string_split(const char *input, const char *sep, char ***strs,
                      size_t *nstrs) ***REMOVED***
  const char *next;
  *strs = NULL;
  *nstrs = 0;
  size_t capstrs = 0;
  while ((next = strstr(input, sep))) ***REMOVED***
    add_string_to_split(input, next, strs, nstrs, &capstrs);
    input = next + strlen(sep);
  ***REMOVED***
  add_string_to_split(input, input + strlen(input), strs, nstrs, &capstrs);
***REMOVED***

void *gpr_memrchr(const void *s, int c, size_t n) ***REMOVED***
  if (s == NULL) return NULL;
  char *b = (char *)s;
  size_t i;
  for (i = 0; i < n; i++) ***REMOVED***
    if (b[n - i - 1] == c) ***REMOVED***
      return &b[n - i - 1];
    ***REMOVED***
  ***REMOVED***
  return NULL;
***REMOVED***

bool gpr_is_true(const char *s) ***REMOVED***
  size_t i;
  if (s == NULL) ***REMOVED***
    return false;
  ***REMOVED***
  static const char *truthy[] = ***REMOVED***"yes", "true", "1"***REMOVED***;
  for (i = 0; i < GPR_ARRAY_SIZE(truthy); i++) ***REMOVED***
    if (0 == gpr_stricmp(s, truthy[i])) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***
