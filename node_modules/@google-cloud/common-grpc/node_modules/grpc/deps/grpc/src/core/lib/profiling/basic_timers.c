/*
 *
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <grpc/support/port_platform.h>

#ifdef GRPC_BASIC_PROFILER

#include "src/core/lib/profiling/timers.h"

#include <grpc/support/alloc.h>
#include <grpc/support/log.h>
#include <grpc/support/sync.h>
#include <grpc/support/thd.h>
#include <grpc/support/time.h>
#include <stdio.h>
#include <string.h>

#include "src/core/lib/support/env.h"

typedef enum ***REMOVED*** BEGIN = '***REMOVED***', END = '***REMOVED***', MARK = '.' ***REMOVED*** marker_type;

typedef struct gpr_timer_entry ***REMOVED***
  gpr_timespec tm;
  const char *tagstr;
  const char *file;
  short line;
  char type;
  uint8_t important;
  int thd;
***REMOVED*** gpr_timer_entry;

#define MAX_COUNT 1000000

typedef struct gpr_timer_log ***REMOVED***
  size_t num_entries;
  struct gpr_timer_log *next;
  struct gpr_timer_log *prev;
  gpr_timer_entry log[MAX_COUNT];
***REMOVED*** gpr_timer_log;

typedef struct gpr_timer_log_list ***REMOVED***
  gpr_timer_log *head;
  /* valid iff head!=NULL */
  gpr_timer_log *tail;
***REMOVED*** gpr_timer_log_list;

static __thread gpr_timer_log *g_thread_log;
static gpr_once g_once_init = GPR_ONCE_INIT;
static FILE *output_file;
static const char *output_filename_or_null = NULL;
static pthread_mutex_t g_mu;
static pthread_cond_t g_cv;
static gpr_timer_log_list g_in_progress_logs;
static gpr_timer_log_list g_done_logs;
static int g_shutdown;
static gpr_thd_id g_writing_thread;
static __thread int g_thread_id;
static int g_next_thread_id;
static int g_writing_enabled = 1;

static const char *output_filename() ***REMOVED***
  if (output_filename_or_null == NULL) ***REMOVED***
    output_filename_or_null = gpr_getenv("LATENCY_TRACE");
    if (output_filename_or_null == NULL ||
        strlen(output_filename_or_null) == 0) ***REMOVED***
      output_filename_or_null = "latency_trace.txt";
    ***REMOVED***
  ***REMOVED***
  return output_filename_or_null;
***REMOVED***

static int timer_log_push_back(gpr_timer_log_list *list, gpr_timer_log *log) ***REMOVED***
  if (list->head == NULL) ***REMOVED***
    list->head = list->tail = log;
    log->next = log->prev = NULL;
    return 1;
  ***REMOVED*** else ***REMOVED***
    log->prev = list->tail;
    log->next = NULL;
    list->tail->next = log;
    list->tail = log;
    return 0;
  ***REMOVED***
***REMOVED***

static gpr_timer_log *timer_log_pop_front(gpr_timer_log_list *list) ***REMOVED***
  gpr_timer_log *out = list->head;
  if (out != NULL) ***REMOVED***
    list->head = out->next;
    if (list->head != NULL) ***REMOVED***
      list->head->prev = NULL;
    ***REMOVED*** else ***REMOVED***
      list->tail = NULL;
    ***REMOVED***
  ***REMOVED***
  return out;
***REMOVED***

static void timer_log_remove(gpr_timer_log_list *list, gpr_timer_log *log) ***REMOVED***
  if (log->prev == NULL) ***REMOVED***
    list->head = log->next;
    if (list->head != NULL) ***REMOVED***
      list->head->prev = NULL;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    log->prev->next = log->next;
  ***REMOVED***
  if (log->next == NULL) ***REMOVED***
    list->tail = log->prev;
    if (list->tail != NULL) ***REMOVED***
      list->tail->next = NULL;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    log->next->prev = log->prev;
  ***REMOVED***
***REMOVED***

static void write_log(gpr_timer_log *log) ***REMOVED***
  size_t i;
  if (output_file == NULL) ***REMOVED***
    output_file = fopen(output_filename(), "w");
  ***REMOVED***
  for (i = 0; i < log->num_entries; i++) ***REMOVED***
    gpr_timer_entry *entry = &(log->log[i]);
    if (gpr_time_cmp(entry->tm, gpr_time_0(entry->tm.clock_type)) < 0) ***REMOVED***
      entry->tm = gpr_time_0(entry->tm.clock_type);
    ***REMOVED***
    fprintf(output_file,
            "***REMOVED***\"t\": %" PRId64
            ".%09d, \"thd\": \"%d\", \"type\": \"%c\", \"tag\": "
            "\"%s\", \"file\": \"%s\", \"line\": %d, \"imp\": %d***REMOVED***\n",
            entry->tm.tv_sec, entry->tm.tv_nsec, entry->thd, entry->type,
            entry->tagstr, entry->file, entry->line, entry->important);
  ***REMOVED***
***REMOVED***

static void writing_thread(void *unused) ***REMOVED***
  gpr_timer_log *log;
  pthread_mutex_lock(&g_mu);
  for (;;) ***REMOVED***
    while ((log = timer_log_pop_front(&g_done_logs)) == NULL && !g_shutdown) ***REMOVED***
      pthread_cond_wait(&g_cv, &g_mu);
    ***REMOVED***
    if (log != NULL) ***REMOVED***
      pthread_mutex_unlock(&g_mu);
      write_log(log);
      free(log);
      pthread_mutex_lock(&g_mu);
    ***REMOVED***
    if (g_shutdown) ***REMOVED***
      pthread_mutex_unlock(&g_mu);
      return;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

static void flush_logs(gpr_timer_log_list *list) ***REMOVED***
  gpr_timer_log *log;
  while ((log = timer_log_pop_front(list)) != NULL) ***REMOVED***
    write_log(log);
    free(log);
  ***REMOVED***
***REMOVED***

static void finish_writing(void) ***REMOVED***
  pthread_mutex_lock(&g_mu);
  g_shutdown = 1;
  pthread_cond_signal(&g_cv);
  pthread_mutex_unlock(&g_mu);
  gpr_thd_join(g_writing_thread);

  gpr_log(GPR_INFO, "flushing logs");

  pthread_mutex_lock(&g_mu);
  flush_logs(&g_done_logs);
  flush_logs(&g_in_progress_logs);
  pthread_mutex_unlock(&g_mu);

  if (output_file) ***REMOVED***
    fclose(output_file);
  ***REMOVED***
***REMOVED***

void gpr_timers_set_log_filename(const char *filename) ***REMOVED***
  output_filename_or_null = filename;
***REMOVED***

static void init_output() ***REMOVED***
  gpr_thd_options options = gpr_thd_options_default();
  gpr_thd_options_set_joinable(&options);
  GPR_ASSERT(gpr_thd_new(&g_writing_thread, writing_thread, NULL, &options));
  atexit(finish_writing);
***REMOVED***

static void rotate_log() ***REMOVED***
  /* Using malloc here, as this code could end up being called by gpr_malloc */
  gpr_timer_log *new = malloc(sizeof(*new));
  gpr_once_init(&g_once_init, init_output);
  new->num_entries = 0;
  pthread_mutex_lock(&g_mu);
  if (g_thread_log != NULL) ***REMOVED***
    timer_log_remove(&g_in_progress_logs, g_thread_log);
    if (timer_log_push_back(&g_done_logs, g_thread_log)) ***REMOVED***
      pthread_cond_signal(&g_cv);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    g_thread_id = g_next_thread_id++;
  ***REMOVED***
  timer_log_push_back(&g_in_progress_logs, new);
  pthread_mutex_unlock(&g_mu);
  g_thread_log = new;
***REMOVED***

static void gpr_timers_log_add(const char *tagstr, marker_type type,
                               int important, const char *file, int line) ***REMOVED***
  gpr_timer_entry *entry;

  if (!g_writing_enabled) ***REMOVED***
    return;
  ***REMOVED***

  if (g_thread_log == NULL || g_thread_log->num_entries == MAX_COUNT) ***REMOVED***
    rotate_log();
  ***REMOVED***

  entry = &g_thread_log->log[g_thread_log->num_entries++];

  entry->tm = gpr_now(GPR_CLOCK_PRECISE);
  entry->tagstr = tagstr;
  entry->type = type;
  entry->file = file;
  entry->line = (short)line;
  entry->important = important != 0;
  entry->thd = g_thread_id;
***REMOVED***

/* Latency profiler API implementation. */
void gpr_timer_add_mark(const char *tagstr, int important, const char *file,
                        int line) ***REMOVED***
  gpr_timers_log_add(tagstr, MARK, important, file, line);
***REMOVED***

void gpr_timer_begin(const char *tagstr, int important, const char *file,
                     int line) ***REMOVED***
  gpr_timers_log_add(tagstr, BEGIN, important, file, line);
***REMOVED***

void gpr_timer_end(const char *tagstr, int important, const char *file,
                   int line) ***REMOVED***
  gpr_timers_log_add(tagstr, END, important, file, line);
***REMOVED***

void gpr_timer_set_enabled(int enabled) ***REMOVED*** g_writing_enabled = enabled; ***REMOVED***

/* Basic profiler specific API functions. */
void gpr_timers_global_init(void) ***REMOVED******REMOVED***

void gpr_timers_global_destroy(void) ***REMOVED******REMOVED***

#else  /* !GRPC_BASIC_PROFILER */
void gpr_timers_global_init(void) ***REMOVED******REMOVED***

void gpr_timers_global_destroy(void) ***REMOVED******REMOVED***

void gpr_timers_set_log_filename(const char *filename) ***REMOVED******REMOVED***

void gpr_timer_set_enabled(int enabled) ***REMOVED******REMOVED***
#endif /* GRPC_BASIC_PROFILER */
