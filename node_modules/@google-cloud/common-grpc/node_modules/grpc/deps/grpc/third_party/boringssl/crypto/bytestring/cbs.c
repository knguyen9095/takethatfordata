/* Copyright (c) 2014, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

#include <openssl/buf.h>
#include <openssl/mem.h>
#include <openssl/bytestring.h>

#include <assert.h>
#include <string.h>

#include "internal.h"
#include "../internal.h"


void CBS_init(CBS *cbs, const uint8_t *data, size_t len) ***REMOVED***
  cbs->data = data;
  cbs->len = len;
***REMOVED***

static int cbs_get(CBS *cbs, const uint8_t **p, size_t n) ***REMOVED***
  if (cbs->len < n) ***REMOVED***
    return 0;
  ***REMOVED***

  *p = cbs->data;
  cbs->data += n;
  cbs->len -= n;
  return 1;
***REMOVED***

int CBS_skip(CBS *cbs, size_t len) ***REMOVED***
  const uint8_t *dummy;
  return cbs_get(cbs, &dummy, len);
***REMOVED***

const uint8_t *CBS_data(const CBS *cbs) ***REMOVED***
  return cbs->data;
***REMOVED***

size_t CBS_len(const CBS *cbs) ***REMOVED***
  return cbs->len;
***REMOVED***

int CBS_stow(const CBS *cbs, uint8_t **out_ptr, size_t *out_len) ***REMOVED***
  OPENSSL_free(*out_ptr);
  *out_ptr = NULL;
  *out_len = 0;

  if (cbs->len == 0) ***REMOVED***
    return 1;
  ***REMOVED***
  *out_ptr = BUF_memdup(cbs->data, cbs->len);
  if (*out_ptr == NULL) ***REMOVED***
    return 0;
  ***REMOVED***
  *out_len = cbs->len;
  return 1;
***REMOVED***

int CBS_strdup(const CBS *cbs, char **out_ptr) ***REMOVED***
  if (*out_ptr != NULL) ***REMOVED***
    OPENSSL_free(*out_ptr);
  ***REMOVED***
  *out_ptr = BUF_strndup((const char*)cbs->data, cbs->len);
  return (*out_ptr != NULL);
***REMOVED***

int CBS_contains_zero_byte(const CBS *cbs) ***REMOVED***
  return OPENSSL_memchr(cbs->data, 0, cbs->len) != NULL;
***REMOVED***

int CBS_mem_equal(const CBS *cbs, const uint8_t *data, size_t len) ***REMOVED***
  if (len != cbs->len) ***REMOVED***
    return 0;
  ***REMOVED***
  return CRYPTO_memcmp(cbs->data, data, len) == 0;
***REMOVED***

static int cbs_get_u(CBS *cbs, uint32_t *out, size_t len) ***REMOVED***
  uint32_t result = 0;
  const uint8_t *data;

  if (!cbs_get(cbs, &data, len)) ***REMOVED***
    return 0;
  ***REMOVED***
  for (size_t i = 0; i < len; i++) ***REMOVED***
    result <<= 8;
    result |= data[i];
  ***REMOVED***
  *out = result;
  return 1;
***REMOVED***

int CBS_get_u8(CBS *cbs, uint8_t *out) ***REMOVED***
  const uint8_t *v;
  if (!cbs_get(cbs, &v, 1)) ***REMOVED***
    return 0;
  ***REMOVED***
  *out = *v;
  return 1;
***REMOVED***

int CBS_get_u16(CBS *cbs, uint16_t *out) ***REMOVED***
  uint32_t v;
  if (!cbs_get_u(cbs, &v, 2)) ***REMOVED***
    return 0;
  ***REMOVED***
  *out = v;
  return 1;
***REMOVED***

int CBS_get_u24(CBS *cbs, uint32_t *out) ***REMOVED***
  return cbs_get_u(cbs, out, 3);
***REMOVED***

int CBS_get_u32(CBS *cbs, uint32_t *out) ***REMOVED***
  return cbs_get_u(cbs, out, 4);
***REMOVED***

int CBS_get_last_u8(CBS *cbs, uint8_t *out) ***REMOVED***
  if (cbs->len == 0) ***REMOVED***
    return 0;
  ***REMOVED***
  *out = cbs->data[cbs->len - 1];
  cbs->len--;
  return 1;
***REMOVED***

int CBS_get_bytes(CBS *cbs, CBS *out, size_t len) ***REMOVED***
  const uint8_t *v;
  if (!cbs_get(cbs, &v, len)) ***REMOVED***
    return 0;
  ***REMOVED***
  CBS_init(out, v, len);
  return 1;
***REMOVED***

int CBS_copy_bytes(CBS *cbs, uint8_t *out, size_t len) ***REMOVED***
  const uint8_t *v;
  if (!cbs_get(cbs, &v, len)) ***REMOVED***
    return 0;
  ***REMOVED***
  OPENSSL_memcpy(out, v, len);
  return 1;
***REMOVED***

static int cbs_get_length_prefixed(CBS *cbs, CBS *out, size_t len_len) ***REMOVED***
  uint32_t len;
  if (!cbs_get_u(cbs, &len, len_len)) ***REMOVED***
    return 0;
  ***REMOVED***
  return CBS_get_bytes(cbs, out, len);
***REMOVED***

int CBS_get_u8_length_prefixed(CBS *cbs, CBS *out) ***REMOVED***
  return cbs_get_length_prefixed(cbs, out, 1);
***REMOVED***

int CBS_get_u16_length_prefixed(CBS *cbs, CBS *out) ***REMOVED***
  return cbs_get_length_prefixed(cbs, out, 2);
***REMOVED***

int CBS_get_u24_length_prefixed(CBS *cbs, CBS *out) ***REMOVED***
  return cbs_get_length_prefixed(cbs, out, 3);
***REMOVED***

static int cbs_get_any_asn1_element(CBS *cbs, CBS *out, unsigned *out_tag,
                                    size_t *out_header_len, int ber_ok) ***REMOVED***
  uint8_t tag, length_byte;
  CBS header = *cbs;
  CBS throwaway;

  if (out == NULL) ***REMOVED***
    out = &throwaway;
  ***REMOVED***

  if (!CBS_get_u8(&header, &tag) ||
      !CBS_get_u8(&header, &length_byte)) ***REMOVED***
    return 0;
  ***REMOVED***

  /* ITU-T X.690 section 8.1.2.3 specifies the format for identifiers with a tag
   * number no greater than 30.
   *
   * If the number portion is 31 (0x1f, the largest value that fits in the
   * allotted bits), then the tag is more than one byte long and the
   * continuation bytes contain the tag number. This parser only supports tag
   * numbers less than 31 (and thus single-byte tags). */
  if ((tag & 0x1f) == 0x1f) ***REMOVED***
    return 0;
  ***REMOVED***

  if (out_tag != NULL) ***REMOVED***
    *out_tag = tag;
  ***REMOVED***

  size_t len;
  /* The format for the length encoding is specified in ITU-T X.690 section
   * 8.1.3. */
  if ((length_byte & 0x80) == 0) ***REMOVED***
    /* Short form length. */
    len = ((size_t) length_byte) + 2;
    if (out_header_len != NULL) ***REMOVED***
      *out_header_len = 2;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    /* The high bit indicate that this is the long form, while the next 7 bits
     * encode the number of subsequent octets used to encode the length (ITU-T
     * X.690 clause 8.1.3.5.b). */
    const size_t num_bytes = length_byte & 0x7f;
    uint32_t len32;

    if (ber_ok && (tag & CBS_ASN1_CONSTRUCTED) != 0 && num_bytes == 0) ***REMOVED***
      /* indefinite length */
      if (out_header_len != NULL) ***REMOVED***
        *out_header_len = 2;
      ***REMOVED***
      return CBS_get_bytes(cbs, out, 2);
    ***REMOVED***

    /* ITU-T X.690 clause 8.1.3.5.c specifies that the value 0xff shall not be
     * used as the first byte of the length. If this parser encounters that
     * value, num_bytes will be parsed as 127, which will fail the check below.
     */
    if (num_bytes == 0 || num_bytes > 4) ***REMOVED***
      return 0;
    ***REMOVED***
    if (!cbs_get_u(&header, &len32, num_bytes)) ***REMOVED***
      return 0;
    ***REMOVED***
    /* ITU-T X.690 section 10.1 (DER length forms) requires encoding the length
     * with the minimum number of octets. */
    if (len32 < 128) ***REMOVED***
      /* Length should have used short-form encoding. */
      return 0;
    ***REMOVED***
    if ((len32 >> ((num_bytes-1)*8)) == 0) ***REMOVED***
      /* Length should have been at least one byte shorter. */
      return 0;
    ***REMOVED***
    len = len32;
    if (len + 2 + num_bytes < len) ***REMOVED***
      /* Overflow. */
      return 0;
    ***REMOVED***
    len += 2 + num_bytes;
    if (out_header_len != NULL) ***REMOVED***
      *out_header_len = 2 + num_bytes;
    ***REMOVED***
  ***REMOVED***

  return CBS_get_bytes(cbs, out, len);
***REMOVED***

int CBS_get_any_asn1(CBS *cbs, CBS *out, unsigned *out_tag) ***REMOVED***
  size_t header_len;
  if (!CBS_get_any_asn1_element(cbs, out, out_tag, &header_len)) ***REMOVED***
    return 0;
  ***REMOVED***

  if (!CBS_skip(out, header_len)) ***REMOVED***
    assert(0);
    return 0;
  ***REMOVED***

  return 1;
***REMOVED***

int CBS_get_any_asn1_element(CBS *cbs, CBS *out, unsigned *out_tag,
                                    size_t *out_header_len) ***REMOVED***
  return cbs_get_any_asn1_element(cbs, out, out_tag, out_header_len,
                                  0 /* DER only */);
***REMOVED***

int CBS_get_any_ber_asn1_element(CBS *cbs, CBS *out, unsigned *out_tag,
                                 size_t *out_header_len) ***REMOVED***
  return cbs_get_any_asn1_element(cbs, out, out_tag, out_header_len,
                                  1 /* BER allowed */);
***REMOVED***

static int cbs_get_asn1(CBS *cbs, CBS *out, unsigned tag_value,
                        int skip_header) ***REMOVED***
  size_t header_len;
  unsigned tag;
  CBS throwaway;

  if (out == NULL) ***REMOVED***
    out = &throwaway;
  ***REMOVED***

  if (!CBS_get_any_asn1_element(cbs, out, &tag, &header_len) ||
      tag != tag_value) ***REMOVED***
    return 0;
  ***REMOVED***

  if (skip_header && !CBS_skip(out, header_len)) ***REMOVED***
    assert(0);
    return 0;
  ***REMOVED***

  return 1;
***REMOVED***

int CBS_get_asn1(CBS *cbs, CBS *out, unsigned tag_value) ***REMOVED***
  return cbs_get_asn1(cbs, out, tag_value, 1 /* skip header */);
***REMOVED***

int CBS_get_asn1_element(CBS *cbs, CBS *out, unsigned tag_value) ***REMOVED***
  return cbs_get_asn1(cbs, out, tag_value, 0 /* include header */);
***REMOVED***

int CBS_peek_asn1_tag(const CBS *cbs, unsigned tag_value) ***REMOVED***
  if (CBS_len(cbs) < 1) ***REMOVED***
    return 0;
  ***REMOVED***
  return CBS_data(cbs)[0] == tag_value;
***REMOVED***

int CBS_get_asn1_uint64(CBS *cbs, uint64_t *out) ***REMOVED***
  CBS bytes;
  const uint8_t *data;
  size_t i, len;

  if (!CBS_get_asn1(cbs, &bytes, CBS_ASN1_INTEGER)) ***REMOVED***
    return 0;
  ***REMOVED***

  *out = 0;
  data = CBS_data(&bytes);
  len = CBS_len(&bytes);

  if (len == 0) ***REMOVED***
    /* An INTEGER is encoded with at least one octet. */
    return 0;
  ***REMOVED***

  if ((data[0] & 0x80) != 0) ***REMOVED***
    /* Negative number. */
    return 0;
  ***REMOVED***

  if (data[0] == 0 && len > 1 && (data[1] & 0x80) == 0) ***REMOVED***
    /* Extra leading zeros. */
    return 0;
  ***REMOVED***

  for (i = 0; i < len; i++) ***REMOVED***
    if ((*out >> 56) != 0) ***REMOVED***
      /* Too large to represent as a uint64_t. */
      return 0;
    ***REMOVED***
    *out <<= 8;
    *out |= data[i];
  ***REMOVED***

  return 1;
***REMOVED***

int CBS_get_optional_asn1(CBS *cbs, CBS *out, int *out_present, unsigned tag) ***REMOVED***
  int present = 0;

  if (CBS_peek_asn1_tag(cbs, tag)) ***REMOVED***
    if (!CBS_get_asn1(cbs, out, tag)) ***REMOVED***
      return 0;
    ***REMOVED***
    present = 1;
  ***REMOVED***

  if (out_present != NULL) ***REMOVED***
    *out_present = present;
  ***REMOVED***

  return 1;
***REMOVED***

int CBS_get_optional_asn1_octet_string(CBS *cbs, CBS *out, int *out_present,
                                       unsigned tag) ***REMOVED***
  CBS child;
  int present;
  if (!CBS_get_optional_asn1(cbs, &child, &present, tag)) ***REMOVED***
    return 0;
  ***REMOVED***
  if (present) ***REMOVED***
    if (!CBS_get_asn1(&child, out, CBS_ASN1_OCTETSTRING) ||
        CBS_len(&child) != 0) ***REMOVED***
      return 0;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    CBS_init(out, NULL, 0);
  ***REMOVED***
  if (out_present) ***REMOVED***
    *out_present = present;
  ***REMOVED***
  return 1;
***REMOVED***

int CBS_get_optional_asn1_uint64(CBS *cbs, uint64_t *out, unsigned tag,
                                 uint64_t default_value) ***REMOVED***
  CBS child;
  int present;
  if (!CBS_get_optional_asn1(cbs, &child, &present, tag)) ***REMOVED***
    return 0;
  ***REMOVED***
  if (present) ***REMOVED***
    if (!CBS_get_asn1_uint64(&child, out) ||
        CBS_len(&child) != 0) ***REMOVED***
      return 0;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    *out = default_value;
  ***REMOVED***
  return 1;
***REMOVED***

int CBS_get_optional_asn1_bool(CBS *cbs, int *out, unsigned tag,
                               int default_value) ***REMOVED***
  CBS child, child2;
  int present;
  if (!CBS_get_optional_asn1(cbs, &child, &present, tag)) ***REMOVED***
    return 0;
  ***REMOVED***
  if (present) ***REMOVED***
    uint8_t boolean;

    if (!CBS_get_asn1(&child, &child2, CBS_ASN1_BOOLEAN) ||
        CBS_len(&child2) != 1 ||
        CBS_len(&child) != 0) ***REMOVED***
      return 0;
    ***REMOVED***

    boolean = CBS_data(&child2)[0];
    if (boolean == 0) ***REMOVED***
      *out = 0;
    ***REMOVED*** else if (boolean == 0xff) ***REMOVED***
      *out = 1;
    ***REMOVED*** else ***REMOVED***
      return 0;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    *out = default_value;
  ***REMOVED***
  return 1;
***REMOVED***

int CBS_is_valid_asn1_bitstring(const CBS *cbs) ***REMOVED***
  CBS in = *cbs;
  uint8_t num_unused_bits;
  if (!CBS_get_u8(&in, &num_unused_bits) ||
      num_unused_bits > 7) ***REMOVED***
    return 0;
  ***REMOVED***

  if (num_unused_bits == 0) ***REMOVED***
    return 1;
  ***REMOVED***

  /* All num_unused_bits bits must exist and be zeros. */
  uint8_t last;
  if (!CBS_get_last_u8(&in, &last) ||
      (last & ((1 << num_unused_bits) - 1)) != 0) ***REMOVED***
    return 0;
  ***REMOVED***

  return 1;
***REMOVED***

int CBS_asn1_bitstring_has_bit(const CBS *cbs, unsigned bit) ***REMOVED***
  if (!CBS_is_valid_asn1_bitstring(cbs)) ***REMOVED***
    return 0;
  ***REMOVED***

  const unsigned byte_num = (bit >> 3) + 1;
  const unsigned bit_num = 7 - (bit & 7);

  /* Unused bits are zero, and this function does not distinguish between
   * missing and unset bits. Thus it is sufficient to do a byte-level length
   * check. */
  return byte_num < CBS_len(cbs) &&
         (CBS_data(cbs)[byte_num] & (1 << bit_num)) != 0;
***REMOVED***
