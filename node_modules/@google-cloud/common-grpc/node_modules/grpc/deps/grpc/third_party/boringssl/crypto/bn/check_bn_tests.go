// Copyright (c) 2016, Google Inc.
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
// OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
// CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

package main

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"math/big"
	"os"
	"strings"
)

type test struct ***REMOVED***
	LineNumber int
	Type       string
	Values     map[string]*big.Int
***REMOVED***

type testScanner struct ***REMOVED***
	scanner *bufio.Scanner
	lineNo  int
	err     error
	test    test
***REMOVED***

func newTestScanner(r io.Reader) *testScanner ***REMOVED***
	return &testScanner***REMOVED***scanner: bufio.NewScanner(r)***REMOVED***
***REMOVED***

func (s *testScanner) scanLine() bool ***REMOVED***
	if !s.scanner.Scan() ***REMOVED***
		return false
	***REMOVED***
	s.lineNo++
	return true
***REMOVED***

func (s *testScanner) addAttribute(line string) (key string, ok bool) ***REMOVED***
	fields := strings.SplitN(line, "=", 2)
	if len(fields) != 2 ***REMOVED***
		s.setError(errors.New("invalid syntax"))
		return "", false
	***REMOVED***

	key = strings.TrimSpace(fields[0])
	value := strings.TrimSpace(fields[1])

	valueInt, ok := new(big.Int).SetString(value, 16)
	if !ok ***REMOVED***
		s.setError(fmt.Errorf("could not parse %q", value))
		return "", false
	***REMOVED***
	if _, dup := s.test.Values[key]; dup ***REMOVED***
		s.setError(fmt.Errorf("duplicate key %q", key))
		return "", false
	***REMOVED***
	s.test.Values[key] = valueInt
	return key, true
***REMOVED***

func (s *testScanner) Scan() bool ***REMOVED***
	s.test = test***REMOVED***
		Values: make(map[string]*big.Int),
	***REMOVED***

	// Scan until the first attribute.
	for ***REMOVED***
		if !s.scanLine() ***REMOVED***
			return false
		***REMOVED***
		if len(s.scanner.Text()) != 0 && s.scanner.Text()[0] != '#' ***REMOVED***
			break
		***REMOVED***
	***REMOVED***

	var ok bool
	s.test.Type, ok = s.addAttribute(s.scanner.Text())
	if !ok ***REMOVED***
		return false
	***REMOVED***
	s.test.LineNumber = s.lineNo

	for s.scanLine() ***REMOVED***
		if len(s.scanner.Text()) == 0 ***REMOVED***
			break
		***REMOVED***

		if s.scanner.Text()[0] == '#' ***REMOVED***
			continue
		***REMOVED***

		if _, ok := s.addAttribute(s.scanner.Text()); !ok ***REMOVED***
			return false
		***REMOVED***
	***REMOVED***
	return s.scanner.Err() == nil
***REMOVED***

func (s *testScanner) Test() test ***REMOVED***
	return s.test
***REMOVED***

func (s *testScanner) Err() error ***REMOVED***
	if s.err != nil ***REMOVED***
		return s.err
	***REMOVED***
	return s.scanner.Err()
***REMOVED***

func (s *testScanner) setError(err error) ***REMOVED***
	s.err = fmt.Errorf("line %d: %s", s.lineNo, err)
***REMOVED***

func checkKeys(t test, keys ...string) bool ***REMOVED***
	var foundErrors bool

	for _, k := range keys ***REMOVED***
		if _, ok := t.Values[k]; !ok ***REMOVED***
			fmt.Fprintf(os.Stderr, "Line %d: missing key %q.\n", t.LineNumber, k)
			foundErrors = true
		***REMOVED***
	***REMOVED***

	for k, _ := range t.Values ***REMOVED***
		var found bool
		for _, k2 := range keys ***REMOVED***
			if k == k2 ***REMOVED***
				found = true
				break
			***REMOVED***
		***REMOVED***
		if !found ***REMOVED***
			fmt.Fprintf(os.Stderr, "Line %d: unexpected key %q.\n", t.LineNumber, k)
			foundErrors = true
		***REMOVED***
	***REMOVED***

	return !foundErrors
***REMOVED***

func checkResult(t test, expr, key string, r *big.Int) ***REMOVED***
	if t.Values[key].Cmp(r) != 0 ***REMOVED***
		fmt.Fprintf(os.Stderr, "Line %d: %s did not match %s.\n\tGot %s\n", t.LineNumber, expr, key, r.Text(16))
	***REMOVED***
***REMOVED***

func main() ***REMOVED***
	if len(os.Args) != 2 ***REMOVED***
		fmt.Fprintf(os.Stderr, "Usage: %s bn_tests.txt\n", os.Args[0])
		os.Exit(1)
	***REMOVED***

	in, err := os.Open(os.Args[1])
	if err != nil ***REMOVED***
		fmt.Fprintf(os.Stderr, "Error opening %s: %s.\n", os.Args[0], err)
		os.Exit(1)
	***REMOVED***
	defer in.Close()

	scanner := newTestScanner(in)
	for scanner.Scan() ***REMOVED***
		test := scanner.Test()
		switch test.Type ***REMOVED***
		case "Sum":
			if checkKeys(test, "A", "B", "Sum") ***REMOVED***
				r := new(big.Int).Add(test.Values["A"], test.Values["B"])
				checkResult(test, "A + B", "Sum", r)
			***REMOVED***
		case "LShift1":
			if checkKeys(test, "A", "LShift1") ***REMOVED***
				r := new(big.Int).Add(test.Values["A"], test.Values["A"])
				checkResult(test, "A + A", "LShift1", r)
			***REMOVED***
		case "LShift":
			if checkKeys(test, "A", "N", "LShift") ***REMOVED***
				r := new(big.Int).Lsh(test.Values["A"], uint(test.Values["N"].Uint64()))
				checkResult(test, "A << N", "LShift", r)
			***REMOVED***
		case "RShift":
			if checkKeys(test, "A", "N", "RShift") ***REMOVED***
				r := new(big.Int).Rsh(test.Values["A"], uint(test.Values["N"].Uint64()))
				checkResult(test, "A >> N", "RShift", r)
			***REMOVED***
		case "Square":
			if checkKeys(test, "A", "Square") ***REMOVED***
				r := new(big.Int).Mul(test.Values["A"], test.Values["A"])
				checkResult(test, "A * A", "Square", r)
			***REMOVED***
		case "Product":
			if checkKeys(test, "A", "B", "Product") ***REMOVED***
				r := new(big.Int).Mul(test.Values["A"], test.Values["B"])
				checkResult(test, "A * B", "Product", r)
			***REMOVED***
		case "Quotient":
			if checkKeys(test, "A", "B", "Quotient", "Remainder") ***REMOVED***
				q, r := new(big.Int).QuoRem(test.Values["A"], test.Values["B"], new(big.Int))
				checkResult(test, "A / B", "Quotient", q)
				checkResult(test, "A % B", "Remainder", r)
			***REMOVED***
		case "ModMul":
			if checkKeys(test, "A", "B", "M", "ModMul") ***REMOVED***
				r := new(big.Int).Mul(test.Values["A"], test.Values["B"])
				r = r.Mod(r, test.Values["M"])
				checkResult(test, "A * B (mod M)", "ModMul", r)
			***REMOVED***
		case "ModExp":
			if checkKeys(test, "A", "E", "M", "ModExp") ***REMOVED***
				r := new(big.Int).Exp(test.Values["A"], test.Values["E"], test.Values["M"])
				checkResult(test, "A ^ E (mod M)", "ModExp", r)
			***REMOVED***
		case "Exp":
			if checkKeys(test, "A", "E", "Exp") ***REMOVED***
				r := new(big.Int).Exp(test.Values["A"], test.Values["E"], nil)
				checkResult(test, "A ^ E", "Exp", r)
			***REMOVED***
		case "ModSqrt":
			bigOne := new(big.Int).SetInt64(1)
			bigTwo := new(big.Int).SetInt64(2)

			if checkKeys(test, "A", "P", "ModSqrt") ***REMOVED***
				test.Values["A"].Mod(test.Values["A"], test.Values["P"])

				r := new(big.Int).Mul(test.Values["ModSqrt"], test.Values["ModSqrt"])
				r = r.Mod(r, test.Values["P"])
				checkResult(test, "ModSqrt ^ 2 (mod P)", "A", r)

				if test.Values["P"].Cmp(bigTwo) > 0 ***REMOVED***
					pMinus1Over2 := new(big.Int).Sub(test.Values["P"], bigOne)
					pMinus1Over2.Rsh(pMinus1Over2, 1)

					if test.Values["ModSqrt"].Cmp(pMinus1Over2) > 0 ***REMOVED***
						fmt.Fprintf(os.Stderr, "Line %d: ModSqrt should be minimal.\n", test.LineNumber)
					***REMOVED***
				***REMOVED***
			***REMOVED***
		case "ModInv":
			if checkKeys(test, "A", "M", "ModInv") ***REMOVED***
				r := new(big.Int).ModInverse(test.Values["A"], test.Values["M"])
				checkResult(test, "A ^ -1 (mod M)", "ModInv", r)
			***REMOVED***
		default:
			fmt.Fprintf(os.Stderr, "Line %d: unknown test type %q.\n", test.LineNumber, test.Type)
		***REMOVED***
	***REMOVED***
	if scanner.Err() != nil ***REMOVED***
		fmt.Fprintf(os.Stderr, "Error reading tests: %s.\n", scanner.Err())
	***REMOVED***
***REMOVED***
