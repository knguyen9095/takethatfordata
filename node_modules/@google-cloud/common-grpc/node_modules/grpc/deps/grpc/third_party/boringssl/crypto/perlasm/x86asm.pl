#! /usr/bin/env perl
# Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the OpenSSL license (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


# require 'x86asm.pl';
# &asm_init(<flavor>,"des-586.pl"[,$i386only]);
# &function_begin("foo");
# ...
# &function_end("foo");
# &asm_finish

$out=();
$i386=0;

# AUTOLOAD is this context has quite unpleasant side effect, namely
# that typos in function calls effectively go to assembler output,
# but on the pros side we don't have to implement one subroutine per
# each opcode...
sub ::AUTOLOAD
***REMOVED*** my $opcode = $AUTOLOAD;

    die "more than 4 arguments passed to $opcode" if ($#_>3);

    $opcode =~ s/.*:://;
    if    ($opcode =~ /^push/) ***REMOVED*** $stack+=4; ***REMOVED***
    elsif ($opcode =~ /^pop/)  ***REMOVED*** $stack-=4; ***REMOVED***

    &generic($opcode,@_) or die "undefined subroutine \&$AUTOLOAD";
***REMOVED***

sub ::emit
***REMOVED*** my $opcode=shift;

    if ($#_==-1)    ***REMOVED*** push(@out,"\t$opcode\n");				***REMOVED***
    else            ***REMOVED*** push(@out,"\t$opcode\t".join(',',@_)."\n");	***REMOVED***
***REMOVED***

sub ::LB
***REMOVED***   $_[0] =~ m/^e?([a-d])x$/o or die "$_[0] does not have a 'low byte'";
  $1."l";
***REMOVED***
sub ::HB
***REMOVED***   $_[0] =~ m/^e?([a-d])x$/o or die "$_[0] does not have a 'high byte'";
  $1."h";
***REMOVED***
sub ::stack_push***REMOVED*** my $num=$_[0]*4; $stack+=$num; &sub("esp",$num);	***REMOVED***
sub ::stack_pop	***REMOVED*** my $num=$_[0]*4; $stack-=$num; &add("esp",$num);	***REMOVED***
sub ::blindpop	***REMOVED*** &pop($_[0]); $stack+=4;				***REMOVED***
sub ::wparam	***REMOVED*** &DWP($stack+4*$_[0],"esp");				***REMOVED***
sub ::swtmp	***REMOVED*** &DWP(4*$_[0],"esp");					***REMOVED***

sub ::bswap
***REMOVED***   if ($i386)	# emulate bswap for i386
    ***REMOVED***	&comment("bswap @_");
	&xchg(&HB(@_),&LB(@_));
	&ror (@_,16);
	&xchg(&HB(@_),&LB(@_));
    ***REMOVED***
    else
    ***REMOVED***	&generic("bswap",@_);	***REMOVED***
***REMOVED***
# These are made-up opcodes introduced over the years essentially
# by ignorance, just alias them to real ones...
sub ::movb	***REMOVED*** &mov(@_);	***REMOVED***
sub ::xorb	***REMOVED*** &xor(@_);	***REMOVED***
sub ::rotl	***REMOVED*** &rol(@_);	***REMOVED***
sub ::rotr	***REMOVED*** &ror(@_);	***REMOVED***
sub ::exch	***REMOVED*** &xchg(@_);	***REMOVED***
sub ::halt	***REMOVED*** &hlt;		***REMOVED***
sub ::movz	***REMOVED*** &movzx(@_);	***REMOVED***
sub ::pushf	***REMOVED*** &pushfd;	***REMOVED***
sub ::popf	***REMOVED*** &popfd;	***REMOVED***

# 3 argument instructions
sub ::movq
***REMOVED*** my($p1,$p2,$optimize)=@_;

    if ($optimize && $p1=~/^mm[0-7]$/ && $p2=~/^mm[0-7]$/)
    # movq between mmx registers can sink Intel CPUs
    ***REMOVED***	&::pshufw($p1,$p2,0xe4);		***REMOVED***
    else
    ***REMOVED***	&::generic("movq",@_);			***REMOVED***
***REMOVED***

# SSE>2 instructions
my %regrm = (	"eax"=>0, "ecx"=>1, "edx"=>2, "ebx"=>3,
		"esp"=>4, "ebp"=>5, "esi"=>6, "edi"=>7	);
sub ::pextrd
***REMOVED*** my($dst,$src,$imm)=@_;
    if ("$dst:$src" =~ /(e[a-dsd][ixp]):xmm([0-7])/)
    ***REMOVED***	&::data_byte(0x66,0x0f,0x3a,0x16,0xc0|($2<<3)|$regrm***REMOVED***$1***REMOVED***,$imm);	***REMOVED***
    else
    ***REMOVED***	&::generic("pextrd",@_);		***REMOVED***
***REMOVED***

sub ::pinsrd
***REMOVED*** my($dst,$src,$imm)=@_;
    if ("$dst:$src" =~ /xmm([0-7]):(e[a-dsd][ixp])/)
    ***REMOVED***	&::data_byte(0x66,0x0f,0x3a,0x22,0xc0|($1<<3)|$regrm***REMOVED***$2***REMOVED***,$imm);	***REMOVED***
    else
    ***REMOVED***	&::generic("pinsrd",@_);		***REMOVED***
***REMOVED***

sub ::pshufb
***REMOVED*** my($dst,$src)=@_;
    if ("$dst:$src" =~ /xmm([0-7]):xmm([0-7])/)
    ***REMOVED***	&data_byte(0x66,0x0f,0x38,0x00,0xc0|($1<<3)|$2);	***REMOVED***
    else
    ***REMOVED***	&::generic("pshufb",@_);		***REMOVED***
***REMOVED***

sub ::palignr
***REMOVED*** my($dst,$src,$imm)=@_;
    if ("$dst:$src" =~ /xmm([0-7]):xmm([0-7])/)
    ***REMOVED***	&::data_byte(0x66,0x0f,0x3a,0x0f,0xc0|($1<<3)|$2,$imm);	***REMOVED***
    else
    ***REMOVED***	&::generic("palignr",@_);		***REMOVED***
***REMOVED***

sub ::pclmulqdq
***REMOVED*** my($dst,$src,$imm)=@_;
    if ("$dst:$src" =~ /xmm([0-7]):xmm([0-7])/)
    ***REMOVED***	&::data_byte(0x66,0x0f,0x3a,0x44,0xc0|($1<<3)|$2,$imm);	***REMOVED***
    else
    ***REMOVED***	&::generic("pclmulqdq",@_);		***REMOVED***
***REMOVED***

sub ::rdrand
***REMOVED*** my ($dst)=@_;
    if ($dst =~ /(e[a-dsd][ixp])/)
    ***REMOVED***	&::data_byte(0x0f,0xc7,0xf0|$regrm***REMOVED***$dst***REMOVED***);	***REMOVED***
    else
    ***REMOVED***	&::generic("rdrand",@_);	***REMOVED***
***REMOVED***

sub ::rdseed
***REMOVED*** my ($dst)=@_;
    if ($dst =~ /(e[a-dsd][ixp])/)
    ***REMOVED***	&::data_byte(0x0f,0xc7,0xf8|$regrm***REMOVED***$dst***REMOVED***);	***REMOVED***
    else
    ***REMOVED***	&::generic("rdrand",@_);	***REMOVED***
***REMOVED***

sub rxb ***REMOVED***
 local *opcode=shift;
 my ($dst,$src1,$src2,$rxb)=@_;

   $rxb|=0x7<<5;
   $rxb&=~(0x04<<5) if($dst>=8);
   $rxb&=~(0x01<<5) if($src1>=8);
   $rxb&=~(0x02<<5) if($src2>=8);
   push @opcode,$rxb;
***REMOVED***

sub ::vprotd
***REMOVED*** my $args=join(',',@_);
    if ($args =~ /xmm([0-7]),xmm([0-7]),([x0-9a-f]+)/)
    ***REMOVED*** my @opcode=(0x8f);
	rxb(\@opcode,$1,$2,-1,0x08);
	push @opcode,0x78,0xc2;
	push @opcode,0xc0|($2&7)|(($1&7)<<3);		# ModR/M
	my $c=$3;
	push @opcode,$c=~/^0/?oct($c):$c;
	&::data_byte(@opcode);
    ***REMOVED***
    else
    ***REMOVED***	&::generic("vprotd",@_);	***REMOVED***
***REMOVED***

sub ::endbranch
***REMOVED***
    &::data_byte(0xf3,0x0f,0x1e,0xfb);
***REMOVED***

# label management
$lbdecor="L";		# local label decoration, set by package
$label="000";

sub ::islabel		# see is argument is a known label
***REMOVED*** my $i;
    foreach $i (values %label) ***REMOVED*** return $i if ($i eq $_[0]); ***REMOVED***
  $label***REMOVED***$_[0]***REMOVED***;	# can be undef
***REMOVED***

sub ::label		# instantiate a function-scope label
***REMOVED***   if (!defined($label***REMOVED***$_[0]***REMOVED***))
    ***REMOVED***	$label***REMOVED***$_[0]***REMOVED***="$***REMOVED***lbdecor***REMOVED***$***REMOVED***label***REMOVED***$***REMOVED***_[0]***REMOVED***"; $label++;   ***REMOVED***
  $label***REMOVED***$_[0]***REMOVED***;
***REMOVED***

sub ::LABEL		# instantiate a file-scope label
***REMOVED***   $label***REMOVED***$_[0]***REMOVED***=$_[1] if (!defined($label***REMOVED***$_[0]***REMOVED***));
  $label***REMOVED***$_[0]***REMOVED***;
***REMOVED***

sub ::static_label	***REMOVED*** &::LABEL($_[0],$lbdecor.$_[0]); ***REMOVED***

sub ::set_label_B	***REMOVED*** push(@out,"@_:\n"); ***REMOVED***
sub ::set_label
***REMOVED*** my $label=&::label($_[0]);
    &::align($_[1]) if ($_[1]>1);
    &::set_label_B($label);
  $label;
***REMOVED***

sub ::wipe_labels	# wipes function-scope labels
***REMOVED***   foreach $i (keys %label)
    ***REMOVED***	delete $label***REMOVED***$i***REMOVED*** if ($label***REMOVED***$i***REMOVED*** =~ /^\Q$***REMOVED***lbdecor***REMOVED***\E[0-9]***REMOVED***3***REMOVED***/);	***REMOVED***
***REMOVED***

# subroutine management
sub ::function_begin
***REMOVED***   &function_begin_B(@_);
    $stack=4;
    &push("ebp");
    &push("ebx");
    &push("esi");
    &push("edi");
***REMOVED***

sub ::function_end
***REMOVED***   &pop("edi");
    &pop("esi");
    &pop("ebx");
    &pop("ebp");
    &ret();
    &function_end_B(@_);
    $stack=0;
    &wipe_labels();
***REMOVED***

sub ::function_end_A
***REMOVED***   &pop("edi");
    &pop("esi");
    &pop("ebx");
    &pop("ebp");
    &ret();
    $stack+=16;	# readjust esp as if we didn't pop anything
***REMOVED***

sub ::asciz
***REMOVED*** my @str=unpack("C*",shift);
    push @str,0;
    while ($#str>15) ***REMOVED***
	&data_byte(@str[0..15]);
	foreach (0..15) ***REMOVED*** shift @str; ***REMOVED***
    ***REMOVED***
    &data_byte(@str) if (@str);
***REMOVED***

sub ::asm_finish
***REMOVED***   &file_end();
    print "#if defined(__i386__)\n" unless $win32;
    print @out;
    print "#endif\n" unless $win32;
***REMOVED***

sub ::asm_init
***REMOVED*** my ($type,$fn,$cpu)=@_;

    $filename=$fn;
    $i386=$cpu;

    $elf=$cpp=$coff=$aout=$macosx=$win32=$netware=$mwerks=$android=0;
    if    (($type eq "elf"))
    ***REMOVED***	$elf=1;			require "x86gas.pl";	***REMOVED***
    elsif (($type eq "elf-1"))
    ***REMOVED***	$elf=-1;		require "x86gas.pl";	***REMOVED***
    elsif (($type eq "a\.out"))
    ***REMOVED***	$aout=1;		require "x86gas.pl";	***REMOVED***
    elsif (($type eq "coff" or $type eq "gaswin"))
    ***REMOVED***	$coff=1;		require "x86gas.pl";	***REMOVED***
    elsif (($type eq "win32n"))
    ***REMOVED***	$win32=1;		require "x86nasm.pl";	***REMOVED***
    elsif (($type eq "nw-nasm"))
    ***REMOVED***	$netware=1;		require "x86nasm.pl";	***REMOVED***
    #elsif (($type eq "nw-mwasm"))
    #***REMOVED***	$netware=1; $mwerks=1;	require "x86nasm.pl";	***REMOVED***
    elsif (($type eq "win32"))
    ***REMOVED***	$win32=1;		require "x86masm.pl";	***REMOVED***
    elsif (($type eq "macosx"))
    ***REMOVED***	$aout=1; $macosx=1;	require "x86gas.pl";	***REMOVED***
    elsif (($type eq "android"))
    ***REMOVED***	$elf=1; $android=1;	require "x86gas.pl";	***REMOVED***
    else
    ***REMOVED***	print STDERR <<"EOF";
Pick one target type from
	elf	- Linux, FreeBSD, Solaris x86, etc.
	a.out	- DJGPP, elder OpenBSD, etc.
	coff	- GAS/COFF such as Win32 targets
	win32n	- Windows 95/Windows NT NASM format
	nw-nasm - NetWare NASM format
	macosx	- Mac OS X
EOF
	exit(1);
    ***REMOVED***

    $pic=0;
    for (@ARGV) ***REMOVED*** $pic=1 if (/\-[fK]PIC/i); ***REMOVED***

    $filename =~ s/\.pl$//;
    &file($filename);
***REMOVED***

sub ::hidden ***REMOVED******REMOVED***

1;
