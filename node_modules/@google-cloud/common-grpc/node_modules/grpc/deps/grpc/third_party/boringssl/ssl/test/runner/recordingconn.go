// Copyright (c) 2016, Google Inc.
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
// OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
// CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

package runner

import (
	"bufio"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"net"
	"strconv"
	"strings"
	"sync"
)

type flowType int

const (
	readFlow flowType = iota
	writeFlow
	specialFlow
)

type flow struct ***REMOVED***
	flowType flowType
	message  string
	data     []byte
***REMOVED***

// recordingConn is a net.Conn that records the traffic that passes through it.
// WriteTo can be used to produce output that can be later be loaded with
// ParseTestData.
type recordingConn struct ***REMOVED***
	net.Conn
	sync.Mutex
	flows       []flow
	isDatagram  bool
	local, peer string
***REMOVED***

func (r *recordingConn) appendFlow(flowType flowType, message string, data []byte) ***REMOVED***
	r.Lock()
	defer r.Unlock()

	if l := len(r.flows); flowType == specialFlow || r.isDatagram || l == 0 || r.flows[l-1].flowType != flowType ***REMOVED***
		buf := make([]byte, len(data))
		copy(buf, data)
		r.flows = append(r.flows, flow***REMOVED***flowType, message, buf***REMOVED***)
	***REMOVED*** else ***REMOVED***
		r.flows[l-1].data = append(r.flows[l-1].data, data...)
	***REMOVED***
***REMOVED***

func (r *recordingConn) Read(b []byte) (n int, err error) ***REMOVED***
	if n, err = r.Conn.Read(b); n == 0 ***REMOVED***
		return
	***REMOVED***
	r.appendFlow(readFlow, "", b[:n])
	return
***REMOVED***

func (r *recordingConn) Write(b []byte) (n int, err error) ***REMOVED***
	if n, err = r.Conn.Write(b); n == 0 ***REMOVED***
		return
	***REMOVED***
	r.appendFlow(writeFlow, "", b[:n])
	return
***REMOVED***

// LogSpecial appends an entry to the record of type 'special'.
func (r *recordingConn) LogSpecial(message string, data []byte) ***REMOVED***
	r.appendFlow(specialFlow, message, data)
***REMOVED***

// WriteTo writes hex dumps to w that contains the recorded traffic.
func (r *recordingConn) WriteTo(w io.Writer) ***REMOVED***
	fmt.Fprintf(w, ">>> runner is %s, shim is %s\n", r.local, r.peer)
	for i, flow := range r.flows ***REMOVED***
		switch flow.flowType ***REMOVED***
		case readFlow:
			fmt.Fprintf(w, ">>> Flow %d (%s to %s)\n", i+1, r.peer, r.local)
		case writeFlow:
			fmt.Fprintf(w, ">>> Flow %d (%s to %s)\n", i+1, r.local, r.peer)
		case specialFlow:
			fmt.Fprintf(w, ">>> Flow %d %q\n", i+1, flow.message)
		***REMOVED***

		if flow.data != nil ***REMOVED***
			dumper := hex.Dumper(w)
			dumper.Write(flow.data)
			dumper.Close()
		***REMOVED***
	***REMOVED***
***REMOVED***

func (r *recordingConn) Transcript() []byte ***REMOVED***
	var ret []byte
	for _, flow := range r.flows ***REMOVED***
		if flow.flowType != writeFlow ***REMOVED***
			continue
		***REMOVED***
		ret = append(ret, flow.data...)
	***REMOVED***
	return ret
***REMOVED***

func parseTestData(r io.Reader) (flows [][]byte, err error) ***REMOVED***
	var currentFlow []byte

	scanner := bufio.NewScanner(r)
	for scanner.Scan() ***REMOVED***
		line := scanner.Text()
		// If the line starts with ">>> " then it marks the beginning
		// of a new flow.
		if strings.HasPrefix(line, ">>> ") ***REMOVED***
			if len(currentFlow) > 0 || len(flows) > 0 ***REMOVED***
				flows = append(flows, currentFlow)
				currentFlow = nil
			***REMOVED***
			continue
		***REMOVED***

		// Otherwise the line is a line of hex dump that looks like:
		// 00000170  fc f5 06 bf (...)  |.....X***REMOVED***&?......!|
		// (Some bytes have been omitted from the middle section.)

		if i := strings.IndexByte(line, ' '); i >= 0 ***REMOVED***
			line = line[i:]
		***REMOVED*** else ***REMOVED***
			return nil, errors.New("invalid test data")
		***REMOVED***

		if i := strings.IndexByte(line, '|'); i >= 0 ***REMOVED***
			line = line[:i]
		***REMOVED*** else ***REMOVED***
			return nil, errors.New("invalid test data")
		***REMOVED***

		hexBytes := strings.Fields(line)
		for _, hexByte := range hexBytes ***REMOVED***
			val, err := strconv.ParseUint(hexByte, 16, 8)
			if err != nil ***REMOVED***
				return nil, errors.New("invalid hex byte in test data: " + err.Error())
			***REMOVED***
			currentFlow = append(currentFlow, byte(val))
		***REMOVED***
	***REMOVED***

	if len(currentFlow) > 0 ***REMOVED***
		flows = append(flows, currentFlow)
	***REMOVED***

	return flows, nil
***REMOVED***
