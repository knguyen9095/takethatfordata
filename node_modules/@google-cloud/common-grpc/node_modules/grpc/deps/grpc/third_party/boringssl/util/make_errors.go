// Copyright (c) 2014, Google Inc.
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
// OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
// CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

package main

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

// ssl.h reserves values 1000 and above for error codes corresponding to
// alerts. If automatically assigned reason codes exceed this value, this script
// will error. This must be kept in sync with SSL_AD_REASON_OFFSET in ssl.h.
const reservedReasonCode = 1000

var resetFlag *bool = flag.Bool("reset", false, "If true, ignore current assignments and reassign from scratch")

func makeErrors(reset bool) error ***REMOVED***
	topLevelPath, err := findToplevel()
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	dirName, err := os.Getwd()
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	lib := filepath.Base(dirName)
	headerPath := filepath.Join(topLevelPath, "include", "openssl", lib+".h")
	errDir := filepath.Join(topLevelPath, "crypto", "err")
	dataPath := filepath.Join(errDir, lib+".errordata")

	headerFile, err := os.Open(headerPath)
	if err != nil ***REMOVED***
		if os.IsNotExist(err) ***REMOVED***
			return fmt.Errorf("No header %s. Run in the right directory or touch the file.", headerPath)
		***REMOVED***

		return err
	***REMOVED***

	prefix := strings.ToUpper(lib)
	reasons, err := parseHeader(prefix, headerFile)
	headerFile.Close()

	if reset ***REMOVED***
		err = nil
		// Retain any reason codes above reservedReasonCode.
		newReasons := make(map[string]int)
		for key, value := range reasons ***REMOVED***
			if value >= reservedReasonCode ***REMOVED***
				newReasons[key] = value
			***REMOVED***
		***REMOVED***
		reasons = newReasons
	***REMOVED***

	if err != nil ***REMOVED***
		return err
	***REMOVED***

	dir, err := os.Open(".")
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	defer dir.Close()

	filenames, err := dir.Readdirnames(-1)
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	for _, name := range filenames ***REMOVED***
		if !strings.HasSuffix(name, ".c") ***REMOVED***
			continue
		***REMOVED***

		if err := addReasons(reasons, name, prefix); err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	assignNewValues(reasons, reservedReasonCode)

	headerFile, err = os.Open(headerPath)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	defer headerFile.Close()

	newHeaderFile, err := os.OpenFile(headerPath+".tmp", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	defer newHeaderFile.Close()

	if err := writeHeaderFile(newHeaderFile, headerFile, prefix, reasons); err != nil ***REMOVED***
		return err
	***REMOVED***
	os.Rename(headerPath+".tmp", headerPath)

	dataFile, err := os.OpenFile(dataPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	outputStrings(dataFile, lib, reasons)
	dataFile.Close()

	return nil
***REMOVED***

func findToplevel() (path string, err error) ***REMOVED***
	path = ".."
	buildingPath := filepath.Join(path, "BUILDING.md")

	_, err = os.Stat(buildingPath)
	if err != nil && os.IsNotExist(err) ***REMOVED***
		path = filepath.Join("..", path)
		buildingPath = filepath.Join(path, "BUILDING.md")
		_, err = os.Stat(buildingPath)
	***REMOVED***
	if err != nil ***REMOVED***
		return "", errors.New("Cannot find BUILDING.md file at the top-level")
	***REMOVED***
	return path, nil
***REMOVED***

type assignment struct ***REMOVED***
	key   string
	value int
***REMOVED***

type assignmentsSlice []assignment

func (a assignmentsSlice) Len() int ***REMOVED***
	return len(a)
***REMOVED***

func (a assignmentsSlice) Less(i, j int) bool ***REMOVED***
	return a[i].value < a[j].value
***REMOVED***

func (a assignmentsSlice) Swap(i, j int) ***REMOVED***
	a[i], a[j] = a[j], a[i]
***REMOVED***

func outputAssignments(w io.Writer, assignments map[string]int) ***REMOVED***
	var sorted assignmentsSlice

	for key, value := range assignments ***REMOVED***
		sorted = append(sorted, assignment***REMOVED***key, value***REMOVED***)
	***REMOVED***

	sort.Sort(sorted)

	for _, assignment := range sorted ***REMOVED***
		fmt.Fprintf(w, "#define %s %d\n", assignment.key, assignment.value)
	***REMOVED***
***REMOVED***

func parseDefineLine(line, lib string) (key string, value int, ok bool) ***REMOVED***
	if !strings.HasPrefix(line, "#define ") ***REMOVED***
		return
	***REMOVED***

	fields := strings.Fields(line)
	if len(fields) != 3 ***REMOVED***
		return
	***REMOVED***

	key = fields[1]
	if !strings.HasPrefix(key, lib+"_R_") ***REMOVED***
		return
	***REMOVED***

	var err error
	if value, err = strconv.Atoi(fields[2]); err != nil ***REMOVED***
		return
	***REMOVED***

	ok = true
	return
***REMOVED***

func writeHeaderFile(w io.Writer, headerFile io.Reader, lib string, reasons map[string]int) error ***REMOVED***
	var last []byte
	var haveLast, sawDefine bool
	newLine := []byte("\n")

	scanner := bufio.NewScanner(headerFile)
	for scanner.Scan() ***REMOVED***
		line := scanner.Text()
		_, _, ok := parseDefineLine(line, lib)
		if ok ***REMOVED***
			sawDefine = true
			continue
		***REMOVED***

		if haveLast ***REMOVED***
			w.Write(last)
			w.Write(newLine)
		***REMOVED***

		if len(line) > 0 || !sawDefine ***REMOVED***
			last = []byte(line)
			haveLast = true
		***REMOVED*** else ***REMOVED***
			haveLast = false
		***REMOVED***
		sawDefine = false
	***REMOVED***

	if err := scanner.Err(); err != nil ***REMOVED***
		return err
	***REMOVED***

	outputAssignments(w, reasons)
	w.Write(newLine)

	if haveLast ***REMOVED***
		w.Write(last)
		w.Write(newLine)
	***REMOVED***

	return nil
***REMOVED***

func outputStrings(w io.Writer, lib string, assignments map[string]int) ***REMOVED***
	lib = strings.ToUpper(lib)
	prefixLen := len(lib + "_R_")

	keys := make([]string, 0, len(assignments))
	for key := range assignments ***REMOVED***
		keys = append(keys, key)
	***REMOVED***
	sort.Strings(keys)

	for _, key := range keys ***REMOVED***
		fmt.Fprintf(w, "%s,%d,%s\n", lib, assignments[key], key[prefixLen:])
	***REMOVED***
***REMOVED***

func assignNewValues(assignments map[string]int, reserved int) ***REMOVED***
	// Needs to be in sync with the reason limit in
	// |ERR_reason_error_string|.
	max := 99

	for _, value := range assignments ***REMOVED***
		if reserved >= 0 && value >= reserved ***REMOVED***
			continue
		***REMOVED***
		if value > max ***REMOVED***
			max = value
		***REMOVED***
	***REMOVED***

	max++

	// Sort the keys, so this script is reproducible.
	keys := make([]string, 0, len(assignments))
	for key, value := range assignments ***REMOVED***
		if value == -1 ***REMOVED***
			keys = append(keys, key)
		***REMOVED***
	***REMOVED***
	sort.Strings(keys)

	for _, key := range keys ***REMOVED***
		if reserved >= 0 && max >= reserved ***REMOVED***
			// If this happens, try passing -reset. Otherwise bump
			// up reservedReasonCode.
			panic("Automatically-assigned values exceeded limit!")
		***REMOVED***
		assignments[key] = max
		max++
	***REMOVED***
***REMOVED***

func handleDeclareMacro(line, join, macroName string, m map[string]int) ***REMOVED***
	if i := strings.Index(line, macroName); i >= 0 ***REMOVED***
		contents := line[i+len(macroName):]
		if i := strings.Index(contents, ")"); i >= 0 ***REMOVED***
			contents = contents[:i]
			args := strings.Split(contents, ",")
			for i := range args ***REMOVED***
				args[i] = strings.TrimSpace(args[i])
			***REMOVED***
			if len(args) != 2 ***REMOVED***
				panic("Bad macro line: " + line)
			***REMOVED***
			token := args[0] + join + args[1]
			if _, ok := m[token]; !ok ***REMOVED***
				m[token] = -1
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***

func addReasons(reasons map[string]int, filename, prefix string) error ***REMOVED***
	file, err := os.Open(filename)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	defer file.Close()

	reasonPrefix := prefix + "_R_"

	scanner := bufio.NewScanner(file)
	for scanner.Scan() ***REMOVED***
		line := scanner.Text()

		handleDeclareMacro(line, "_R_", "OPENSSL_DECLARE_ERROR_REASON(", reasons)

		for len(line) > 0 ***REMOVED***
			i := strings.Index(line, prefix+"_")
			if i == -1 ***REMOVED***
				break
			***REMOVED***

			line = line[i:]
			end := strings.IndexFunc(line, func(r rune) bool ***REMOVED***
				return !(r == '_' || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9'))
			***REMOVED***)
			if end == -1 ***REMOVED***
				end = len(line)
			***REMOVED***

			var token string
			token, line = line[:end], line[end:]

			switch ***REMOVED***
			case strings.HasPrefix(token, reasonPrefix):
				if _, ok := reasons[token]; !ok ***REMOVED***
					reasons[token] = -1
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***

	return scanner.Err()
***REMOVED***

func parseHeader(lib string, file io.Reader) (reasons map[string]int, err error) ***REMOVED***
	reasons = make(map[string]int)

	scanner := bufio.NewScanner(file)
	for scanner.Scan() ***REMOVED***
		key, value, ok := parseDefineLine(scanner.Text(), lib)
		if !ok ***REMOVED***
			continue
		***REMOVED***

		reasons[key] = value
	***REMOVED***

	err = scanner.Err()
	return
***REMOVED***

func main() ***REMOVED***
	flag.Parse()

	if err := makeErrors(*resetFlag); err != nil ***REMOVED***
		fmt.Fprintf(os.Stderr, "%s\n", err)
		os.Exit(1)
	***REMOVED***
***REMOVED***
