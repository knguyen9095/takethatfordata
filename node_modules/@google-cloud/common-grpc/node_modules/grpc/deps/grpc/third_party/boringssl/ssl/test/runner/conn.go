// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// TLS low level connection and record layer

package runner

import (
	"bytes"
	"crypto/cipher"
	"crypto/ecdsa"
	"crypto/subtle"
	"crypto/x509"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"
	"sync"
	"time"
)

var errNoCertificateAlert = errors.New("tls: no certificate alert")
var errEndOfEarlyDataAlert = errors.New("tls: end of early data alert")

// A Conn represents a secured connection.
// It implements the net.Conn interface.
type Conn struct ***REMOVED***
	// constant
	conn     net.Conn
	isDTLS   bool
	isClient bool

	// constant after handshake; protected by handshakeMutex
	handshakeMutex       sync.Mutex // handshakeMutex < in.Mutex, out.Mutex, errMutex
	handshakeErr         error      // error resulting from handshake
	vers                 uint16     // TLS version
	haveVers             bool       // version has been negotiated
	config               *Config    // configuration passed to constructor
	handshakeComplete    bool
	skipEarlyData        bool // On a server, indicates that the client is sending early data that must be skipped over.
	didResume            bool // whether this connection was a session resumption
	extendedMasterSecret bool // whether this session used an extended master secret
	cipherSuite          *cipherSuite
	ocspResponse         []byte // stapled OCSP response
	sctList              []byte // signed certificate timestamp list
	peerCertificates     []*x509.Certificate
	// verifiedChains contains the certificate chains that we built, as
	// opposed to the ones presented by the server.
	verifiedChains [][]*x509.Certificate
	// serverName contains the server name indicated by the client, if any.
	serverName string
	// firstFinished contains the first Finished hash sent during the
	// handshake. This is the "tls-unique" channel binding value.
	firstFinished [12]byte
	// peerSignatureAlgorithm contains the signature algorithm that was used
	// by the peer in the handshake, or zero if not applicable.
	peerSignatureAlgorithm signatureAlgorithm
	// curveID contains the curve that was used in the handshake, or zero if
	// not applicable.
	curveID CurveID

	clientRandom, serverRandom [32]byte
	exporterSecret             []byte
	resumptionSecret           []byte

	clientProtocol         string
	clientProtocolFallback bool
	usedALPN               bool

	// verify_data values for the renegotiation extension.
	clientVerify []byte
	serverVerify []byte

	channelID *ecdsa.PublicKey

	srtpProtectionProfile uint16

	clientVersion uint16

	// input/output
	in, out  halfConn     // in.Mutex < out.Mutex
	rawInput *block       // raw input, right off the wire
	input    *block       // application record waiting to be read
	hand     bytes.Buffer // handshake record waiting to be read

	// pendingFlight, if PackHandshakeFlight is enabled, is the buffer of
	// handshake data to be split into records at the end of the flight.
	pendingFlight bytes.Buffer

	// DTLS state
	sendHandshakeSeq uint16
	recvHandshakeSeq uint16
	handMsg          []byte   // pending assembled handshake message
	handMsgLen       int      // handshake message length, not including the header
	pendingFragments [][]byte // pending outgoing handshake fragments.

	keyUpdateRequested bool

	tmp [16]byte
***REMOVED***

func (c *Conn) init() ***REMOVED***
	c.in.isDTLS = c.isDTLS
	c.out.isDTLS = c.isDTLS
	c.in.config = c.config
	c.out.config = c.config

	c.out.updateOutSeq()
***REMOVED***

// Access to net.Conn methods.
// Cannot just embed net.Conn because that would
// export the struct field too.

// LocalAddr returns the local network address.
func (c *Conn) LocalAddr() net.Addr ***REMOVED***
	return c.conn.LocalAddr()
***REMOVED***

// RemoteAddr returns the remote network address.
func (c *Conn) RemoteAddr() net.Addr ***REMOVED***
	return c.conn.RemoteAddr()
***REMOVED***

// SetDeadline sets the read and write deadlines associated with the connection.
// A zero value for t means Read and Write will not time out.
// After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.
func (c *Conn) SetDeadline(t time.Time) error ***REMOVED***
	return c.conn.SetDeadline(t)
***REMOVED***

// SetReadDeadline sets the read deadline on the underlying connection.
// A zero value for t means Read will not time out.
func (c *Conn) SetReadDeadline(t time.Time) error ***REMOVED***
	return c.conn.SetReadDeadline(t)
***REMOVED***

// SetWriteDeadline sets the write deadline on the underlying conneciton.
// A zero value for t means Write will not time out.
// After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.
func (c *Conn) SetWriteDeadline(t time.Time) error ***REMOVED***
	return c.conn.SetWriteDeadline(t)
***REMOVED***

// A halfConn represents one direction of the record layer
// connection, either sending or receiving.
type halfConn struct ***REMOVED***
	sync.Mutex

	err     error  // first permanent error
	version uint16 // protocol version
	isDTLS  bool
	cipher  interface***REMOVED******REMOVED*** // cipher algorithm
	mac     macFunction
	seq     [8]byte // 64-bit sequence number
	outSeq  [8]byte // Mapped sequence number
	bfree   *block  // list of free blocks

	nextCipher interface***REMOVED******REMOVED*** // next encryption state
	nextMac    macFunction // next MAC algorithm
	nextSeq    [6]byte     // next epoch's starting sequence number in DTLS

	// used to save allocating a new buffer for each MAC.
	inDigestBuf, outDigestBuf []byte

	trafficSecret []byte

	shortHeader bool

	config *Config
***REMOVED***

func (hc *halfConn) setErrorLocked(err error) error ***REMOVED***
	hc.err = err
	return err
***REMOVED***

func (hc *halfConn) error() error ***REMOVED***
	// This should be locked, but I've removed it for the renegotiation
	// tests since we don't concurrently read and write the same tls.Conn
	// in any case during testing.
	err := hc.err
	return err
***REMOVED***

// prepareCipherSpec sets the encryption and MAC states
// that a subsequent changeCipherSpec will use.
func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface***REMOVED******REMOVED***, mac macFunction) ***REMOVED***
	hc.version = version
	hc.nextCipher = cipher
	hc.nextMac = mac
***REMOVED***

// changeCipherSpec changes the encryption and MAC states
// to the ones previously passed to prepareCipherSpec.
func (hc *halfConn) changeCipherSpec(config *Config) error ***REMOVED***
	if hc.nextCipher == nil ***REMOVED***
		return alertInternalError
	***REMOVED***
	hc.cipher = hc.nextCipher
	hc.mac = hc.nextMac
	hc.nextCipher = nil
	hc.nextMac = nil
	hc.config = config
	hc.incEpoch()

	if config.Bugs.NullAllCiphers ***REMOVED***
		hc.cipher = nullCipher***REMOVED******REMOVED***
		hc.mac = nil
	***REMOVED***
	return nil
***REMOVED***

// useTrafficSecret sets the current cipher state for TLS 1.3.
func (hc *halfConn) useTrafficSecret(version uint16, suite *cipherSuite, secret []byte, side trafficDirection) ***REMOVED***
	hc.version = version
	hc.cipher = deriveTrafficAEAD(version, suite, secret, side)
	if hc.config.Bugs.NullAllCiphers ***REMOVED***
		hc.cipher = nullCipher***REMOVED******REMOVED***
	***REMOVED***
	hc.trafficSecret = secret
	hc.incEpoch()
***REMOVED***

// resetCipher changes the cipher state back to no encryption to be able
// to send an unencrypted ClientHello in response to HelloRetryRequest
// after 0-RTT data was rejected.
func (hc *halfConn) resetCipher() ***REMOVED***
	hc.cipher = nil
	hc.incEpoch()
***REMOVED***

func (hc *halfConn) doKeyUpdate(c *Conn, isOutgoing bool) ***REMOVED***
	side := serverWrite
	if c.isClient == isOutgoing ***REMOVED***
		side = clientWrite
	***REMOVED***
	hc.useTrafficSecret(hc.version, c.cipherSuite, updateTrafficSecret(c.cipherSuite.hash(), hc.trafficSecret), side)
***REMOVED***

// incSeq increments the sequence number.
func (hc *halfConn) incSeq(isOutgoing bool) ***REMOVED***
	limit := 0
	increment := uint64(1)
	if hc.isDTLS ***REMOVED***
		// Increment up to the epoch in DTLS.
		limit = 2
	***REMOVED***
	for i := 7; i >= limit; i-- ***REMOVED***
		increment += uint64(hc.seq[i])
		hc.seq[i] = byte(increment)
		increment >>= 8
	***REMOVED***

	// Not allowed to let sequence number wrap.
	// Instead, must renegotiate before it does.
	// Not likely enough to bother.
	if increment != 0 ***REMOVED***
		panic("TLS: sequence number wraparound")
	***REMOVED***

	hc.updateOutSeq()
***REMOVED***

// incNextSeq increments the starting sequence number for the next epoch.
func (hc *halfConn) incNextSeq() ***REMOVED***
	for i := len(hc.nextSeq) - 1; i >= 0; i-- ***REMOVED***
		hc.nextSeq[i]++
		if hc.nextSeq[i] != 0 ***REMOVED***
			return
		***REMOVED***
	***REMOVED***
	panic("TLS: sequence number wraparound")
***REMOVED***

// incEpoch resets the sequence number. In DTLS, it also increments the epoch
// half of the sequence number.
func (hc *halfConn) incEpoch() ***REMOVED***
	if hc.isDTLS ***REMOVED***
		for i := 1; i >= 0; i-- ***REMOVED***
			hc.seq[i]++
			if hc.seq[i] != 0 ***REMOVED***
				break
			***REMOVED***
			if i == 0 ***REMOVED***
				panic("TLS: epoch number wraparound")
			***REMOVED***
		***REMOVED***
		copy(hc.seq[2:], hc.nextSeq[:])
		for i := range hc.nextSeq ***REMOVED***
			hc.nextSeq[i] = 0
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		for i := range hc.seq ***REMOVED***
			hc.seq[i] = 0
		***REMOVED***
	***REMOVED***

	hc.updateOutSeq()
***REMOVED***

func (hc *halfConn) updateOutSeq() ***REMOVED***
	if hc.config.Bugs.SequenceNumberMapping != nil ***REMOVED***
		seqU64 := binary.BigEndian.Uint64(hc.seq[:])
		seqU64 = hc.config.Bugs.SequenceNumberMapping(seqU64)
		binary.BigEndian.PutUint64(hc.outSeq[:], seqU64)

		// The DTLS epoch cannot be changed.
		copy(hc.outSeq[:2], hc.seq[:2])
		return
	***REMOVED***

	copy(hc.outSeq[:], hc.seq[:])
***REMOVED***

func (hc *halfConn) isShortHeader() bool ***REMOVED***
	return hc.shortHeader && hc.cipher != nil
***REMOVED***

func (hc *halfConn) recordHeaderLen() int ***REMOVED***
	if hc.isDTLS ***REMOVED***
		return dtlsRecordHeaderLen
	***REMOVED***
	if hc.isShortHeader() ***REMOVED***
		return 2
	***REMOVED***
	return tlsRecordHeaderLen
***REMOVED***

// removePadding returns an unpadded slice, in constant time, which is a prefix
// of the input. It also returns a byte which is equal to 255 if the padding
// was valid and 0 otherwise. See RFC 2246, section 6.2.3.2
func removePadding(payload []byte) ([]byte, byte) ***REMOVED***
	if len(payload) < 1 ***REMOVED***
		return payload, 0
	***REMOVED***

	paddingLen := payload[len(payload)-1]
	t := uint(len(payload)-1) - uint(paddingLen)
	// if len(payload) >= (paddingLen - 1) then the MSB of t is zero
	good := byte(int32(^t) >> 31)

	toCheck := 255 // the maximum possible padding length
	// The length of the padded data is public, so we can use an if here
	if toCheck+1 > len(payload) ***REMOVED***
		toCheck = len(payload) - 1
	***REMOVED***

	for i := 0; i < toCheck; i++ ***REMOVED***
		t := uint(paddingLen) - uint(i)
		// if i <= paddingLen then the MSB of t is zero
		mask := byte(int32(^t) >> 31)
		b := payload[len(payload)-1-i]
		good &^= mask&paddingLen ^ mask&b
	***REMOVED***

	// We AND together the bits of good and replicate the result across
	// all the bits.
	good &= good << 4
	good &= good << 2
	good &= good << 1
	good = uint8(int8(good) >> 7)

	toRemove := good&paddingLen + 1
	return payload[:len(payload)-int(toRemove)], good
***REMOVED***

// removePaddingSSL30 is a replacement for removePadding in the case that the
// protocol version is SSLv3. In this version, the contents of the padding
// are random and cannot be checked.
func removePaddingSSL30(payload []byte) ([]byte, byte) ***REMOVED***
	if len(payload) < 1 ***REMOVED***
		return payload, 0
	***REMOVED***

	paddingLen := int(payload[len(payload)-1]) + 1
	if paddingLen > len(payload) ***REMOVED***
		return payload, 0
	***REMOVED***

	return payload[:len(payload)-paddingLen], 255
***REMOVED***

func roundUp(a, b int) int ***REMOVED***
	return a + (b-a%b)%b
***REMOVED***

// cbcMode is an interface for block ciphers using cipher block chaining.
type cbcMode interface ***REMOVED***
	cipher.BlockMode
	SetIV([]byte)
***REMOVED***

// decrypt checks and strips the mac and decrypts the data in b. Returns a
// success boolean, the number of bytes to skip from the start of the record in
// order to get the application payload, the encrypted record type (or 0
// if there is none), and an optional alert value.
func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, contentType recordType, alertValue alert) ***REMOVED***
	recordHeaderLen := hc.recordHeaderLen()

	// pull out payload
	payload := b.data[recordHeaderLen:]

	macSize := 0
	if hc.mac != nil ***REMOVED***
		macSize = hc.mac.Size()
	***REMOVED***

	paddingGood := byte(255)
	explicitIVLen := 0

	seq := hc.seq[:]
	if hc.isDTLS ***REMOVED***
		// DTLS sequence numbers are explicit.
		seq = b.data[3:11]
	***REMOVED***

	// decrypt
	if hc.cipher != nil ***REMOVED***
		switch c := hc.cipher.(type) ***REMOVED***
		case cipher.Stream:
			c.XORKeyStream(payload, payload)
		case *tlsAead:
			nonce := seq
			if c.explicitNonce ***REMOVED***
				explicitIVLen = 8
				if len(payload) < explicitIVLen ***REMOVED***
					return false, 0, 0, alertBadRecordMAC
				***REMOVED***
				nonce = payload[:8]
				payload = payload[8:]
			***REMOVED***

			var additionalData []byte
			if hc.version < VersionTLS13 ***REMOVED***
				additionalData = make([]byte, 13)
				copy(additionalData, seq)
				copy(additionalData[8:], b.data[:3])
				n := len(payload) - c.Overhead()
				additionalData[11] = byte(n >> 8)
				additionalData[12] = byte(n)
			***REMOVED***
			var err error
			payload, err = c.Open(payload[:0], nonce, payload, additionalData)
			if err != nil ***REMOVED***
				return false, 0, 0, alertBadRecordMAC
			***REMOVED***
			b.resize(recordHeaderLen + explicitIVLen + len(payload))
		case cbcMode:
			blockSize := c.BlockSize()
			if hc.version >= VersionTLS11 || hc.isDTLS ***REMOVED***
				explicitIVLen = blockSize
			***REMOVED***

			if len(payload)%blockSize != 0 || len(payload) < roundUp(explicitIVLen+macSize+1, blockSize) ***REMOVED***
				return false, 0, 0, alertBadRecordMAC
			***REMOVED***

			if explicitIVLen > 0 ***REMOVED***
				c.SetIV(payload[:explicitIVLen])
				payload = payload[explicitIVLen:]
			***REMOVED***
			c.CryptBlocks(payload, payload)
			if hc.version == VersionSSL30 ***REMOVED***
				payload, paddingGood = removePaddingSSL30(payload)
			***REMOVED*** else ***REMOVED***
				payload, paddingGood = removePadding(payload)
			***REMOVED***
			b.resize(recordHeaderLen + explicitIVLen + len(payload))

			// note that we still have a timing side-channel in the
			// MAC check, below. An attacker can align the record
			// so that a correct padding will cause one less hash
			// block to be calculated. Then they can iteratively
			// decrypt a record by breaking each byte. See
			// "Password Interception in a SSL/TLS Channel", Brice
			// Canvel et al.
			//
			// However, our behavior matches OpenSSL, so we leak
			// only as much as they do.
		case nullCipher:
			break
		default:
			panic("unknown cipher type")
		***REMOVED***

		if hc.version >= VersionTLS13 ***REMOVED***
			i := len(payload)
			for i > 0 && payload[i-1] == 0 ***REMOVED***
				i--
			***REMOVED***
			payload = payload[:i]
			if len(payload) == 0 ***REMOVED***
				return false, 0, 0, alertUnexpectedMessage
			***REMOVED***
			contentType = recordType(payload[len(payload)-1])
			payload = payload[:len(payload)-1]
			b.resize(recordHeaderLen + len(payload))
		***REMOVED***
	***REMOVED***

	// check, strip mac
	if hc.mac != nil ***REMOVED***
		if len(payload) < macSize ***REMOVED***
			return false, 0, 0, alertBadRecordMAC
		***REMOVED***

		// strip mac off payload, b.data
		n := len(payload) - macSize
		b.data[recordHeaderLen-2] = byte(n >> 8)
		b.data[recordHeaderLen-1] = byte(n)
		b.resize(recordHeaderLen + explicitIVLen + n)
		remoteMAC := payload[n:]
		localMAC := hc.mac.MAC(hc.inDigestBuf, seq, b.data[:3], b.data[recordHeaderLen-2:recordHeaderLen], payload[:n])

		if subtle.ConstantTimeCompare(localMAC, remoteMAC) != 1 || paddingGood != 255 ***REMOVED***
			return false, 0, 0, alertBadRecordMAC
		***REMOVED***
		hc.inDigestBuf = localMAC
	***REMOVED***
	hc.incSeq(false)

	return true, recordHeaderLen + explicitIVLen, contentType, 0
***REMOVED***

// padToBlockSize calculates the needed padding block, if any, for a payload.
// On exit, prefix aliases payload and extends to the end of the last full
// block of payload. finalBlock is a fresh slice which contains the contents of
// any suffix of payload as well as the needed padding to make finalBlock a
// full block.
func padToBlockSize(payload []byte, blockSize int, config *Config) (prefix, finalBlock []byte) ***REMOVED***
	overrun := len(payload) % blockSize
	prefix = payload[:len(payload)-overrun]

	paddingLen := blockSize - overrun
	finalSize := blockSize
	if config.Bugs.MaxPadding ***REMOVED***
		for paddingLen+blockSize <= 256 ***REMOVED***
			paddingLen += blockSize
		***REMOVED***
		finalSize = 256
	***REMOVED***
	finalBlock = make([]byte, finalSize)
	for i := range finalBlock ***REMOVED***
		finalBlock[i] = byte(paddingLen - 1)
	***REMOVED***
	if config.Bugs.PaddingFirstByteBad || config.Bugs.PaddingFirstByteBadIf255 && paddingLen == 256 ***REMOVED***
		finalBlock[overrun] ^= 0xff
	***REMOVED***
	copy(finalBlock, payload[len(payload)-overrun:])
	return
***REMOVED***

// encrypt encrypts and macs the data in b.
func (hc *halfConn) encrypt(b *block, explicitIVLen int, typ recordType) (bool, alert) ***REMOVED***
	recordHeaderLen := hc.recordHeaderLen()

	// mac
	if hc.mac != nil ***REMOVED***
		mac := hc.mac.MAC(hc.outDigestBuf, hc.outSeq[0:], b.data[:3], b.data[recordHeaderLen-2:recordHeaderLen], b.data[recordHeaderLen+explicitIVLen:])

		n := len(b.data)
		b.resize(n + len(mac))
		copy(b.data[n:], mac)
		hc.outDigestBuf = mac
	***REMOVED***

	payload := b.data[recordHeaderLen:]

	// encrypt
	if hc.cipher != nil ***REMOVED***
		// Add TLS 1.3 padding.
		if hc.version >= VersionTLS13 ***REMOVED***
			paddingLen := hc.config.Bugs.RecordPadding
			if hc.config.Bugs.OmitRecordContents ***REMOVED***
				b.resize(recordHeaderLen + paddingLen)
			***REMOVED*** else ***REMOVED***
				b.resize(len(b.data) + 1 + paddingLen)
				b.data[len(b.data)-paddingLen-1] = byte(typ)
			***REMOVED***
			for i := 0; i < paddingLen; i++ ***REMOVED***
				b.data[len(b.data)-paddingLen+i] = 0
			***REMOVED***
		***REMOVED***

		switch c := hc.cipher.(type) ***REMOVED***
		case cipher.Stream:
			c.XORKeyStream(payload, payload)
		case *tlsAead:
			payloadLen := len(b.data) - recordHeaderLen - explicitIVLen
			b.resize(len(b.data) + c.Overhead())
			nonce := hc.outSeq[:]
			if c.explicitNonce ***REMOVED***
				nonce = b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]
			***REMOVED***
			payload := b.data[recordHeaderLen+explicitIVLen:]
			payload = payload[:payloadLen]

			var additionalData []byte
			if hc.version < VersionTLS13 ***REMOVED***
				additionalData = make([]byte, 13)
				copy(additionalData, hc.outSeq[:])
				copy(additionalData[8:], b.data[:3])
				additionalData[11] = byte(payloadLen >> 8)
				additionalData[12] = byte(payloadLen)
			***REMOVED***

			c.Seal(payload[:0], nonce, payload, additionalData)
		case cbcMode:
			blockSize := c.BlockSize()
			if explicitIVLen > 0 ***REMOVED***
				c.SetIV(payload[:explicitIVLen])
				payload = payload[explicitIVLen:]
			***REMOVED***
			prefix, finalBlock := padToBlockSize(payload, blockSize, hc.config)
			b.resize(recordHeaderLen + explicitIVLen + len(prefix) + len(finalBlock))
			c.CryptBlocks(b.data[recordHeaderLen+explicitIVLen:], prefix)
			c.CryptBlocks(b.data[recordHeaderLen+explicitIVLen+len(prefix):], finalBlock)
		case nullCipher:
			break
		default:
			panic("unknown cipher type")
		***REMOVED***
	***REMOVED***

	// update length to include MAC and any block padding needed.
	n := len(b.data) - recordHeaderLen
	b.data[recordHeaderLen-2] = byte(n >> 8)
	b.data[recordHeaderLen-1] = byte(n)
	if hc.isShortHeader() && !hc.config.Bugs.ClearShortHeaderBit ***REMOVED***
		b.data[0] |= 0x80
	***REMOVED***
	hc.incSeq(true)

	return true, 0
***REMOVED***

// A block is a simple data buffer.
type block struct ***REMOVED***
	data []byte
	off  int // index for Read
	link *block
***REMOVED***

// resize resizes block to be n bytes, growing if necessary.
func (b *block) resize(n int) ***REMOVED***
	if n > cap(b.data) ***REMOVED***
		b.reserve(n)
	***REMOVED***
	b.data = b.data[0:n]
***REMOVED***

// reserve makes sure that block contains a capacity of at least n bytes.
func (b *block) reserve(n int) ***REMOVED***
	if cap(b.data) >= n ***REMOVED***
		return
	***REMOVED***
	m := cap(b.data)
	if m == 0 ***REMOVED***
		m = 1024
	***REMOVED***
	for m < n ***REMOVED***
		m *= 2
	***REMOVED***
	data := make([]byte, len(b.data), m)
	copy(data, b.data)
	b.data = data
***REMOVED***

// readFromUntil reads from r into b until b contains at least n bytes
// or else returns an error.
func (b *block) readFromUntil(r io.Reader, n int) error ***REMOVED***
	// quick case
	if len(b.data) >= n ***REMOVED***
		return nil
	***REMOVED***

	// read until have enough.
	b.reserve(n)
	for ***REMOVED***
		m, err := r.Read(b.data[len(b.data):cap(b.data)])
		b.data = b.data[0 : len(b.data)+m]
		if len(b.data) >= n ***REMOVED***
			// TODO(bradfitz,agl): slightly suspicious
			// that we're throwing away r.Read's err here.
			break
		***REMOVED***
		if err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***
	return nil
***REMOVED***

func (b *block) Read(p []byte) (n int, err error) ***REMOVED***
	n = copy(p, b.data[b.off:])
	b.off += n
	return
***REMOVED***

// newBlock allocates a new block, from hc's free list if possible.
func (hc *halfConn) newBlock() *block ***REMOVED***
	b := hc.bfree
	if b == nil ***REMOVED***
		return new(block)
	***REMOVED***
	hc.bfree = b.link
	b.link = nil
	b.resize(0)
	return b
***REMOVED***

// freeBlock returns a block to hc's free list.
// The protocol is such that each side only has a block or two on
// its free list at a time, so there's no need to worry about
// trimming the list, etc.
func (hc *halfConn) freeBlock(b *block) ***REMOVED***
	b.link = hc.bfree
	hc.bfree = b
***REMOVED***

// splitBlock splits a block after the first n bytes,
// returning a block with those n bytes and a
// block with the remainder.  the latter may be nil.
func (hc *halfConn) splitBlock(b *block, n int) (*block, *block) ***REMOVED***
	if len(b.data) <= n ***REMOVED***
		return b, nil
	***REMOVED***
	bb := hc.newBlock()
	bb.resize(len(b.data) - n)
	copy(bb.data, b.data[n:])
	b.data = b.data[0:n]
	return b, bb
***REMOVED***

func (c *Conn) doReadRecord(want recordType) (recordType, *block, error) ***REMOVED***
RestartReadRecord:
	if c.isDTLS ***REMOVED***
		return c.dtlsDoReadRecord(want)
	***REMOVED***

	recordHeaderLen := c.in.recordHeaderLen()

	if c.rawInput == nil ***REMOVED***
		c.rawInput = c.in.newBlock()
	***REMOVED***
	b := c.rawInput

	// Read header, payload.
	if err := b.readFromUntil(c.conn, recordHeaderLen); err != nil ***REMOVED***
		// RFC suggests that EOF without an alertCloseNotify is
		// an error, but popular web sites seem to do this,
		// so we can't make it an error, outside of tests.
		if err == io.EOF && c.config.Bugs.ExpectCloseNotify ***REMOVED***
			err = io.ErrUnexpectedEOF
		***REMOVED***
		if e, ok := err.(net.Error); !ok || !e.Temporary() ***REMOVED***
			c.in.setErrorLocked(err)
		***REMOVED***
		return 0, nil, err
	***REMOVED***

	var typ recordType
	var vers uint16
	var n int
	if c.in.isShortHeader() ***REMOVED***
		typ = recordTypeApplicationData
		vers = VersionTLS10
		n = int(b.data[0])<<8 | int(b.data[1])
		if n&0x8000 == 0 ***REMOVED***
			c.sendAlert(alertDecodeError)
			return 0, nil, c.in.setErrorLocked(errors.New("tls: length did not have high bit set"))
		***REMOVED***

		n = n & 0x7fff
	***REMOVED*** else ***REMOVED***
		typ = recordType(b.data[0])

		// No valid TLS record has a type of 0x80, however SSLv2 handshakes
		// start with a uint16 length where the MSB is set and the first record
		// is always < 256 bytes long. Therefore typ == 0x80 strongly suggests
		// an SSLv2 client.
		if want == recordTypeHandshake && typ == 0x80 ***REMOVED***
			c.sendAlert(alertProtocolVersion)
			return 0, nil, c.in.setErrorLocked(errors.New("tls: unsupported SSLv2 handshake received"))
		***REMOVED***

		vers = uint16(b.data[1])<<8 | uint16(b.data[2])
		n = int(b.data[3])<<8 | int(b.data[4])
	***REMOVED***

	// Alerts sent near version negotiation do not have a well-defined
	// record-layer version prior to TLS 1.3. (In TLS 1.3, the record-layer
	// version is irrelevant.)
	if typ != recordTypeAlert ***REMOVED***
		var expect uint16
		if c.haveVers ***REMOVED***
			expect = c.vers
			if c.vers >= VersionTLS13 ***REMOVED***
				expect = VersionTLS10
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			expect = c.config.Bugs.ExpectInitialRecordVersion
		***REMOVED***
		if expect != 0 && vers != expect ***REMOVED***
			c.sendAlert(alertProtocolVersion)
			return 0, nil, c.in.setErrorLocked(fmt.Errorf("tls: received record with version %x when expecting version %x", vers, expect))
		***REMOVED***
	***REMOVED***
	if n > maxCiphertext ***REMOVED***
		c.sendAlert(alertRecordOverflow)
		return 0, nil, c.in.setErrorLocked(fmt.Errorf("tls: oversized record received with length %d", n))
	***REMOVED***
	if !c.haveVers ***REMOVED***
		// First message, be extra suspicious:
		// this might not be a TLS client.
		// Bail out before reading a full 'body', if possible.
		// The current max version is 3.1.
		// If the version is >= 16.0, it's probably not real.
		// Similarly, a clientHello message encodes in
		// well under a kilobyte.  If the length is >= 12 kB,
		// it's probably not real.
		if (typ != recordTypeAlert && typ != want) || vers >= 0x1000 || n >= 0x3000 ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return 0, nil, c.in.setErrorLocked(fmt.Errorf("tls: first record does not look like a TLS handshake"))
		***REMOVED***
	***REMOVED***
	if err := b.readFromUntil(c.conn, recordHeaderLen+n); err != nil ***REMOVED***
		if err == io.EOF ***REMOVED***
			err = io.ErrUnexpectedEOF
		***REMOVED***
		if e, ok := err.(net.Error); !ok || !e.Temporary() ***REMOVED***
			c.in.setErrorLocked(err)
		***REMOVED***
		return 0, nil, err
	***REMOVED***

	// Process message.
	b, c.rawInput = c.in.splitBlock(b, recordHeaderLen+n)
	ok, off, encTyp, alertValue := c.in.decrypt(b)

	// Handle skipping over early data.
	if !ok && c.skipEarlyData ***REMOVED***
		goto RestartReadRecord
	***REMOVED***

	// If the server is expecting a second ClientHello (in response to
	// a HelloRetryRequest) and the client sends early data, there
	// won't be a decryption failure but it still needs to be skipped.
	if c.in.cipher == nil && typ == recordTypeApplicationData && c.skipEarlyData ***REMOVED***
		goto RestartReadRecord
	***REMOVED***

	if !ok ***REMOVED***
		return 0, nil, c.in.setErrorLocked(c.sendAlert(alertValue))
	***REMOVED***
	b.off = off
	c.skipEarlyData = false

	if c.vers >= VersionTLS13 && c.in.cipher != nil ***REMOVED***
		if typ != recordTypeApplicationData ***REMOVED***
			return 0, nil, c.in.setErrorLocked(fmt.Errorf("tls: outer record type is not application data"))
		***REMOVED***
		typ = encTyp
	***REMOVED***
	return typ, b, nil
***REMOVED***

// readRecord reads the next TLS record from the connection
// and updates the record layer state.
// c.in.Mutex <= L; c.input == nil.
func (c *Conn) readRecord(want recordType) error ***REMOVED***
	// Caller must be in sync with connection:
	// handshake data if handshake not yet completed,
	// else application data.
	switch want ***REMOVED***
	default:
		c.sendAlert(alertInternalError)
		return c.in.setErrorLocked(errors.New("tls: unknown record type requested"))
	case recordTypeHandshake, recordTypeChangeCipherSpec:
		if c.handshakeComplete ***REMOVED***
			c.sendAlert(alertInternalError)
			return c.in.setErrorLocked(errors.New("tls: handshake or ChangeCipherSpec requested after handshake complete"))
		***REMOVED***
	case recordTypeApplicationData:
		if !c.handshakeComplete && !c.config.Bugs.ExpectFalseStart && len(c.config.Bugs.ExpectHalfRTTData) == 0 && len(c.config.Bugs.ExpectEarlyData) == 0 ***REMOVED***
			c.sendAlert(alertInternalError)
			return c.in.setErrorLocked(errors.New("tls: application data record requested before handshake complete"))
		***REMOVED***
	case recordTypeAlert:
		// Looking for a close_notify. Note: unlike a real
		// implementation, this is not tolerant of additional records.
		// See the documentation for ExpectCloseNotify.
	***REMOVED***

Again:
	typ, b, err := c.doReadRecord(want)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	data := b.data[b.off:]
	max := maxPlaintext
	if c.config.Bugs.MaxReceivePlaintext != 0 ***REMOVED***
		max = c.config.Bugs.MaxReceivePlaintext
	***REMOVED***
	if len(data) > max ***REMOVED***
		err := c.sendAlert(alertRecordOverflow)
		c.in.freeBlock(b)
		return c.in.setErrorLocked(err)
	***REMOVED***

	switch typ ***REMOVED***
	default:
		c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))

	case recordTypeAlert:
		if len(data) != 2 ***REMOVED***
			c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
			break
		***REMOVED***
		if alert(data[1]) == alertCloseNotify ***REMOVED***
			c.in.setErrorLocked(io.EOF)
			break
		***REMOVED***
		switch data[0] ***REMOVED***
		case alertLevelWarning:
			if alert(data[1]) == alertNoCertificate ***REMOVED***
				c.in.freeBlock(b)
				return errNoCertificateAlert
			***REMOVED***
			if alert(data[1]) == alertEndOfEarlyData ***REMOVED***
				c.in.freeBlock(b)
				return errEndOfEarlyDataAlert
			***REMOVED***

			// drop on the floor
			c.in.freeBlock(b)
			goto Again
		case alertLevelError:
			c.in.setErrorLocked(&net.OpError***REMOVED***Op: "remote error", Err: alert(data[1])***REMOVED***)
		default:
			c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
		***REMOVED***

	case recordTypeChangeCipherSpec:
		if typ != want || len(data) != 1 || data[0] != 1 ***REMOVED***
			c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
			break
		***REMOVED***
		err := c.in.changeCipherSpec(c.config)
		if err != nil ***REMOVED***
			c.in.setErrorLocked(c.sendAlert(err.(alert)))
		***REMOVED***

	case recordTypeApplicationData:
		if typ != want ***REMOVED***
			c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
			break
		***REMOVED***
		c.input = b
		b = nil

	case recordTypeHandshake:
		// Allow handshake data while reading application data to
		// trigger post-handshake messages.
		// TODO(rsc): Should at least pick off connection close.
		if typ != want && want != recordTypeApplicationData ***REMOVED***
			return c.in.setErrorLocked(c.sendAlert(alertNoRenegotiation))
		***REMOVED***
		c.hand.Write(data)
	***REMOVED***

	if b != nil ***REMOVED***
		c.in.freeBlock(b)
	***REMOVED***
	return c.in.err
***REMOVED***

// sendAlert sends a TLS alert message.
// c.out.Mutex <= L.
func (c *Conn) sendAlertLocked(level byte, err alert) error ***REMOVED***
	c.tmp[0] = level
	c.tmp[1] = byte(err)
	if c.config.Bugs.FragmentAlert ***REMOVED***
		c.writeRecord(recordTypeAlert, c.tmp[0:1])
		c.writeRecord(recordTypeAlert, c.tmp[1:2])
	***REMOVED*** else if c.config.Bugs.DoubleAlert ***REMOVED***
		copy(c.tmp[2:4], c.tmp[0:2])
		c.writeRecord(recordTypeAlert, c.tmp[0:4])
	***REMOVED*** else ***REMOVED***
		c.writeRecord(recordTypeAlert, c.tmp[0:2])
	***REMOVED***
	// Error alerts are fatal to the connection.
	if level == alertLevelError ***REMOVED***
		return c.out.setErrorLocked(&net.OpError***REMOVED***Op: "local error", Err: err***REMOVED***)
	***REMOVED***
	return nil
***REMOVED***

// sendAlert sends a TLS alert message.
// L < c.out.Mutex.
func (c *Conn) sendAlert(err alert) error ***REMOVED***
	level := byte(alertLevelError)
	if err == alertNoRenegotiation || err == alertCloseNotify || err == alertNoCertificate || err == alertEndOfEarlyData ***REMOVED***
		level = alertLevelWarning
	***REMOVED***
	return c.SendAlert(level, err)
***REMOVED***

func (c *Conn) SendAlert(level byte, err alert) error ***REMOVED***
	c.out.Lock()
	defer c.out.Unlock()
	return c.sendAlertLocked(level, err)
***REMOVED***

// writeV2Record writes a record for a V2ClientHello.
func (c *Conn) writeV2Record(data []byte) (n int, err error) ***REMOVED***
	record := make([]byte, 2+len(data))
	record[0] = uint8(len(data)>>8) | 0x80
	record[1] = uint8(len(data))
	copy(record[2:], data)
	return c.conn.Write(record)
***REMOVED***

// writeRecord writes a TLS record with the given type and payload
// to the connection and updates the record layer state.
// c.out.Mutex <= L.
func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) ***REMOVED***
	if msgType := c.config.Bugs.SendWrongMessageType; msgType != 0 ***REMOVED***
		if typ == recordTypeHandshake && data[0] == msgType ***REMOVED***
			newData := make([]byte, len(data))
			copy(newData, data)
			newData[0] += 42
			data = newData
		***REMOVED***
	***REMOVED***

	if msgType := c.config.Bugs.SendTrailingMessageData; msgType != 0 ***REMOVED***
		if typ == recordTypeHandshake && data[0] == msgType ***REMOVED***
			newData := make([]byte, len(data))
			copy(newData, data)

			// Add a 0 to the body.
			newData = append(newData, 0)
			// Fix the header.
			newLen := len(newData) - 4
			newData[1] = byte(newLen >> 16)
			newData[2] = byte(newLen >> 8)
			newData[3] = byte(newLen)

			data = newData
		***REMOVED***
	***REMOVED***

	if c.isDTLS ***REMOVED***
		return c.dtlsWriteRecord(typ, data)
	***REMOVED***

	if typ == recordTypeHandshake ***REMOVED***
		if c.config.Bugs.SendHelloRequestBeforeEveryHandshakeMessage ***REMOVED***
			newData := make([]byte, 0, 4+len(data))
			newData = append(newData, typeHelloRequest, 0, 0, 0)
			newData = append(newData, data...)
			data = newData
		***REMOVED***

		if c.config.Bugs.PackHandshakeFlight ***REMOVED***
			c.pendingFlight.Write(data)
			return len(data), nil
		***REMOVED***
	***REMOVED***

	return c.doWriteRecord(typ, data)
***REMOVED***

func (c *Conn) doWriteRecord(typ recordType, data []byte) (n int, err error) ***REMOVED***
	recordHeaderLen := c.out.recordHeaderLen()
	b := c.out.newBlock()
	first := true
	isClientHello := typ == recordTypeHandshake && len(data) > 0 && data[0] == typeClientHello
	for len(data) > 0 || first ***REMOVED***
		m := len(data)
		if m > maxPlaintext && !c.config.Bugs.SendLargeRecords ***REMOVED***
			m = maxPlaintext
		***REMOVED***
		if typ == recordTypeHandshake && c.config.Bugs.MaxHandshakeRecordLength > 0 && m > c.config.Bugs.MaxHandshakeRecordLength ***REMOVED***
			m = c.config.Bugs.MaxHandshakeRecordLength
			// By default, do not fragment the client_version or
			// server_version, which are located in the first 6
			// bytes.
			if first && isClientHello && !c.config.Bugs.FragmentClientVersion && m < 6 ***REMOVED***
				m = 6
			***REMOVED***
		***REMOVED***
		explicitIVLen := 0
		explicitIVIsSeq := false
		first = false

		var cbc cbcMode
		if c.out.version >= VersionTLS11 ***REMOVED***
			var ok bool
			if cbc, ok = c.out.cipher.(cbcMode); ok ***REMOVED***
				explicitIVLen = cbc.BlockSize()
			***REMOVED***
		***REMOVED***
		if explicitIVLen == 0 ***REMOVED***
			if aead, ok := c.out.cipher.(*tlsAead); ok && aead.explicitNonce ***REMOVED***
				explicitIVLen = 8
				// The AES-GCM construction in TLS has an
				// explicit nonce so that the nonce can be
				// random. However, the nonce is only 8 bytes
				// which is too small for a secure, random
				// nonce. Therefore we use the sequence number
				// as the nonce.
				explicitIVIsSeq = true
			***REMOVED***
		***REMOVED***
		b.resize(recordHeaderLen + explicitIVLen + m)
		// If using a short record header, the length will be filled in
		// by encrypt.
		if !c.out.isShortHeader() ***REMOVED***
			b.data[0] = byte(typ)
			if c.vers >= VersionTLS13 && c.out.cipher != nil ***REMOVED***
				b.data[0] = byte(recordTypeApplicationData)
				if outerType := c.config.Bugs.OuterRecordType; outerType != 0 ***REMOVED***
					b.data[0] = byte(outerType)
				***REMOVED***
			***REMOVED***
			vers := c.vers
			if vers == 0 || vers >= VersionTLS13 ***REMOVED***
				// Some TLS servers fail if the record version is
				// greater than TLS 1.0 for the initial ClientHello.
				//
				// TLS 1.3 fixes the version number in the record
				// layer to ***REMOVED***3, 1***REMOVED***.
				vers = VersionTLS10
			***REMOVED***
			if c.config.Bugs.SendRecordVersion != 0 ***REMOVED***
				vers = c.config.Bugs.SendRecordVersion
			***REMOVED***
			if c.vers == 0 && c.config.Bugs.SendInitialRecordVersion != 0 ***REMOVED***
				vers = c.config.Bugs.SendInitialRecordVersion
			***REMOVED***
			b.data[1] = byte(vers >> 8)
			b.data[2] = byte(vers)
			b.data[3] = byte(m >> 8)
			b.data[4] = byte(m)
		***REMOVED***
		if explicitIVLen > 0 ***REMOVED***
			explicitIV := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]
			if explicitIVIsSeq ***REMOVED***
				copy(explicitIV, c.out.seq[:])
			***REMOVED*** else ***REMOVED***
				if _, err = io.ReadFull(c.config.rand(), explicitIV); err != nil ***REMOVED***
					break
				***REMOVED***
			***REMOVED***
		***REMOVED***
		copy(b.data[recordHeaderLen+explicitIVLen:], data)
		c.out.encrypt(b, explicitIVLen, typ)
		_, err = c.conn.Write(b.data)
		if err != nil ***REMOVED***
			break
		***REMOVED***
		n += m
		data = data[m:]
	***REMOVED***
	c.out.freeBlock(b)

	if typ == recordTypeChangeCipherSpec ***REMOVED***
		err = c.out.changeCipherSpec(c.config)
		if err != nil ***REMOVED***
			// Cannot call sendAlert directly,
			// because we already hold c.out.Mutex.
			c.tmp[0] = alertLevelError
			c.tmp[1] = byte(err.(alert))
			c.writeRecord(recordTypeAlert, c.tmp[0:2])
			return n, c.out.setErrorLocked(&net.OpError***REMOVED***Op: "local error", Err: err***REMOVED***)
		***REMOVED***
	***REMOVED***
	return
***REMOVED***

func (c *Conn) flushHandshake() error ***REMOVED***
	if c.isDTLS ***REMOVED***
		return c.dtlsFlushHandshake()
	***REMOVED***

	for c.pendingFlight.Len() > 0 ***REMOVED***
		var buf [maxPlaintext]byte
		n, _ := c.pendingFlight.Read(buf[:])
		if _, err := c.doWriteRecord(recordTypeHandshake, buf[:n]); err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	c.pendingFlight.Reset()
	return nil
***REMOVED***

func (c *Conn) doReadHandshake() ([]byte, error) ***REMOVED***
	if c.isDTLS ***REMOVED***
		return c.dtlsDoReadHandshake()
	***REMOVED***

	for c.hand.Len() < 4 ***REMOVED***
		if err := c.in.err; err != nil ***REMOVED***
			return nil, err
		***REMOVED***
		if err := c.readRecord(recordTypeHandshake); err != nil ***REMOVED***
			return nil, err
		***REMOVED***
	***REMOVED***

	data := c.hand.Bytes()
	n := int(data[1])<<16 | int(data[2])<<8 | int(data[3])
	if n > maxHandshake ***REMOVED***
		return nil, c.in.setErrorLocked(c.sendAlert(alertInternalError))
	***REMOVED***
	for c.hand.Len() < 4+n ***REMOVED***
		if err := c.in.err; err != nil ***REMOVED***
			return nil, err
		***REMOVED***
		if err := c.readRecord(recordTypeHandshake); err != nil ***REMOVED***
			return nil, err
		***REMOVED***
	***REMOVED***
	return c.hand.Next(4 + n), nil
***REMOVED***

// readHandshake reads the next handshake message from
// the record layer.
// c.in.Mutex < L; c.out.Mutex < L.
func (c *Conn) readHandshake() (interface***REMOVED******REMOVED***, error) ***REMOVED***
	data, err := c.doReadHandshake()
	if err == errNoCertificateAlert ***REMOVED***
		if c.hand.Len() != 0 ***REMOVED***
			// The warning alert may not interleave with a handshake message.
			return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
		***REMOVED***
		return new(ssl3NoCertificateMsg), nil
	***REMOVED***
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	var m handshakeMessage
	switch data[0] ***REMOVED***
	case typeHelloRequest:
		m = new(helloRequestMsg)
	case typeClientHello:
		m = &clientHelloMsg***REMOVED***
			isDTLS: c.isDTLS,
		***REMOVED***
	case typeServerHello:
		m = &serverHelloMsg***REMOVED***
			isDTLS: c.isDTLS,
		***REMOVED***
	case typeHelloRetryRequest:
		m = new(helloRetryRequestMsg)
	case typeNewSessionTicket:
		m = &newSessionTicketMsg***REMOVED***
			version: c.vers,
		***REMOVED***
	case typeEncryptedExtensions:
		m = new(encryptedExtensionsMsg)
	case typeCertificate:
		m = &certificateMsg***REMOVED***
			hasRequestContext: c.vers >= VersionTLS13,
		***REMOVED***
	case typeCertificateRequest:
		m = &certificateRequestMsg***REMOVED***
			hasSignatureAlgorithm: c.vers >= VersionTLS12,
			hasRequestContext:     c.vers >= VersionTLS13,
		***REMOVED***
	case typeCertificateStatus:
		m = new(certificateStatusMsg)
	case typeServerKeyExchange:
		m = new(serverKeyExchangeMsg)
	case typeServerHelloDone:
		m = new(serverHelloDoneMsg)
	case typeClientKeyExchange:
		m = new(clientKeyExchangeMsg)
	case typeCertificateVerify:
		m = &certificateVerifyMsg***REMOVED***
			hasSignatureAlgorithm: c.vers >= VersionTLS12,
		***REMOVED***
	case typeNextProtocol:
		m = new(nextProtoMsg)
	case typeFinished:
		m = new(finishedMsg)
	case typeHelloVerifyRequest:
		m = new(helloVerifyRequestMsg)
	case typeChannelID:
		m = new(channelIDMsg)
	case typeKeyUpdate:
		m = new(keyUpdateMsg)
	default:
		return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
	***REMOVED***

	// The handshake message unmarshallers
	// expect to be able to keep references to data,
	// so pass in a fresh copy that won't be overwritten.
	data = append([]byte(nil), data...)

	if !m.unmarshal(data) ***REMOVED***
		return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
	***REMOVED***
	return m, nil
***REMOVED***

// skipPacket processes all the DTLS records in packet. It updates
// sequence number expectations but otherwise ignores them.
func (c *Conn) skipPacket(packet []byte) error ***REMOVED***
	for len(packet) > 0 ***REMOVED***
		if len(packet) < 13 ***REMOVED***
			return errors.New("tls: bad packet")
		***REMOVED***
		// Dropped packets are completely ignored save to update
		// expected sequence numbers for this and the next epoch. (We
		// don't assert on the contents of the packets both for
		// simplicity and because a previous test with one shorter
		// timeout schedule would have done so.)
		epoch := packet[3:5]
		seq := packet[5:11]
		length := uint16(packet[11])<<8 | uint16(packet[12])
		if bytes.Equal(c.in.seq[:2], epoch) ***REMOVED***
			if bytes.Compare(seq, c.in.seq[2:]) < 0 ***REMOVED***
				return errors.New("tls: sequence mismatch")
			***REMOVED***
			copy(c.in.seq[2:], seq)
			c.in.incSeq(false)
		***REMOVED*** else ***REMOVED***
			if bytes.Compare(seq, c.in.nextSeq[:]) < 0 ***REMOVED***
				return errors.New("tls: sequence mismatch")
			***REMOVED***
			copy(c.in.nextSeq[:], seq)
			c.in.incNextSeq()
		***REMOVED***
		if len(packet) < 13+int(length) ***REMOVED***
			return errors.New("tls: bad packet")
		***REMOVED***
		packet = packet[13+length:]
	***REMOVED***
	return nil
***REMOVED***

// simulatePacketLoss simulates the loss of a handshake leg from the
// peer based on the schedule in c.config.Bugs. If resendFunc is
// non-nil, it is called after each simulated timeout to retransmit
// handshake messages from the local end. This is used in cases where
// the peer retransmits on a stale Finished rather than a timeout.
func (c *Conn) simulatePacketLoss(resendFunc func()) error ***REMOVED***
	if len(c.config.Bugs.TimeoutSchedule) == 0 ***REMOVED***
		return nil
	***REMOVED***
	if !c.isDTLS ***REMOVED***
		return errors.New("tls: TimeoutSchedule may only be set in DTLS")
	***REMOVED***
	if c.config.Bugs.PacketAdaptor == nil ***REMOVED***
		return errors.New("tls: TimeoutSchedule set without PacketAdapter")
	***REMOVED***
	for _, timeout := range c.config.Bugs.TimeoutSchedule ***REMOVED***
		// Simulate a timeout.
		packets, err := c.config.Bugs.PacketAdaptor.SendReadTimeout(timeout)
		if err != nil ***REMOVED***
			return err
		***REMOVED***
		for _, packet := range packets ***REMOVED***
			if err := c.skipPacket(packet); err != nil ***REMOVED***
				return err
			***REMOVED***
		***REMOVED***
		if resendFunc != nil ***REMOVED***
			resendFunc()
		***REMOVED***
	***REMOVED***
	return nil
***REMOVED***

func (c *Conn) SendHalfHelloRequest() error ***REMOVED***
	if err := c.Handshake(); err != nil ***REMOVED***
		return err
	***REMOVED***

	c.out.Lock()
	defer c.out.Unlock()

	if _, err := c.writeRecord(recordTypeHandshake, []byte***REMOVED***typeHelloRequest, 0***REMOVED***); err != nil ***REMOVED***
		return err
	***REMOVED***
	return c.flushHandshake()
***REMOVED***

// Write writes data to the connection.
func (c *Conn) Write(b []byte) (int, error) ***REMOVED***
	if err := c.Handshake(); err != nil ***REMOVED***
		return 0, err
	***REMOVED***

	c.out.Lock()
	defer c.out.Unlock()

	// Flush any pending handshake data. PackHelloRequestWithFinished may
	// have been set and the handshake not followed by Renegotiate.
	c.flushHandshake()

	if err := c.out.err; err != nil ***REMOVED***
		return 0, err
	***REMOVED***

	if !c.handshakeComplete ***REMOVED***
		return 0, alertInternalError
	***REMOVED***

	if c.keyUpdateRequested ***REMOVED***
		if err := c.sendKeyUpdateLocked(keyUpdateNotRequested); err != nil ***REMOVED***
			return 0, err
		***REMOVED***
		c.keyUpdateRequested = false
	***REMOVED***

	if c.config.Bugs.SendSpuriousAlert != 0 ***REMOVED***
		c.sendAlertLocked(alertLevelError, c.config.Bugs.SendSpuriousAlert)
	***REMOVED***

	if c.config.Bugs.SendHelloRequestBeforeEveryAppDataRecord ***REMOVED***
		c.writeRecord(recordTypeHandshake, []byte***REMOVED***typeHelloRequest, 0, 0, 0***REMOVED***)
		c.flushHandshake()
	***REMOVED***

	// SSL 3.0 and TLS 1.0 are susceptible to a chosen-plaintext
	// attack when using block mode ciphers due to predictable IVs.
	// This can be prevented by splitting each Application Data
	// record into two records, effectively randomizing the IV.
	//
	// http://www.openssl.org/~bodo/tls-cbc.txt
	// https://bugzilla.mozilla.org/show_bug.cgi?id=665814
	// http://www.imperialviolet.org/2012/01/15/beastfollowup.html

	var m int
	if len(b) > 1 && c.vers <= VersionTLS10 && !c.isDTLS ***REMOVED***
		if _, ok := c.out.cipher.(cipher.BlockMode); ok ***REMOVED***
			n, err := c.writeRecord(recordTypeApplicationData, b[:1])
			if err != nil ***REMOVED***
				return n, c.out.setErrorLocked(err)
			***REMOVED***
			m, b = 1, b[1:]
		***REMOVED***
	***REMOVED***

	n, err := c.writeRecord(recordTypeApplicationData, b)
	return n + m, c.out.setErrorLocked(err)
***REMOVED***

func (c *Conn) handlePostHandshakeMessage() error ***REMOVED***
	msg, err := c.readHandshake()
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	if c.vers < VersionTLS13 ***REMOVED***
		if !c.isClient ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return errors.New("tls: unexpected post-handshake message")
		***REMOVED***

		_, ok := msg.(*helloRequestMsg)
		if !ok ***REMOVED***
			c.sendAlert(alertUnexpectedMessage)
			return alertUnexpectedMessage
		***REMOVED***

		c.handshakeComplete = false
		return c.Handshake()
	***REMOVED***

	if c.isClient ***REMOVED***
		if newSessionTicket, ok := msg.(*newSessionTicketMsg); ok ***REMOVED***
			if c.config.Bugs.ExpectGREASE && !newSessionTicket.hasGREASEExtension ***REMOVED***
				return errors.New("tls: no GREASE ticket extension found")
			***REMOVED***

			if c.config.Bugs.ExpectTicketEarlyDataInfo && newSessionTicket.maxEarlyDataSize == 0 ***REMOVED***
				return errors.New("tls: no ticket_early_data_info extension found")
			***REMOVED***

			if c.config.Bugs.ExpectNoNewSessionTicket ***REMOVED***
				return errors.New("tls: received unexpected NewSessionTicket")
			***REMOVED***

			if c.config.ClientSessionCache == nil || newSessionTicket.ticketLifetime == 0 ***REMOVED***
				return nil
			***REMOVED***

			session := &ClientSessionState***REMOVED***
				sessionTicket:      newSessionTicket.ticket,
				vers:               c.vers,
				cipherSuite:        c.cipherSuite.id,
				masterSecret:       c.resumptionSecret,
				serverCertificates: c.peerCertificates,
				sctList:            c.sctList,
				ocspResponse:       c.ocspResponse,
				ticketCreationTime: c.config.time(),
				ticketExpiration:   c.config.time().Add(time.Duration(newSessionTicket.ticketLifetime) * time.Second),
				ticketAgeAdd:       newSessionTicket.ticketAgeAdd,
				maxEarlyDataSize:   newSessionTicket.maxEarlyDataSize,
			***REMOVED***

			cacheKey := clientSessionCacheKey(c.conn.RemoteAddr(), c.config)
			c.config.ClientSessionCache.Put(cacheKey, session)
			return nil
		***REMOVED***
	***REMOVED***

	if keyUpdate, ok := msg.(*keyUpdateMsg); ok ***REMOVED***
		c.in.doKeyUpdate(c, false)
		if keyUpdate.keyUpdateRequest == keyUpdateRequested ***REMOVED***
			c.keyUpdateRequested = true
		***REMOVED***
		return nil
	***REMOVED***

	// TODO(davidben): Add support for KeyUpdate.
	c.sendAlert(alertUnexpectedMessage)
	return alertUnexpectedMessage
***REMOVED***

func (c *Conn) Renegotiate() error ***REMOVED***
	if !c.isClient ***REMOVED***
		helloReq := new(helloRequestMsg).marshal()
		if c.config.Bugs.BadHelloRequest != nil ***REMOVED***
			helloReq = c.config.Bugs.BadHelloRequest
		***REMOVED***
		c.writeRecord(recordTypeHandshake, helloReq)
		c.flushHandshake()
	***REMOVED***

	c.handshakeComplete = false
	return c.Handshake()
***REMOVED***

// Read can be made to time out and return a net.Error with Timeout() == true
// after a fixed time limit; see SetDeadline and SetReadDeadline.
func (c *Conn) Read(b []byte) (n int, err error) ***REMOVED***
	if err = c.Handshake(); err != nil ***REMOVED***
		return
	***REMOVED***

	c.in.Lock()
	defer c.in.Unlock()

	// Some OpenSSL servers send empty records in order to randomize the
	// CBC IV. So this loop ignores a limited number of empty records.
	const maxConsecutiveEmptyRecords = 100
	for emptyRecordCount := 0; emptyRecordCount <= maxConsecutiveEmptyRecords; emptyRecordCount++ ***REMOVED***
		for c.input == nil && c.in.err == nil ***REMOVED***
			if err := c.readRecord(recordTypeApplicationData); err != nil ***REMOVED***
				// Soft error, like EAGAIN
				return 0, err
			***REMOVED***
			if c.hand.Len() > 0 ***REMOVED***
				// We received handshake bytes, indicating a
				// post-handshake message.
				if err := c.handlePostHandshakeMessage(); err != nil ***REMOVED***
					return 0, err
				***REMOVED***
				continue
			***REMOVED***
		***REMOVED***
		if err := c.in.err; err != nil ***REMOVED***
			return 0, err
		***REMOVED***

		n, err = c.input.Read(b)
		if c.input.off >= len(c.input.data) || c.isDTLS ***REMOVED***
			c.in.freeBlock(c.input)
			c.input = nil
		***REMOVED***

		// If a close-notify alert is waiting, read it so that
		// we can return (n, EOF) instead of (n, nil), to signal
		// to the HTTP response reading goroutine that the
		// connection is now closed. This eliminates a race
		// where the HTTP response reading goroutine would
		// otherwise not observe the EOF until its next read,
		// by which time a client goroutine might have already
		// tried to reuse the HTTP connection for a new
		// request.
		// See https://codereview.appspot.com/76400046
		// and http://golang.org/issue/3514
		if ri := c.rawInput; ri != nil &&
			n != 0 && err == nil &&
			c.input == nil && len(ri.data) > 0 && recordType(ri.data[0]) == recordTypeAlert ***REMOVED***
			if recErr := c.readRecord(recordTypeApplicationData); recErr != nil ***REMOVED***
				err = recErr // will be io.EOF on closeNotify
			***REMOVED***
		***REMOVED***

		if n != 0 || err != nil ***REMOVED***
			return n, err
		***REMOVED***
	***REMOVED***

	return 0, io.ErrNoProgress
***REMOVED***

// Close closes the connection.
func (c *Conn) Close() error ***REMOVED***
	var alertErr error

	c.handshakeMutex.Lock()
	defer c.handshakeMutex.Unlock()
	if c.handshakeComplete && !c.config.Bugs.NoCloseNotify ***REMOVED***
		alert := alertCloseNotify
		if c.config.Bugs.SendAlertOnShutdown != 0 ***REMOVED***
			alert = c.config.Bugs.SendAlertOnShutdown
		***REMOVED***
		alertErr = c.sendAlert(alert)
		// Clear local alerts when sending alerts so we continue to wait
		// for the peer rather than closing the socket early.
		if opErr, ok := alertErr.(*net.OpError); ok && opErr.Op == "local error" ***REMOVED***
			alertErr = nil
		***REMOVED***
	***REMOVED***

	// Consume a close_notify from the peer if one hasn't been received
	// already. This avoids the peer from failing |SSL_shutdown| due to a
	// write failing.
	if c.handshakeComplete && alertErr == nil && c.config.Bugs.ExpectCloseNotify ***REMOVED***
		for c.in.error() == nil ***REMOVED***
			c.readRecord(recordTypeAlert)
		***REMOVED***
		if c.in.error() != io.EOF ***REMOVED***
			alertErr = c.in.error()
		***REMOVED***
	***REMOVED***

	if err := c.conn.Close(); err != nil ***REMOVED***
		return err
	***REMOVED***
	return alertErr
***REMOVED***

// Handshake runs the client or server handshake
// protocol if it has not yet been run.
// Most uses of this package need not call Handshake
// explicitly: the first Read or Write will call it automatically.
func (c *Conn) Handshake() error ***REMOVED***
	c.handshakeMutex.Lock()
	defer c.handshakeMutex.Unlock()
	if err := c.handshakeErr; err != nil ***REMOVED***
		return err
	***REMOVED***
	if c.handshakeComplete ***REMOVED***
		return nil
	***REMOVED***

	if c.isDTLS && c.config.Bugs.SendSplitAlert ***REMOVED***
		c.conn.Write([]byte***REMOVED***
			byte(recordTypeAlert), // type
			0xfe, 0xff, // version
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // sequence
			0x0, 0x2, // length
		***REMOVED***)
		c.conn.Write([]byte***REMOVED***alertLevelError, byte(alertInternalError)***REMOVED***)
	***REMOVED***
	if data := c.config.Bugs.AppDataBeforeHandshake; data != nil ***REMOVED***
		c.writeRecord(recordTypeApplicationData, data)
	***REMOVED***
	if c.isClient ***REMOVED***
		c.handshakeErr = c.clientHandshake()
	***REMOVED*** else ***REMOVED***
		c.handshakeErr = c.serverHandshake()
	***REMOVED***
	if c.handshakeErr == nil && c.config.Bugs.SendInvalidRecordType ***REMOVED***
		c.writeRecord(recordType(42), []byte("invalid record"))
	***REMOVED***
	return c.handshakeErr
***REMOVED***

// ConnectionState returns basic TLS details about the connection.
func (c *Conn) ConnectionState() ConnectionState ***REMOVED***
	c.handshakeMutex.Lock()
	defer c.handshakeMutex.Unlock()

	var state ConnectionState
	state.HandshakeComplete = c.handshakeComplete
	if c.handshakeComplete ***REMOVED***
		state.Version = c.vers
		state.NegotiatedProtocol = c.clientProtocol
		state.DidResume = c.didResume
		state.NegotiatedProtocolIsMutual = !c.clientProtocolFallback
		state.NegotiatedProtocolFromALPN = c.usedALPN
		state.CipherSuite = c.cipherSuite.id
		state.PeerCertificates = c.peerCertificates
		state.VerifiedChains = c.verifiedChains
		state.ServerName = c.serverName
		state.ChannelID = c.channelID
		state.SRTPProtectionProfile = c.srtpProtectionProfile
		state.TLSUnique = c.firstFinished[:]
		state.SCTList = c.sctList
		state.PeerSignatureAlgorithm = c.peerSignatureAlgorithm
		state.CurveID = c.curveID
		state.ShortHeader = c.in.shortHeader
	***REMOVED***

	return state
***REMOVED***

// OCSPResponse returns the stapled OCSP response from the TLS server, if
// any. (Only valid for client connections.)
func (c *Conn) OCSPResponse() []byte ***REMOVED***
	c.handshakeMutex.Lock()
	defer c.handshakeMutex.Unlock()

	return c.ocspResponse
***REMOVED***

// VerifyHostname checks that the peer certificate chain is valid for
// connecting to host.  If so, it returns nil; if not, it returns an error
// describing the problem.
func (c *Conn) VerifyHostname(host string) error ***REMOVED***
	c.handshakeMutex.Lock()
	defer c.handshakeMutex.Unlock()
	if !c.isClient ***REMOVED***
		return errors.New("tls: VerifyHostname called on TLS server connection")
	***REMOVED***
	if !c.handshakeComplete ***REMOVED***
		return errors.New("tls: handshake has not yet been performed")
	***REMOVED***
	return c.peerCertificates[0].VerifyHostname(host)
***REMOVED***

// ExportKeyingMaterial exports keying material from the current connection
// state, as per RFC 5705.
func (c *Conn) ExportKeyingMaterial(length int, label, context []byte, useContext bool) ([]byte, error) ***REMOVED***
	c.handshakeMutex.Lock()
	defer c.handshakeMutex.Unlock()
	if !c.handshakeComplete ***REMOVED***
		return nil, errors.New("tls: handshake has not yet been performed")
	***REMOVED***

	if c.vers >= VersionTLS13 ***REMOVED***
		// TODO(davidben): What should we do with useContext? See
		// https://github.com/tlswg/tls13-spec/issues/546
		return hkdfExpandLabel(c.cipherSuite.hash(), c.exporterSecret, label, context, length), nil
	***REMOVED***

	seedLen := len(c.clientRandom) + len(c.serverRandom)
	if useContext ***REMOVED***
		seedLen += 2 + len(context)
	***REMOVED***
	seed := make([]byte, 0, seedLen)
	seed = append(seed, c.clientRandom[:]...)
	seed = append(seed, c.serverRandom[:]...)
	if useContext ***REMOVED***
		seed = append(seed, byte(len(context)>>8), byte(len(context)))
		seed = append(seed, context...)
	***REMOVED***
	result := make([]byte, length)
	prfForVersion(c.vers, c.cipherSuite)(result, c.exporterSecret, label, seed)
	return result, nil
***REMOVED***

// noRenegotiationInfo returns true if the renegotiation info extension
// should be supported in the current handshake.
func (c *Conn) noRenegotiationInfo() bool ***REMOVED***
	if c.config.Bugs.NoRenegotiationInfo ***REMOVED***
		return true
	***REMOVED***
	if c.cipherSuite == nil && c.config.Bugs.NoRenegotiationInfoInInitial ***REMOVED***
		return true
	***REMOVED***
	if c.cipherSuite != nil && c.config.Bugs.NoRenegotiationInfoAfterInitial ***REMOVED***
		return true
	***REMOVED***
	return false
***REMOVED***

func (c *Conn) SendNewSessionTicket() error ***REMOVED***
	if c.isClient || c.vers < VersionTLS13 ***REMOVED***
		return errors.New("tls: cannot send post-handshake NewSessionTicket")
	***REMOVED***

	var peerCertificatesRaw [][]byte
	for _, cert := range c.peerCertificates ***REMOVED***
		peerCertificatesRaw = append(peerCertificatesRaw, cert.Raw)
	***REMOVED***

	addBuffer := make([]byte, 4)
	_, err := io.ReadFull(c.config.rand(), addBuffer)
	if err != nil ***REMOVED***
		c.sendAlert(alertInternalError)
		return errors.New("tls: short read from Rand: " + err.Error())
	***REMOVED***
	ticketAgeAdd := uint32(addBuffer[3])<<24 | uint32(addBuffer[2])<<16 | uint32(addBuffer[1])<<8 | uint32(addBuffer[0])

	// TODO(davidben): Allow configuring these values.
	m := &newSessionTicketMsg***REMOVED***
		version:                c.vers,
		ticketLifetime:         uint32(24 * time.Hour / time.Second),
		duplicateEarlyDataInfo: c.config.Bugs.DuplicateTicketEarlyDataInfo,
		customExtension:        c.config.Bugs.CustomTicketExtension,
		ticketAgeAdd:           ticketAgeAdd,
		maxEarlyDataSize:       c.config.MaxEarlyDataSize,
	***REMOVED***

	if c.config.Bugs.SendTicketLifetime != 0 ***REMOVED***
		m.ticketLifetime = uint32(c.config.Bugs.SendTicketLifetime / time.Second)
	***REMOVED***

	state := sessionState***REMOVED***
		vers:               c.vers,
		cipherSuite:        c.cipherSuite.id,
		masterSecret:       c.resumptionSecret,
		certificates:       peerCertificatesRaw,
		ticketCreationTime: c.config.time(),
		ticketExpiration:   c.config.time().Add(time.Duration(m.ticketLifetime) * time.Second),
		ticketAgeAdd:       uint32(addBuffer[3])<<24 | uint32(addBuffer[2])<<16 | uint32(addBuffer[1])<<8 | uint32(addBuffer[0]),
	***REMOVED***

	if !c.config.Bugs.SendEmptySessionTicket ***REMOVED***
		var err error
		m.ticket, err = c.encryptTicket(&state)
		if err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	c.out.Lock()
	defer c.out.Unlock()
	_, err = c.writeRecord(recordTypeHandshake, m.marshal())
	return err
***REMOVED***

func (c *Conn) SendKeyUpdate(keyUpdateRequest byte) error ***REMOVED***
	c.out.Lock()
	defer c.out.Unlock()
	return c.sendKeyUpdateLocked(keyUpdateRequest)
***REMOVED***

func (c *Conn) sendKeyUpdateLocked(keyUpdateRequest byte) error ***REMOVED***
	if c.vers < VersionTLS13 ***REMOVED***
		return errors.New("tls: attempted to send KeyUpdate before TLS 1.3")
	***REMOVED***

	m := keyUpdateMsg***REMOVED***
		keyUpdateRequest: keyUpdateRequest,
	***REMOVED***
	if _, err := c.writeRecord(recordTypeHandshake, m.marshal()); err != nil ***REMOVED***
		return err
	***REMOVED***
	if err := c.flushHandshake(); err != nil ***REMOVED***
		return err
	***REMOVED***
	c.out.doKeyUpdate(c, true)
	return nil
***REMOVED***

func (c *Conn) sendFakeEarlyData(len int) error ***REMOVED***
	// Assemble a fake early data record. This does not use writeRecord
	// because the record layer may be using different keys at this point.
	payload := make([]byte, 5+len)
	payload[0] = byte(recordTypeApplicationData)
	payload[1] = 3
	payload[2] = 1
	payload[3] = byte(len >> 8)
	payload[4] = byte(len)
	_, err := c.conn.Write(payload)
	return err
***REMOVED***

func (c *Conn) setShortHeader() ***REMOVED***
	c.in.shortHeader = true
	c.out.shortHeader = true
***REMOVED***
