// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runner

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/md5"
	"crypto/rsa"
	"crypto/sha1"
	_ "crypto/sha256"
	_ "crypto/sha512"
	"encoding/asn1"
	"errors"
	"fmt"
	"math/big"
)

type signer interface ***REMOVED***
	supportsKey(key crypto.PrivateKey) bool
	signMessage(key crypto.PrivateKey, config *Config, msg []byte) ([]byte, error)
	verifyMessage(key crypto.PublicKey, msg, sig []byte) error
***REMOVED***

func selectSignatureAlgorithm(version uint16, key crypto.PrivateKey, config *Config, peerSigAlgs []signatureAlgorithm) (signatureAlgorithm, error) ***REMOVED***
	// If the client didn't specify any signature_algorithms extension then
	// we can assume that it supports SHA1. See
	// http://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
	if len(peerSigAlgs) == 0 ***REMOVED***
		peerSigAlgs = []signatureAlgorithm***REMOVED***signatureRSAPKCS1WithSHA1, signatureECDSAWithSHA1***REMOVED***
	***REMOVED***

	for _, sigAlg := range config.signSignatureAlgorithms() ***REMOVED***
		if !isSupportedSignatureAlgorithm(sigAlg, peerSigAlgs) ***REMOVED***
			continue
		***REMOVED***

		signer, err := getSigner(version, key, config, sigAlg)
		if err != nil ***REMOVED***
			continue
		***REMOVED***

		if signer.supportsKey(key) ***REMOVED***
			return sigAlg, nil
		***REMOVED***
	***REMOVED***
	return 0, errors.New("tls: no common signature algorithms")
***REMOVED***

func signMessage(version uint16, key crypto.PrivateKey, config *Config, sigAlg signatureAlgorithm, msg []byte) ([]byte, error) ***REMOVED***
	if config.Bugs.InvalidSignature ***REMOVED***
		newMsg := make([]byte, len(msg))
		copy(newMsg, msg)
		newMsg[0] ^= 0x80
		msg = newMsg
	***REMOVED***

	signer, err := getSigner(version, key, config, sigAlg)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	return signer.signMessage(key, config, msg)
***REMOVED***

func verifyMessage(version uint16, key crypto.PublicKey, config *Config, sigAlg signatureAlgorithm, msg, sig []byte) error ***REMOVED***
	if version >= VersionTLS12 && !isSupportedSignatureAlgorithm(sigAlg, config.verifySignatureAlgorithms()) ***REMOVED***
		return errors.New("tls: unsupported signature algorithm")
	***REMOVED***

	signer, err := getSigner(version, key, config, sigAlg)
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	return signer.verifyMessage(key, msg, sig)
***REMOVED***

type rsaPKCS1Signer struct ***REMOVED***
	hash crypto.Hash
***REMOVED***

func (r *rsaPKCS1Signer) computeHash(msg []byte) []byte ***REMOVED***
	if r.hash == crypto.MD5SHA1 ***REMOVED***
		// crypto.MD5SHA1 is not a real hash function.
		hashMD5 := md5.New()
		hashMD5.Write(msg)
		hashSHA1 := sha1.New()
		hashSHA1.Write(msg)
		return hashSHA1.Sum(hashMD5.Sum(nil))
	***REMOVED***

	h := r.hash.New()
	h.Write(msg)
	return h.Sum(nil)
***REMOVED***

func (r *rsaPKCS1Signer) supportsKey(key crypto.PrivateKey) bool ***REMOVED***
	_, ok := key.(*rsa.PrivateKey)
	return ok
***REMOVED***

func (r *rsaPKCS1Signer) signMessage(key crypto.PrivateKey, config *Config, msg []byte) ([]byte, error) ***REMOVED***
	rsaKey, ok := key.(*rsa.PrivateKey)
	if !ok ***REMOVED***
		return nil, errors.New("invalid key type for RSA-PKCS1")
	***REMOVED***

	return rsa.SignPKCS1v15(config.rand(), rsaKey, r.hash, r.computeHash(msg))
***REMOVED***

func (r *rsaPKCS1Signer) verifyMessage(key crypto.PublicKey, msg, sig []byte) error ***REMOVED***
	rsaKey, ok := key.(*rsa.PublicKey)
	if !ok ***REMOVED***
		return errors.New("invalid key type for RSA-PKCS1")
	***REMOVED***

	return rsa.VerifyPKCS1v15(rsaKey, r.hash, r.computeHash(msg), sig)
***REMOVED***

type ecdsaSigner struct ***REMOVED***
	version uint16
	config  *Config
	curve   elliptic.Curve
	hash    crypto.Hash
***REMOVED***

func (e *ecdsaSigner) isCurveValid(curve elliptic.Curve) bool ***REMOVED***
	if e.config.Bugs.SkipECDSACurveCheck ***REMOVED***
		return true
	***REMOVED***
	if e.version <= VersionTLS12 ***REMOVED***
		return true
	***REMOVED***
	return e.curve != nil && curve == e.curve
***REMOVED***

func (e *ecdsaSigner) supportsKey(key crypto.PrivateKey) bool ***REMOVED***
	ecdsaKey, ok := key.(*ecdsa.PrivateKey)
	return ok && e.isCurveValid(ecdsaKey.Curve)
***REMOVED***

func maybeCorruptECDSAValue(n *big.Int, typeOfCorruption BadValue, limit *big.Int) *big.Int ***REMOVED***
	switch typeOfCorruption ***REMOVED***
	case BadValueNone:
		return n
	case BadValueNegative:
		return new(big.Int).Neg(n)
	case BadValueZero:
		return big.NewInt(0)
	case BadValueLimit:
		return limit
	case BadValueLarge:
		bad := new(big.Int).Set(limit)
		return bad.Lsh(bad, 20)
	default:
		panic("unknown BadValue type")
	***REMOVED***
***REMOVED***

func (e *ecdsaSigner) signMessage(key crypto.PrivateKey, config *Config, msg []byte) ([]byte, error) ***REMOVED***
	ecdsaKey, ok := key.(*ecdsa.PrivateKey)
	if !ok ***REMOVED***
		return nil, errors.New("invalid key type for ECDSA")
	***REMOVED***
	if !e.isCurveValid(ecdsaKey.Curve) ***REMOVED***
		return nil, errors.New("invalid curve for ECDSA")
	***REMOVED***

	h := e.hash.New()
	h.Write(msg)
	digest := h.Sum(nil)

	r, s, err := ecdsa.Sign(config.rand(), ecdsaKey, digest)
	if err != nil ***REMOVED***
		return nil, errors.New("failed to sign ECDHE parameters: " + err.Error())
	***REMOVED***
	order := ecdsaKey.Curve.Params().N
	r = maybeCorruptECDSAValue(r, config.Bugs.BadECDSAR, order)
	s = maybeCorruptECDSAValue(s, config.Bugs.BadECDSAS, order)
	return asn1.Marshal(ecdsaSignature***REMOVED***r, s***REMOVED***)
***REMOVED***

func (e *ecdsaSigner) verifyMessage(key crypto.PublicKey, msg, sig []byte) error ***REMOVED***
	ecdsaKey, ok := key.(*ecdsa.PublicKey)
	if !ok ***REMOVED***
		return errors.New("invalid key type for ECDSA")
	***REMOVED***
	if !e.isCurveValid(ecdsaKey.Curve) ***REMOVED***
		return errors.New("invalid curve for ECDSA")
	***REMOVED***

	ecdsaSig := new(ecdsaSignature)
	if _, err := asn1.Unmarshal(sig, ecdsaSig); err != nil ***REMOVED***
		return err
	***REMOVED***
	if ecdsaSig.R.Sign() <= 0 || ecdsaSig.S.Sign() <= 0 ***REMOVED***
		return errors.New("ECDSA signature contained zero or negative values")
	***REMOVED***

	h := e.hash.New()
	h.Write(msg)
	if !ecdsa.Verify(ecdsaKey, h.Sum(nil), ecdsaSig.R, ecdsaSig.S) ***REMOVED***
		return errors.New("ECDSA verification failure")
	***REMOVED***
	return nil
***REMOVED***

var pssOptions = rsa.PSSOptions***REMOVED***SaltLength: rsa.PSSSaltLengthEqualsHash***REMOVED***

type rsaPSSSigner struct ***REMOVED***
	hash crypto.Hash
***REMOVED***

func (r *rsaPSSSigner) supportsKey(key crypto.PrivateKey) bool ***REMOVED***
	_, ok := key.(*rsa.PrivateKey)
	return ok
***REMOVED***

func (r *rsaPSSSigner) signMessage(key crypto.PrivateKey, config *Config, msg []byte) ([]byte, error) ***REMOVED***
	rsaKey, ok := key.(*rsa.PrivateKey)
	if !ok ***REMOVED***
		return nil, errors.New("invalid key type for RSA-PSS")
	***REMOVED***

	h := r.hash.New()
	h.Write(msg)
	return rsa.SignPSS(config.rand(), rsaKey, r.hash, h.Sum(nil), &pssOptions)
***REMOVED***

func (r *rsaPSSSigner) verifyMessage(key crypto.PublicKey, msg, sig []byte) error ***REMOVED***
	rsaKey, ok := key.(*rsa.PublicKey)
	if !ok ***REMOVED***
		return errors.New("invalid key type for RSA-PSS")
	***REMOVED***

	h := r.hash.New()
	h.Write(msg)
	return rsa.VerifyPSS(rsaKey, r.hash, h.Sum(nil), sig, &pssOptions)
***REMOVED***

func getSigner(version uint16, key interface***REMOVED******REMOVED***, config *Config, sigAlg signatureAlgorithm) (signer, error) ***REMOVED***
	// TLS 1.1 and below use legacy signature algorithms.
	if version < VersionTLS12 ***REMOVED***
		switch key.(type) ***REMOVED***
		case *rsa.PrivateKey, *rsa.PublicKey:
			return &rsaPKCS1Signer***REMOVED***crypto.MD5SHA1***REMOVED***, nil
		case *ecdsa.PrivateKey, *ecdsa.PublicKey:
			return &ecdsaSigner***REMOVED***version, config, nil, crypto.SHA1***REMOVED***, nil
		default:
			return nil, errors.New("unknown key type")
		***REMOVED***
	***REMOVED***

	// TODO(davidben): Forbid RSASSA-PKCS1-v1_5 in TLS 1.3.
	switch sigAlg ***REMOVED***
	case signatureRSAPKCS1WithMD5:
		if version < VersionTLS13 || config.Bugs.IgnoreSignatureVersionChecks ***REMOVED***
			return &rsaPKCS1Signer***REMOVED***crypto.MD5***REMOVED***, nil
		***REMOVED***
	case signatureRSAPKCS1WithSHA1:
		if version < VersionTLS13 || config.Bugs.IgnoreSignatureVersionChecks ***REMOVED***
			return &rsaPKCS1Signer***REMOVED***crypto.SHA1***REMOVED***, nil
		***REMOVED***
	case signatureRSAPKCS1WithSHA256:
		if version < VersionTLS13 || config.Bugs.IgnoreSignatureVersionChecks ***REMOVED***
			return &rsaPKCS1Signer***REMOVED***crypto.SHA256***REMOVED***, nil
		***REMOVED***
	case signatureRSAPKCS1WithSHA384:
		if version < VersionTLS13 || config.Bugs.IgnoreSignatureVersionChecks ***REMOVED***
			return &rsaPKCS1Signer***REMOVED***crypto.SHA384***REMOVED***, nil
		***REMOVED***
	case signatureRSAPKCS1WithSHA512:
		if version < VersionTLS13 || config.Bugs.IgnoreSignatureVersionChecks ***REMOVED***
			return &rsaPKCS1Signer***REMOVED***crypto.SHA512***REMOVED***, nil
		***REMOVED***
	case signatureECDSAWithSHA1:
		return &ecdsaSigner***REMOVED***version, config, nil, crypto.SHA1***REMOVED***, nil
	case signatureECDSAWithP256AndSHA256:
		return &ecdsaSigner***REMOVED***version, config, elliptic.P256(), crypto.SHA256***REMOVED***, nil
	case signatureECDSAWithP384AndSHA384:
		return &ecdsaSigner***REMOVED***version, config, elliptic.P384(), crypto.SHA384***REMOVED***, nil
	case signatureECDSAWithP521AndSHA512:
		return &ecdsaSigner***REMOVED***version, config, elliptic.P521(), crypto.SHA512***REMOVED***, nil
	case signatureRSAPSSWithSHA256:
		return &rsaPSSSigner***REMOVED***crypto.SHA256***REMOVED***, nil
	case signatureRSAPSSWithSHA384:
		return &rsaPSSSigner***REMOVED***crypto.SHA384***REMOVED***, nil
	case signatureRSAPSSWithSHA512:
		return &rsaPSSSigner***REMOVED***crypto.SHA512***REMOVED***, nil
	***REMOVED***

	return nil, fmt.Errorf("unsupported signature algorithm %04x", sigAlg)
***REMOVED***
