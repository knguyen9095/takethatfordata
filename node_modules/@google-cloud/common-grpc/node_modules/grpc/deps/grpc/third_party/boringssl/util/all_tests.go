/* Copyright (c) 2015, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"
)

// TODO(davidben): Link tests with the malloc shim and port -malloc-test to this runner.

var (
	useValgrind     = flag.Bool("valgrind", false, "If true, run code under valgrind")
	useCallgrind    = flag.Bool("callgrind", false, "If true, run code under valgrind to generate callgrind traces.")
	useGDB          = flag.Bool("gdb", false, "If true, run BoringSSL code under gdb")
	useSDE          = flag.Bool("sde", false, "If true, run BoringSSL code under Intel's SDE for each supported chip")
	buildDir        = flag.String("build-dir", "build", "The build directory to run the tests from.")
	numWorkers      = flag.Int("num-workers", 1, "Runs the given number of workers when testing.")
	jsonOutput      = flag.String("json-output", "", "The file to output JSON results to.")
	mallocTest      = flag.Int64("malloc-test", -1, "If non-negative, run each test with each malloc in turn failing from the given number onwards.")
	mallocTestDebug = flag.Bool("malloc-test-debug", false, "If true, ask each test to abort rather than fail a malloc. This can be used with a specific value for --malloc-test to identity the malloc failing that is causing problems.")
)

type test struct ***REMOVED***
	args []string
	// cpu, if not empty, contains an Intel CPU code to simulate. Run
	// `sde64 -help` to get a list of these codes.
	cpu string
***REMOVED***

type result struct ***REMOVED***
	Test   test
	Passed bool
	Error  error
***REMOVED***

// testOutput is a representation of Chromium's JSON test result format. See
// https://www.chromium.org/developers/the-json-test-results-format
type testOutput struct ***REMOVED***
	Version           int                   `json:"version"`
	Interrupted       bool                  `json:"interrupted"`
	PathDelimiter     string                `json:"path_delimiter"`
	SecondsSinceEpoch float64               `json:"seconds_since_epoch"`
	NumFailuresByType map[string]int        `json:"num_failures_by_type"`
	Tests             map[string]testResult `json:"tests"`
***REMOVED***

type testResult struct ***REMOVED***
	Actual       string `json:"actual"`
	Expected     string `json:"expected"`
	IsUnexpected bool   `json:"is_unexpected"`
***REMOVED***

// sdeCPUs contains a list of CPU code that we run all tests under when *useSDE
// is true.
var sdeCPUs = []string***REMOVED***
	"p4p", // Pentium4 Prescott
	"mrm", // Merom
	"pnr", // Penryn
	"nhm", // Nehalem
	"wsm", // Westmere
	"snb", // Sandy Bridge
	"ivb", // Ivy Bridge
	"hsw", // Haswell
	"bdw", // Broadwell
	"skx", // Skylake Server
	"skl", // Skylake Client
	"cnl", // Cannonlake
	"knl", // Knights Landing
	"slt", // Saltwell
	"slm", // Silvermont
	"glm", // Goldmont
***REMOVED***

func newTestOutput() *testOutput ***REMOVED***
	return &testOutput***REMOVED***
		Version:           3,
		PathDelimiter:     ".",
		SecondsSinceEpoch: float64(time.Now().UnixNano()) / float64(time.Second/time.Nanosecond),
		NumFailuresByType: make(map[string]int),
		Tests:             make(map[string]testResult),
	***REMOVED***
***REMOVED***

func (t *testOutput) addResult(name, result string) ***REMOVED***
	if _, found := t.Tests[name]; found ***REMOVED***
		panic(name)
	***REMOVED***
	t.Tests[name] = testResult***REMOVED***
		Actual:       result,
		Expected:     "PASS",
		IsUnexpected: result != "PASS",
	***REMOVED***
	t.NumFailuresByType[result]++
***REMOVED***

func (t *testOutput) writeTo(name string) error ***REMOVED***
	file, err := os.Create(name)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	defer file.Close()
	out, err := json.MarshalIndent(t, "", "  ")
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	_, err = file.Write(out)
	return err
***REMOVED***

func valgrindOf(dbAttach bool, path string, args ...string) *exec.Cmd ***REMOVED***
	valgrindArgs := []string***REMOVED***"--error-exitcode=99", "--track-origins=yes", "--leak-check=full", "--quiet"***REMOVED***
	if dbAttach ***REMOVED***
		valgrindArgs = append(valgrindArgs, "--db-attach=yes", "--db-command=xterm -e gdb -nw %f %p")
	***REMOVED***
	valgrindArgs = append(valgrindArgs, path)
	valgrindArgs = append(valgrindArgs, args...)

	return exec.Command("valgrind", valgrindArgs...)
***REMOVED***

func callgrindOf(path string, args ...string) *exec.Cmd ***REMOVED***
	valgrindArgs := []string***REMOVED***"-q", "--tool=callgrind", "--dump-instr=yes", "--collect-jumps=yes", "--callgrind-out-file=" + *buildDir + "/callgrind/callgrind.out.%p"***REMOVED***
	valgrindArgs = append(valgrindArgs, path)
	valgrindArgs = append(valgrindArgs, args...)

	return exec.Command("valgrind", valgrindArgs...)
***REMOVED***

func gdbOf(path string, args ...string) *exec.Cmd ***REMOVED***
	xtermArgs := []string***REMOVED***"-e", "gdb", "--args"***REMOVED***
	xtermArgs = append(xtermArgs, path)
	xtermArgs = append(xtermArgs, args...)

	return exec.Command("xterm", xtermArgs...)
***REMOVED***

func sdeOf(cpu, path string, args ...string) *exec.Cmd ***REMOVED***
	sdeArgs := []string***REMOVED***"-" + cpu, "--", path***REMOVED***
	sdeArgs = append(sdeArgs, args...)
	return exec.Command("sde", sdeArgs...)
***REMOVED***

type moreMallocsError struct***REMOVED******REMOVED***

func (moreMallocsError) Error() string ***REMOVED***
	return "child process did not exhaust all allocation calls"
***REMOVED***

var errMoreMallocs = moreMallocsError***REMOVED******REMOVED***

func runTestOnce(test test, mallocNumToFail int64) (passed bool, err error) ***REMOVED***
	prog := path.Join(*buildDir, test.args[0])
	args := test.args[1:]
	var cmd *exec.Cmd
	if *useValgrind ***REMOVED***
		cmd = valgrindOf(false, prog, args...)
	***REMOVED*** else if *useCallgrind ***REMOVED***
		cmd = callgrindOf(prog, args...)
	***REMOVED*** else if *useGDB ***REMOVED***
		cmd = gdbOf(prog, args...)
	***REMOVED*** else if *useSDE ***REMOVED***
		cmd = sdeOf(test.cpu, prog, args...)
	***REMOVED*** else ***REMOVED***
		cmd = exec.Command(prog, args...)
	***REMOVED***
	var outBuf bytes.Buffer
	cmd.Stdout = &outBuf
	cmd.Stderr = &outBuf
	if mallocNumToFail >= 0 ***REMOVED***
		cmd.Env = os.Environ()
		cmd.Env = append(cmd.Env, "MALLOC_NUMBER_TO_FAIL="+strconv.FormatInt(mallocNumToFail, 10))
		if *mallocTestDebug ***REMOVED***
			cmd.Env = append(cmd.Env, "MALLOC_ABORT_ON_FAIL=1")
		***REMOVED***
		cmd.Env = append(cmd.Env, "_MALLOC_CHECK=1")
	***REMOVED***

	if err := cmd.Start(); err != nil ***REMOVED***
		return false, err
	***REMOVED***
	if err := cmd.Wait(); err != nil ***REMOVED***
		if exitError, ok := err.(*exec.ExitError); ok ***REMOVED***
			if exitError.Sys().(syscall.WaitStatus).ExitStatus() == 88 ***REMOVED***
				return false, errMoreMallocs
			***REMOVED***
		***REMOVED***
		fmt.Print(string(outBuf.Bytes()))
		return false, err
	***REMOVED***

	// Account for Windows line-endings.
	stdout := bytes.Replace(outBuf.Bytes(), []byte("\r\n"), []byte("\n"), -1)

	if bytes.HasSuffix(stdout, []byte("PASS\n")) &&
		(len(stdout) == 5 || stdout[len(stdout)-6] == '\n') ***REMOVED***
		return true, nil
	***REMOVED***

	// Also accept a googletest-style pass line. This is left here in
	// transition until the tests are all converted and this script made
	// unnecessary.
	if bytes.Contains(stdout, []byte("\n[  PASSED  ]")) ***REMOVED***
		return true, nil
	***REMOVED***

	fmt.Print(string(outBuf.Bytes()))
	return false, nil
***REMOVED***

func runTest(test test) (bool, error) ***REMOVED***
	if *mallocTest < 0 ***REMOVED***
		return runTestOnce(test, -1)
	***REMOVED***

	for mallocNumToFail := int64(*mallocTest); ; mallocNumToFail++ ***REMOVED***
		if passed, err := runTestOnce(test, mallocNumToFail); err != errMoreMallocs ***REMOVED***
			if err != nil ***REMOVED***
				err = fmt.Errorf("at malloc %d: %s", mallocNumToFail, err)
			***REMOVED***
			return passed, err
		***REMOVED***
	***REMOVED***
***REMOVED***

// shortTestName returns the short name of a test. Except for evp_test, it
// assumes that any argument which ends in .txt is a path to a data file and not
// relevant to the test's uniqueness.
func shortTestName(test test) string ***REMOVED***
	var args []string
	for _, arg := range test.args ***REMOVED***
		if test.args[0] == "crypto/evp/evp_test" || !strings.HasSuffix(arg, ".txt") ***REMOVED***
			args = append(args, arg)
		***REMOVED***
	***REMOVED***
	return strings.Join(args, " ") + test.cpuMsg()
***REMOVED***

// setWorkingDirectory walks up directories as needed until the current working
// directory is the top of a BoringSSL checkout.
func setWorkingDirectory() ***REMOVED***
	for i := 0; i < 64; i++ ***REMOVED***
		if _, err := os.Stat("BUILDING.md"); err == nil ***REMOVED***
			return
		***REMOVED***
		os.Chdir("..")
	***REMOVED***

	panic("Couldn't find BUILDING.md in a parent directory!")
***REMOVED***

func parseTestConfig(filename string) ([]test, error) ***REMOVED***
	in, err := os.Open(filename)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	defer in.Close()

	decoder := json.NewDecoder(in)
	var testArgs [][]string
	if err := decoder.Decode(&testArgs); err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	var result []test
	for _, args := range testArgs ***REMOVED***
		result = append(result, test***REMOVED***args: args***REMOVED***)
	***REMOVED***
	return result, nil
***REMOVED***

func worker(tests <-chan test, results chan<- result, done *sync.WaitGroup) ***REMOVED***
	defer done.Done()
	for test := range tests ***REMOVED***
		passed, err := runTest(test)
		results <- result***REMOVED***test, passed, err***REMOVED***
	***REMOVED***
***REMOVED***

func (t test) cpuMsg() string ***REMOVED***
	if len(t.cpu) == 0 ***REMOVED***
		return ""
	***REMOVED***

	return fmt.Sprintf(" (for CPU %q)", t.cpu)
***REMOVED***

func main() ***REMOVED***
	flag.Parse()
	setWorkingDirectory()

	testCases, err := parseTestConfig("util/all_tests.json")
	if err != nil ***REMOVED***
		fmt.Printf("Failed to parse input: %s\n", err)
		os.Exit(1)
	***REMOVED***

	var wg sync.WaitGroup
	tests := make(chan test, *numWorkers)
	results := make(chan result, *numWorkers)

	for i := 0; i < *numWorkers; i++ ***REMOVED***
		wg.Add(1)
		go worker(tests, results, &wg)
	***REMOVED***

	go func() ***REMOVED***
		for _, test := range testCases ***REMOVED***
			if *useSDE ***REMOVED***
				for _, cpu := range sdeCPUs ***REMOVED***
					testForCPU := test
					testForCPU.cpu = cpu
					tests <- testForCPU
				***REMOVED***
			***REMOVED*** else ***REMOVED***
				tests <- test
			***REMOVED***
		***REMOVED***
		close(tests)

		wg.Wait()
		close(results)
	***REMOVED***()

	testOutput := newTestOutput()
	var failed []test
	for testResult := range results ***REMOVED***
		test := testResult.Test
		args := test.args

		fmt.Printf("%s%s\n", strings.Join(args, " "), test.cpuMsg())
		name := shortTestName(test)
		if testResult.Error != nil ***REMOVED***
			fmt.Printf("%s failed to complete: %s\n", args[0], testResult.Error)
			failed = append(failed, test)
			testOutput.addResult(name, "CRASHED")
		***REMOVED*** else if !testResult.Passed ***REMOVED***
			fmt.Printf("%s failed to print PASS on the last line.\n", args[0])
			failed = append(failed, test)
			testOutput.addResult(name, "FAIL")
		***REMOVED*** else ***REMOVED***
			testOutput.addResult(name, "PASS")
		***REMOVED***
	***REMOVED***

	if *jsonOutput != "" ***REMOVED***
		if err := testOutput.writeTo(*jsonOutput); err != nil ***REMOVED***
			fmt.Fprintf(os.Stderr, "Error: %s\n", err)
		***REMOVED***
	***REMOVED***

	if len(failed) > 0 ***REMOVED***
		fmt.Printf("\n%d of %d tests failed:\n", len(failed), len(testCases))
		for _, test := range failed ***REMOVED***
			fmt.Printf("\t%s%s\n", strings.Join(test.args, ""), test.cpuMsg())
		***REMOVED***
		os.Exit(1)
	***REMOVED***

	fmt.Printf("\nAll tests passed!\n")
***REMOVED***
