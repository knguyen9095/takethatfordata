#! /usr/bin/env perl
# Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the OpenSSL license (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html

my $flavour = shift;
my $output = shift;
open STDOUT,">$output" || die "can't open $output: $!";

my %GLOBALS;
my %TYPES;
my $dotinlocallabels=($flavour=~/linux/)?1:0;

################################################################
# directives which need special treatment on different platforms
################################################################
my $type = sub ***REMOVED***
    my ($dir,$name,$type) = @_;

    $TYPES***REMOVED***$name***REMOVED*** = $type;
    if ($flavour =~ /linux/) ***REMOVED***
	$name =~ s|^\.||;
	".type	$name,$type";
    ***REMOVED*** else ***REMOVED***
	"";
    ***REMOVED***
***REMOVED***;
my $globl = sub ***REMOVED***
    my $junk = shift;
    my $name = shift;
    my $global = \$GLOBALS***REMOVED***$name***REMOVED***;
    my $type = \$TYPES***REMOVED***$name***REMOVED***;
    my $ret;

    $name =~ s|^\.||;

    SWITCH: for ($flavour) ***REMOVED***
	/aix/		&& do ***REMOVED*** if (!$$type) ***REMOVED***
				    $$type = "\@function";
				***REMOVED***
				if ($$type =~ /function/) ***REMOVED***
				    $name = ".$name";
				***REMOVED***
				last;
			      ***REMOVED***;
	/osx/		&& do ***REMOVED*** $name = "_$name";
				last;
			      ***REMOVED***;
	/linux.*(32|64le)/
			&& do ***REMOVED***	$ret .= ".globl	$name";
				if (!$$type) ***REMOVED***
				    $ret .= "\n.type	$name,\@function";
				    $$type = "\@function";
				***REMOVED***
				last;
			      ***REMOVED***;
	/linux.*64/	&& do ***REMOVED***	$ret .= ".globl	$name";
				if (!$$type) ***REMOVED***
				    $ret .= "\n.type	$name,\@function";
				    $$type = "\@function";
				***REMOVED***
				if ($$type =~ /function/) ***REMOVED***
				    $ret .= "\n.section	\".opd\",\"aw\"";
				    $ret .= "\n.align	3";
				    $ret .= "\n$name:";
				    $ret .= "\n.quad	.$name,.TOC.\@tocbase,0";
				    $ret .= "\n.previous";
				    $name = ".$name";
				***REMOVED***
				last;
			      ***REMOVED***;
    ***REMOVED***

    $ret = ".globl	$name" if (!$ret);
    $$global = $name;
    $ret;
***REMOVED***;
my $text = sub ***REMOVED***
    my $ret = ($flavour =~ /aix/) ? ".csect\t.text[PR],7" : ".text";
    $ret = ".abiversion	2\n".$ret	if ($flavour =~ /linux.*64le/);
    $ret;
***REMOVED***;
my $machine = sub ***REMOVED***
    my $junk = shift;
    my $arch = shift;
    if ($flavour =~ /osx/)
    ***REMOVED***	$arch =~ s/\"//g;
	$arch = ($flavour=~/64/) ? "ppc970-64" : "ppc970" if ($arch eq "any");
    ***REMOVED***
    ".machine	$arch";
***REMOVED***;
my $size = sub ***REMOVED***
    if ($flavour =~ /linux/)
    ***REMOVED***	shift;
	my $name = shift;
	my $real = $GLOBALS***REMOVED***$name***REMOVED*** ? \$GLOBALS***REMOVED***$name***REMOVED*** : \$name;
	my $ret  = ".size	$$real,.-$$real";
	$name =~ s|^\.||;
	if ($$real ne $name) ***REMOVED***
	    $ret .= "\n.size	$name,.-$$real";
	***REMOVED***
	$ret;
    ***REMOVED***
    else
    ***REMOVED***	"";	***REMOVED***
***REMOVED***;
my $asciz = sub ***REMOVED***
    shift;
    my $line = join(",",@_);
    if ($line =~ /^"(.*)"$/)
    ***REMOVED***	".byte	" . join(",",unpack("C*",$1),0) . "\n.align	2";	***REMOVED***
    else
    ***REMOVED***	"";	***REMOVED***
***REMOVED***;
my $quad = sub ***REMOVED***
    shift;
    my @ret;
    my ($hi,$lo);
    for (@_) ***REMOVED***
	if (/^0x([0-9a-f]*?)([0-9a-f]***REMOVED***1,8***REMOVED***)$/io)
	***REMOVED***  $hi=$1?"0x$1":"0"; $lo="0x$2";  ***REMOVED***
	elsif (/^([0-9]+)$/o)
	***REMOVED***  $hi=$1>>32; $lo=$1&0xffffffff;  ***REMOVED*** # error-prone with 32-bit perl
	else
	***REMOVED***  $hi=undef; $lo=$_; ***REMOVED***

	if (defined($hi))
	***REMOVED***  push(@ret,$flavour=~/le$/o?".long\t$lo,$hi":".long\t$hi,$lo");  ***REMOVED***
	else
	***REMOVED***  push(@ret,".quad	$lo");  ***REMOVED***
    ***REMOVED***
    join("\n",@ret);
***REMOVED***;

################################################################
# simplified mnemonics not handled by at least one assembler
################################################################
my $cmplw = sub ***REMOVED***
    my $f = shift;
    my $cr = 0; $cr = shift if ($#_>1);
    # Some out-of-date 32-bit GNU assembler just can't handle cmplw...
    ($flavour =~ /linux.*32/) ?
	"	.long	".sprintf "0x%x",31<<26|$cr<<23|$_[0]<<16|$_[1]<<11|64 :
	"	cmplw	".join(',',$cr,@_);
***REMOVED***;
my $bdnz = sub ***REMOVED***
    my $f = shift;
    my $bo = $f=~/[\+\-]/ ? 16+9 : 16;	# optional "to be taken" hint
    "	bc	$bo,0,".shift;
***REMOVED*** if ($flavour!~/linux/);
my $bltlr = sub ***REMOVED***
    my $f = shift;
    my $bo = $f=~/\-/ ? 12+2 : 12;	# optional "not to be taken" hint
    ($flavour =~ /linux/) ?		# GNU as doesn't allow most recent hints
	"	.long	".sprintf "0x%x",19<<26|$bo<<21|16<<1 :
	"	bclr	$bo,0";
***REMOVED***;
my $bnelr = sub ***REMOVED***
    my $f = shift;
    my $bo = $f=~/\-/ ? 4+2 : 4;	# optional "not to be taken" hint
    ($flavour =~ /linux/) ?		# GNU as doesn't allow most recent hints
	"	.long	".sprintf "0x%x",19<<26|$bo<<21|2<<16|16<<1 :
	"	bclr	$bo,2";
***REMOVED***;
my $beqlr = sub ***REMOVED***
    my $f = shift;
    my $bo = $f=~/-/ ? 12+2 : 12;	# optional "not to be taken" hint
    ($flavour =~ /linux/) ?		# GNU as doesn't allow most recent hints
	"	.long	".sprintf "0x%X",19<<26|$bo<<21|2<<16|16<<1 :
	"	bclr	$bo,2";
***REMOVED***;
# GNU assembler can't handle extrdi rA,rS,16,48, or when sum of last two
# arguments is 64, with "operand out of range" error.
my $extrdi = sub ***REMOVED***
    my ($f,$ra,$rs,$n,$b) = @_;
    $b = ($b+$n)&63; $n = 64-$n;
    "	rldicl	$ra,$rs,$b,$n";
***REMOVED***;
my $vmr = sub ***REMOVED***
    my ($f,$vx,$vy) = @_;
    "	vor	$vx,$vy,$vy";
***REMOVED***;

# Some ABIs specify vrsave, special-purpose register #256, as reserved
# for system use.
my $no_vrsave = ($flavour =~ /aix|linux64le/);
my $mtspr = sub ***REMOVED***
    my ($f,$idx,$ra) = @_;
    if ($idx == 256 && $no_vrsave) ***REMOVED***
	"	or	$ra,$ra,$ra";
    ***REMOVED*** else ***REMOVED***
	"	mtspr	$idx,$ra";
    ***REMOVED***
***REMOVED***;
my $mfspr = sub ***REMOVED***
    my ($f,$rd,$idx) = @_;
    if ($idx == 256 && $no_vrsave) ***REMOVED***
	"	li	$rd,-1";
    ***REMOVED*** else ***REMOVED***
	"	mfspr	$rd,$idx";
    ***REMOVED***
***REMOVED***;

# PowerISA 2.06 stuff
sub vsxmem_op ***REMOVED***
    my ($f, $vrt, $ra, $rb, $op) = @_;
    "	.long	".sprintf "0x%X",(31<<26)|($vrt<<21)|($ra<<16)|($rb<<11)|($op*2+1);
***REMOVED***
# made-up unaligned memory reference AltiVec/VMX instructions
my $lvx_u	= sub ***REMOVED***	vsxmem_op(@_, 844); ***REMOVED***;	# lxvd2x
my $stvx_u	= sub ***REMOVED***	vsxmem_op(@_, 972); ***REMOVED***;	# stxvd2x
my $lvdx_u	= sub ***REMOVED***	vsxmem_op(@_, 588); ***REMOVED***;	# lxsdx
my $stvdx_u	= sub ***REMOVED***	vsxmem_op(@_, 716); ***REMOVED***;	# stxsdx
my $lvx_4w	= sub ***REMOVED*** vsxmem_op(@_, 780); ***REMOVED***;	# lxvw4x
my $stvx_4w	= sub ***REMOVED*** vsxmem_op(@_, 908); ***REMOVED***;	# stxvw4x

# PowerISA 2.07 stuff
sub vcrypto_op ***REMOVED***
    my ($f, $vrt, $vra, $vrb, $op) = @_;
    "	.long	".sprintf "0x%X",(4<<26)|($vrt<<21)|($vra<<16)|($vrb<<11)|$op;
***REMOVED***
my $vcipher	= sub ***REMOVED*** vcrypto_op(@_, 1288); ***REMOVED***;
my $vcipherlast	= sub ***REMOVED*** vcrypto_op(@_, 1289); ***REMOVED***;
my $vncipher	= sub ***REMOVED*** vcrypto_op(@_, 1352); ***REMOVED***;
my $vncipherlast= sub ***REMOVED*** vcrypto_op(@_, 1353); ***REMOVED***;
my $vsbox	= sub ***REMOVED*** vcrypto_op(@_, 0, 1480); ***REMOVED***;
my $vshasigmad	= sub ***REMOVED*** my ($st,$six)=splice(@_,-2); vcrypto_op(@_, $st<<4|$six, 1730); ***REMOVED***;
my $vshasigmaw	= sub ***REMOVED*** my ($st,$six)=splice(@_,-2); vcrypto_op(@_, $st<<4|$six, 1666); ***REMOVED***;
my $vpmsumb	= sub ***REMOVED*** vcrypto_op(@_, 1032); ***REMOVED***;
my $vpmsumd	= sub ***REMOVED*** vcrypto_op(@_, 1224); ***REMOVED***;
my $vpmsubh	= sub ***REMOVED*** vcrypto_op(@_, 1096); ***REMOVED***;
my $vpmsumw	= sub ***REMOVED*** vcrypto_op(@_, 1160); ***REMOVED***;
my $vaddudm	= sub ***REMOVED*** vcrypto_op(@_, 192);  ***REMOVED***;

my $mtsle	= sub ***REMOVED***
    my ($f, $arg) = @_;
    "	.long	".sprintf "0x%X",(31<<26)|($arg<<21)|(147*2);
***REMOVED***;

# PowerISA 3.0 stuff
my $maddhdu = sub ***REMOVED***
    my ($f, $rt, $ra, $rb, $rc) = @_;
    "	.long	".sprintf "0x%X",(4<<26)|($rt<<21)|($ra<<16)|($rb<<11)|($rc<<6)|49;
***REMOVED***;
my $maddld = sub ***REMOVED***
    my ($f, $rt, $ra, $rb, $rc) = @_;
    "	.long	".sprintf "0x%X",(4<<26)|($rt<<21)|($ra<<16)|($rb<<11)|($rc<<6)|51;
***REMOVED***;

my $darn = sub ***REMOVED***
    my ($f, $rt, $l) = @_;
    "	.long	".sprintf "0x%X",(31<<26)|($rt<<21)|($l<<16)|(755<<1);
***REMOVED***;

while($line=<>) ***REMOVED***

    $line =~ s|[#!;].*$||;	# get rid of asm-style comments...
    $line =~ s|/\*.*\*/||;	# ... and C-style comments...
    $line =~ s|^\s+||;		# ... and skip white spaces in beginning...
    $line =~ s|\s+$||;		# ... and at the end

    ***REMOVED***
	$line =~ s|\.L(\w+)|L$1|g;	# common denominator for Locallabel
	$line =~ s|\bL(\w+)|\.L$1|g	if ($dotinlocallabels);
    ***REMOVED***

    ***REMOVED***
	$line =~ s|(^[\.\w]+)\:\s*||;
	my $label = $1;
	if ($label) ***REMOVED***
	    my $xlated = ($GLOBALS***REMOVED***$label***REMOVED*** or $label);
	    print "$xlated:";
	    if ($flavour =~ /linux.*64le/) ***REMOVED***
		if ($TYPES***REMOVED***$label***REMOVED*** =~ /function/) ***REMOVED***
		    printf "\n.localentry	%s,0\n",$xlated;
		***REMOVED***
	    ***REMOVED***
	***REMOVED***
    ***REMOVED***

    ***REMOVED***
	$line =~ s|^\s*(\.?)(\w+)([\.\+\-]?)\s*||;
	my $c = $1; $c = "\t" if ($c eq "");
	my $mnemonic = $2;
	my $f = $3;
	my $opcode = eval("\$$mnemonic");
	$line =~ s/\b(c?[rf]|v|vs)([0-9]+)\b/$2/g if ($c ne "." and $flavour !~ /osx/);
	if (ref($opcode) eq 'CODE') ***REMOVED*** $line = &$opcode($f,split(',',$line)); ***REMOVED***
	elsif ($mnemonic)           ***REMOVED*** $line = $c.$mnemonic.$f."\t".$line; ***REMOVED***
    ***REMOVED***

    print $line if ($line);
    print "\n";
***REMOVED***

close STDOUT;
