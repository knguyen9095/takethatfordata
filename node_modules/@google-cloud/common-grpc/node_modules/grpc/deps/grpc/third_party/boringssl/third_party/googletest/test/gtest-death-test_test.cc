// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Author: wan@google.com (Zhanyong Wan)
//
// Tests for death tests.

#include "gtest/gtest-death-test.h"
#include "gtest/gtest.h"
#include "gtest/internal/gtest-filepath.h"

using testing::internal::AlwaysFalse;
using testing::internal::AlwaysTrue;

#if GTEST_HAS_DEATH_TEST

# if GTEST_OS_WINDOWS
#  include <direct.h>          // For chdir().
# else
#  include <unistd.h>
#  include <sys/wait.h>        // For waitpid.
# endif  // GTEST_OS_WINDOWS

# include <limits.h>
# include <signal.h>
# include <stdio.h>

# if GTEST_OS_LINUX
#  include <sys/time.h>
# endif  // GTEST_OS_LINUX

# include "gtest/gtest-spi.h"

// Indicates that this translation unit is part of Google Test's
// implementation.  It must come before gtest-internal-inl.h is
// included, or there will be a compiler error.  This trick is to
// prevent a user from accidentally including gtest-internal-inl.h in
// his code.
# define GTEST_IMPLEMENTATION_ 1
# include "src/gtest-internal-inl.h"
# undef GTEST_IMPLEMENTATION_

namespace posix = ::testing::internal::posix;

using testing::Message;
using testing::internal::DeathTest;
using testing::internal::DeathTestFactory;
using testing::internal::FilePath;
using testing::internal::GetLastErrnoDescription;
using testing::internal::GetUnitTestImpl;
using testing::internal::InDeathTestChild;
using testing::internal::ParseNaturalNumber;

namespace testing ***REMOVED***
namespace internal ***REMOVED***

// A helper class whose objects replace the death test factory for a
// single UnitTest object during their lifetimes.
class ReplaceDeathTestFactory ***REMOVED***
 public:
  explicit ReplaceDeathTestFactory(DeathTestFactory* new_factory)
      : unit_test_impl_(GetUnitTestImpl()) ***REMOVED***
    old_factory_ = unit_test_impl_->death_test_factory_.release();
    unit_test_impl_->death_test_factory_.reset(new_factory);
  ***REMOVED***

  ~ReplaceDeathTestFactory() ***REMOVED***
    unit_test_impl_->death_test_factory_.release();
    unit_test_impl_->death_test_factory_.reset(old_factory_);
  ***REMOVED***
 private:
  // Prevents copying ReplaceDeathTestFactory objects.
  ReplaceDeathTestFactory(const ReplaceDeathTestFactory&);
  void operator=(const ReplaceDeathTestFactory&);

  UnitTestImpl* unit_test_impl_;
  DeathTestFactory* old_factory_;
***REMOVED***;

***REMOVED***  // namespace internal
***REMOVED***  // namespace testing

void DieWithMessage(const ::std::string& message) ***REMOVED***
  fprintf(stderr, "%s", message.c_str());
  fflush(stderr);  // Make sure the text is printed before the process exits.

  // We call _exit() instead of exit(), as the former is a direct
  // system call and thus safer in the presence of threads.  exit()
  // will invoke user-defined exit-hooks, which may do dangerous
  // things that conflict with death tests.
  //
  // Some compilers can recognize that _exit() never returns and issue the
  // 'unreachable code' warning for code following this function, unless
  // fooled by a fake condition.
  if (AlwaysTrue())
    _exit(1);
***REMOVED***

void DieInside(const ::std::string& function) ***REMOVED***
  DieWithMessage("death inside " + function + "().");
***REMOVED***

// Tests that death tests work.

class TestForDeathTest : public testing::Test ***REMOVED***
 protected:
  TestForDeathTest() : original_dir_(FilePath::GetCurrentDir()) ***REMOVED******REMOVED***

  virtual ~TestForDeathTest() ***REMOVED***
    posix::ChDir(original_dir_.c_str());
  ***REMOVED***

  // A static member function that's expected to die.
  static void StaticMemberFunction() ***REMOVED*** DieInside("StaticMemberFunction"); ***REMOVED***

  // A method of the test fixture that may die.
  void MemberFunction() ***REMOVED***
    if (should_die_)
      DieInside("MemberFunction");
  ***REMOVED***

  // True iff MemberFunction() should die.
  bool should_die_;
  const FilePath original_dir_;
***REMOVED***;

// A class with a member function that may die.
class MayDie ***REMOVED***
 public:
  explicit MayDie(bool should_die) : should_die_(should_die) ***REMOVED******REMOVED***

  // A member function that may die.
  void MemberFunction() const ***REMOVED***
    if (should_die_)
      DieInside("MayDie::MemberFunction");
  ***REMOVED***

 private:
  // True iff MemberFunction() should die.
  bool should_die_;
***REMOVED***;

// A global function that's expected to die.
void GlobalFunction() ***REMOVED*** DieInside("GlobalFunction"); ***REMOVED***

// A non-void function that's expected to die.
int NonVoidFunction() ***REMOVED***
  DieInside("NonVoidFunction");
  return 1;
***REMOVED***

// A unary function that may die.
void DieIf(bool should_die) ***REMOVED***
  if (should_die)
    DieInside("DieIf");
***REMOVED***

// A binary function that may die.
bool DieIfLessThan(int x, int y) ***REMOVED***
  if (x < y) ***REMOVED***
    DieInside("DieIfLessThan");
  ***REMOVED***
  return true;
***REMOVED***

// Tests that ASSERT_DEATH can be used outside a TEST, TEST_F, or test fixture.
void DeathTestSubroutine() ***REMOVED***
  EXPECT_DEATH(GlobalFunction(), "death.*GlobalFunction");
  ASSERT_DEATH(GlobalFunction(), "death.*GlobalFunction");
***REMOVED***

// Death in dbg, not opt.
int DieInDebugElse12(int* sideeffect) ***REMOVED***
  if (sideeffect) *sideeffect = 12;

# ifndef NDEBUG

  DieInside("DieInDebugElse12");

# endif  // NDEBUG

  return 12;
***REMOVED***

# if GTEST_OS_WINDOWS

// Tests the ExitedWithCode predicate.
TEST(ExitStatusPredicateTest, ExitedWithCode) ***REMOVED***
  // On Windows, the process's exit code is the same as its exit status,
  // so the predicate just compares the its input with its parameter.
  EXPECT_TRUE(testing::ExitedWithCode(0)(0));
  EXPECT_TRUE(testing::ExitedWithCode(1)(1));
  EXPECT_TRUE(testing::ExitedWithCode(42)(42));
  EXPECT_FALSE(testing::ExitedWithCode(0)(1));
  EXPECT_FALSE(testing::ExitedWithCode(1)(0));
***REMOVED***

# else

// Returns the exit status of a process that calls _exit(2) with a
// given exit code.  This is a helper function for the
// ExitStatusPredicateTest test suite.
static int NormalExitStatus(int exit_code) ***REMOVED***
  pid_t child_pid = fork();
  if (child_pid == 0) ***REMOVED***
    _exit(exit_code);
  ***REMOVED***
  int status;
  waitpid(child_pid, &status, 0);
  return status;
***REMOVED***

// Returns the exit status of a process that raises a given signal.
// If the signal does not cause the process to die, then it returns
// instead the exit status of a process that exits normally with exit
// code 1.  This is a helper function for the ExitStatusPredicateTest
// test suite.
static int KilledExitStatus(int signum) ***REMOVED***
  pid_t child_pid = fork();
  if (child_pid == 0) ***REMOVED***
    raise(signum);
    _exit(1);
  ***REMOVED***
  int status;
  waitpid(child_pid, &status, 0);
  return status;
***REMOVED***

// Tests the ExitedWithCode predicate.
TEST(ExitStatusPredicateTest, ExitedWithCode) ***REMOVED***
  const int status0  = NormalExitStatus(0);
  const int status1  = NormalExitStatus(1);
  const int status42 = NormalExitStatus(42);
  const testing::ExitedWithCode pred0(0);
  const testing::ExitedWithCode pred1(1);
  const testing::ExitedWithCode pred42(42);
  EXPECT_PRED1(pred0,  status0);
  EXPECT_PRED1(pred1,  status1);
  EXPECT_PRED1(pred42, status42);
  EXPECT_FALSE(pred0(status1));
  EXPECT_FALSE(pred42(status0));
  EXPECT_FALSE(pred1(status42));
***REMOVED***

// Tests the KilledBySignal predicate.
TEST(ExitStatusPredicateTest, KilledBySignal) ***REMOVED***
  const int status_segv = KilledExitStatus(SIGSEGV);
  const int status_kill = KilledExitStatus(SIGKILL);
  const testing::KilledBySignal pred_segv(SIGSEGV);
  const testing::KilledBySignal pred_kill(SIGKILL);
  EXPECT_PRED1(pred_segv, status_segv);
  EXPECT_PRED1(pred_kill, status_kill);
  EXPECT_FALSE(pred_segv(status_kill));
  EXPECT_FALSE(pred_kill(status_segv));
***REMOVED***

# endif  // GTEST_OS_WINDOWS

// Tests that the death test macros expand to code which may or may not
// be followed by operator<<, and that in either case the complete text
// comprises only a single C++ statement.
TEST_F(TestForDeathTest, SingleStatement) ***REMOVED***
  if (AlwaysFalse())
    // This would fail if executed; this is a compilation test only
    ASSERT_DEATH(return, "");

  if (AlwaysTrue())
    EXPECT_DEATH(_exit(1), "");
  else
    // This empty "else" branch is meant to ensure that EXPECT_DEATH
    // doesn't expand into an "if" statement without an "else"
    ;

  if (AlwaysFalse())
    ASSERT_DEATH(return, "") << "did not die";

  if (AlwaysFalse())
    ;
  else
    EXPECT_DEATH(_exit(1), "") << 1 << 2 << 3;
***REMOVED***

void DieWithEmbeddedNul() ***REMOVED***
  fprintf(stderr, "Hello%cmy null world.\n", '\0');
  fflush(stderr);
  _exit(1);
***REMOVED***

# if GTEST_USES_PCRE
// Tests that EXPECT_DEATH and ASSERT_DEATH work when the error
// message has a NUL character in it.
TEST_F(TestForDeathTest, EmbeddedNulInMessage) ***REMOVED***
  // TODO(wan@google.com): <regex.h> doesn't support matching strings
  // with embedded NUL characters - find a way to workaround it.
  EXPECT_DEATH(DieWithEmbeddedNul(), "my null world");
  ASSERT_DEATH(DieWithEmbeddedNul(), "my null world");
***REMOVED***
# endif  // GTEST_USES_PCRE

// Tests that death test macros expand to code which interacts well with switch
// statements.
TEST_F(TestForDeathTest, SwitchStatement) ***REMOVED***
  // Microsoft compiler usually complains about switch statements without
  // case labels. We suppress that warning for this test.
  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4065)

  switch (0)
    default:
      ASSERT_DEATH(_exit(1), "") << "exit in default switch handler";

  switch (0)
    case 0:
      EXPECT_DEATH(_exit(1), "") << "exit in switch case";

  GTEST_DISABLE_MSC_WARNINGS_POP_()
***REMOVED***

// Tests that a static member function can be used in a "fast" style
// death test.
TEST_F(TestForDeathTest, StaticMemberFunctionFastStyle) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";
  ASSERT_DEATH(StaticMemberFunction(), "death.*StaticMember");
***REMOVED***

// Tests that a method of the test fixture can be used in a "fast"
// style death test.
TEST_F(TestForDeathTest, MemberFunctionFastStyle) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";
  should_die_ = true;
  EXPECT_DEATH(MemberFunction(), "inside.*MemberFunction");
***REMOVED***

void ChangeToRootDir() ***REMOVED*** posix::ChDir(GTEST_PATH_SEP_); ***REMOVED***

// Tests that death tests work even if the current directory has been
// changed.
TEST_F(TestForDeathTest, FastDeathTestInChangedDir) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";

  ChangeToRootDir();
  EXPECT_EXIT(_exit(1), testing::ExitedWithCode(1), "");

  ChangeToRootDir();
  ASSERT_DEATH(_exit(1), "");
***REMOVED***

# if GTEST_OS_LINUX
void SigprofAction(int, siginfo_t*, void*) ***REMOVED*** /* no op */ ***REMOVED***

// Sets SIGPROF action and ITIMER_PROF timer (interval: 1ms).
void SetSigprofActionAndTimer() ***REMOVED***
  struct itimerval timer;
  timer.it_interval.tv_sec = 0;
  timer.it_interval.tv_usec = 1;
  timer.it_value = timer.it_interval;
  ASSERT_EQ(0, setitimer(ITIMER_PROF, &timer, NULL));
  struct sigaction signal_action;
  memset(&signal_action, 0, sizeof(signal_action));
  sigemptyset(&signal_action.sa_mask);
  signal_action.sa_sigaction = SigprofAction;
  signal_action.sa_flags = SA_RESTART | SA_SIGINFO;
  ASSERT_EQ(0, sigaction(SIGPROF, &signal_action, NULL));
***REMOVED***

// Disables ITIMER_PROF timer and ignores SIGPROF signal.
void DisableSigprofActionAndTimer(struct sigaction* old_signal_action) ***REMOVED***
  struct itimerval timer;
  timer.it_interval.tv_sec = 0;
  timer.it_interval.tv_usec = 0;
  timer.it_value = timer.it_interval;
  ASSERT_EQ(0, setitimer(ITIMER_PROF, &timer, NULL));
  struct sigaction signal_action;
  memset(&signal_action, 0, sizeof(signal_action));
  sigemptyset(&signal_action.sa_mask);
  signal_action.sa_handler = SIG_IGN;
  ASSERT_EQ(0, sigaction(SIGPROF, &signal_action, old_signal_action));
***REMOVED***

// Tests that death tests work when SIGPROF handler and timer are set.
TEST_F(TestForDeathTest, FastSigprofActionSet) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";
  SetSigprofActionAndTimer();
  EXPECT_DEATH(_exit(1), "");
  struct sigaction old_signal_action;
  DisableSigprofActionAndTimer(&old_signal_action);
  EXPECT_TRUE(old_signal_action.sa_sigaction == SigprofAction);
***REMOVED***

TEST_F(TestForDeathTest, ThreadSafeSigprofActionSet) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "threadsafe";
  SetSigprofActionAndTimer();
  EXPECT_DEATH(_exit(1), "");
  struct sigaction old_signal_action;
  DisableSigprofActionAndTimer(&old_signal_action);
  EXPECT_TRUE(old_signal_action.sa_sigaction == SigprofAction);
***REMOVED***
# endif  // GTEST_OS_LINUX

// Repeats a representative sample of death tests in the "threadsafe" style:

TEST_F(TestForDeathTest, StaticMemberFunctionThreadsafeStyle) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "threadsafe";
  ASSERT_DEATH(StaticMemberFunction(), "death.*StaticMember");
***REMOVED***

TEST_F(TestForDeathTest, MemberFunctionThreadsafeStyle) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "threadsafe";
  should_die_ = true;
  EXPECT_DEATH(MemberFunction(), "inside.*MemberFunction");
***REMOVED***

TEST_F(TestForDeathTest, ThreadsafeDeathTestInLoop) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "threadsafe";

  for (int i = 0; i < 3; ++i)
    EXPECT_EXIT(_exit(i), testing::ExitedWithCode(i), "") << ": i = " << i;
***REMOVED***

TEST_F(TestForDeathTest, ThreadsafeDeathTestInChangedDir) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "threadsafe";

  ChangeToRootDir();
  EXPECT_EXIT(_exit(1), testing::ExitedWithCode(1), "");

  ChangeToRootDir();
  ASSERT_DEATH(_exit(1), "");
***REMOVED***

TEST_F(TestForDeathTest, MixedStyles) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "threadsafe";
  EXPECT_DEATH(_exit(1), "");
  testing::GTEST_FLAG(death_test_style) = "fast";
  EXPECT_DEATH(_exit(1), "");
***REMOVED***

# if GTEST_HAS_CLONE && GTEST_HAS_PTHREAD

namespace ***REMOVED***

bool pthread_flag;

void SetPthreadFlag() ***REMOVED***
  pthread_flag = true;
***REMOVED***

***REMOVED***  // namespace

TEST_F(TestForDeathTest, DoesNotExecuteAtforkHooks) ***REMOVED***
  if (!testing::GTEST_FLAG(death_test_use_fork)) ***REMOVED***
    testing::GTEST_FLAG(death_test_style) = "threadsafe";
    pthread_flag = false;
    ASSERT_EQ(0, pthread_atfork(&SetPthreadFlag, NULL, NULL));
    ASSERT_DEATH(_exit(1), "");
    ASSERT_FALSE(pthread_flag);
  ***REMOVED***
***REMOVED***

# endif  // GTEST_HAS_CLONE && GTEST_HAS_PTHREAD

// Tests that a method of another class can be used in a death test.
TEST_F(TestForDeathTest, MethodOfAnotherClass) ***REMOVED***
  const MayDie x(true);
  ASSERT_DEATH(x.MemberFunction(), "MayDie\\:\\:MemberFunction");
***REMOVED***

// Tests that a global function can be used in a death test.
TEST_F(TestForDeathTest, GlobalFunction) ***REMOVED***
  EXPECT_DEATH(GlobalFunction(), "GlobalFunction");
***REMOVED***

// Tests that any value convertible to an RE works as a second
// argument to EXPECT_DEATH.
TEST_F(TestForDeathTest, AcceptsAnythingConvertibleToRE) ***REMOVED***
  static const char regex_c_str[] = "GlobalFunction";
  EXPECT_DEATH(GlobalFunction(), regex_c_str);

  const testing::internal::RE regex(regex_c_str);
  EXPECT_DEATH(GlobalFunction(), regex);

# if GTEST_HAS_GLOBAL_STRING

  const string regex_str(regex_c_str);
  EXPECT_DEATH(GlobalFunction(), regex_str);

# endif  // GTEST_HAS_GLOBAL_STRING

# if !GTEST_USES_PCRE

  const ::std::string regex_std_str(regex_c_str);
  EXPECT_DEATH(GlobalFunction(), regex_std_str);

# endif  // !GTEST_USES_PCRE
***REMOVED***

// Tests that a non-void function can be used in a death test.
TEST_F(TestForDeathTest, NonVoidFunction) ***REMOVED***
  ASSERT_DEATH(NonVoidFunction(), "NonVoidFunction");
***REMOVED***

// Tests that functions that take parameter(s) can be used in a death test.
TEST_F(TestForDeathTest, FunctionWithParameter) ***REMOVED***
  EXPECT_DEATH(DieIf(true), "DieIf\\(\\)");
  EXPECT_DEATH(DieIfLessThan(2, 3), "DieIfLessThan");
***REMOVED***

// Tests that ASSERT_DEATH can be used outside a TEST, TEST_F, or test fixture.
TEST_F(TestForDeathTest, OutsideFixture) ***REMOVED***
  DeathTestSubroutine();
***REMOVED***

// Tests that death tests can be done inside a loop.
TEST_F(TestForDeathTest, InsideLoop) ***REMOVED***
  for (int i = 0; i < 5; i++) ***REMOVED***
    EXPECT_DEATH(DieIfLessThan(-1, i), "DieIfLessThan") << "where i == " << i;
  ***REMOVED***
***REMOVED***

// Tests that a compound statement can be used in a death test.
TEST_F(TestForDeathTest, CompoundStatement) ***REMOVED***
  EXPECT_DEATH(***REMOVED***  // NOLINT
    const int x = 2;
    const int y = x + 1;
    DieIfLessThan(x, y);
  ***REMOVED***,
  "DieIfLessThan");
***REMOVED***

// Tests that code that doesn't die causes a death test to fail.
TEST_F(TestForDeathTest, DoesNotDie) ***REMOVED***
  EXPECT_NONFATAL_FAILURE(EXPECT_DEATH(DieIf(false), "DieIf"),
                          "failed to die");
***REMOVED***

// Tests that a death test fails when the error message isn't expected.
TEST_F(TestForDeathTest, ErrorMessageMismatch) ***REMOVED***
  EXPECT_NONFATAL_FAILURE(***REMOVED***  // NOLINT
    EXPECT_DEATH(DieIf(true), "DieIfLessThan") << "End of death test message.";
  ***REMOVED***, "died but not with expected error");
***REMOVED***

// On exit, *aborted will be true iff the EXPECT_DEATH() statement
// aborted the function.
void ExpectDeathTestHelper(bool* aborted) ***REMOVED***
  *aborted = true;
  EXPECT_DEATH(DieIf(false), "DieIf");  // This assertion should fail.
  *aborted = false;
***REMOVED***

// Tests that EXPECT_DEATH doesn't abort the test on failure.
TEST_F(TestForDeathTest, EXPECT_DEATH) ***REMOVED***
  bool aborted = true;
  EXPECT_NONFATAL_FAILURE(ExpectDeathTestHelper(&aborted),
                          "failed to die");
  EXPECT_FALSE(aborted);
***REMOVED***

// Tests that ASSERT_DEATH does abort the test on failure.
TEST_F(TestForDeathTest, ASSERT_DEATH) ***REMOVED***
  static bool aborted;
  EXPECT_FATAL_FAILURE(***REMOVED***  // NOLINT
    aborted = true;
    ASSERT_DEATH(DieIf(false), "DieIf");  // This assertion should fail.
    aborted = false;
  ***REMOVED***, "failed to die");
  EXPECT_TRUE(aborted);
***REMOVED***

// Tests that EXPECT_DEATH evaluates the arguments exactly once.
TEST_F(TestForDeathTest, SingleEvaluation) ***REMOVED***
  int x = 3;
  EXPECT_DEATH(DieIf((++x) == 4), "DieIf");

  const char* regex = "DieIf";
  const char* regex_save = regex;
  EXPECT_DEATH(DieIfLessThan(3, 4), regex++);
  EXPECT_EQ(regex_save + 1, regex);
***REMOVED***

// Tests that run-away death tests are reported as failures.
TEST_F(TestForDeathTest, RunawayIsFailure) ***REMOVED***
  EXPECT_NONFATAL_FAILURE(EXPECT_DEATH(static_cast<void>(0), "Foo"),
                          "failed to die.");
***REMOVED***

// Tests that death tests report executing 'return' in the statement as
// failure.
TEST_F(TestForDeathTest, ReturnIsFailure) ***REMOVED***
  EXPECT_FATAL_FAILURE(ASSERT_DEATH(return, "Bar"),
                       "illegal return in test statement.");
***REMOVED***

// Tests that EXPECT_DEBUG_DEATH works as expected, that is, you can stream a
// message to it, and in debug mode it:
// 1. Asserts on death.
// 2. Has no side effect.
//
// And in opt mode, it:
// 1.  Has side effects but does not assert.
TEST_F(TestForDeathTest, TestExpectDebugDeath) ***REMOVED***
  int sideeffect = 0;

  EXPECT_DEBUG_DEATH(DieInDebugElse12(&sideeffect), "death.*DieInDebugElse12")
      << "Must accept a streamed message";

# ifdef NDEBUG

  // Checks that the assignment occurs in opt mode (sideeffect).
  EXPECT_EQ(12, sideeffect);

# else

  // Checks that the assignment does not occur in dbg mode (no sideeffect).
  EXPECT_EQ(0, sideeffect);

# endif
***REMOVED***

// Tests that ASSERT_DEBUG_DEATH works as expected, that is, you can stream a
// message to it, and in debug mode it:
// 1. Asserts on death.
// 2. Has no side effect.
//
// And in opt mode, it:
// 1.  Has side effects but does not assert.
TEST_F(TestForDeathTest, TestAssertDebugDeath) ***REMOVED***
  int sideeffect = 0;

  ASSERT_DEBUG_DEATH(DieInDebugElse12(&sideeffect), "death.*DieInDebugElse12")
      << "Must accept a streamed message";

# ifdef NDEBUG

  // Checks that the assignment occurs in opt mode (sideeffect).
  EXPECT_EQ(12, sideeffect);

# else

  // Checks that the assignment does not occur in dbg mode (no sideeffect).
  EXPECT_EQ(0, sideeffect);

# endif
***REMOVED***

# ifndef NDEBUG

void ExpectDebugDeathHelper(bool* aborted) ***REMOVED***
  *aborted = true;
  EXPECT_DEBUG_DEATH(return, "") << "This is expected to fail.";
  *aborted = false;
***REMOVED***

#  if GTEST_OS_WINDOWS
TEST(PopUpDeathTest, DoesNotShowPopUpOnAbort) ***REMOVED***
  printf("This test should be considered failing if it shows "
         "any pop-up dialogs.\n");
  fflush(stdout);

  EXPECT_DEATH(***REMOVED***
    testing::GTEST_FLAG(catch_exceptions) = false;
    abort();
  ***REMOVED***, "");
***REMOVED***
#  endif  // GTEST_OS_WINDOWS

// Tests that EXPECT_DEBUG_DEATH in debug mode does not abort
// the function.
TEST_F(TestForDeathTest, ExpectDebugDeathDoesNotAbort) ***REMOVED***
  bool aborted = true;
  EXPECT_NONFATAL_FAILURE(ExpectDebugDeathHelper(&aborted), "");
  EXPECT_FALSE(aborted);
***REMOVED***

void AssertDebugDeathHelper(bool* aborted) ***REMOVED***
  *aborted = true;
  GTEST_LOG_(INFO) << "Before ASSERT_DEBUG_DEATH";
  ASSERT_DEBUG_DEATH(GTEST_LOG_(INFO) << "In ASSERT_DEBUG_DEATH"; return, "")
      << "This is expected to fail.";
  GTEST_LOG_(INFO) << "After ASSERT_DEBUG_DEATH";
  *aborted = false;
***REMOVED***

// Tests that ASSERT_DEBUG_DEATH in debug mode aborts the function on
// failure.
TEST_F(TestForDeathTest, AssertDebugDeathAborts) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

TEST_F(TestForDeathTest, AssertDebugDeathAborts2) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

TEST_F(TestForDeathTest, AssertDebugDeathAborts3) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

TEST_F(TestForDeathTest, AssertDebugDeathAborts4) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

TEST_F(TestForDeathTest, AssertDebugDeathAborts5) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

TEST_F(TestForDeathTest, AssertDebugDeathAborts6) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

TEST_F(TestForDeathTest, AssertDebugDeathAborts7) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

TEST_F(TestForDeathTest, AssertDebugDeathAborts8) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

TEST_F(TestForDeathTest, AssertDebugDeathAborts9) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

TEST_F(TestForDeathTest, AssertDebugDeathAborts10) ***REMOVED***
  static bool aborted;
  aborted = false;
  EXPECT_FATAL_FAILURE(AssertDebugDeathHelper(&aborted), "");
  EXPECT_TRUE(aborted);
***REMOVED***

# endif  // _NDEBUG

// Tests the *_EXIT family of macros, using a variety of predicates.
static void TestExitMacros() ***REMOVED***
  EXPECT_EXIT(_exit(1),  testing::ExitedWithCode(1),  "");
  ASSERT_EXIT(_exit(42), testing::ExitedWithCode(42), "");

# if GTEST_OS_WINDOWS

  // Of all signals effects on the process exit code, only those of SIGABRT
  // are documented on Windows.
  // See http://msdn.microsoft.com/en-us/library/dwwzkt4c(VS.71).aspx.
  EXPECT_EXIT(raise(SIGABRT), testing::ExitedWithCode(3), "") << "b_ar";

# else

  EXPECT_EXIT(raise(SIGKILL), testing::KilledBySignal(SIGKILL), "") << "foo";
  ASSERT_EXIT(raise(SIGUSR2), testing::KilledBySignal(SIGUSR2), "") << "bar";

  EXPECT_FATAL_FAILURE(***REMOVED***  // NOLINT
    ASSERT_EXIT(_exit(0), testing::KilledBySignal(SIGSEGV), "")
      << "This failure is expected, too.";
  ***REMOVED***, "This failure is expected, too.");

# endif  // GTEST_OS_WINDOWS

  EXPECT_NONFATAL_FAILURE(***REMOVED***  // NOLINT
    EXPECT_EXIT(raise(SIGSEGV), testing::ExitedWithCode(0), "")
      << "This failure is expected.";
  ***REMOVED***, "This failure is expected.");
***REMOVED***

TEST_F(TestForDeathTest, ExitMacros) ***REMOVED***
  TestExitMacros();
***REMOVED***

TEST_F(TestForDeathTest, ExitMacrosUsingFork) ***REMOVED***
  testing::GTEST_FLAG(death_test_use_fork) = true;
  TestExitMacros();
***REMOVED***

TEST_F(TestForDeathTest, InvalidStyle) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "rococo";
  EXPECT_NONFATAL_FAILURE(***REMOVED***  // NOLINT
    EXPECT_DEATH(_exit(0), "") << "This failure is expected.";
  ***REMOVED***, "This failure is expected.");
***REMOVED***

TEST_F(TestForDeathTest, DeathTestFailedOutput) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";
  EXPECT_NONFATAL_FAILURE(
      EXPECT_DEATH(DieWithMessage("death\n"),
                   "expected message"),
      "Actual msg:\n"
      "[  DEATH   ] death\n");
***REMOVED***

TEST_F(TestForDeathTest, DeathTestUnexpectedReturnOutput) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";
  EXPECT_NONFATAL_FAILURE(
      EXPECT_DEATH(***REMOVED***
          fprintf(stderr, "returning\n");
          fflush(stderr);
          return;
        ***REMOVED***, ""),
      "    Result: illegal return in test statement.\n"
      " Error msg:\n"
      "[  DEATH   ] returning\n");
***REMOVED***

TEST_F(TestForDeathTest, DeathTestBadExitCodeOutput) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";
  EXPECT_NONFATAL_FAILURE(
      EXPECT_EXIT(DieWithMessage("exiting with rc 1\n"),
                  testing::ExitedWithCode(3),
                  "expected message"),
      "    Result: died but not with expected exit code:\n"
      "            Exited with exit status 1\n"
      "Actual msg:\n"
      "[  DEATH   ] exiting with rc 1\n");
***REMOVED***

TEST_F(TestForDeathTest, DeathTestMultiLineMatchFail) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";
  EXPECT_NONFATAL_FAILURE(
      EXPECT_DEATH(DieWithMessage("line 1\nline 2\nline 3\n"),
                   "line 1\nxyz\nline 3\n"),
      "Actual msg:\n"
      "[  DEATH   ] line 1\n"
      "[  DEATH   ] line 2\n"
      "[  DEATH   ] line 3\n");
***REMOVED***

TEST_F(TestForDeathTest, DeathTestMultiLineMatchPass) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";
  EXPECT_DEATH(DieWithMessage("line 1\nline 2\nline 3\n"),
               "line 1\nline 2\nline 3\n");
***REMOVED***

// A DeathTestFactory that returns MockDeathTests.
class MockDeathTestFactory : public DeathTestFactory ***REMOVED***
 public:
  MockDeathTestFactory();
  virtual bool Create(const char* statement,
                      const ::testing::internal::RE* regex,
                      const char* file, int line, DeathTest** test);

  // Sets the parameters for subsequent calls to Create.
  void SetParameters(bool create, DeathTest::TestRole role,
                     int status, bool passed);

  // Accessors.
  int AssumeRoleCalls() const ***REMOVED*** return assume_role_calls_; ***REMOVED***
  int WaitCalls() const ***REMOVED*** return wait_calls_; ***REMOVED***
  size_t PassedCalls() const ***REMOVED*** return passed_args_.size(); ***REMOVED***
  bool PassedArgument(int n) const ***REMOVED*** return passed_args_[n]; ***REMOVED***
  size_t AbortCalls() const ***REMOVED*** return abort_args_.size(); ***REMOVED***
  DeathTest::AbortReason AbortArgument(int n) const ***REMOVED***
    return abort_args_[n];
  ***REMOVED***
  bool TestDeleted() const ***REMOVED*** return test_deleted_; ***REMOVED***

 private:
  friend class MockDeathTest;
  // If true, Create will return a MockDeathTest; otherwise it returns
  // NULL.
  bool create_;
  // The value a MockDeathTest will return from its AssumeRole method.
  DeathTest::TestRole role_;
  // The value a MockDeathTest will return from its Wait method.
  int status_;
  // The value a MockDeathTest will return from its Passed method.
  bool passed_;

  // Number of times AssumeRole was called.
  int assume_role_calls_;
  // Number of times Wait was called.
  int wait_calls_;
  // The arguments to the calls to Passed since the last call to
  // SetParameters.
  std::vector<bool> passed_args_;
  // The arguments to the calls to Abort since the last call to
  // SetParameters.
  std::vector<DeathTest::AbortReason> abort_args_;
  // True if the last MockDeathTest returned by Create has been
  // deleted.
  bool test_deleted_;
***REMOVED***;


// A DeathTest implementation useful in testing.  It returns values set
// at its creation from its various inherited DeathTest methods, and
// reports calls to those methods to its parent MockDeathTestFactory
// object.
class MockDeathTest : public DeathTest ***REMOVED***
 public:
  MockDeathTest(MockDeathTestFactory *parent,
                TestRole role, int status, bool passed) :
      parent_(parent), role_(role), status_(status), passed_(passed) ***REMOVED***
  ***REMOVED***
  virtual ~MockDeathTest() ***REMOVED***
    parent_->test_deleted_ = true;
  ***REMOVED***
  virtual TestRole AssumeRole() ***REMOVED***
    ++parent_->assume_role_calls_;
    return role_;
  ***REMOVED***
  virtual int Wait() ***REMOVED***
    ++parent_->wait_calls_;
    return status_;
  ***REMOVED***
  virtual bool Passed(bool exit_status_ok) ***REMOVED***
    parent_->passed_args_.push_back(exit_status_ok);
    return passed_;
  ***REMOVED***
  virtual void Abort(AbortReason reason) ***REMOVED***
    parent_->abort_args_.push_back(reason);
  ***REMOVED***

 private:
  MockDeathTestFactory* const parent_;
  const TestRole role_;
  const int status_;
  const bool passed_;
***REMOVED***;


// MockDeathTestFactory constructor.
MockDeathTestFactory::MockDeathTestFactory()
    : create_(true),
      role_(DeathTest::OVERSEE_TEST),
      status_(0),
      passed_(true),
      assume_role_calls_(0),
      wait_calls_(0),
      passed_args_(),
      abort_args_() ***REMOVED***
***REMOVED***


// Sets the parameters for subsequent calls to Create.
void MockDeathTestFactory::SetParameters(bool create,
                                         DeathTest::TestRole role,
                                         int status, bool passed) ***REMOVED***
  create_ = create;
  role_ = role;
  status_ = status;
  passed_ = passed;

  assume_role_calls_ = 0;
  wait_calls_ = 0;
  passed_args_.clear();
  abort_args_.clear();
***REMOVED***


// Sets test to NULL (if create_ is false) or to the address of a new
// MockDeathTest object with parameters taken from the last call
// to SetParameters (if create_ is true).  Always returns true.
bool MockDeathTestFactory::Create(const char* /*statement*/,
                                  const ::testing::internal::RE* /*regex*/,
                                  const char* /*file*/,
                                  int /*line*/,
                                  DeathTest** test) ***REMOVED***
  test_deleted_ = false;
  if (create_) ***REMOVED***
    *test = new MockDeathTest(this, role_, status_, passed_);
  ***REMOVED*** else ***REMOVED***
    *test = NULL;
  ***REMOVED***
  return true;
***REMOVED***

// A test fixture for testing the logic of the GTEST_DEATH_TEST_ macro.
// It installs a MockDeathTestFactory that is used for the duration
// of the test case.
class MacroLogicDeathTest : public testing::Test ***REMOVED***
 protected:
  static testing::internal::ReplaceDeathTestFactory* replacer_;
  static MockDeathTestFactory* factory_;

  static void SetUpTestCase() ***REMOVED***
    factory_ = new MockDeathTestFactory;
    replacer_ = new testing::internal::ReplaceDeathTestFactory(factory_);
  ***REMOVED***

  static void TearDownTestCase() ***REMOVED***
    delete replacer_;
    replacer_ = NULL;
    delete factory_;
    factory_ = NULL;
  ***REMOVED***

  // Runs a death test that breaks the rules by returning.  Such a death
  // test cannot be run directly from a test routine that uses a
  // MockDeathTest, or the remainder of the routine will not be executed.
  static void RunReturningDeathTest(bool* flag) ***REMOVED***
    ASSERT_DEATH(***REMOVED***  // NOLINT
      *flag = true;
      return;
    ***REMOVED***, "");
  ***REMOVED***
***REMOVED***;

testing::internal::ReplaceDeathTestFactory* MacroLogicDeathTest::replacer_
    = NULL;
MockDeathTestFactory* MacroLogicDeathTest::factory_ = NULL;


// Test that nothing happens when the factory doesn't return a DeathTest:
TEST_F(MacroLogicDeathTest, NothingHappens) ***REMOVED***
  bool flag = false;
  factory_->SetParameters(false, DeathTest::OVERSEE_TEST, 0, true);
  EXPECT_DEATH(flag = true, "");
  EXPECT_FALSE(flag);
  EXPECT_EQ(0, factory_->AssumeRoleCalls());
  EXPECT_EQ(0, factory_->WaitCalls());
  EXPECT_EQ(0U, factory_->PassedCalls());
  EXPECT_EQ(0U, factory_->AbortCalls());
  EXPECT_FALSE(factory_->TestDeleted());
***REMOVED***

// Test that the parent process doesn't run the death test code,
// and that the Passed method returns false when the (simulated)
// child process exits with status 0:
TEST_F(MacroLogicDeathTest, ChildExitsSuccessfully) ***REMOVED***
  bool flag = false;
  factory_->SetParameters(true, DeathTest::OVERSEE_TEST, 0, true);
  EXPECT_DEATH(flag = true, "");
  EXPECT_FALSE(flag);
  EXPECT_EQ(1, factory_->AssumeRoleCalls());
  EXPECT_EQ(1, factory_->WaitCalls());
  ASSERT_EQ(1U, factory_->PassedCalls());
  EXPECT_FALSE(factory_->PassedArgument(0));
  EXPECT_EQ(0U, factory_->AbortCalls());
  EXPECT_TRUE(factory_->TestDeleted());
***REMOVED***

// Tests that the Passed method was given the argument "true" when
// the (simulated) child process exits with status 1:
TEST_F(MacroLogicDeathTest, ChildExitsUnsuccessfully) ***REMOVED***
  bool flag = false;
  factory_->SetParameters(true, DeathTest::OVERSEE_TEST, 1, true);
  EXPECT_DEATH(flag = true, "");
  EXPECT_FALSE(flag);
  EXPECT_EQ(1, factory_->AssumeRoleCalls());
  EXPECT_EQ(1, factory_->WaitCalls());
  ASSERT_EQ(1U, factory_->PassedCalls());
  EXPECT_TRUE(factory_->PassedArgument(0));
  EXPECT_EQ(0U, factory_->AbortCalls());
  EXPECT_TRUE(factory_->TestDeleted());
***REMOVED***

// Tests that the (simulated) child process executes the death test
// code, and is aborted with the correct AbortReason if it
// executes a return statement.
TEST_F(MacroLogicDeathTest, ChildPerformsReturn) ***REMOVED***
  bool flag = false;
  factory_->SetParameters(true, DeathTest::EXECUTE_TEST, 0, true);
  RunReturningDeathTest(&flag);
  EXPECT_TRUE(flag);
  EXPECT_EQ(1, factory_->AssumeRoleCalls());
  EXPECT_EQ(0, factory_->WaitCalls());
  EXPECT_EQ(0U, factory_->PassedCalls());
  EXPECT_EQ(1U, factory_->AbortCalls());
  EXPECT_EQ(DeathTest::TEST_ENCOUNTERED_RETURN_STATEMENT,
            factory_->AbortArgument(0));
  EXPECT_TRUE(factory_->TestDeleted());
***REMOVED***

// Tests that the (simulated) child process is aborted with the
// correct AbortReason if it does not die.
TEST_F(MacroLogicDeathTest, ChildDoesNotDie) ***REMOVED***
  bool flag = false;
  factory_->SetParameters(true, DeathTest::EXECUTE_TEST, 0, true);
  EXPECT_DEATH(flag = true, "");
  EXPECT_TRUE(flag);
  EXPECT_EQ(1, factory_->AssumeRoleCalls());
  EXPECT_EQ(0, factory_->WaitCalls());
  EXPECT_EQ(0U, factory_->PassedCalls());
  // This time there are two calls to Abort: one since the test didn't
  // die, and another from the ReturnSentinel when it's destroyed.  The
  // sentinel normally isn't destroyed if a test doesn't die, since
  // _exit(2) is called in that case by ForkingDeathTest, but not by
  // our MockDeathTest.
  ASSERT_EQ(2U, factory_->AbortCalls());
  EXPECT_EQ(DeathTest::TEST_DID_NOT_DIE,
            factory_->AbortArgument(0));
  EXPECT_EQ(DeathTest::TEST_ENCOUNTERED_RETURN_STATEMENT,
            factory_->AbortArgument(1));
  EXPECT_TRUE(factory_->TestDeleted());
***REMOVED***

// Tests that a successful death test does not register a successful
// test part.
TEST(SuccessRegistrationDeathTest, NoSuccessPart) ***REMOVED***
  EXPECT_DEATH(_exit(1), "");
  EXPECT_EQ(0, GetUnitTestImpl()->current_test_result()->total_part_count());
***REMOVED***

TEST(StreamingAssertionsDeathTest, DeathTest) ***REMOVED***
  EXPECT_DEATH(_exit(1), "") << "unexpected failure";
  ASSERT_DEATH(_exit(1), "") << "unexpected failure";
  EXPECT_NONFATAL_FAILURE(***REMOVED***  // NOLINT
    EXPECT_DEATH(_exit(0), "") << "expected failure";
  ***REMOVED***, "expected failure");
  EXPECT_FATAL_FAILURE(***REMOVED***  // NOLINT
    ASSERT_DEATH(_exit(0), "") << "expected failure";
  ***REMOVED***, "expected failure");
***REMOVED***

// Tests that GetLastErrnoDescription returns an empty string when the
// last error is 0 and non-empty string when it is non-zero.
TEST(GetLastErrnoDescription, GetLastErrnoDescriptionWorks) ***REMOVED***
  errno = ENOENT;
  EXPECT_STRNE("", GetLastErrnoDescription().c_str());
  errno = 0;
  EXPECT_STREQ("", GetLastErrnoDescription().c_str());
***REMOVED***

# if GTEST_OS_WINDOWS
TEST(AutoHandleTest, AutoHandleWorks) ***REMOVED***
  HANDLE handle = ::CreateEvent(NULL, FALSE, FALSE, NULL);
  ASSERT_NE(INVALID_HANDLE_VALUE, handle);

  // Tests that the AutoHandle is correctly initialized with a handle.
  testing::internal::AutoHandle auto_handle(handle);
  EXPECT_EQ(handle, auto_handle.Get());

  // Tests that Reset assigns INVALID_HANDLE_VALUE.
  // Note that this cannot verify whether the original handle is closed.
  auto_handle.Reset();
  EXPECT_EQ(INVALID_HANDLE_VALUE, auto_handle.Get());

  // Tests that Reset assigns the new handle.
  // Note that this cannot verify whether the original handle is closed.
  handle = ::CreateEvent(NULL, FALSE, FALSE, NULL);
  ASSERT_NE(INVALID_HANDLE_VALUE, handle);
  auto_handle.Reset(handle);
  EXPECT_EQ(handle, auto_handle.Get());

  // Tests that AutoHandle contains INVALID_HANDLE_VALUE by default.
  testing::internal::AutoHandle auto_handle2;
  EXPECT_EQ(INVALID_HANDLE_VALUE, auto_handle2.Get());
***REMOVED***
# endif  // GTEST_OS_WINDOWS

# if GTEST_OS_WINDOWS
typedef unsigned __int64 BiggestParsable;
typedef signed __int64 BiggestSignedParsable;
# else
typedef unsigned long long BiggestParsable;
typedef signed long long BiggestSignedParsable;
# endif  // GTEST_OS_WINDOWS

// We cannot use std::numeric_limits<T>::max() as it clashes with the
// max() macro defined by <windows.h>.
const BiggestParsable kBiggestParsableMax = ULLONG_MAX;
const BiggestSignedParsable kBiggestSignedParsableMax = LLONG_MAX;

TEST(ParseNaturalNumberTest, RejectsInvalidFormat) ***REMOVED***
  BiggestParsable result = 0;

  // Rejects non-numbers.
  EXPECT_FALSE(ParseNaturalNumber("non-number string", &result));

  // Rejects numbers with whitespace prefix.
  EXPECT_FALSE(ParseNaturalNumber(" 123", &result));

  // Rejects negative numbers.
  EXPECT_FALSE(ParseNaturalNumber("-123", &result));

  // Rejects numbers starting with a plus sign.
  EXPECT_FALSE(ParseNaturalNumber("+123", &result));
  errno = 0;
***REMOVED***

TEST(ParseNaturalNumberTest, RejectsOverflownNumbers) ***REMOVED***
  BiggestParsable result = 0;

  EXPECT_FALSE(ParseNaturalNumber("99999999999999999999999", &result));

  signed char char_result = 0;
  EXPECT_FALSE(ParseNaturalNumber("200", &char_result));
  errno = 0;
***REMOVED***

TEST(ParseNaturalNumberTest, AcceptsValidNumbers) ***REMOVED***
  BiggestParsable result = 0;

  result = 0;
  ASSERT_TRUE(ParseNaturalNumber("123", &result));
  EXPECT_EQ(123U, result);

  // Check 0 as an edge case.
  result = 1;
  ASSERT_TRUE(ParseNaturalNumber("0", &result));
  EXPECT_EQ(0U, result);

  result = 1;
  ASSERT_TRUE(ParseNaturalNumber("00000", &result));
  EXPECT_EQ(0U, result);
***REMOVED***

TEST(ParseNaturalNumberTest, AcceptsTypeLimits) ***REMOVED***
  Message msg;
  msg << kBiggestParsableMax;

  BiggestParsable result = 0;
  EXPECT_TRUE(ParseNaturalNumber(msg.GetString(), &result));
  EXPECT_EQ(kBiggestParsableMax, result);

  Message msg2;
  msg2 << kBiggestSignedParsableMax;

  BiggestSignedParsable signed_result = 0;
  EXPECT_TRUE(ParseNaturalNumber(msg2.GetString(), &signed_result));
  EXPECT_EQ(kBiggestSignedParsableMax, signed_result);

  Message msg3;
  msg3 << INT_MAX;

  int int_result = 0;
  EXPECT_TRUE(ParseNaturalNumber(msg3.GetString(), &int_result));
  EXPECT_EQ(INT_MAX, int_result);

  Message msg4;
  msg4 << UINT_MAX;

  unsigned int uint_result = 0;
  EXPECT_TRUE(ParseNaturalNumber(msg4.GetString(), &uint_result));
  EXPECT_EQ(UINT_MAX, uint_result);
***REMOVED***

TEST(ParseNaturalNumberTest, WorksForShorterIntegers) ***REMOVED***
  short short_result = 0;
  ASSERT_TRUE(ParseNaturalNumber("123", &short_result));
  EXPECT_EQ(123, short_result);

  signed char char_result = 0;
  ASSERT_TRUE(ParseNaturalNumber("123", &char_result));
  EXPECT_EQ(123, char_result);
***REMOVED***

# if GTEST_OS_WINDOWS
TEST(EnvironmentTest, HandleFitsIntoSizeT) ***REMOVED***
  // TODO(vladl@google.com): Remove this test after this condition is verified
  // in a static assertion in gtest-death-test.cc in the function
  // GetStatusFileDescriptor.
  ASSERT_TRUE(sizeof(HANDLE) <= sizeof(size_t));
***REMOVED***
# endif  // GTEST_OS_WINDOWS

// Tests that EXPECT_DEATH_IF_SUPPORTED/ASSERT_DEATH_IF_SUPPORTED trigger
// failures when death tests are available on the system.
TEST(ConditionalDeathMacrosDeathTest, ExpectsDeathWhenDeathTestsAvailable) ***REMOVED***
  EXPECT_DEATH_IF_SUPPORTED(DieInside("CondDeathTestExpectMacro"),
                            "death inside CondDeathTestExpectMacro");
  ASSERT_DEATH_IF_SUPPORTED(DieInside("CondDeathTestAssertMacro"),
                            "death inside CondDeathTestAssertMacro");

  // Empty statement will not crash, which must trigger a failure.
  EXPECT_NONFATAL_FAILURE(EXPECT_DEATH_IF_SUPPORTED(;, ""), "");
  EXPECT_FATAL_FAILURE(ASSERT_DEATH_IF_SUPPORTED(;, ""), "");
***REMOVED***

TEST(InDeathTestChildDeathTest, ReportsDeathTestCorrectlyInFastStyle) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "fast";
  EXPECT_FALSE(InDeathTestChild());
  EXPECT_DEATH(***REMOVED***
    fprintf(stderr, InDeathTestChild() ? "Inside" : "Outside");
    fflush(stderr);
    _exit(1);
  ***REMOVED***, "Inside");
***REMOVED***

TEST(InDeathTestChildDeathTest, ReportsDeathTestCorrectlyInThreadSafeStyle) ***REMOVED***
  testing::GTEST_FLAG(death_test_style) = "threadsafe";
  EXPECT_FALSE(InDeathTestChild());
  EXPECT_DEATH(***REMOVED***
    fprintf(stderr, InDeathTestChild() ? "Inside" : "Outside");
    fflush(stderr);
    _exit(1);
  ***REMOVED***, "Inside");
***REMOVED***

#else  // !GTEST_HAS_DEATH_TEST follows

using testing::internal::CaptureStderr;
using testing::internal::GetCapturedStderr;

// Tests that EXPECT_DEATH_IF_SUPPORTED/ASSERT_DEATH_IF_SUPPORTED are still
// defined but do not trigger failures when death tests are not available on
// the system.
TEST(ConditionalDeathMacrosTest, WarnsWhenDeathTestsNotAvailable) ***REMOVED***
  // Empty statement will not crash, but that should not trigger a failure
  // when death tests are not supported.
  CaptureStderr();
  EXPECT_DEATH_IF_SUPPORTED(;, "");
  std::string output = GetCapturedStderr();
  ASSERT_TRUE(NULL != strstr(output.c_str(),
                             "Death tests are not supported on this platform"));
  ASSERT_TRUE(NULL != strstr(output.c_str(), ";"));

  // The streamed message should not be printed as there is no test failure.
  CaptureStderr();
  EXPECT_DEATH_IF_SUPPORTED(;, "") << "streamed message";
  output = GetCapturedStderr();
  ASSERT_TRUE(NULL == strstr(output.c_str(), "streamed message"));

  CaptureStderr();
  ASSERT_DEATH_IF_SUPPORTED(;, "");  // NOLINT
  output = GetCapturedStderr();
  ASSERT_TRUE(NULL != strstr(output.c_str(),
                             "Death tests are not supported on this platform"));
  ASSERT_TRUE(NULL != strstr(output.c_str(), ";"));

  CaptureStderr();
  ASSERT_DEATH_IF_SUPPORTED(;, "") << "streamed message";  // NOLINT
  output = GetCapturedStderr();
  ASSERT_TRUE(NULL == strstr(output.c_str(), "streamed message"));
***REMOVED***

void FuncWithAssert(int* n) ***REMOVED***
  ASSERT_DEATH_IF_SUPPORTED(return;, "");
  (*n)++;
***REMOVED***

// Tests that ASSERT_DEATH_IF_SUPPORTED does not return from the current
// function (as ASSERT_DEATH does) if death tests are not supported.
TEST(ConditionalDeathMacrosTest, AssertDeatDoesNotReturnhIfUnsupported) ***REMOVED***
  int n = 0;
  FuncWithAssert(&n);
  EXPECT_EQ(1, n);
***REMOVED***

#endif  // !GTEST_HAS_DEATH_TEST

// Tests that the death test macros expand to code which may or may not
// be followed by operator<<, and that in either case the complete text
// comprises only a single C++ statement.
//
// The syntax should work whether death tests are available or not.
TEST(ConditionalDeathMacrosSyntaxDeathTest, SingleStatement) ***REMOVED***
  if (AlwaysFalse())
    // This would fail if executed; this is a compilation test only
    ASSERT_DEATH_IF_SUPPORTED(return, "");

  if (AlwaysTrue())
    EXPECT_DEATH_IF_SUPPORTED(_exit(1), "");
  else
    // This empty "else" branch is meant to ensure that EXPECT_DEATH
    // doesn't expand into an "if" statement without an "else"
    ;  // NOLINT

  if (AlwaysFalse())
    ASSERT_DEATH_IF_SUPPORTED(return, "") << "did not die";

  if (AlwaysFalse())
    ;  // NOLINT
  else
    EXPECT_DEATH_IF_SUPPORTED(_exit(1), "") << 1 << 2 << 3;
***REMOVED***

// Tests that conditional death test macros expand to code which interacts
// well with switch statements.
TEST(ConditionalDeathMacrosSyntaxDeathTest, SwitchStatement) ***REMOVED***
  // Microsoft compiler usually complains about switch statements without
  // case labels. We suppress that warning for this test.
  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4065)

  switch (0)
    default:
      ASSERT_DEATH_IF_SUPPORTED(_exit(1), "")
          << "exit in default switch handler";

  switch (0)
    case 0:
      EXPECT_DEATH_IF_SUPPORTED(_exit(1), "") << "exit in switch case";

  GTEST_DISABLE_MSC_WARNINGS_POP_()
***REMOVED***

// Tests that a test case whose name ends with "DeathTest" works fine
// on Windows.
TEST(NotADeathTest, Test) ***REMOVED***
  SUCCEED();
***REMOVED***
