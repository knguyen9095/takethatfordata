// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Author: wan@google.com (Zhanyong Wan)

// Google Test - The Google C++ Testing Framework
//
// This file tests the universal value printer.

#include "gtest/gtest-printers.h"

#include <ctype.h>
#include <limits.h>
#include <string.h>
#include <algorithm>
#include <deque>
#include <list>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

#include "gtest/gtest.h"

// hash_map and hash_set are available under Visual C++, or on Linux.
#if GTEST_HAS_HASH_MAP_
# include <hash_map>            // NOLINT
#endif  // GTEST_HAS_HASH_MAP_
#if GTEST_HAS_HASH_SET_
# include <hash_set>            // NOLINT
#endif  // GTEST_HAS_HASH_SET_

#if GTEST_HAS_STD_FORWARD_LIST_
# include <forward_list> // NOLINT
#endif  // GTEST_HAS_STD_FORWARD_LIST_

// Some user-defined types for testing the universal value printer.

// An anonymous enum type.
enum AnonymousEnum ***REMOVED***
  kAE1 = -1,
  kAE2 = 1
***REMOVED***;

// An enum without a user-defined printer.
enum EnumWithoutPrinter ***REMOVED***
  kEWP1 = -2,
  kEWP2 = 42
***REMOVED***;

// An enum with a << operator.
enum EnumWithStreaming ***REMOVED***
  kEWS1 = 10
***REMOVED***;

std::ostream& operator<<(std::ostream& os, EnumWithStreaming e) ***REMOVED***
  return os << (e == kEWS1 ? "kEWS1" : "invalid");
***REMOVED***

// An enum with a PrintTo() function.
enum EnumWithPrintTo ***REMOVED***
  kEWPT1 = 1
***REMOVED***;

void PrintTo(EnumWithPrintTo e, std::ostream* os) ***REMOVED***
  *os << (e == kEWPT1 ? "kEWPT1" : "invalid");
***REMOVED***

// A class implicitly convertible to BiggestInt.
class BiggestIntConvertible ***REMOVED***
 public:
  operator ::testing::internal::BiggestInt() const ***REMOVED*** return 42; ***REMOVED***
***REMOVED***;

// A user-defined unprintable class template in the global namespace.
template <typename T>
class UnprintableTemplateInGlobal ***REMOVED***
 public:
  UnprintableTemplateInGlobal() : value_() ***REMOVED******REMOVED***
 private:
  T value_;
***REMOVED***;

// A user-defined streamable type in the global namespace.
class StreamableInGlobal ***REMOVED***
 public:
  virtual ~StreamableInGlobal() ***REMOVED******REMOVED***
***REMOVED***;

inline void operator<<(::std::ostream& os, const StreamableInGlobal& /* x */) ***REMOVED***
  os << "StreamableInGlobal";
***REMOVED***

void operator<<(::std::ostream& os, const StreamableInGlobal* /* x */) ***REMOVED***
  os << "StreamableInGlobal*";
***REMOVED***

namespace foo ***REMOVED***

// A user-defined unprintable type in a user namespace.
class UnprintableInFoo ***REMOVED***
 public:
  UnprintableInFoo() : z_(0) ***REMOVED*** memcpy(xy_, "\xEF\x12\x0\x0\x34\xAB\x0\x0", 8); ***REMOVED***
  double z() const ***REMOVED*** return z_; ***REMOVED***
 private:
  char xy_[8];
  double z_;
***REMOVED***;

// A user-defined printable type in a user-chosen namespace.
struct PrintableViaPrintTo ***REMOVED***
  PrintableViaPrintTo() : value() ***REMOVED******REMOVED***
  int value;
***REMOVED***;

void PrintTo(const PrintableViaPrintTo& x, ::std::ostream* os) ***REMOVED***
  *os << "PrintableViaPrintTo: " << x.value;
***REMOVED***

// A type with a user-defined << for printing its pointer.
struct PointerPrintable ***REMOVED***
***REMOVED***;

::std::ostream& operator<<(::std::ostream& os,
                           const PointerPrintable* /* x */) ***REMOVED***
  return os << "PointerPrintable*";
***REMOVED***

// A user-defined printable class template in a user-chosen namespace.
template <typename T>
class PrintableViaPrintToTemplate ***REMOVED***
 public:
  explicit PrintableViaPrintToTemplate(const T& a_value) : value_(a_value) ***REMOVED******REMOVED***

  const T& value() const ***REMOVED*** return value_; ***REMOVED***
 private:
  T value_;
***REMOVED***;

template <typename T>
void PrintTo(const PrintableViaPrintToTemplate<T>& x, ::std::ostream* os) ***REMOVED***
  *os << "PrintableViaPrintToTemplate: " << x.value();
***REMOVED***

// A user-defined streamable class template in a user namespace.
template <typename T>
class StreamableTemplateInFoo ***REMOVED***
 public:
  StreamableTemplateInFoo() : value_() ***REMOVED******REMOVED***

  const T& value() const ***REMOVED*** return value_; ***REMOVED***
 private:
  T value_;
***REMOVED***;

template <typename T>
inline ::std::ostream& operator<<(::std::ostream& os,
                                  const StreamableTemplateInFoo<T>& x) ***REMOVED***
  return os << "StreamableTemplateInFoo: " << x.value();
***REMOVED***

***REMOVED***  // namespace foo

namespace testing ***REMOVED***
namespace gtest_printers_test ***REMOVED***

using ::std::deque;
using ::std::list;
using ::std::make_pair;
using ::std::map;
using ::std::multimap;
using ::std::multiset;
using ::std::pair;
using ::std::set;
using ::std::vector;
using ::testing::PrintToString;
using ::testing::internal::FormatForComparisonFailureMessage;
using ::testing::internal::ImplicitCast_;
using ::testing::internal::NativeArray;
using ::testing::internal::RE;
using ::testing::internal::RelationToSourceReference;
using ::testing::internal::Strings;
using ::testing::internal::UniversalPrint;
using ::testing::internal::UniversalPrinter;
using ::testing::internal::UniversalTersePrint;
#if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_
using ::testing::internal::UniversalTersePrintTupleFieldsToStrings;
#endif
using ::testing::internal::string;

// The hash_* classes are not part of the C++ standard.  STLport
// defines them in namespace std.  MSVC defines them in ::stdext.  GCC
// defines them in ::.
#ifdef _STLP_HASH_MAP  // We got <hash_map> from STLport.
using ::std::hash_map;
using ::std::hash_set;
using ::std::hash_multimap;
using ::std::hash_multiset;
#elif _MSC_VER
using ::stdext::hash_map;
using ::stdext::hash_set;
using ::stdext::hash_multimap;
using ::stdext::hash_multiset;
#endif

// Prints a value to a string using the universal value printer.  This
// is a helper for testing UniversalPrinter<T>::Print() for various types.
template <typename T>
string Print(const T& value) ***REMOVED***
  ::std::stringstream ss;
  UniversalPrinter<T>::Print(value, &ss);
  return ss.str();
***REMOVED***

// Prints a value passed by reference to a string, using the universal
// value printer.  This is a helper for testing
// UniversalPrinter<T&>::Print() for various types.
template <typename T>
string PrintByRef(const T& value) ***REMOVED***
  ::std::stringstream ss;
  UniversalPrinter<T&>::Print(value, &ss);
  return ss.str();
***REMOVED***

// Tests printing various enum types.

TEST(PrintEnumTest, AnonymousEnum) ***REMOVED***
  EXPECT_EQ("-1", Print(kAE1));
  EXPECT_EQ("1", Print(kAE2));
***REMOVED***

TEST(PrintEnumTest, EnumWithoutPrinter) ***REMOVED***
  EXPECT_EQ("-2", Print(kEWP1));
  EXPECT_EQ("42", Print(kEWP2));
***REMOVED***

TEST(PrintEnumTest, EnumWithStreaming) ***REMOVED***
  EXPECT_EQ("kEWS1", Print(kEWS1));
  EXPECT_EQ("invalid", Print(static_cast<EnumWithStreaming>(0)));
***REMOVED***

TEST(PrintEnumTest, EnumWithPrintTo) ***REMOVED***
  EXPECT_EQ("kEWPT1", Print(kEWPT1));
  EXPECT_EQ("invalid", Print(static_cast<EnumWithPrintTo>(0)));
***REMOVED***

// Tests printing a class implicitly convertible to BiggestInt.

TEST(PrintClassTest, BiggestIntConvertible) ***REMOVED***
  EXPECT_EQ("42", Print(BiggestIntConvertible()));
***REMOVED***

// Tests printing various char types.

// char.
TEST(PrintCharTest, PlainChar) ***REMOVED***
  EXPECT_EQ("'\\0'", Print('\0'));
  EXPECT_EQ("'\\'' (39, 0x27)", Print('\''));
  EXPECT_EQ("'\"' (34, 0x22)", Print('"'));
  EXPECT_EQ("'?' (63, 0x3F)", Print('?'));
  EXPECT_EQ("'\\\\' (92, 0x5C)", Print('\\'));
  EXPECT_EQ("'\\a' (7)", Print('\a'));
  EXPECT_EQ("'\\b' (8)", Print('\b'));
  EXPECT_EQ("'\\f' (12, 0xC)", Print('\f'));
  EXPECT_EQ("'\\n' (10, 0xA)", Print('\n'));
  EXPECT_EQ("'\\r' (13, 0xD)", Print('\r'));
  EXPECT_EQ("'\\t' (9)", Print('\t'));
  EXPECT_EQ("'\\v' (11, 0xB)", Print('\v'));
  EXPECT_EQ("'\\x7F' (127)", Print('\x7F'));
  EXPECT_EQ("'\\xFF' (255)", Print('\xFF'));
  EXPECT_EQ("' ' (32, 0x20)", Print(' '));
  EXPECT_EQ("'a' (97, 0x61)", Print('a'));
***REMOVED***

// signed char.
TEST(PrintCharTest, SignedChar) ***REMOVED***
  EXPECT_EQ("'\\0'", Print(static_cast<signed char>('\0')));
  EXPECT_EQ("'\\xCE' (-50)",
            Print(static_cast<signed char>(-50)));
***REMOVED***

// unsigned char.
TEST(PrintCharTest, UnsignedChar) ***REMOVED***
  EXPECT_EQ("'\\0'", Print(static_cast<unsigned char>('\0')));
  EXPECT_EQ("'b' (98, 0x62)",
            Print(static_cast<unsigned char>('b')));
***REMOVED***

// Tests printing other simple, built-in types.

// bool.
TEST(PrintBuiltInTypeTest, Bool) ***REMOVED***
  EXPECT_EQ("false", Print(false));
  EXPECT_EQ("true", Print(true));
***REMOVED***

// wchar_t.
TEST(PrintBuiltInTypeTest, Wchar_t) ***REMOVED***
  EXPECT_EQ("L'\\0'", Print(L'\0'));
  EXPECT_EQ("L'\\'' (39, 0x27)", Print(L'\''));
  EXPECT_EQ("L'\"' (34, 0x22)", Print(L'"'));
  EXPECT_EQ("L'?' (63, 0x3F)", Print(L'?'));
  EXPECT_EQ("L'\\\\' (92, 0x5C)", Print(L'\\'));
  EXPECT_EQ("L'\\a' (7)", Print(L'\a'));
  EXPECT_EQ("L'\\b' (8)", Print(L'\b'));
  EXPECT_EQ("L'\\f' (12, 0xC)", Print(L'\f'));
  EXPECT_EQ("L'\\n' (10, 0xA)", Print(L'\n'));
  EXPECT_EQ("L'\\r' (13, 0xD)", Print(L'\r'));
  EXPECT_EQ("L'\\t' (9)", Print(L'\t'));
  EXPECT_EQ("L'\\v' (11, 0xB)", Print(L'\v'));
  EXPECT_EQ("L'\\x7F' (127)", Print(L'\x7F'));
  EXPECT_EQ("L'\\xFF' (255)", Print(L'\xFF'));
  EXPECT_EQ("L' ' (32, 0x20)", Print(L' '));
  EXPECT_EQ("L'a' (97, 0x61)", Print(L'a'));
  EXPECT_EQ("L'\\x576' (1398)", Print(static_cast<wchar_t>(0x576)));
  EXPECT_EQ("L'\\xC74D' (51021)", Print(static_cast<wchar_t>(0xC74D)));
***REMOVED***

// Test that Int64 provides more storage than wchar_t.
TEST(PrintTypeSizeTest, Wchar_t) ***REMOVED***
  EXPECT_LT(sizeof(wchar_t), sizeof(testing::internal::Int64));
***REMOVED***

// Various integer types.
TEST(PrintBuiltInTypeTest, Integer) ***REMOVED***
  EXPECT_EQ("'\\xFF' (255)", Print(static_cast<unsigned char>(255)));  // uint8
  EXPECT_EQ("'\\x80' (-128)", Print(static_cast<signed char>(-128)));  // int8
  EXPECT_EQ("65535", Print(USHRT_MAX));  // uint16
  EXPECT_EQ("-32768", Print(SHRT_MIN));  // int16
  EXPECT_EQ("4294967295", Print(UINT_MAX));  // uint32
  EXPECT_EQ("-2147483648", Print(INT_MIN));  // int32
  EXPECT_EQ("18446744073709551615",
            Print(static_cast<testing::internal::UInt64>(-1)));  // uint64
  EXPECT_EQ("-9223372036854775808",
            Print(static_cast<testing::internal::Int64>(1) << 63));  // int64
***REMOVED***

// Size types.
TEST(PrintBuiltInTypeTest, Size_t) ***REMOVED***
  EXPECT_EQ("1", Print(sizeof('a')));  // size_t.
#if !GTEST_OS_WINDOWS
  // Windows has no ssize_t type.
  EXPECT_EQ("-2", Print(static_cast<ssize_t>(-2)));  // ssize_t.
#endif  // !GTEST_OS_WINDOWS
***REMOVED***

// Floating-points.
TEST(PrintBuiltInTypeTest, FloatingPoints) ***REMOVED***
  EXPECT_EQ("1.5", Print(1.5f));   // float
  EXPECT_EQ("-2.5", Print(-2.5));  // double
***REMOVED***

// Since ::std::stringstream::operator<<(const void *) formats the pointer
// output differently with different compilers, we have to create the expected
// output first and use it as our expectation.
static string PrintPointer(const void *p) ***REMOVED***
  ::std::stringstream expected_result_stream;
  expected_result_stream << p;
  return expected_result_stream.str();
***REMOVED***

// Tests printing C strings.

// const char*.
TEST(PrintCStringTest, Const) ***REMOVED***
  const char* p = "World";
  EXPECT_EQ(PrintPointer(p) + " pointing to \"World\"", Print(p));
***REMOVED***

// char*.
TEST(PrintCStringTest, NonConst) ***REMOVED***
  char p[] = "Hi";
  EXPECT_EQ(PrintPointer(p) + " pointing to \"Hi\"",
            Print(static_cast<char*>(p)));
***REMOVED***

// NULL C string.
TEST(PrintCStringTest, Null) ***REMOVED***
  const char* p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// Tests that C strings are escaped properly.
TEST(PrintCStringTest, EscapesProperly) ***REMOVED***
  const char* p = "'\"?\\\a\b\f\n\r\t\v\x7F\xFF a";
  EXPECT_EQ(PrintPointer(p) + " pointing to \"'\\\"?\\\\\\a\\b\\f"
            "\\n\\r\\t\\v\\x7F\\xFF a\"",
            Print(p));
***REMOVED***

// MSVC compiler can be configured to define whar_t as a typedef
// of unsigned short. Defining an overload for const wchar_t* in that case
// would cause pointers to unsigned shorts be printed as wide strings,
// possibly accessing more memory than intended and causing invalid
// memory accesses. MSVC defines _NATIVE_WCHAR_T_DEFINED symbol when
// wchar_t is implemented as a native type.
#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)

// const wchar_t*.
TEST(PrintWideCStringTest, Const) ***REMOVED***
  const wchar_t* p = L"World";
  EXPECT_EQ(PrintPointer(p) + " pointing to L\"World\"", Print(p));
***REMOVED***

// wchar_t*.
TEST(PrintWideCStringTest, NonConst) ***REMOVED***
  wchar_t p[] = L"Hi";
  EXPECT_EQ(PrintPointer(p) + " pointing to L\"Hi\"",
            Print(static_cast<wchar_t*>(p)));
***REMOVED***

// NULL wide C string.
TEST(PrintWideCStringTest, Null) ***REMOVED***
  const wchar_t* p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// Tests that wide C strings are escaped properly.
TEST(PrintWideCStringTest, EscapesProperly) ***REMOVED***
  const wchar_t s[] = ***REMOVED***'\'', '"', '?', '\\', '\a', '\b', '\f', '\n', '\r',
                       '\t', '\v', 0xD3, 0x576, 0x8D3, 0xC74D, ' ', 'a', '\0'***REMOVED***;
  EXPECT_EQ(PrintPointer(s) + " pointing to L\"'\\\"?\\\\\\a\\b\\f"
            "\\n\\r\\t\\v\\xD3\\x576\\x8D3\\xC74D a\"",
            Print(static_cast<const wchar_t*>(s)));
***REMOVED***
#endif  // native wchar_t

// Tests printing pointers to other char types.

// signed char*.
TEST(PrintCharPointerTest, SignedChar) ***REMOVED***
  signed char* p = reinterpret_cast<signed char*>(0x1234);
  EXPECT_EQ(PrintPointer(p), Print(p));
  p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// const signed char*.
TEST(PrintCharPointerTest, ConstSignedChar) ***REMOVED***
  signed char* p = reinterpret_cast<signed char*>(0x1234);
  EXPECT_EQ(PrintPointer(p), Print(p));
  p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// unsigned char*.
TEST(PrintCharPointerTest, UnsignedChar) ***REMOVED***
  unsigned char* p = reinterpret_cast<unsigned char*>(0x1234);
  EXPECT_EQ(PrintPointer(p), Print(p));
  p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// const unsigned char*.
TEST(PrintCharPointerTest, ConstUnsignedChar) ***REMOVED***
  const unsigned char* p = reinterpret_cast<const unsigned char*>(0x1234);
  EXPECT_EQ(PrintPointer(p), Print(p));
  p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// Tests printing pointers to simple, built-in types.

// bool*.
TEST(PrintPointerToBuiltInTypeTest, Bool) ***REMOVED***
  bool* p = reinterpret_cast<bool*>(0xABCD);
  EXPECT_EQ(PrintPointer(p), Print(p));
  p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// void*.
TEST(PrintPointerToBuiltInTypeTest, Void) ***REMOVED***
  void* p = reinterpret_cast<void*>(0xABCD);
  EXPECT_EQ(PrintPointer(p), Print(p));
  p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// const void*.
TEST(PrintPointerToBuiltInTypeTest, ConstVoid) ***REMOVED***
  const void* p = reinterpret_cast<const void*>(0xABCD);
  EXPECT_EQ(PrintPointer(p), Print(p));
  p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// Tests printing pointers to pointers.
TEST(PrintPointerToPointerTest, IntPointerPointer) ***REMOVED***
  int** p = reinterpret_cast<int**>(0xABCD);
  EXPECT_EQ(PrintPointer(p), Print(p));
  p = NULL;
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// Tests printing (non-member) function pointers.

void MyFunction(int /* n */) ***REMOVED******REMOVED***

TEST(PrintPointerTest, NonMemberFunctionPointer) ***REMOVED***
  // We cannot directly cast &MyFunction to const void* because the
  // standard disallows casting between pointers to functions and
  // pointers to objects, and some compilers (e.g. GCC 3.4) enforce
  // this limitation.
  EXPECT_EQ(
      PrintPointer(reinterpret_cast<const void*>(
          reinterpret_cast<internal::BiggestInt>(&MyFunction))),
      Print(&MyFunction));
  int (*p)(bool) = NULL;  // NOLINT
  EXPECT_EQ("NULL", Print(p));
***REMOVED***

// An assertion predicate determining whether a one string is a prefix for
// another.
template <typename StringType>
AssertionResult HasPrefix(const StringType& str, const StringType& prefix) ***REMOVED***
  if (str.find(prefix, 0) == 0)
    return AssertionSuccess();

  const bool is_wide_string = sizeof(prefix[0]) > 1;
  const char* const begin_string_quote = is_wide_string ? "L\"" : "\"";
  return AssertionFailure()
      << begin_string_quote << prefix << "\" is not a prefix of "
      << begin_string_quote << str << "\"\n";
***REMOVED***

// Tests printing member variable pointers.  Although they are called
// pointers, they don't point to a location in the address space.
// Their representation is implementation-defined.  Thus they will be
// printed as raw bytes.

struct Foo ***REMOVED***
 public:
  virtual ~Foo() ***REMOVED******REMOVED***
  int MyMethod(char x) ***REMOVED*** return x + 1; ***REMOVED***
  virtual char MyVirtualMethod(int /* n */) ***REMOVED*** return 'a'; ***REMOVED***

  int value;
***REMOVED***;

TEST(PrintPointerTest, MemberVariablePointer) ***REMOVED***
  EXPECT_TRUE(HasPrefix(Print(&Foo::value),
                        Print(sizeof(&Foo::value)) + "-byte object "));
  int (Foo::*p) = NULL;  // NOLINT
  EXPECT_TRUE(HasPrefix(Print(p),
                        Print(sizeof(p)) + "-byte object "));
***REMOVED***

// Tests printing member function pointers.  Although they are called
// pointers, they don't point to a location in the address space.
// Their representation is implementation-defined.  Thus they will be
// printed as raw bytes.
TEST(PrintPointerTest, MemberFunctionPointer) ***REMOVED***
  EXPECT_TRUE(HasPrefix(Print(&Foo::MyMethod),
                        Print(sizeof(&Foo::MyMethod)) + "-byte object "));
  EXPECT_TRUE(
      HasPrefix(Print(&Foo::MyVirtualMethod),
                Print(sizeof((&Foo::MyVirtualMethod))) + "-byte object "));
  int (Foo::*p)(char) = NULL;  // NOLINT
  EXPECT_TRUE(HasPrefix(Print(p),
                        Print(sizeof(p)) + "-byte object "));
***REMOVED***

// Tests printing C arrays.

// The difference between this and Print() is that it ensures that the
// argument is a reference to an array.
template <typename T, size_t N>
string PrintArrayHelper(T (&a)[N]) ***REMOVED***
  return Print(a);
***REMOVED***

// One-dimensional array.
TEST(PrintArrayTest, OneDimensionalArray) ***REMOVED***
  int a[5] = ***REMOVED*** 1, 2, 3, 4, 5 ***REMOVED***;
  EXPECT_EQ("***REMOVED*** 1, 2, 3, 4, 5 ***REMOVED***", PrintArrayHelper(a));
***REMOVED***

// Two-dimensional array.
TEST(PrintArrayTest, TwoDimensionalArray) ***REMOVED***
  int a[2][5] = ***REMOVED***
    ***REMOVED*** 1, 2, 3, 4, 5 ***REMOVED***,
    ***REMOVED*** 6, 7, 8, 9, 0 ***REMOVED***
  ***REMOVED***;
  EXPECT_EQ("***REMOVED*** ***REMOVED*** 1, 2, 3, 4, 5 ***REMOVED***, ***REMOVED*** 6, 7, 8, 9, 0 ***REMOVED*** ***REMOVED***", PrintArrayHelper(a));
***REMOVED***

// Array of const elements.
TEST(PrintArrayTest, ConstArray) ***REMOVED***
  const bool a[1] = ***REMOVED*** false ***REMOVED***;
  EXPECT_EQ("***REMOVED*** false ***REMOVED***", PrintArrayHelper(a));
***REMOVED***

// char array without terminating NUL.
TEST(PrintArrayTest, CharArrayWithNoTerminatingNul) ***REMOVED***
  // Array a contains '\0' in the middle and doesn't end with '\0'.
  char a[] = ***REMOVED*** 'H', '\0', 'i' ***REMOVED***;
  EXPECT_EQ("\"H\\0i\" (no terminating NUL)", PrintArrayHelper(a));
***REMOVED***

// const char array with terminating NUL.
TEST(PrintArrayTest, ConstCharArrayWithTerminatingNul) ***REMOVED***
  const char a[] = "\0Hi";
  EXPECT_EQ("\"\\0Hi\"", PrintArrayHelper(a));
***REMOVED***

// const wchar_t array without terminating NUL.
TEST(PrintArrayTest, WCharArrayWithNoTerminatingNul) ***REMOVED***
  // Array a contains '\0' in the middle and doesn't end with '\0'.
  const wchar_t a[] = ***REMOVED*** L'H', L'\0', L'i' ***REMOVED***;
  EXPECT_EQ("L\"H\\0i\" (no terminating NUL)", PrintArrayHelper(a));
***REMOVED***

// wchar_t array with terminating NUL.
TEST(PrintArrayTest, WConstCharArrayWithTerminatingNul) ***REMOVED***
  const wchar_t a[] = L"\0Hi";
  EXPECT_EQ("L\"\\0Hi\"", PrintArrayHelper(a));
***REMOVED***

// Array of objects.
TEST(PrintArrayTest, ObjectArray) ***REMOVED***
  string a[3] = ***REMOVED*** "Hi", "Hello", "Ni hao" ***REMOVED***;
  EXPECT_EQ("***REMOVED*** \"Hi\", \"Hello\", \"Ni hao\" ***REMOVED***", PrintArrayHelper(a));
***REMOVED***

// Array with many elements.
TEST(PrintArrayTest, BigArray) ***REMOVED***
  int a[100] = ***REMOVED*** 1, 2, 3 ***REMOVED***;
  EXPECT_EQ("***REMOVED*** 1, 2, 3, 0, 0, 0, 0, 0, ..., 0, 0, 0, 0, 0, 0, 0, 0 ***REMOVED***",
            PrintArrayHelper(a));
***REMOVED***

// Tests printing ::string and ::std::string.

#if GTEST_HAS_GLOBAL_STRING
// ::string.
TEST(PrintStringTest, StringInGlobalNamespace) ***REMOVED***
  const char s[] = "'\"?\\\a\b\f\n\0\r\t\v\x7F\xFF a";
  const ::string str(s, sizeof(s));
  EXPECT_EQ("\"'\\\"?\\\\\\a\\b\\f\\n\\0\\r\\t\\v\\x7F\\xFF a\\0\"",
            Print(str));
***REMOVED***
#endif  // GTEST_HAS_GLOBAL_STRING

// ::std::string.
TEST(PrintStringTest, StringInStdNamespace) ***REMOVED***
  const char s[] = "'\"?\\\a\b\f\n\0\r\t\v\x7F\xFF a";
  const ::std::string str(s, sizeof(s));
  EXPECT_EQ("\"'\\\"?\\\\\\a\\b\\f\\n\\0\\r\\t\\v\\x7F\\xFF a\\0\"",
            Print(str));
***REMOVED***

TEST(PrintStringTest, StringAmbiguousHex) ***REMOVED***
  // "\x6BANANA" is ambiguous, it can be interpreted as starting with either of:
  // '\x6', '\x6B', or '\x6BA'.

  // a hex escaping sequence following by a decimal digit
  EXPECT_EQ("\"0\\x12\" \"3\"", Print(::std::string("0\x12" "3")));
  // a hex escaping sequence following by a hex digit (lower-case)
  EXPECT_EQ("\"mm\\x6\" \"bananas\"", Print(::std::string("mm\x6" "bananas")));
  // a hex escaping sequence following by a hex digit (upper-case)
  EXPECT_EQ("\"NOM\\x6\" \"BANANA\"", Print(::std::string("NOM\x6" "BANANA")));
  // a hex escaping sequence following by a non-xdigit
  EXPECT_EQ("\"!\\x5-!\"", Print(::std::string("!\x5-!")));
***REMOVED***

// Tests printing ::wstring and ::std::wstring.

#if GTEST_HAS_GLOBAL_WSTRING
// ::wstring.
TEST(PrintWideStringTest, StringInGlobalNamespace) ***REMOVED***
  const wchar_t s[] = L"'\"?\\\a\b\f\n\0\r\t\v\xD3\x576\x8D3\xC74D a";
  const ::wstring str(s, sizeof(s)/sizeof(wchar_t));
  EXPECT_EQ("L\"'\\\"?\\\\\\a\\b\\f\\n\\0\\r\\t\\v"
            "\\xD3\\x576\\x8D3\\xC74D a\\0\"",
            Print(str));
***REMOVED***
#endif  // GTEST_HAS_GLOBAL_WSTRING

#if GTEST_HAS_STD_WSTRING
// ::std::wstring.
TEST(PrintWideStringTest, StringInStdNamespace) ***REMOVED***
  const wchar_t s[] = L"'\"?\\\a\b\f\n\0\r\t\v\xD3\x576\x8D3\xC74D a";
  const ::std::wstring str(s, sizeof(s)/sizeof(wchar_t));
  EXPECT_EQ("L\"'\\\"?\\\\\\a\\b\\f\\n\\0\\r\\t\\v"
            "\\xD3\\x576\\x8D3\\xC74D a\\0\"",
            Print(str));
***REMOVED***

TEST(PrintWideStringTest, StringAmbiguousHex) ***REMOVED***
  // same for wide strings.
  EXPECT_EQ("L\"0\\x12\" L\"3\"", Print(::std::wstring(L"0\x12" L"3")));
  EXPECT_EQ("L\"mm\\x6\" L\"bananas\"",
            Print(::std::wstring(L"mm\x6" L"bananas")));
  EXPECT_EQ("L\"NOM\\x6\" L\"BANANA\"",
            Print(::std::wstring(L"NOM\x6" L"BANANA")));
  EXPECT_EQ("L\"!\\x5-!\"", Print(::std::wstring(L"!\x5-!")));
***REMOVED***
#endif  // GTEST_HAS_STD_WSTRING

// Tests printing types that support generic streaming (i.e. streaming
// to std::basic_ostream<Char, CharTraits> for any valid Char and
// CharTraits types).

// Tests printing a non-template type that supports generic streaming.

class AllowsGenericStreaming ***REMOVED******REMOVED***;

template <typename Char, typename CharTraits>
std::basic_ostream<Char, CharTraits>& operator<<(
    std::basic_ostream<Char, CharTraits>& os,
    const AllowsGenericStreaming& /* a */) ***REMOVED***
  return os << "AllowsGenericStreaming";
***REMOVED***

TEST(PrintTypeWithGenericStreamingTest, NonTemplateType) ***REMOVED***
  AllowsGenericStreaming a;
  EXPECT_EQ("AllowsGenericStreaming", Print(a));
***REMOVED***

// Tests printing a template type that supports generic streaming.

template <typename T>
class AllowsGenericStreamingTemplate ***REMOVED******REMOVED***;

template <typename Char, typename CharTraits, typename T>
std::basic_ostream<Char, CharTraits>& operator<<(
    std::basic_ostream<Char, CharTraits>& os,
    const AllowsGenericStreamingTemplate<T>& /* a */) ***REMOVED***
  return os << "AllowsGenericStreamingTemplate";
***REMOVED***

TEST(PrintTypeWithGenericStreamingTest, TemplateType) ***REMOVED***
  AllowsGenericStreamingTemplate<int> a;
  EXPECT_EQ("AllowsGenericStreamingTemplate", Print(a));
***REMOVED***

// Tests printing a type that supports generic streaming and can be
// implicitly converted to another printable type.

template <typename T>
class AllowsGenericStreamingAndImplicitConversionTemplate ***REMOVED***
 public:
  operator bool() const ***REMOVED*** return false; ***REMOVED***
***REMOVED***;

template <typename Char, typename CharTraits, typename T>
std::basic_ostream<Char, CharTraits>& operator<<(
    std::basic_ostream<Char, CharTraits>& os,
    const AllowsGenericStreamingAndImplicitConversionTemplate<T>& /* a */) ***REMOVED***
  return os << "AllowsGenericStreamingAndImplicitConversionTemplate";
***REMOVED***

TEST(PrintTypeWithGenericStreamingTest, TypeImplicitlyConvertible) ***REMOVED***
  AllowsGenericStreamingAndImplicitConversionTemplate<int> a;
  EXPECT_EQ("AllowsGenericStreamingAndImplicitConversionTemplate", Print(a));
***REMOVED***

#if GTEST_HAS_STRING_PIECE_

// Tests printing StringPiece.

TEST(PrintStringPieceTest, SimpleStringPiece) ***REMOVED***
  const StringPiece sp = "Hello";
  EXPECT_EQ("\"Hello\"", Print(sp));
***REMOVED***

TEST(PrintStringPieceTest, UnprintableCharacters) ***REMOVED***
  const char str[] = "NUL (\0) and \r\t";
  const StringPiece sp(str, sizeof(str) - 1);
  EXPECT_EQ("\"NUL (\\0) and \\r\\t\"", Print(sp));
***REMOVED***

#endif  // GTEST_HAS_STRING_PIECE_

// Tests printing STL containers.

TEST(PrintStlContainerTest, EmptyDeque) ***REMOVED***
  deque<char> empty;
  EXPECT_EQ("***REMOVED******REMOVED***", Print(empty));
***REMOVED***

TEST(PrintStlContainerTest, NonEmptyDeque) ***REMOVED***
  deque<int> non_empty;
  non_empty.push_back(1);
  non_empty.push_back(3);
  EXPECT_EQ("***REMOVED*** 1, 3 ***REMOVED***", Print(non_empty));
***REMOVED***

#if GTEST_HAS_HASH_MAP_

TEST(PrintStlContainerTest, OneElementHashMap) ***REMOVED***
  hash_map<int, char> map1;
  map1[1] = 'a';
  EXPECT_EQ("***REMOVED*** (1, 'a' (97, 0x61)) ***REMOVED***", Print(map1));
***REMOVED***

TEST(PrintStlContainerTest, HashMultiMap) ***REMOVED***
  hash_multimap<int, bool> map1;
  map1.insert(make_pair(5, true));
  map1.insert(make_pair(5, false));

  // Elements of hash_multimap can be printed in any order.
  const string result = Print(map1);
  EXPECT_TRUE(result == "***REMOVED*** (5, true), (5, false) ***REMOVED***" ||
              result == "***REMOVED*** (5, false), (5, true) ***REMOVED***")
                  << " where Print(map1) returns \"" << result << "\".";
***REMOVED***

#endif  // GTEST_HAS_HASH_MAP_

#if GTEST_HAS_HASH_SET_

TEST(PrintStlContainerTest, HashSet) ***REMOVED***
  hash_set<string> set1;
  set1.insert("hello");
  EXPECT_EQ("***REMOVED*** \"hello\" ***REMOVED***", Print(set1));
***REMOVED***

TEST(PrintStlContainerTest, HashMultiSet) ***REMOVED***
  const int kSize = 5;
  int a[kSize] = ***REMOVED*** 1, 1, 2, 5, 1 ***REMOVED***;
  hash_multiset<int> set1(a, a + kSize);

  // Elements of hash_multiset can be printed in any order.
  const string result = Print(set1);
  const string expected_pattern = "***REMOVED*** d, d, d, d, d ***REMOVED***";  // d means a digit.

  // Verifies the result matches the expected pattern; also extracts
  // the numbers in the result.
  ASSERT_EQ(expected_pattern.length(), result.length());
  std::vector<int> numbers;
  for (size_t i = 0; i != result.length(); i++) ***REMOVED***
    if (expected_pattern[i] == 'd') ***REMOVED***
      ASSERT_NE(isdigit(static_cast<unsigned char>(result[i])), 0);
      numbers.push_back(result[i] - '0');
    ***REMOVED*** else ***REMOVED***
      EXPECT_EQ(expected_pattern[i], result[i]) << " where result is "
                                                << result;
    ***REMOVED***
  ***REMOVED***

  // Makes sure the result contains the right numbers.
  std::sort(numbers.begin(), numbers.end());
  std::sort(a, a + kSize);
  EXPECT_TRUE(std::equal(a, a + kSize, numbers.begin()));
***REMOVED***

#endif  // GTEST_HAS_HASH_SET_

TEST(PrintStlContainerTest, List) ***REMOVED***
  const string a[] = ***REMOVED***
    "hello",
    "world"
  ***REMOVED***;
  const list<string> strings(a, a + 2);
  EXPECT_EQ("***REMOVED*** \"hello\", \"world\" ***REMOVED***", Print(strings));
***REMOVED***

TEST(PrintStlContainerTest, Map) ***REMOVED***
  map<int, bool> map1;
  map1[1] = true;
  map1[5] = false;
  map1[3] = true;
  EXPECT_EQ("***REMOVED*** (1, true), (3, true), (5, false) ***REMOVED***", Print(map1));
***REMOVED***

TEST(PrintStlContainerTest, MultiMap) ***REMOVED***
  multimap<bool, int> map1;
  // The make_pair template function would deduce the type as
  // pair<bool, int> here, and since the key part in a multimap has to
  // be constant, without a templated ctor in the pair class (as in
  // libCstd on Solaris), make_pair call would fail to compile as no
  // implicit conversion is found.  Thus explicit typename is used
  // here instead.
  map1.insert(pair<const bool, int>(true, 0));
  map1.insert(pair<const bool, int>(true, 1));
  map1.insert(pair<const bool, int>(false, 2));
  EXPECT_EQ("***REMOVED*** (false, 2), (true, 0), (true, 1) ***REMOVED***", Print(map1));
***REMOVED***

TEST(PrintStlContainerTest, Set) ***REMOVED***
  const unsigned int a[] = ***REMOVED*** 3, 0, 5 ***REMOVED***;
  set<unsigned int> set1(a, a + 3);
  EXPECT_EQ("***REMOVED*** 0, 3, 5 ***REMOVED***", Print(set1));
***REMOVED***

TEST(PrintStlContainerTest, MultiSet) ***REMOVED***
  const int a[] = ***REMOVED*** 1, 1, 2, 5, 1 ***REMOVED***;
  multiset<int> set1(a, a + 5);
  EXPECT_EQ("***REMOVED*** 1, 1, 1, 2, 5 ***REMOVED***", Print(set1));
***REMOVED***

#if GTEST_HAS_STD_FORWARD_LIST_
// <slist> is available on Linux in the google3 mode, but not on
// Windows or Mac OS X.

TEST(PrintStlContainerTest, SinglyLinkedList) ***REMOVED***
  int a[] = ***REMOVED*** 9, 2, 8 ***REMOVED***;
  const std::forward_list<int> ints(a, a + 3);
  EXPECT_EQ("***REMOVED*** 9, 2, 8 ***REMOVED***", Print(ints));
***REMOVED***
#endif  // GTEST_HAS_STD_FORWARD_LIST_

TEST(PrintStlContainerTest, Pair) ***REMOVED***
  pair<const bool, int> p(true, 5);
  EXPECT_EQ("(true, 5)", Print(p));
***REMOVED***

TEST(PrintStlContainerTest, Vector) ***REMOVED***
  vector<int> v;
  v.push_back(1);
  v.push_back(2);
  EXPECT_EQ("***REMOVED*** 1, 2 ***REMOVED***", Print(v));
***REMOVED***

TEST(PrintStlContainerTest, LongSequence) ***REMOVED***
  const int a[100] = ***REMOVED*** 1, 2, 3 ***REMOVED***;
  const vector<int> v(a, a + 100);
  EXPECT_EQ("***REMOVED*** 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "
            "0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... ***REMOVED***", Print(v));
***REMOVED***

TEST(PrintStlContainerTest, NestedContainer) ***REMOVED***
  const int a1[] = ***REMOVED*** 1, 2 ***REMOVED***;
  const int a2[] = ***REMOVED*** 3, 4, 5 ***REMOVED***;
  const list<int> l1(a1, a1 + 2);
  const list<int> l2(a2, a2 + 3);

  vector<list<int> > v;
  v.push_back(l1);
  v.push_back(l2);
  EXPECT_EQ("***REMOVED*** ***REMOVED*** 1, 2 ***REMOVED***, ***REMOVED*** 3, 4, 5 ***REMOVED*** ***REMOVED***", Print(v));
***REMOVED***

TEST(PrintStlContainerTest, OneDimensionalNativeArray) ***REMOVED***
  const int a[3] = ***REMOVED*** 1, 2, 3 ***REMOVED***;
  NativeArray<int> b(a, 3, RelationToSourceReference());
  EXPECT_EQ("***REMOVED*** 1, 2, 3 ***REMOVED***", Print(b));
***REMOVED***

TEST(PrintStlContainerTest, TwoDimensionalNativeArray) ***REMOVED***
  const int a[2][3] = ***REMOVED*** ***REMOVED*** 1, 2, 3 ***REMOVED***, ***REMOVED*** 4, 5, 6 ***REMOVED*** ***REMOVED***;
  NativeArray<int[3]> b(a, 2, RelationToSourceReference());
  EXPECT_EQ("***REMOVED*** ***REMOVED*** 1, 2, 3 ***REMOVED***, ***REMOVED*** 4, 5, 6 ***REMOVED*** ***REMOVED***", Print(b));
***REMOVED***

// Tests that a class named iterator isn't treated as a container.

struct iterator ***REMOVED***
  char x;
***REMOVED***;

TEST(PrintStlContainerTest, Iterator) ***REMOVED***
  iterator it = ***REMOVED******REMOVED***;
  EXPECT_EQ("1-byte object <00>", Print(it));
***REMOVED***

// Tests that a class named const_iterator isn't treated as a container.

struct const_iterator ***REMOVED***
  char x;
***REMOVED***;

TEST(PrintStlContainerTest, ConstIterator) ***REMOVED***
  const_iterator it = ***REMOVED******REMOVED***;
  EXPECT_EQ("1-byte object <00>", Print(it));
***REMOVED***

#if GTEST_HAS_TR1_TUPLE
// Tests printing ::std::tr1::tuples.

// Tuples of various arities.
TEST(PrintTr1TupleTest, VariousSizes) ***REMOVED***
  ::std::tr1::tuple<> t0;
  EXPECT_EQ("()", Print(t0));

  ::std::tr1::tuple<int> t1(5);
  EXPECT_EQ("(5)", Print(t1));

  ::std::tr1::tuple<char, bool> t2('a', true);
  EXPECT_EQ("('a' (97, 0x61), true)", Print(t2));

  ::std::tr1::tuple<bool, int, int> t3(false, 2, 3);
  EXPECT_EQ("(false, 2, 3)", Print(t3));

  ::std::tr1::tuple<bool, int, int, int> t4(false, 2, 3, 4);
  EXPECT_EQ("(false, 2, 3, 4)", Print(t4));

  ::std::tr1::tuple<bool, int, int, int, bool> t5(false, 2, 3, 4, true);
  EXPECT_EQ("(false, 2, 3, 4, true)", Print(t5));

  ::std::tr1::tuple<bool, int, int, int, bool, int> t6(false, 2, 3, 4, true, 6);
  EXPECT_EQ("(false, 2, 3, 4, true, 6)", Print(t6));

  ::std::tr1::tuple<bool, int, int, int, bool, int, int> t7(
      false, 2, 3, 4, true, 6, 7);
  EXPECT_EQ("(false, 2, 3, 4, true, 6, 7)", Print(t7));

  ::std::tr1::tuple<bool, int, int, int, bool, int, int, bool> t8(
      false, 2, 3, 4, true, 6, 7, true);
  EXPECT_EQ("(false, 2, 3, 4, true, 6, 7, true)", Print(t8));

  ::std::tr1::tuple<bool, int, int, int, bool, int, int, bool, int> t9(
      false, 2, 3, 4, true, 6, 7, true, 9);
  EXPECT_EQ("(false, 2, 3, 4, true, 6, 7, true, 9)", Print(t9));

  const char* const str = "8";
  // VC++ 2010's implementation of tuple of C++0x is deficient, requiring
  // an explicit type cast of NULL to be used.
  ::std::tr1::tuple<bool, char, short, testing::internal::Int32,  // NOLINT
      testing::internal::Int64, float, double, const char*, void*, string>
      t10(false, 'a', 3, 4, 5, 1.5F, -2.5, str,
          ImplicitCast_<void*>(NULL), "10");
  EXPECT_EQ("(false, 'a' (97, 0x61), 3, 4, 5, 1.5, -2.5, " + PrintPointer(str) +
            " pointing to \"8\", NULL, \"10\")",
            Print(t10));
***REMOVED***

// Nested tuples.
TEST(PrintTr1TupleTest, NestedTuple) ***REMOVED***
  ::std::tr1::tuple< ::std::tr1::tuple<int, bool>, char> nested(
      ::std::tr1::make_tuple(5, true), 'a');
  EXPECT_EQ("((5, true), 'a' (97, 0x61))", Print(nested));
***REMOVED***

#endif  // GTEST_HAS_TR1_TUPLE

#if GTEST_HAS_STD_TUPLE_
// Tests printing ::std::tuples.

// Tuples of various arities.
TEST(PrintStdTupleTest, VariousSizes) ***REMOVED***
  ::std::tuple<> t0;
  EXPECT_EQ("()", Print(t0));

  ::std::tuple<int> t1(5);
  EXPECT_EQ("(5)", Print(t1));

  ::std::tuple<char, bool> t2('a', true);
  EXPECT_EQ("('a' (97, 0x61), true)", Print(t2));

  ::std::tuple<bool, int, int> t3(false, 2, 3);
  EXPECT_EQ("(false, 2, 3)", Print(t3));

  ::std::tuple<bool, int, int, int> t4(false, 2, 3, 4);
  EXPECT_EQ("(false, 2, 3, 4)", Print(t4));

  ::std::tuple<bool, int, int, int, bool> t5(false, 2, 3, 4, true);
  EXPECT_EQ("(false, 2, 3, 4, true)", Print(t5));

  ::std::tuple<bool, int, int, int, bool, int> t6(false, 2, 3, 4, true, 6);
  EXPECT_EQ("(false, 2, 3, 4, true, 6)", Print(t6));

  ::std::tuple<bool, int, int, int, bool, int, int> t7(
      false, 2, 3, 4, true, 6, 7);
  EXPECT_EQ("(false, 2, 3, 4, true, 6, 7)", Print(t7));

  ::std::tuple<bool, int, int, int, bool, int, int, bool> t8(
      false, 2, 3, 4, true, 6, 7, true);
  EXPECT_EQ("(false, 2, 3, 4, true, 6, 7, true)", Print(t8));

  ::std::tuple<bool, int, int, int, bool, int, int, bool, int> t9(
      false, 2, 3, 4, true, 6, 7, true, 9);
  EXPECT_EQ("(false, 2, 3, 4, true, 6, 7, true, 9)", Print(t9));

  const char* const str = "8";
  // VC++ 2010's implementation of tuple of C++0x is deficient, requiring
  // an explicit type cast of NULL to be used.
  ::std::tuple<bool, char, short, testing::internal::Int32,  // NOLINT
      testing::internal::Int64, float, double, const char*, void*, string>
      t10(false, 'a', 3, 4, 5, 1.5F, -2.5, str,
          ImplicitCast_<void*>(NULL), "10");
  EXPECT_EQ("(false, 'a' (97, 0x61), 3, 4, 5, 1.5, -2.5, " + PrintPointer(str) +
            " pointing to \"8\", NULL, \"10\")",
            Print(t10));
***REMOVED***

// Nested tuples.
TEST(PrintStdTupleTest, NestedTuple) ***REMOVED***
  ::std::tuple< ::std::tuple<int, bool>, char> nested(
      ::std::make_tuple(5, true), 'a');
  EXPECT_EQ("((5, true), 'a' (97, 0x61))", Print(nested));
***REMOVED***

#endif  // GTEST_LANG_CXX11

// Tests printing user-defined unprintable types.

// Unprintable types in the global namespace.
TEST(PrintUnprintableTypeTest, InGlobalNamespace) ***REMOVED***
  EXPECT_EQ("1-byte object <00>",
            Print(UnprintableTemplateInGlobal<char>()));
***REMOVED***

// Unprintable types in a user namespace.
TEST(PrintUnprintableTypeTest, InUserNamespace) ***REMOVED***
  EXPECT_EQ("16-byte object <EF-12 00-00 34-AB 00-00 00-00 00-00 00-00 00-00>",
            Print(::foo::UnprintableInFoo()));
***REMOVED***

// Unprintable types are that too big to be printed completely.

struct Big ***REMOVED***
  Big() ***REMOVED*** memset(array, 0, sizeof(array)); ***REMOVED***
  char array[257];
***REMOVED***;

TEST(PrintUnpritableTypeTest, BigObject) ***REMOVED***
  EXPECT_EQ("257-byte object <00-00 00-00 00-00 00-00 00-00 00-00 "
            "00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 "
            "00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 "
            "00-00 00-00 00-00 00-00 00-00 00-00 ... 00-00 00-00 00-00 "
            "00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 "
            "00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 "
            "00-00 00-00 00-00 00-00 00-00 00-00 00-00 00-00 00>",
            Print(Big()));
***REMOVED***

// Tests printing user-defined streamable types.

// Streamable types in the global namespace.
TEST(PrintStreamableTypeTest, InGlobalNamespace) ***REMOVED***
  StreamableInGlobal x;
  EXPECT_EQ("StreamableInGlobal", Print(x));
  EXPECT_EQ("StreamableInGlobal*", Print(&x));
***REMOVED***

// Printable template types in a user namespace.
TEST(PrintStreamableTypeTest, TemplateTypeInUserNamespace) ***REMOVED***
  EXPECT_EQ("StreamableTemplateInFoo: 0",
            Print(::foo::StreamableTemplateInFoo<int>()));
***REMOVED***

// Tests printing user-defined types that have a PrintTo() function.
TEST(PrintPrintableTypeTest, InUserNamespace) ***REMOVED***
  EXPECT_EQ("PrintableViaPrintTo: 0",
            Print(::foo::PrintableViaPrintTo()));
***REMOVED***

// Tests printing a pointer to a user-defined type that has a <<
// operator for its pointer.
TEST(PrintPrintableTypeTest, PointerInUserNamespace) ***REMOVED***
  ::foo::PointerPrintable x;
  EXPECT_EQ("PointerPrintable*", Print(&x));
***REMOVED***

// Tests printing user-defined class template that have a PrintTo() function.
TEST(PrintPrintableTypeTest, TemplateInUserNamespace) ***REMOVED***
  EXPECT_EQ("PrintableViaPrintToTemplate: 5",
            Print(::foo::PrintableViaPrintToTemplate<int>(5)));
***REMOVED***

// Tests that the universal printer prints both the address and the
// value of a reference.
TEST(PrintReferenceTest, PrintsAddressAndValue) ***REMOVED***
  int n = 5;
  EXPECT_EQ("@" + PrintPointer(&n) + " 5", PrintByRef(n));

  int a[2][3] = ***REMOVED***
    ***REMOVED*** 0, 1, 2 ***REMOVED***,
    ***REMOVED*** 3, 4, 5 ***REMOVED***
  ***REMOVED***;
  EXPECT_EQ("@" + PrintPointer(a) + " ***REMOVED*** ***REMOVED*** 0, 1, 2 ***REMOVED***, ***REMOVED*** 3, 4, 5 ***REMOVED*** ***REMOVED***",
            PrintByRef(a));

  const ::foo::UnprintableInFoo x;
  EXPECT_EQ("@" + PrintPointer(&x) + " 16-byte object "
            "<EF-12 00-00 34-AB 00-00 00-00 00-00 00-00 00-00>",
            PrintByRef(x));
***REMOVED***

// Tests that the universal printer prints a function pointer passed by
// reference.
TEST(PrintReferenceTest, HandlesFunctionPointer) ***REMOVED***
  void (*fp)(int n) = &MyFunction;
  const string fp_pointer_string =
      PrintPointer(reinterpret_cast<const void*>(&fp));
  // We cannot directly cast &MyFunction to const void* because the
  // standard disallows casting between pointers to functions and
  // pointers to objects, and some compilers (e.g. GCC 3.4) enforce
  // this limitation.
  const string fp_string = PrintPointer(reinterpret_cast<const void*>(
      reinterpret_cast<internal::BiggestInt>(fp)));
  EXPECT_EQ("@" + fp_pointer_string + " " + fp_string,
            PrintByRef(fp));
***REMOVED***

// Tests that the universal printer prints a member function pointer
// passed by reference.
TEST(PrintReferenceTest, HandlesMemberFunctionPointer) ***REMOVED***
  int (Foo::*p)(char ch) = &Foo::MyMethod;
  EXPECT_TRUE(HasPrefix(
      PrintByRef(p),
      "@" + PrintPointer(reinterpret_cast<const void*>(&p)) + " " +
          Print(sizeof(p)) + "-byte object "));

  char (Foo::*p2)(int n) = &Foo::MyVirtualMethod;
  EXPECT_TRUE(HasPrefix(
      PrintByRef(p2),
      "@" + PrintPointer(reinterpret_cast<const void*>(&p2)) + " " +
          Print(sizeof(p2)) + "-byte object "));
***REMOVED***

// Tests that the universal printer prints a member variable pointer
// passed by reference.
TEST(PrintReferenceTest, HandlesMemberVariablePointer) ***REMOVED***
  int (Foo::*p) = &Foo::value;  // NOLINT
  EXPECT_TRUE(HasPrefix(
      PrintByRef(p),
      "@" + PrintPointer(&p) + " " + Print(sizeof(p)) + "-byte object "));
***REMOVED***

// Tests that FormatForComparisonFailureMessage(), which is used to print
// an operand in a comparison assertion (e.g. ASSERT_EQ) when the assertion
// fails, formats the operand in the desired way.

// scalar
TEST(FormatForComparisonFailureMessageTest, WorksForScalar) ***REMOVED***
  EXPECT_STREQ("123",
               FormatForComparisonFailureMessage(123, 124).c_str());
***REMOVED***

// non-char pointer
TEST(FormatForComparisonFailureMessageTest, WorksForNonCharPointer) ***REMOVED***
  int n = 0;
  EXPECT_EQ(PrintPointer(&n),
            FormatForComparisonFailureMessage(&n, &n).c_str());
***REMOVED***

// non-char array
TEST(FormatForComparisonFailureMessageTest, FormatsNonCharArrayAsPointer) ***REMOVED***
  // In expression 'array == x', 'array' is compared by pointer.
  // Therefore we want to print an array operand as a pointer.
  int n[] = ***REMOVED*** 1, 2, 3 ***REMOVED***;
  EXPECT_EQ(PrintPointer(n),
            FormatForComparisonFailureMessage(n, n).c_str());
***REMOVED***

// Tests formatting a char pointer when it's compared with another pointer.
// In this case we want to print it as a raw pointer, as the comparision is by
// pointer.

// char pointer vs pointer
TEST(FormatForComparisonFailureMessageTest, WorksForCharPointerVsPointer) ***REMOVED***
  // In expression 'p == x', where 'p' and 'x' are (const or not) char
  // pointers, the operands are compared by pointer.  Therefore we
  // want to print 'p' as a pointer instead of a C string (we don't
  // even know if it's supposed to point to a valid C string).

  // const char*
  const char* s = "hello";
  EXPECT_EQ(PrintPointer(s),
            FormatForComparisonFailureMessage(s, s).c_str());

  // char*
  char ch = 'a';
  EXPECT_EQ(PrintPointer(&ch),
            FormatForComparisonFailureMessage(&ch, &ch).c_str());
***REMOVED***

// wchar_t pointer vs pointer
TEST(FormatForComparisonFailureMessageTest, WorksForWCharPointerVsPointer) ***REMOVED***
  // In expression 'p == x', where 'p' and 'x' are (const or not) char
  // pointers, the operands are compared by pointer.  Therefore we
  // want to print 'p' as a pointer instead of a wide C string (we don't
  // even know if it's supposed to point to a valid wide C string).

  // const wchar_t*
  const wchar_t* s = L"hello";
  EXPECT_EQ(PrintPointer(s),
            FormatForComparisonFailureMessage(s, s).c_str());

  // wchar_t*
  wchar_t ch = L'a';
  EXPECT_EQ(PrintPointer(&ch),
            FormatForComparisonFailureMessage(&ch, &ch).c_str());
***REMOVED***

// Tests formatting a char pointer when it's compared to a string object.
// In this case we want to print the char pointer as a C string.

#if GTEST_HAS_GLOBAL_STRING
// char pointer vs ::string
TEST(FormatForComparisonFailureMessageTest, WorksForCharPointerVsString) ***REMOVED***
  const char* s = "hello \"world";
  EXPECT_STREQ("\"hello \\\"world\"",  // The string content should be escaped.
               FormatForComparisonFailureMessage(s, ::string()).c_str());

  // char*
  char str[] = "hi\1";
  char* p = str;
  EXPECT_STREQ("\"hi\\x1\"",  // The string content should be escaped.
               FormatForComparisonFailureMessage(p, ::string()).c_str());
***REMOVED***
#endif

// char pointer vs std::string
TEST(FormatForComparisonFailureMessageTest, WorksForCharPointerVsStdString) ***REMOVED***
  const char* s = "hello \"world";
  EXPECT_STREQ("\"hello \\\"world\"",  // The string content should be escaped.
               FormatForComparisonFailureMessage(s, ::std::string()).c_str());

  // char*
  char str[] = "hi\1";
  char* p = str;
  EXPECT_STREQ("\"hi\\x1\"",  // The string content should be escaped.
               FormatForComparisonFailureMessage(p, ::std::string()).c_str());
***REMOVED***

#if GTEST_HAS_GLOBAL_WSTRING
// wchar_t pointer vs ::wstring
TEST(FormatForComparisonFailureMessageTest, WorksForWCharPointerVsWString) ***REMOVED***
  const wchar_t* s = L"hi \"world";
  EXPECT_STREQ("L\"hi \\\"world\"",  // The string content should be escaped.
               FormatForComparisonFailureMessage(s, ::wstring()).c_str());

  // wchar_t*
  wchar_t str[] = L"hi\1";
  wchar_t* p = str;
  EXPECT_STREQ("L\"hi\\x1\"",  // The string content should be escaped.
               FormatForComparisonFailureMessage(p, ::wstring()).c_str());
***REMOVED***
#endif

#if GTEST_HAS_STD_WSTRING
// wchar_t pointer vs std::wstring
TEST(FormatForComparisonFailureMessageTest, WorksForWCharPointerVsStdWString) ***REMOVED***
  const wchar_t* s = L"hi \"world";
  EXPECT_STREQ("L\"hi \\\"world\"",  // The string content should be escaped.
               FormatForComparisonFailureMessage(s, ::std::wstring()).c_str());

  // wchar_t*
  wchar_t str[] = L"hi\1";
  wchar_t* p = str;
  EXPECT_STREQ("L\"hi\\x1\"",  // The string content should be escaped.
               FormatForComparisonFailureMessage(p, ::std::wstring()).c_str());
***REMOVED***
#endif

// Tests formatting a char array when it's compared with a pointer or array.
// In this case we want to print the array as a row pointer, as the comparison
// is by pointer.

// char array vs pointer
TEST(FormatForComparisonFailureMessageTest, WorksForCharArrayVsPointer) ***REMOVED***
  char str[] = "hi \"world\"";
  char* p = NULL;
  EXPECT_EQ(PrintPointer(str),
            FormatForComparisonFailureMessage(str, p).c_str());
***REMOVED***

// char array vs char array
TEST(FormatForComparisonFailureMessageTest, WorksForCharArrayVsCharArray) ***REMOVED***
  const char str[] = "hi \"world\"";
  EXPECT_EQ(PrintPointer(str),
            FormatForComparisonFailureMessage(str, str).c_str());
***REMOVED***

// wchar_t array vs pointer
TEST(FormatForComparisonFailureMessageTest, WorksForWCharArrayVsPointer) ***REMOVED***
  wchar_t str[] = L"hi \"world\"";
  wchar_t* p = NULL;
  EXPECT_EQ(PrintPointer(str),
            FormatForComparisonFailureMessage(str, p).c_str());
***REMOVED***

// wchar_t array vs wchar_t array
TEST(FormatForComparisonFailureMessageTest, WorksForWCharArrayVsWCharArray) ***REMOVED***
  const wchar_t str[] = L"hi \"world\"";
  EXPECT_EQ(PrintPointer(str),
            FormatForComparisonFailureMessage(str, str).c_str());
***REMOVED***

// Tests formatting a char array when it's compared with a string object.
// In this case we want to print the array as a C string.

#if GTEST_HAS_GLOBAL_STRING
// char array vs string
TEST(FormatForComparisonFailureMessageTest, WorksForCharArrayVsString) ***REMOVED***
  const char str[] = "hi \"w\0rld\"";
  EXPECT_STREQ("\"hi \\\"w\"",  // The content should be escaped.
                                // Embedded NUL terminates the string.
               FormatForComparisonFailureMessage(str, ::string()).c_str());
***REMOVED***
#endif

// char array vs std::string
TEST(FormatForComparisonFailureMessageTest, WorksForCharArrayVsStdString) ***REMOVED***
  const char str[] = "hi \"world\"";
  EXPECT_STREQ("\"hi \\\"world\\\"\"",  // The content should be escaped.
               FormatForComparisonFailureMessage(str, ::std::string()).c_str());
***REMOVED***

#if GTEST_HAS_GLOBAL_WSTRING
// wchar_t array vs wstring
TEST(FormatForComparisonFailureMessageTest, WorksForWCharArrayVsWString) ***REMOVED***
  const wchar_t str[] = L"hi \"world\"";
  EXPECT_STREQ("L\"hi \\\"world\\\"\"",  // The content should be escaped.
               FormatForComparisonFailureMessage(str, ::wstring()).c_str());
***REMOVED***
#endif

#if GTEST_HAS_STD_WSTRING
// wchar_t array vs std::wstring
TEST(FormatForComparisonFailureMessageTest, WorksForWCharArrayVsStdWString) ***REMOVED***
  const wchar_t str[] = L"hi \"w\0rld\"";
  EXPECT_STREQ(
      "L\"hi \\\"w\"",  // The content should be escaped.
                        // Embedded NUL terminates the string.
      FormatForComparisonFailureMessage(str, ::std::wstring()).c_str());
***REMOVED***
#endif

// Useful for testing PrintToString().  We cannot use EXPECT_EQ()
// there as its implementation uses PrintToString().  The caller must
// ensure that 'value' has no side effect.
#define EXPECT_PRINT_TO_STRING_(value, expected_string)         \
  EXPECT_TRUE(PrintToString(value) == (expected_string))        \
      << " where " #value " prints as " << (PrintToString(value))

TEST(PrintToStringTest, WorksForScalar) ***REMOVED***
  EXPECT_PRINT_TO_STRING_(123, "123");
***REMOVED***

TEST(PrintToStringTest, WorksForPointerToConstChar) ***REMOVED***
  const char* p = "hello";
  EXPECT_PRINT_TO_STRING_(p, "\"hello\"");
***REMOVED***

TEST(PrintToStringTest, WorksForPointerToNonConstChar) ***REMOVED***
  char s[] = "hello";
  char* p = s;
  EXPECT_PRINT_TO_STRING_(p, "\"hello\"");
***REMOVED***

TEST(PrintToStringTest, EscapesForPointerToConstChar) ***REMOVED***
  const char* p = "hello\n";
  EXPECT_PRINT_TO_STRING_(p, "\"hello\\n\"");
***REMOVED***

TEST(PrintToStringTest, EscapesForPointerToNonConstChar) ***REMOVED***
  char s[] = "hello\1";
  char* p = s;
  EXPECT_PRINT_TO_STRING_(p, "\"hello\\x1\"");
***REMOVED***

TEST(PrintToStringTest, WorksForArray) ***REMOVED***
  int n[3] = ***REMOVED*** 1, 2, 3 ***REMOVED***;
  EXPECT_PRINT_TO_STRING_(n, "***REMOVED*** 1, 2, 3 ***REMOVED***");
***REMOVED***

TEST(PrintToStringTest, WorksForCharArray) ***REMOVED***
  char s[] = "hello";
  EXPECT_PRINT_TO_STRING_(s, "\"hello\"");
***REMOVED***

TEST(PrintToStringTest, WorksForCharArrayWithEmbeddedNul) ***REMOVED***
  const char str_with_nul[] = "hello\0 world";
  EXPECT_PRINT_TO_STRING_(str_with_nul, "\"hello\\0 world\"");

  char mutable_str_with_nul[] = "hello\0 world";
  EXPECT_PRINT_TO_STRING_(mutable_str_with_nul, "\"hello\\0 world\"");
***REMOVED***

#undef EXPECT_PRINT_TO_STRING_

TEST(UniversalTersePrintTest, WorksForNonReference) ***REMOVED***
  ::std::stringstream ss;
  UniversalTersePrint(123, &ss);
  EXPECT_EQ("123", ss.str());
***REMOVED***

TEST(UniversalTersePrintTest, WorksForReference) ***REMOVED***
  const int& n = 123;
  ::std::stringstream ss;
  UniversalTersePrint(n, &ss);
  EXPECT_EQ("123", ss.str());
***REMOVED***

TEST(UniversalTersePrintTest, WorksForCString) ***REMOVED***
  const char* s1 = "abc";
  ::std::stringstream ss1;
  UniversalTersePrint(s1, &ss1);
  EXPECT_EQ("\"abc\"", ss1.str());

  char* s2 = const_cast<char*>(s1);
  ::std::stringstream ss2;
  UniversalTersePrint(s2, &ss2);
  EXPECT_EQ("\"abc\"", ss2.str());

  const char* s3 = NULL;
  ::std::stringstream ss3;
  UniversalTersePrint(s3, &ss3);
  EXPECT_EQ("NULL", ss3.str());
***REMOVED***

TEST(UniversalPrintTest, WorksForNonReference) ***REMOVED***
  ::std::stringstream ss;
  UniversalPrint(123, &ss);
  EXPECT_EQ("123", ss.str());
***REMOVED***

TEST(UniversalPrintTest, WorksForReference) ***REMOVED***
  const int& n = 123;
  ::std::stringstream ss;
  UniversalPrint(n, &ss);
  EXPECT_EQ("123", ss.str());
***REMOVED***

TEST(UniversalPrintTest, WorksForCString) ***REMOVED***
  const char* s1 = "abc";
  ::std::stringstream ss1;
  UniversalPrint(s1, &ss1);
  EXPECT_EQ(PrintPointer(s1) + " pointing to \"abc\"", string(ss1.str()));

  char* s2 = const_cast<char*>(s1);
  ::std::stringstream ss2;
  UniversalPrint(s2, &ss2);
  EXPECT_EQ(PrintPointer(s2) + " pointing to \"abc\"", string(ss2.str()));

  const char* s3 = NULL;
  ::std::stringstream ss3;
  UniversalPrint(s3, &ss3);
  EXPECT_EQ("NULL", ss3.str());
***REMOVED***

TEST(UniversalPrintTest, WorksForCharArray) ***REMOVED***
  const char str[] = "\"Line\0 1\"\nLine 2";
  ::std::stringstream ss1;
  UniversalPrint(str, &ss1);
  EXPECT_EQ("\"\\\"Line\\0 1\\\"\\nLine 2\"", ss1.str());

  const char mutable_str[] = "\"Line\0 1\"\nLine 2";
  ::std::stringstream ss2;
  UniversalPrint(mutable_str, &ss2);
  EXPECT_EQ("\"\\\"Line\\0 1\\\"\\nLine 2\"", ss2.str());
***REMOVED***

#if GTEST_HAS_TR1_TUPLE

TEST(UniversalTersePrintTupleFieldsToStringsTestWithTr1, PrintsEmptyTuple) ***REMOVED***
  Strings result = UniversalTersePrintTupleFieldsToStrings(
      ::std::tr1::make_tuple());
  EXPECT_EQ(0u, result.size());
***REMOVED***

TEST(UniversalTersePrintTupleFieldsToStringsTestWithTr1, PrintsOneTuple) ***REMOVED***
  Strings result = UniversalTersePrintTupleFieldsToStrings(
      ::std::tr1::make_tuple(1));
  ASSERT_EQ(1u, result.size());
  EXPECT_EQ("1", result[0]);
***REMOVED***

TEST(UniversalTersePrintTupleFieldsToStringsTestWithTr1, PrintsTwoTuple) ***REMOVED***
  Strings result = UniversalTersePrintTupleFieldsToStrings(
      ::std::tr1::make_tuple(1, 'a'));
  ASSERT_EQ(2u, result.size());
  EXPECT_EQ("1", result[0]);
  EXPECT_EQ("'a' (97, 0x61)", result[1]);
***REMOVED***

TEST(UniversalTersePrintTupleFieldsToStringsTestWithTr1, PrintsTersely) ***REMOVED***
  const int n = 1;
  Strings result = UniversalTersePrintTupleFieldsToStrings(
      ::std::tr1::tuple<const int&, const char*>(n, "a"));
  ASSERT_EQ(2u, result.size());
  EXPECT_EQ("1", result[0]);
  EXPECT_EQ("\"a\"", result[1]);
***REMOVED***

#endif  // GTEST_HAS_TR1_TUPLE

#if GTEST_HAS_STD_TUPLE_

TEST(UniversalTersePrintTupleFieldsToStringsTestWithStd, PrintsEmptyTuple) ***REMOVED***
  Strings result = UniversalTersePrintTupleFieldsToStrings(::std::make_tuple());
  EXPECT_EQ(0u, result.size());
***REMOVED***

TEST(UniversalTersePrintTupleFieldsToStringsTestWithStd, PrintsOneTuple) ***REMOVED***
  Strings result = UniversalTersePrintTupleFieldsToStrings(
      ::std::make_tuple(1));
  ASSERT_EQ(1u, result.size());
  EXPECT_EQ("1", result[0]);
***REMOVED***

TEST(UniversalTersePrintTupleFieldsToStringsTestWithStd, PrintsTwoTuple) ***REMOVED***
  Strings result = UniversalTersePrintTupleFieldsToStrings(
      ::std::make_tuple(1, 'a'));
  ASSERT_EQ(2u, result.size());
  EXPECT_EQ("1", result[0]);
  EXPECT_EQ("'a' (97, 0x61)", result[1]);
***REMOVED***

TEST(UniversalTersePrintTupleFieldsToStringsTestWithStd, PrintsTersely) ***REMOVED***
  const int n = 1;
  Strings result = UniversalTersePrintTupleFieldsToStrings(
      ::std::tuple<const int&, const char*>(n, "a"));
  ASSERT_EQ(2u, result.size());
  EXPECT_EQ("1", result[0]);
  EXPECT_EQ("\"a\"", result[1]);
***REMOVED***

#endif  // GTEST_HAS_STD_TUPLE_

***REMOVED***  // namespace gtest_printers_test
***REMOVED***  // namespace testing

