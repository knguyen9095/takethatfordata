/* Copyright (c) 2015, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

var verbose = flag.Bool("verbose", false, "If true, prints a status message at the end.")

// libraryNames must be kept in sync with the enum in err.h. The generated code
// will contain static assertions to enforce this.
var libraryNames = []string***REMOVED***
	"NONE",
	"SYS",
	"BN",
	"RSA",
	"DH",
	"EVP",
	"BUF",
	"OBJ",
	"PEM",
	"DSA",
	"X509",
	"ASN1",
	"CONF",
	"CRYPTO",
	"EC",
	"SSL",
	"BIO",
	"PKCS7",
	"PKCS8",
	"X509V3",
	"RAND",
	"ENGINE",
	"OCSP",
	"UI",
	"COMP",
	"ECDSA",
	"ECDH",
	"HMAC",
	"DIGEST",
	"CIPHER",
	"HKDF",
	"USER",
***REMOVED***

// stringList is a map from uint32 -> string which can output data for a sorted
// list as C literals.
type stringList struct ***REMOVED***
	// entries is an array of keys and offsets into |stringData|. The
	// offsets are in the bottom 15 bits of each uint32 and the key is the
	// top 17 bits.
	entries []uint32
	// internedStrings contains the same strings as are in |stringData|,
	// but allows for easy deduplication. It maps a string to its offset in
	// |stringData|.
	internedStrings map[string]uint32
	stringData      []byte
***REMOVED***

func newStringList() *stringList ***REMOVED***
	return &stringList***REMOVED***
		internedStrings: make(map[string]uint32),
	***REMOVED***
***REMOVED***

// offsetMask is the bottom 15 bits. It's a mask that selects the offset from a
// uint32 in entries.
const offsetMask = 0x7fff

func (st *stringList) Add(key uint32, value string) error ***REMOVED***
	if key&offsetMask != 0 ***REMOVED***
		return errors.New("need bottom 15 bits of the key for the offset")
	***REMOVED***
	offset, ok := st.internedStrings[value]
	if !ok ***REMOVED***
		offset = uint32(len(st.stringData))
		if offset&offsetMask != offset ***REMOVED***
			return errors.New("stringList overflow")
		***REMOVED***
		st.stringData = append(st.stringData, []byte(value)...)
		st.stringData = append(st.stringData, 0)
		st.internedStrings[value] = offset
	***REMOVED***

	for _, existing := range st.entries ***REMOVED***
		if existing>>15 == key>>15 ***REMOVED***
			panic("duplicate entry")
		***REMOVED***
	***REMOVED***
	st.entries = append(st.entries, key|offset)
	return nil
***REMOVED***

// keySlice is a type that implements sorting of entries values.
type keySlice []uint32

func (ks keySlice) Len() int ***REMOVED***
	return len(ks)
***REMOVED***

func (ks keySlice) Less(i, j int) bool ***REMOVED***
	return (ks[i] >> 15) < (ks[j] >> 15)
***REMOVED***

func (ks keySlice) Swap(i, j int) ***REMOVED***
	ks[i], ks[j] = ks[j], ks[i]
***REMOVED***

func (st *stringList) buildList() []uint32 ***REMOVED***
	sort.Sort(keySlice(st.entries))
	return st.entries
***REMOVED***

type stringWriter interface ***REMOVED***
	io.Writer
	WriteString(string) (int, error)
***REMOVED***

func (st *stringList) WriteTo(out stringWriter, name string) ***REMOVED***
	list := st.buildList()
	if *verbose ***REMOVED***
		fmt.Fprintf(os.Stderr, "%s: %d bytes of list and %d bytes of string data.\n", name, 4*len(list), len(st.stringData))
	***REMOVED***

	values := "kOpenSSL" + name + "Values"
	out.WriteString("const uint32_t " + values + "[] = ***REMOVED***\n")
	for _, v := range list ***REMOVED***
		fmt.Fprintf(out, "    0x%x,\n", v)
	***REMOVED***
	out.WriteString("***REMOVED***;\n\n")
	out.WriteString("const size_t " + values + "Len = sizeof(" + values + ") / sizeof(" + values + "[0]);\n\n")

	stringData := "kOpenSSL" + name + "StringData"
	out.WriteString("const char " + stringData + "[] =\n    \"")
	for i, c := range st.stringData ***REMOVED***
		if c == 0 ***REMOVED***
			out.WriteString("\\0\"\n    \"")
			continue
		***REMOVED***
		out.Write(st.stringData[i : i+1])
	***REMOVED***
	out.WriteString("\";\n\n")
***REMOVED***

type errorData struct ***REMOVED***
	reasons    *stringList
	libraryMap map[string]uint32
***REMOVED***

func (e *errorData) readErrorDataFile(filename string) error ***REMOVED***
	inFile, err := os.Open(filename)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	defer inFile.Close()

	scanner := bufio.NewScanner(inFile)
	comma := []byte(",")

	lineNo := 0
	for scanner.Scan() ***REMOVED***
		lineNo++

		line := scanner.Bytes()
		if len(line) == 0 ***REMOVED***
			continue
		***REMOVED***
		parts := bytes.Split(line, comma)
		if len(parts) != 3 ***REMOVED***
			return fmt.Errorf("bad line %d in %s: found %d values but want 3", lineNo, filename, len(parts))
		***REMOVED***
		libNum, ok := e.libraryMap[string(parts[0])]
		if !ok ***REMOVED***
			return fmt.Errorf("bad line %d in %s: unknown library", lineNo, filename)
		***REMOVED***
		if libNum >= 64 ***REMOVED***
			return fmt.Errorf("bad line %d in %s: library value too large", lineNo, filename)
		***REMOVED***
		key, err := strconv.ParseUint(string(parts[1]), 10 /* base */, 32 /* bit size */)
		if err != nil ***REMOVED***
			return fmt.Errorf("bad line %d in %s: %s", lineNo, filename, err)
		***REMOVED***
		if key >= 2048 ***REMOVED***
			return fmt.Errorf("bad line %d in %s: key too large", lineNo, filename)
		***REMOVED***
		value := string(parts[2])

		listKey := libNum<<26 | uint32(key)<<15

		err = e.reasons.Add(listKey, value)
		if err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	return scanner.Err()
***REMOVED***

func main() ***REMOVED***
	flag.Parse()

	e := &errorData***REMOVED***
		reasons:    newStringList(),
		libraryMap: make(map[string]uint32),
	***REMOVED***
	for i, name := range libraryNames ***REMOVED***
		e.libraryMap[name] = uint32(i) + 1
	***REMOVED***

	cwd, err := os.Open(".")
	if err != nil ***REMOVED***
		panic(err)
	***REMOVED***
	names, err := cwd.Readdirnames(-1)
	if err != nil ***REMOVED***
		panic(err)
	***REMOVED***

	sort.Strings(names)
	for _, name := range names ***REMOVED***
		if !strings.HasSuffix(name, ".errordata") ***REMOVED***
			continue
		***REMOVED***
		if err := e.readErrorDataFile(name); err != nil ***REMOVED***
			panic(err)
		***REMOVED***
	***REMOVED***

	out := os.Stdout

	out.WriteString(`/* Copyright (c) 2015, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

 /* This file was generated by err_data_generate.go. */

#include <openssl/base.h>
#include <openssl/err.h>
#include <openssl/type_check.h>


`)

	for i, name := range libraryNames ***REMOVED***
		fmt.Fprintf(out, "OPENSSL_COMPILE_ASSERT(ERR_LIB_%s == %d, library_values_changed_%d);\n", name, i+1, i+1)
	***REMOVED***
	fmt.Fprintf(out, "OPENSSL_COMPILE_ASSERT(ERR_NUM_LIBS == %d, library_values_changed_num);\n", len(libraryNames)+1)
	out.WriteString("\n")

	e.reasons.WriteTo(out, "Reason")
***REMOVED***
