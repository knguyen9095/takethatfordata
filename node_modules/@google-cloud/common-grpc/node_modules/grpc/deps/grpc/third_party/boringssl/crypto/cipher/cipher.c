/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.] */

#include <openssl/cipher.h>

#include <assert.h>
#include <string.h>

#include <openssl/err.h>
#include <openssl/mem.h>
#include <openssl/nid.h>

#include "internal.h"
#include "../internal.h"


const EVP_CIPHER *EVP_get_cipherbynid(int nid) ***REMOVED***
  switch (nid) ***REMOVED***
    case NID_rc2_cbc:
      return EVP_rc2_cbc();
    case NID_rc2_40_cbc:
      return EVP_rc2_40_cbc();
    case NID_des_ede3_cbc:
      return EVP_des_ede3_cbc();
    case NID_des_ede_cbc:
      return EVP_des_cbc();
    case NID_aes_128_cbc:
      return EVP_aes_128_cbc();
    case NID_aes_192_cbc:
      return EVP_aes_192_cbc();
    case NID_aes_256_cbc:
      return EVP_aes_256_cbc();
    default:
      return NULL;
  ***REMOVED***
***REMOVED***

void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx) ***REMOVED***
  OPENSSL_memset(ctx, 0, sizeof(EVP_CIPHER_CTX));
***REMOVED***

EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void) ***REMOVED***
  EVP_CIPHER_CTX *ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
  if (ctx) ***REMOVED***
    EVP_CIPHER_CTX_init(ctx);
  ***REMOVED***
  return ctx;
***REMOVED***

int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c) ***REMOVED***
  if (c->cipher != NULL) ***REMOVED***
    if (c->cipher->cleanup) ***REMOVED***
      c->cipher->cleanup(c);
    ***REMOVED***
    OPENSSL_cleanse(c->cipher_data, c->cipher->ctx_size);
  ***REMOVED***
  OPENSSL_free(c->cipher_data);

  OPENSSL_memset(c, 0, sizeof(EVP_CIPHER_CTX));
  return 1;
***REMOVED***

void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx) ***REMOVED***
  if (ctx) ***REMOVED***
    EVP_CIPHER_CTX_cleanup(ctx);
    OPENSSL_free(ctx);
  ***REMOVED***
***REMOVED***

int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in) ***REMOVED***
  if (in == NULL || in->cipher == NULL) ***REMOVED***
    OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_INPUT_NOT_INITIALIZED);
    return 0;
  ***REMOVED***

  EVP_CIPHER_CTX_cleanup(out);
  OPENSSL_memcpy(out, in, sizeof(EVP_CIPHER_CTX));

  if (in->cipher_data && in->cipher->ctx_size) ***REMOVED***
    out->cipher_data = OPENSSL_malloc(in->cipher->ctx_size);
    if (!out->cipher_data) ***REMOVED***
      out->cipher = NULL;
      OPENSSL_PUT_ERROR(CIPHER, ERR_R_MALLOC_FAILURE);
      return 0;
    ***REMOVED***
    OPENSSL_memcpy(out->cipher_data, in->cipher_data, in->cipher->ctx_size);
  ***REMOVED***

  if (in->cipher->flags & EVP_CIPH_CUSTOM_COPY) ***REMOVED***
    if (!in->cipher->ctrl((EVP_CIPHER_CTX *)in, EVP_CTRL_COPY, 0, out)) ***REMOVED***
      out->cipher = NULL;
      return 0;
    ***REMOVED***
  ***REMOVED***

  return 1;
***REMOVED***

int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                      ENGINE *engine, const uint8_t *key, const uint8_t *iv,
                      int enc) ***REMOVED***
  if (enc == -1) ***REMOVED***
    enc = ctx->encrypt;
  ***REMOVED*** else ***REMOVED***
    if (enc) ***REMOVED***
      enc = 1;
    ***REMOVED***
    ctx->encrypt = enc;
  ***REMOVED***

  if (cipher) ***REMOVED***
    /* Ensure a context left from last time is cleared (the previous check
     * attempted to avoid this if the same ENGINE and EVP_CIPHER could be
     * used). */
    if (ctx->cipher) ***REMOVED***
      EVP_CIPHER_CTX_cleanup(ctx);
      /* Restore encrypt and flags */
      ctx->encrypt = enc;
    ***REMOVED***

    ctx->cipher = cipher;
    if (ctx->cipher->ctx_size) ***REMOVED***
      ctx->cipher_data = OPENSSL_malloc(ctx->cipher->ctx_size);
      if (!ctx->cipher_data) ***REMOVED***
        ctx->cipher = NULL;
        OPENSSL_PUT_ERROR(CIPHER, ERR_R_MALLOC_FAILURE);
        return 0;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      ctx->cipher_data = NULL;
    ***REMOVED***

    ctx->key_len = cipher->key_len;
    ctx->flags = 0;

    if (ctx->cipher->flags & EVP_CIPH_CTRL_INIT) ***REMOVED***
      if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL)) ***REMOVED***
        ctx->cipher = NULL;
        OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_INITIALIZATION_ERROR);
        return 0;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (!ctx->cipher) ***REMOVED***
    OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_NO_CIPHER_SET);
    return 0;
  ***REMOVED***

  /* we assume block size is a power of 2 in *cryptUpdate */
  assert(ctx->cipher->block_size == 1 || ctx->cipher->block_size == 8 ||
         ctx->cipher->block_size == 16);

  if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_CUSTOM_IV)) ***REMOVED***
    switch (EVP_CIPHER_CTX_mode(ctx)) ***REMOVED***
      case EVP_CIPH_STREAM_CIPHER:
      case EVP_CIPH_ECB_MODE:
        break;

      case EVP_CIPH_CFB_MODE:
        ctx->num = 0;
        /* fall-through */

      case EVP_CIPH_CBC_MODE:
        assert(EVP_CIPHER_CTX_iv_length(ctx) <= sizeof(ctx->iv));
        if (iv) ***REMOVED***
          OPENSSL_memcpy(ctx->oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));
        ***REMOVED***
        OPENSSL_memcpy(ctx->iv, ctx->oiv, EVP_CIPHER_CTX_iv_length(ctx));
        break;

      case EVP_CIPH_CTR_MODE:
      case EVP_CIPH_OFB_MODE:
        ctx->num = 0;
        /* Don't reuse IV for CTR mode */
        if (iv) ***REMOVED***
          OPENSSL_memcpy(ctx->iv, iv, EVP_CIPHER_CTX_iv_length(ctx));
        ***REMOVED***
        break;

      default:
        return 0;
    ***REMOVED***
  ***REMOVED***

  if (key || (ctx->cipher->flags & EVP_CIPH_ALWAYS_CALL_INIT)) ***REMOVED***
    if (!ctx->cipher->init(ctx, key, iv, enc)) ***REMOVED***
      return 0;
    ***REMOVED***
  ***REMOVED***

  ctx->buf_len = 0;
  ctx->final_used = 0;
  ctx->block_mask = ctx->cipher->block_size - 1;
  return 1;
***REMOVED***

int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                       ENGINE *impl, const uint8_t *key, const uint8_t *iv) ***REMOVED***
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 1);
***REMOVED***

int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                       ENGINE *impl, const uint8_t *key, const uint8_t *iv) ***REMOVED***
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 0);
***REMOVED***

int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, uint8_t *out, int *out_len,
                      const uint8_t *in, int in_len) ***REMOVED***
  int i, j, bl;

  if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) ***REMOVED***
    i = ctx->cipher->cipher(ctx, out, in, in_len);
    if (i < 0) ***REMOVED***
      return 0;
    ***REMOVED*** else ***REMOVED***
      *out_len = i;
    ***REMOVED***
    return 1;
  ***REMOVED***

  if (in_len <= 0) ***REMOVED***
    *out_len = 0;
    return in_len == 0;
  ***REMOVED***

  if (ctx->buf_len == 0 && (in_len & ctx->block_mask) == 0) ***REMOVED***
    if (ctx->cipher->cipher(ctx, out, in, in_len)) ***REMOVED***
      *out_len = in_len;
      return 1;
    ***REMOVED*** else ***REMOVED***
      *out_len = 0;
      return 0;
    ***REMOVED***
  ***REMOVED***

  i = ctx->buf_len;
  bl = ctx->cipher->block_size;
  assert(bl <= (int)sizeof(ctx->buf));
  if (i != 0) ***REMOVED***
    if (bl - i > in_len) ***REMOVED***
      OPENSSL_memcpy(&ctx->buf[i], in, in_len);
      ctx->buf_len += in_len;
      *out_len = 0;
      return 1;
    ***REMOVED*** else ***REMOVED***
      j = bl - i;
      OPENSSL_memcpy(&ctx->buf[i], in, j);
      if (!ctx->cipher->cipher(ctx, out, ctx->buf, bl)) ***REMOVED***
        return 0;
      ***REMOVED***
      in_len -= j;
      in += j;
      out += bl;
      *out_len = bl;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    *out_len = 0;
  ***REMOVED***

  i = in_len & ctx->block_mask;
  in_len -= i;
  if (in_len > 0) ***REMOVED***
    if (!ctx->cipher->cipher(ctx, out, in, in_len)) ***REMOVED***
      return 0;
    ***REMOVED***
    *out_len += in_len;
  ***REMOVED***

  if (i != 0) ***REMOVED***
    OPENSSL_memcpy(ctx->buf, &in[in_len], i);
  ***REMOVED***
  ctx->buf_len = i;
  return 1;
***REMOVED***

int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, uint8_t *out, int *out_len) ***REMOVED***
  int n, ret;
  unsigned int i, b, bl;

  if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) ***REMOVED***
    ret = ctx->cipher->cipher(ctx, out, NULL, 0);
    if (ret < 0) ***REMOVED***
      return 0;
    ***REMOVED*** else ***REMOVED***
      *out_len = ret;
    ***REMOVED***
    return 1;
  ***REMOVED***

  b = ctx->cipher->block_size;
  assert(b <= sizeof(ctx->buf));
  if (b == 1) ***REMOVED***
    *out_len = 0;
    return 1;
  ***REMOVED***

  bl = ctx->buf_len;
  if (ctx->flags & EVP_CIPH_NO_PADDING) ***REMOVED***
    if (bl) ***REMOVED***
      OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
      return 0;
    ***REMOVED***
    *out_len = 0;
    return 1;
  ***REMOVED***

  n = b - bl;
  for (i = bl; i < b; i++) ***REMOVED***
    ctx->buf[i] = n;
  ***REMOVED***
  ret = ctx->cipher->cipher(ctx, out, ctx->buf, b);

  if (ret) ***REMOVED***
    *out_len = b;
  ***REMOVED***

  return ret;
***REMOVED***

int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, uint8_t *out, int *out_len,
                      const uint8_t *in, int in_len) ***REMOVED***
  int fix_len;
  unsigned int b;

  if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) ***REMOVED***
    int r = ctx->cipher->cipher(ctx, out, in, in_len);
    if (r < 0) ***REMOVED***
      *out_len = 0;
      return 0;
    ***REMOVED*** else ***REMOVED***
      *out_len = r;
    ***REMOVED***
    return 1;
  ***REMOVED***

  if (in_len <= 0) ***REMOVED***
    *out_len = 0;
    return in_len == 0;
  ***REMOVED***

  if (ctx->flags & EVP_CIPH_NO_PADDING) ***REMOVED***
    return EVP_EncryptUpdate(ctx, out, out_len, in, in_len);
  ***REMOVED***

  b = ctx->cipher->block_size;
  assert(b <= sizeof(ctx->final));

  if (ctx->final_used) ***REMOVED***
    OPENSSL_memcpy(out, ctx->final, b);
    out += b;
    fix_len = 1;
  ***REMOVED*** else ***REMOVED***
    fix_len = 0;
  ***REMOVED***

  if (!EVP_EncryptUpdate(ctx, out, out_len, in, in_len)) ***REMOVED***
    return 0;
  ***REMOVED***

  /* if we have 'decrypted' a multiple of block size, make sure
   * we have a copy of this last block */
  if (b > 1 && !ctx->buf_len) ***REMOVED***
    *out_len -= b;
    ctx->final_used = 1;
    OPENSSL_memcpy(ctx->final, &out[*out_len], b);
  ***REMOVED*** else ***REMOVED***
    ctx->final_used = 0;
  ***REMOVED***

  if (fix_len) ***REMOVED***
    *out_len += b;
  ***REMOVED***

  return 1;
***REMOVED***

int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *out_len) ***REMOVED***
  int i, n;
  unsigned int b;
  *out_len = 0;

  if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) ***REMOVED***
    i = ctx->cipher->cipher(ctx, out, NULL, 0);
    if (i < 0) ***REMOVED***
      return 0;
    ***REMOVED*** else ***REMOVED***
      *out_len = i;
    ***REMOVED***
    return 1;
  ***REMOVED***

  b = ctx->cipher->block_size;
  if (ctx->flags & EVP_CIPH_NO_PADDING) ***REMOVED***
    if (ctx->buf_len) ***REMOVED***
      OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
      return 0;
    ***REMOVED***
    *out_len = 0;
    return 1;
  ***REMOVED***

  if (b > 1) ***REMOVED***
    if (ctx->buf_len || !ctx->final_used) ***REMOVED***
      OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_WRONG_FINAL_BLOCK_LENGTH);
      return 0;
    ***REMOVED***
    assert(b <= sizeof(ctx->final));

    /* The following assumes that the ciphertext has been authenticated.
     * Otherwise it provides a padding oracle. */
    n = ctx->final[b - 1];
    if (n == 0 || n > (int)b) ***REMOVED***
      OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BAD_DECRYPT);
      return 0;
    ***REMOVED***

    for (i = 0; i < n; i++) ***REMOVED***
      if (ctx->final[--b] != n) ***REMOVED***
        OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BAD_DECRYPT);
        return 0;
      ***REMOVED***
    ***REMOVED***

    n = ctx->cipher->block_size - n;
    for (i = 0; i < n; i++) ***REMOVED***
      out[i] = ctx->final[i];
    ***REMOVED***
    *out_len = n;
  ***REMOVED*** else ***REMOVED***
    *out_len = 0;
  ***REMOVED***

  return 1;
***REMOVED***

int EVP_Cipher(EVP_CIPHER_CTX *ctx, uint8_t *out, const uint8_t *in,
               size_t in_len) ***REMOVED***
  return ctx->cipher->cipher(ctx, out, in, in_len);
***REMOVED***

int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, uint8_t *out, int *out_len,
                     const uint8_t *in, int in_len) ***REMOVED***
  if (ctx->encrypt) ***REMOVED***
    return EVP_EncryptUpdate(ctx, out, out_len, in, in_len);
  ***REMOVED*** else ***REMOVED***
    return EVP_DecryptUpdate(ctx, out, out_len, in, in_len);
  ***REMOVED***
***REMOVED***

int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, uint8_t *out, int *out_len) ***REMOVED***
  if (ctx->encrypt) ***REMOVED***
    return EVP_EncryptFinal_ex(ctx, out, out_len);
  ***REMOVED*** else ***REMOVED***
    return EVP_DecryptFinal_ex(ctx, out, out_len);
  ***REMOVED***
***REMOVED***

const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx) ***REMOVED***
  return ctx->cipher;
***REMOVED***

int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx) ***REMOVED***
  return ctx->cipher->nid;
***REMOVED***

unsigned EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx) ***REMOVED***
  return ctx->cipher->block_size;
***REMOVED***

unsigned EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx) ***REMOVED***
  return ctx->key_len;
***REMOVED***

unsigned EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx) ***REMOVED***
  return ctx->cipher->iv_len;
***REMOVED***

void *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx) ***REMOVED***
  return ctx->app_data;
***REMOVED***

void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data) ***REMOVED***
  ctx->app_data = data;
***REMOVED***

uint32_t EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx) ***REMOVED***
  return ctx->cipher->flags & ~EVP_CIPH_MODE_MASK;
***REMOVED***

uint32_t EVP_CIPHER_CTX_mode(const EVP_CIPHER_CTX *ctx) ***REMOVED***
  return ctx->cipher->flags & EVP_CIPH_MODE_MASK;
***REMOVED***

int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int command, int arg, void *ptr) ***REMOVED***
  int ret;
  if (!ctx->cipher) ***REMOVED***
    OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_NO_CIPHER_SET);
    return 0;
  ***REMOVED***

  if (!ctx->cipher->ctrl) ***REMOVED***
    OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_CTRL_NOT_IMPLEMENTED);
    return 0;
  ***REMOVED***

  ret = ctx->cipher->ctrl(ctx, command, arg, ptr);
  if (ret == -1) ***REMOVED***
    OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_CTRL_OPERATION_NOT_IMPLEMENTED);
    return 0;
  ***REMOVED***

  return ret;
***REMOVED***

int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad) ***REMOVED***
  if (pad) ***REMOVED***
    ctx->flags &= ~EVP_CIPH_NO_PADDING;
  ***REMOVED*** else ***REMOVED***
    ctx->flags |= EVP_CIPH_NO_PADDING;
  ***REMOVED***
  return 1;
***REMOVED***

int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, unsigned key_len) ***REMOVED***
  if (c->key_len == key_len) ***REMOVED***
    return 1;
  ***REMOVED***

  if (key_len == 0 || !(c->cipher->flags & EVP_CIPH_VARIABLE_LENGTH)) ***REMOVED***
    OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_INVALID_KEY_LENGTH);
    return 0;
  ***REMOVED***

  c->key_len = key_len;
  return 1;
***REMOVED***

int EVP_CIPHER_nid(const EVP_CIPHER *cipher) ***REMOVED*** return cipher->nid; ***REMOVED***

unsigned EVP_CIPHER_block_size(const EVP_CIPHER *cipher) ***REMOVED***
  return cipher->block_size;
***REMOVED***

unsigned EVP_CIPHER_key_length(const EVP_CIPHER *cipher) ***REMOVED***
  return cipher->key_len;
***REMOVED***

unsigned EVP_CIPHER_iv_length(const EVP_CIPHER *cipher) ***REMOVED***
  return cipher->iv_len;
***REMOVED***

uint32_t EVP_CIPHER_flags(const EVP_CIPHER *cipher) ***REMOVED***
  return cipher->flags & ~EVP_CIPH_MODE_MASK;
***REMOVED***

uint32_t EVP_CIPHER_mode(const EVP_CIPHER *cipher) ***REMOVED***
  return cipher->flags & EVP_CIPH_MODE_MASK;
***REMOVED***

int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                   const uint8_t *key, const uint8_t *iv, int enc) ***REMOVED***
  if (cipher) ***REMOVED***
    EVP_CIPHER_CTX_init(ctx);
  ***REMOVED***
  return EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, enc);
***REMOVED***

int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                    const uint8_t *key, const uint8_t *iv) ***REMOVED***
  return EVP_CipherInit(ctx, cipher, key, iv, 1);
***REMOVED***

int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                    const uint8_t *key, const uint8_t *iv) ***REMOVED***
  return EVP_CipherInit(ctx, cipher, key, iv, 0);
***REMOVED***

int EVP_add_cipher_alias(const char *a, const char *b) ***REMOVED***
  return 1;
***REMOVED***

const EVP_CIPHER *EVP_get_cipherbyname(const char *name) ***REMOVED***
  if (OPENSSL_strcasecmp(name, "rc4") == 0) ***REMOVED***
    return EVP_rc4();
  ***REMOVED*** else if (OPENSSL_strcasecmp(name, "des-cbc") == 0) ***REMOVED***
    return EVP_des_cbc();
  ***REMOVED*** else if (OPENSSL_strcasecmp(name, "des-ede3-cbc") == 0 ||
             OPENSSL_strcasecmp(name, "3des") == 0) ***REMOVED***
    return EVP_des_ede3_cbc();
  ***REMOVED*** else if (OPENSSL_strcasecmp(name, "aes-128-cbc") == 0) ***REMOVED***
    return EVP_aes_128_cbc();
  ***REMOVED*** else if (OPENSSL_strcasecmp(name, "aes-256-cbc") == 0) ***REMOVED***
    return EVP_aes_256_cbc();
  ***REMOVED*** else if (OPENSSL_strcasecmp(name, "aes-128-ctr") == 0) ***REMOVED***
    return EVP_aes_128_ctr();
  ***REMOVED*** else if (OPENSSL_strcasecmp(name, "aes-256-ctr") == 0) ***REMOVED***
    return EVP_aes_256_ctr();
  ***REMOVED*** else if (OPENSSL_strcasecmp(name, "aes-128-ecb") == 0) ***REMOVED***
    return EVP_aes_128_ecb();
  ***REMOVED*** else if (OPENSSL_strcasecmp(name, "aes-256-ecb") == 0) ***REMOVED***
    return EVP_aes_256_ecb();
  ***REMOVED***

  return NULL;
***REMOVED***
