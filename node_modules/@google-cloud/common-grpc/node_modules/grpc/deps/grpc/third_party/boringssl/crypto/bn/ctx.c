/* Written by Ulf Moeller for the OpenSSL project. */
/* ====================================================================
 * Copyright (c) 1998-2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com). */


#include <openssl/bn.h>

#include <string.h>

#include <openssl/err.h>
#include <openssl/mem.h>

#include "../internal.h"


/* How many bignums are in each "pool item"; */
#define BN_CTX_POOL_SIZE 16
/* The stack frame info is resizing, set a first-time expansion size; */
#define BN_CTX_START_FRAMES 32

/* A bundle of bignums that can be linked with other bundles */
typedef struct bignum_pool_item ***REMOVED***
  /* The bignum values */
  BIGNUM vals[BN_CTX_POOL_SIZE];
  /* Linked-list admin */
  struct bignum_pool_item *prev, *next;
***REMOVED*** BN_POOL_ITEM;


typedef struct bignum_pool ***REMOVED***
  /* Linked-list admin */
  BN_POOL_ITEM *head, *current, *tail;
  /* Stack depth and allocation size */
  unsigned used, size;
***REMOVED*** BN_POOL;

static void BN_POOL_init(BN_POOL *);
static void BN_POOL_finish(BN_POOL *);
static BIGNUM *BN_POOL_get(BN_POOL *);
static void BN_POOL_release(BN_POOL *, unsigned int);

/************/
/* BN_STACK */
/************/

/* A wrapper to manage the "stack frames" */
typedef struct bignum_ctx_stack ***REMOVED***
  /* Array of indexes into the bignum stack */
  unsigned int *indexes;
  /* Number of stack frames, and the size of the allocated array */
  unsigned int depth, size;
***REMOVED*** BN_STACK;

static void		BN_STACK_init(BN_STACK *);
static void		BN_STACK_finish(BN_STACK *);
static int		BN_STACK_push(BN_STACK *, unsigned int);
static unsigned int	BN_STACK_pop(BN_STACK *);

/**********/
/* BN_CTX */
/**********/

/* The opaque BN_CTX type */
struct bignum_ctx ***REMOVED***
  /* The bignum bundles */
  BN_POOL pool;
  /* The "stack frames", if you will */
  BN_STACK stack;
  /* The number of bignums currently assigned */
  unsigned int used;
  /* Depth of stack overflow */
  int err_stack;
  /* Block "gets" until an "end" (compatibility behaviour) */
  int too_many;
***REMOVED***;

BN_CTX *BN_CTX_new(void) ***REMOVED***
  BN_CTX *ret = OPENSSL_malloc(sizeof(BN_CTX));
  if (!ret) ***REMOVED***
    OPENSSL_PUT_ERROR(BN, ERR_R_MALLOC_FAILURE);
    return NULL;
  ***REMOVED***

  /* Initialise the structure */
  BN_POOL_init(&ret->pool);
  BN_STACK_init(&ret->stack);
  ret->used = 0;
  ret->err_stack = 0;
  ret->too_many = 0;
  return ret;
***REMOVED***

void BN_CTX_free(BN_CTX *ctx) ***REMOVED***
  if (ctx == NULL) ***REMOVED***
    return;
  ***REMOVED***

  BN_STACK_finish(&ctx->stack);
  BN_POOL_finish(&ctx->pool);
  OPENSSL_free(ctx);
***REMOVED***

void BN_CTX_start(BN_CTX *ctx) ***REMOVED***
  /* If we're already overflowing ... */
  if (ctx->err_stack || ctx->too_many) ***REMOVED***
    ctx->err_stack++;
  ***REMOVED*** else if (!BN_STACK_push(&ctx->stack, ctx->used)) ***REMOVED***
    /* (Try to) get a new frame pointer */
    OPENSSL_PUT_ERROR(BN, BN_R_TOO_MANY_TEMPORARY_VARIABLES);
    ctx->err_stack++;
  ***REMOVED***
***REMOVED***

BIGNUM *BN_CTX_get(BN_CTX *ctx) ***REMOVED***
  BIGNUM *ret;
  if (ctx->err_stack || ctx->too_many) ***REMOVED***
    return NULL;
  ***REMOVED***

  ret = BN_POOL_get(&ctx->pool);
  if (ret == NULL) ***REMOVED***
    /* Setting too_many prevents repeated "get" attempts from
     * cluttering the error stack. */
    ctx->too_many = 1;
    OPENSSL_PUT_ERROR(BN, BN_R_TOO_MANY_TEMPORARY_VARIABLES);
    return NULL;
  ***REMOVED***

  /* OK, make sure the returned bignum is "zero" */
  BN_zero(ret);
  ctx->used++;
  return ret;
***REMOVED***

void BN_CTX_end(BN_CTX *ctx) ***REMOVED***
  if (ctx->err_stack) ***REMOVED***
    ctx->err_stack--;
  ***REMOVED*** else ***REMOVED***
    unsigned int fp = BN_STACK_pop(&ctx->stack);
    /* Does this stack frame have anything to release? */
    if (fp < ctx->used) ***REMOVED***
      BN_POOL_release(&ctx->pool, ctx->used - fp);
    ***REMOVED***

    ctx->used = fp;
    /* Unjam "too_many" in case "get" had failed */
    ctx->too_many = 0;
  ***REMOVED***
***REMOVED***

/************/
/* BN_STACK */
/************/

static void BN_STACK_init(BN_STACK *st) ***REMOVED***
  st->indexes = NULL;
  st->depth = st->size = 0;
***REMOVED***

static void BN_STACK_finish(BN_STACK *st) ***REMOVED***
  OPENSSL_free(st->indexes);
***REMOVED***

static int BN_STACK_push(BN_STACK *st, unsigned int idx) ***REMOVED***
  if (st->depth == st->size) ***REMOVED***
    /* Need to expand */
    unsigned int newsize =
        (st->size ? (st->size * 3 / 2) : BN_CTX_START_FRAMES);
    unsigned int *newitems = OPENSSL_malloc(newsize * sizeof(unsigned int));
    if (!newitems) ***REMOVED***
      return 0;
    ***REMOVED***
    if (st->depth) ***REMOVED***
      OPENSSL_memcpy(newitems, st->indexes, st->depth * sizeof(unsigned int));
    ***REMOVED***
    OPENSSL_free(st->indexes);
    st->indexes = newitems;
    st->size = newsize;
  ***REMOVED***

  st->indexes[(st->depth)++] = idx;
  return 1;
***REMOVED***

static unsigned int BN_STACK_pop(BN_STACK *st) ***REMOVED***
  return st->indexes[--(st->depth)];
***REMOVED***

static void BN_POOL_init(BN_POOL *p) ***REMOVED***
  p->head = p->current = p->tail = NULL;
  p->used = p->size = 0;
***REMOVED***

static void BN_POOL_finish(BN_POOL *p) ***REMOVED***
  while (p->head) ***REMOVED***
    unsigned int loop = 0;
    BIGNUM *bn = p->head->vals;
    while (loop++ < BN_CTX_POOL_SIZE) ***REMOVED***
      if (bn->d) ***REMOVED***
        BN_clear_free(bn);
      ***REMOVED***
      bn++;
    ***REMOVED***

    p->current = p->head->next;
    OPENSSL_free(p->head);
    p->head = p->current;
  ***REMOVED***
***REMOVED***

static BIGNUM *BN_POOL_get(BN_POOL *p) ***REMOVED***
  if (p->used == p->size) ***REMOVED***
    BIGNUM *bn;
    unsigned int loop = 0;
    BN_POOL_ITEM *item = OPENSSL_malloc(sizeof(BN_POOL_ITEM));
    if (!item) ***REMOVED***
      return NULL;
    ***REMOVED***

    /* Initialise the structure */
    bn = item->vals;
    while (loop++ < BN_CTX_POOL_SIZE) ***REMOVED***
      BN_init(bn++);
    ***REMOVED***

    item->prev = p->tail;
    item->next = NULL;
    /* Link it in */
    if (!p->head) ***REMOVED***
      p->head = p->current = p->tail = item;
    ***REMOVED*** else ***REMOVED***
      p->tail->next = item;
      p->tail = item;
      p->current = item;
    ***REMOVED***

    p->size += BN_CTX_POOL_SIZE;
    p->used++;
    /* Return the first bignum from the new pool */
    return item->vals;
  ***REMOVED***

  if (!p->used) ***REMOVED***
    p->current = p->head;
  ***REMOVED*** else if ((p->used % BN_CTX_POOL_SIZE) == 0) ***REMOVED***
    p->current = p->current->next;
  ***REMOVED***

  return p->current->vals + ((p->used++) % BN_CTX_POOL_SIZE);
***REMOVED***

static void BN_POOL_release(BN_POOL *p, unsigned int num) ***REMOVED***
  unsigned int offset = (p->used - 1) % BN_CTX_POOL_SIZE;
  p->used -= num;

  while (num--) ***REMOVED***
    if (!offset) ***REMOVED***
      offset = BN_CTX_POOL_SIZE - 1;
      p->current = p->current->prev;
    ***REMOVED*** else ***REMOVED***
      offset--;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
