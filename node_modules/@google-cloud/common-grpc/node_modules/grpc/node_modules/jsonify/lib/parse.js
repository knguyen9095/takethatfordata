var at, // The index of the current character
    ch, // The current character
    escapee = ***REMOVED***
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    ***REMOVED***,
    text,

    error = function (m) ***REMOVED***
        // Call error when something is wrong.
        throw ***REMOVED***
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        ***REMOVED***;
    ***REMOVED***,
    
    next = function (c) ***REMOVED***
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) ***REMOVED***
            error("Expected '" + c + "' instead of '" + ch + "'");
        ***REMOVED***
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    ***REMOVED***,
    
    number = function () ***REMOVED***
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') ***REMOVED***
            string = '-';
            next('-');
        ***REMOVED***
        while (ch >= '0' && ch <= '9') ***REMOVED***
            string += ch;
            next();
        ***REMOVED***
        if (ch === '.') ***REMOVED***
            string += '.';
            while (next() && ch >= '0' && ch <= '9') ***REMOVED***
                string += ch;
            ***REMOVED***
        ***REMOVED***
        if (ch === 'e' || ch === 'E') ***REMOVED***
            string += ch;
            next();
            if (ch === '-' || ch === '+') ***REMOVED***
                string += ch;
                next();
            ***REMOVED***
            while (ch >= '0' && ch <= '9') ***REMOVED***
                string += ch;
                next();
            ***REMOVED***
        ***REMOVED***
        number = +string;
        if (!isFinite(number)) ***REMOVED***
            error("Bad number");
        ***REMOVED*** else ***REMOVED***
            return number;
        ***REMOVED***
    ***REMOVED***,
    
    string = function () ***REMOVED***
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') ***REMOVED***
            while (next()) ***REMOVED***
                if (ch === '"') ***REMOVED***
                    next();
                    return string;
                ***REMOVED*** else if (ch === '\\') ***REMOVED***
                    next();
                    if (ch === 'u') ***REMOVED***
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) ***REMOVED***
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) ***REMOVED***
                                break;
                            ***REMOVED***
                            uffff = uffff * 16 + hex;
                        ***REMOVED***
                        string += String.fromCharCode(uffff);
                    ***REMOVED*** else if (typeof escapee[ch] === 'string') ***REMOVED***
                        string += escapee[ch];
                    ***REMOVED*** else ***REMOVED***
                        break;
                    ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                    string += ch;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        error("Bad string");
    ***REMOVED***,

    white = function () ***REMOVED***

// Skip whitespace.

        while (ch && ch <= ' ') ***REMOVED***
            next();
        ***REMOVED***
    ***REMOVED***,

    word = function () ***REMOVED***

// true, false, or null.

        switch (ch) ***REMOVED***
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        ***REMOVED***
        error("Unexpected '" + ch + "'");
    ***REMOVED***,

    value,  // Place holder for the value function.

    array = function () ***REMOVED***

// Parse an array value.

        var array = [];

        if (ch === '[') ***REMOVED***
            next('[');
            white();
            if (ch === ']') ***REMOVED***
                next(']');
                return array;   // empty array
            ***REMOVED***
            while (ch) ***REMOVED***
                array.push(value());
                white();
                if (ch === ']') ***REMOVED***
                    next(']');
                    return array;
                ***REMOVED***
                next(',');
                white();
            ***REMOVED***
        ***REMOVED***
        error("Bad array");
    ***REMOVED***,

    object = function () ***REMOVED***

// Parse an object value.

        var key,
            object = ***REMOVED******REMOVED***;

        if (ch === '***REMOVED***') ***REMOVED***
            next('***REMOVED***');
            white();
            if (ch === '***REMOVED***') ***REMOVED***
                next('***REMOVED***');
                return object;   // empty object
            ***REMOVED***
            while (ch) ***REMOVED***
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) ***REMOVED***
                    error('Duplicate key "' + key + '"');
                ***REMOVED***
                object[key] = value();
                white();
                if (ch === '***REMOVED***') ***REMOVED***
                    next('***REMOVED***');
                    return object;
                ***REMOVED***
                next(',');
                white();
            ***REMOVED***
        ***REMOVED***
        error("Bad object");
    ***REMOVED***;

value = function () ***REMOVED***

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) ***REMOVED***
    case '***REMOVED***':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    ***REMOVED***
***REMOVED***;

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) ***REMOVED***
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) ***REMOVED***
        error("Syntax error");
    ***REMOVED***

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) ***REMOVED***
        var k, v, value = holder[key];
        if (value && typeof value === 'object') ***REMOVED***
            for (k in value) ***REMOVED***
                if (Object.prototype.hasOwnProperty.call(value, k)) ***REMOVED***
                    v = walk(value, k);
                    if (v !== undefined) ***REMOVED***
                        value[k] = v;
                    ***REMOVED*** else ***REMOVED***
                        delete value[k];
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        return reviver.call(holder, key, value);
    ***REMOVED***(***REMOVED***'': result***REMOVED***, '')) : result;
***REMOVED***;
