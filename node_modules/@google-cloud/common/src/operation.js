/*!
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @module common/operation
 */

'use strict';

var events = require('events');
var extend = require('extend');
var modelo = require('modelo');

/**
 * @type ***REMOVED***module:common/serviceObject***REMOVED***
 * @private
 */
var ServiceObject = require('./service-object.js');

// jscs:disable maximumLineLength
/**
 * An Operation object allows you to interact with APIs that take longer to
 * process things.
 *
 * @constructor
 * @alias module:common/operation
 *
 * @param ***REMOVED***object***REMOVED*** config - Configuration object.
 * @param ***REMOVED***module:common/service|module:common/serviceObject|module:common/grpcService|module:common/grpcServiceObject***REMOVED*** config.parent - The
 *     parent object.
 * @param ***REMOVED***string***REMOVED*** id - The operation ID.
 */
// jscs:enable maximumLineLength
function Operation(config) ***REMOVED***
  var methods = ***REMOVED***
    /**
     * Checks to see if an operation exists.
     */
    exists: true,

    /**
     * Retrieves the operation.
     */
    get: true,

    /**
     * Retrieves metadata for the operation.
     */
    getMetadata: ***REMOVED***
      reqOpts: ***REMOVED***
        name: config.id,
      ***REMOVED***,
    ***REMOVED***,
  ***REMOVED***;

  config = extend(
    ***REMOVED***
      baseUrl: '',
    ***REMOVED***,
    config
  );

  config.methods = config.methods || methods;

  ServiceObject.call(this, config);
  events.EventEmitter.call(this);

  this.completeListeners = 0;
  this.hasActiveListeners = false;

  this.listenForEvents_();
***REMOVED***

modelo.inherits(Operation, ServiceObject, events.EventEmitter);

/**
 * Wraps the `complete` and `error` events in a Promise.
 *
 * @return ***REMOVED***promise***REMOVED***
 */
Operation.prototype.promise = function() ***REMOVED***
  var self = this;

  return new self.Promise(function(resolve, reject) ***REMOVED***
    self.on('error', reject).on('complete', function(metadata) ***REMOVED***
      resolve([metadata]);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Begin listening for events on the operation. This method keeps track of how
 * many "complete" listeners are registered and removed, making sure polling is
 * handled automatically.
 *
 * As long as there is one active "complete" listener, the connection is open.
 * When there are no more listeners, the polling stops.
 *
 * @private
 */
Operation.prototype.listenForEvents_ = function() ***REMOVED***
  var self = this;

  this.on('newListener', function(event) ***REMOVED***
    if (event === 'complete') ***REMOVED***
      self.completeListeners++;

      if (!self.hasActiveListeners) ***REMOVED***
        self.hasActiveListeners = true;
        self.startPolling_();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  this.on('removeListener', function(event) ***REMOVED***
    if (event === 'complete' && --self.completeListeners === 0) ***REMOVED***
      self.hasActiveListeners = false;
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Poll for a status update. Execute the callback:
 *
 *   - callback(err): Operation failed
 *   - callback(): Operation incomplete
 *   - callback(null, metadata): Operation complete
 *
 * @private
 *
 * @param ***REMOVED***function***REMOVED*** callback
 */
Operation.prototype.poll_ = function(callback) ***REMOVED***
  this.getMetadata(function(err, resp) ***REMOVED***
    if (err || resp.error) ***REMOVED***
      callback(err || resp.error);
      return;
    ***REMOVED***

    if (!resp.done) ***REMOVED***
      callback();
      return;
    ***REMOVED***

    callback(null, resp);
  ***REMOVED***);
***REMOVED***;

/**
 * Poll `getMetadata` to check the operation's status. This runs a loop to ping
 * the API on an interval.
 *
 * Note: This method is automatically called once a "complete" event handler is
 * registered on the operation.
 *
 * @private
 */
Operation.prototype.startPolling_ = function() ***REMOVED***
  var self = this;

  if (!this.hasActiveListeners) ***REMOVED***
    return;
  ***REMOVED***

  this.poll_(function(err, metadata) ***REMOVED***
    if (err) ***REMOVED***
      self.emit('error', err);
      return;
    ***REMOVED***

    if (!metadata) ***REMOVED***
      setTimeout(self.startPolling_.bind(self), 500);
      return;
    ***REMOVED***

    self.emit('complete', metadata);
  ***REMOVED***);
***REMOVED***;

module.exports = Operation;
