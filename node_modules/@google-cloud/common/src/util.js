/**
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @module common/util
 */

'use strict';

var createErrorClass = require('create-error-class');
var duplexify = require('duplexify');
var ent = require('ent');
var extend = require('extend');
var format = require('string-format-obj');
var googleAuth = require('google-auto-auth');
var is = require('is');
var request = require('request').defaults(***REMOVED***
  timeout: 60000,
  gzip: true,
  forever: true,
  pool: ***REMOVED***
    maxSockets: Infinity,
  ***REMOVED***,
***REMOVED***);
var retryRequest = require('retry-request');
var streamEvents = require('stream-events');
var through = require('through2');
var uniq = require('array-uniq');

var util = module.exports;

var errorMessage = format(
  [
    'Sorry, we cannot connect to Cloud Services without a project ID.',
    'You may specify one with an environment variable named "GCLOUD_PROJECT".',
    'See ***REMOVED***baseUrl***REMOVED***/***REMOVED***path***REMOVED*** for a detailed guide on creating an authenticated',
    'connection.',
  ].join(' '),
  ***REMOVED***
    baseUrl: 'https://googlecloudplatform.github.io/google-cloud-node/#',
    path: 'docs/guides/authentication',
  ***REMOVED***
);

var missingProjectIdError = new Error(errorMessage);

util.missingProjectIdError = missingProjectIdError;

/**
 * No op.
 *
 * @example
 * function doSomething(callback) ***REMOVED***
 *   callback = callback || noop;
 * ***REMOVED***
 */
function noop() ***REMOVED******REMOVED***

util.noop = noop;

/**
 * Custom error type for API errors.
 *
 * @param ***REMOVED***object***REMOVED*** errorBody - Error object.
 */
util.ApiError = createErrorClass('ApiError', function(errorBody) ***REMOVED***
  this.code = errorBody.code;
  this.errors = errorBody.errors;
  this.response = errorBody.response;

  try ***REMOVED***
    this.errors = JSON.parse(this.response.body).error.errors;
  ***REMOVED*** catch (e) ***REMOVED***
    this.errors = errorBody.errors;
  ***REMOVED***

  var messages = [];

  if (errorBody.message) ***REMOVED***
    messages.push(errorBody.message);
  ***REMOVED***

  if (this.errors && this.errors.length === 1) ***REMOVED***
    messages.push(this.errors[0].message);
  ***REMOVED*** else if (this.response && this.response.body) ***REMOVED***
    messages.push(ent.decode(errorBody.response.body.toString()));
  ***REMOVED*** else if (!errorBody.message) ***REMOVED***
    messages.push('Error during request.');
  ***REMOVED***

  this.message = uniq(messages).join(' - ');
***REMOVED***);

/**
 * Custom error type for partial errors returned from the API.
 *
 * @param ***REMOVED***object***REMOVED*** b - Error object.
 */
util.PartialFailureError = createErrorClass('PartialFailureError', function(b) ***REMOVED***
  var errorObject = b;

  this.errors = errorObject.errors;
  this.response = errorObject.response;

  var defaultErrorMessage = 'A failure occurred during this request.';
  this.message = errorObject.message || defaultErrorMessage;
***REMOVED***);

/**
 * Uniformly process an API response.
 *
 * @param ***REMOVED*******REMOVED*** err - Error value.
 * @param ***REMOVED*******REMOVED*** resp - Response value.
 * @param ***REMOVED*******REMOVED*** body - Body value.
 * @param ***REMOVED***function***REMOVED*** callback - The callback function.
 */
function handleResp(err, resp, body, callback) ***REMOVED***
  callback = callback || util.noop;

  var parsedResp = extend(
    true,
    ***REMOVED***err: err || null***REMOVED***,
    resp && util.parseHttpRespMessage(resp),
    body && util.parseHttpRespBody(body)
  );

  callback(parsedResp.err, parsedResp.body, parsedResp.resp);
***REMOVED***

util.handleResp = handleResp;

/**
 * Sniff an incoming HTTP response message for errors.
 *
 * @param ***REMOVED***object***REMOVED*** httpRespMessage - An incoming HTTP response message from
 *     `request`.
 * @return ***REMOVED***object***REMOVED*** parsedHttpRespMessage - The parsed response.
 * @param ***REMOVED***?error***REMOVED*** parsedHttpRespMessage.err - An error detected.
 * @param ***REMOVED***object***REMOVED*** parsedHttpRespMessage.resp - The original response object.
 */
function parseHttpRespMessage(httpRespMessage) ***REMOVED***
  var parsedHttpRespMessage = ***REMOVED***
    resp: httpRespMessage,
  ***REMOVED***;

  if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) ***REMOVED***
    // Unknown error. Format according to ApiError standard.
    parsedHttpRespMessage.err = new util.ApiError(***REMOVED***
      errors: [],
      code: httpRespMessage.statusCode,
      message: httpRespMessage.statusMessage,
      response: httpRespMessage,
    ***REMOVED***);
  ***REMOVED***

  return parsedHttpRespMessage;
***REMOVED***

util.parseHttpRespMessage = parseHttpRespMessage;

/**
 * Parse the response body from an HTTP request.
 *
 * @param ***REMOVED***object***REMOVED*** body - The response body.
 * @return ***REMOVED***object***REMOVED*** parsedHttpRespMessage - The parsed response.
 * @param ***REMOVED***?error***REMOVED*** parsedHttpRespMessage.err - An error detected.
 * @param ***REMOVED***object***REMOVED*** parsedHttpRespMessage.body - The original body value provided
 *     will try to be JSON.parse'd. If it's successful, the parsed value will be
 *     returned here, otherwise the original value.
 */
function parseHttpRespBody(body) ***REMOVED***
  var parsedHttpRespBody = ***REMOVED***
    body: body,
  ***REMOVED***;

  if (is.string(body)) ***REMOVED***
    try ***REMOVED***
      parsedHttpRespBody.body = JSON.parse(body);
    ***REMOVED*** catch (err) ***REMOVED***
      parsedHttpRespBody.err = new util.ApiError('Cannot parse JSON response');
    ***REMOVED***
  ***REMOVED***

  if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) ***REMOVED***
    // Error from JSON API.
    parsedHttpRespBody.err = new util.ApiError(parsedHttpRespBody.body.error);
  ***REMOVED***

  return parsedHttpRespBody;
***REMOVED***

util.parseHttpRespBody = parseHttpRespBody;

/**
 * Take a Duplexify stream, fetch an authenticated connection header, and create
 * an outgoing writable stream.
 *
 * @param ***REMOVED***Duplexify***REMOVED*** dup - Duplexify stream.
 * @param ***REMOVED***object***REMOVED*** options - Configuration object.
 * @param ***REMOVED***module:common/connection***REMOVED*** options.connection - A connection instance,
 *     used to get a token with and send the request through.
 * @param ***REMOVED***object***REMOVED*** options.metadata - Metadata to send at the head of the
 *     request.
 * @param ***REMOVED***object***REMOVED*** options.request - Request object, in the format of a standard
 *     Node.js http.request() object.
 * @param ***REMOVED***string=***REMOVED*** options.request.method - Default: "POST".
 * @param ***REMOVED***string=***REMOVED*** options.request.qs.uploadType - Default: "multipart".
 * @param ***REMOVED***string=***REMOVED*** options.streamContentType - Default:
 *     "application/octet-stream".
 * @param ***REMOVED***function***REMOVED*** onComplete - Callback, executed after the writable Request
 *     stream has completed.
 */
function makeWritableStream(dup, options, onComplete) ***REMOVED***
  onComplete = onComplete || util.noop;

  var writeStream = through();
  dup.setWritable(writeStream);

  var defaultReqOpts = ***REMOVED***
    method: 'POST',
    qs: ***REMOVED***
      uploadType: 'multipart',
    ***REMOVED***,
  ***REMOVED***;

  var metadata = options.metadata || ***REMOVED******REMOVED***;

  var reqOpts = extend(true, defaultReqOpts, options.request, ***REMOVED***
    multipart: [
      ***REMOVED***
        'Content-Type': 'application/json',
        body: JSON.stringify(metadata),
      ***REMOVED***,
      ***REMOVED***
        'Content-Type': metadata.contentType || 'application/octet-stream',
        body: writeStream,
      ***REMOVED***,
    ],
  ***REMOVED***);

  options.makeAuthenticatedRequest(reqOpts, ***REMOVED***
    onAuthenticated: function(err, authenticatedReqOpts) ***REMOVED***
      if (err) ***REMOVED***
        dup.destroy(err);
        return;
      ***REMOVED***

      request(authenticatedReqOpts, function(err, resp, body) ***REMOVED***
        util.handleResp(err, resp, body, function(err, data) ***REMOVED***
          if (err) ***REMOVED***
            dup.destroy(err);
            return;
          ***REMOVED***

          dup.emit('response', resp);
          onComplete(data);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***,
  ***REMOVED***);
***REMOVED***

util.makeWritableStream = makeWritableStream;

/**
 * Returns true if the API request should be retried, given the error that was
 * given the first time the request was attempted. This is used for rate limit
 * related errors as well as intermittent server errors.
 *
 * @param ***REMOVED***error***REMOVED*** err - The API error to check if it is appropriate to retry.
 * @return ***REMOVED***boolean***REMOVED*** True if the API request should be retried, false otherwise.
 */
function shouldRetryRequest(err) ***REMOVED***
  if (err) ***REMOVED***
    if ([429, 500, 502, 503].indexOf(err.code) !== -1) ***REMOVED***
      return true;
    ***REMOVED***

    if (err.errors) ***REMOVED***
      for (var i in err.errors) ***REMOVED***
        var reason = err.errors[i].reason;
        if (reason === 'rateLimitExceeded') ***REMOVED***
          return true;
        ***REMOVED***
        if (reason === 'userRateLimitExceeded') ***REMOVED***
          return true;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***

util.shouldRetryRequest = shouldRetryRequest;

/**
 * Get a function for making authenticated requests.
 *
 * @throws ***REMOVED***Error***REMOVED*** If a projectId is requested, but not able to be detected.
 *
 * @param ***REMOVED***object***REMOVED*** config - Configuration object.
 * @param ***REMOVED***boolean=***REMOVED*** config.autoRetry - Automatically retry requests if the
 *     response is related to rate limits or certain intermittent server errors.
 *     We will exponentially backoff subsequent requests by default. (default:
 *     true)
 * @param ***REMOVED***object=***REMOVED*** config.credentials - Credentials object.
 * @param ***REMOVED***boolean=***REMOVED*** config.customEndpoint - If true, just return the provided
 *     request options. Default: false.
 * @param ***REMOVED***string=***REMOVED*** config.email - Account email address, required for PEM/P12
 *     usage.
 * @param ***REMOVED***number=***REMOVED*** config.maxRetries - Maximum number of automatic retries
 *     attempted before returning the error. (default: 3)
 * @param ***REMOVED***string=***REMOVED*** config.keyFile - Path to a .json, .pem, or .p12 keyfile.
 * @param ***REMOVED***array***REMOVED*** config.scopes - Array of scopes required for the API.
 */
function makeAuthenticatedRequestFactory(config) ***REMOVED***
  config = config || ***REMOVED******REMOVED***;

  var authClient = googleAuth(config);

  /**
   * The returned function that will make an authenticated request.
   *
   * @param ***REMOVED***type***REMOVED*** reqOpts - Request options in the format `request` expects.
   * @param ***REMOVED***object|function***REMOVED*** options - Configuration object or callback
   *     function.
   * @param ***REMOVED***function=***REMOVED*** options.onAuthenticated - If provided, a request will
   *     not be made. Instead, this function is passed the error & authenticated
   *     request options.
   */
  function makeAuthenticatedRequest(reqOpts, options) ***REMOVED***
    var stream;
    var reqConfig = extend(***REMOVED******REMOVED***, config);
    var activeRequest_;

    if (!options) ***REMOVED***
      stream = duplexify();
      reqConfig.stream = stream;
    ***REMOVED***

    function onAuthenticated(err, authenticatedReqOpts) ***REMOVED***
      var autoAuthFailed =
        err &&
        err.message.indexOf('Could not load the default credentials') > -1;

      if (autoAuthFailed) ***REMOVED***
        // Even though authentication failed, the API might not actually care.
        authenticatedReqOpts = reqOpts;
      ***REMOVED***

      if (!err || autoAuthFailed) ***REMOVED***
        var projectId = authClient.projectId;

        if (config.projectId && config.projectId !== '***REMOVED******REMOVED***projectId***REMOVED******REMOVED***') ***REMOVED***
          projectId = config.projectId;
        ***REMOVED***

        try ***REMOVED***
          authenticatedReqOpts = util.decorateRequest(
            authenticatedReqOpts,
            projectId
          );
          err = null;
        ***REMOVED*** catch (e) ***REMOVED***
          // A projectId was required, but we don't have one.
          // Re-use the "Could not load the default credentials error" if auto
          // auth failed.
          err = err || e;
        ***REMOVED***
      ***REMOVED***

      if (err) ***REMOVED***
        if (stream) ***REMOVED***
          stream.destroy(err);
        ***REMOVED*** else ***REMOVED***
          (options.onAuthenticated || options)(err);
        ***REMOVED***

        return;
      ***REMOVED***

      if (options && options.onAuthenticated) ***REMOVED***
        options.onAuthenticated(null, authenticatedReqOpts);
      ***REMOVED*** else ***REMOVED***
        activeRequest_ = util.makeRequest(
          authenticatedReqOpts,
          reqConfig,
          options
        );
      ***REMOVED***
    ***REMOVED***

    if (reqConfig.customEndpoint) ***REMOVED***
      // Using a custom API override. Do not use `google-auto-auth` for
      // authentication. (ex: connecting to a local Datastore server)
      onAuthenticated(null, reqOpts);
    ***REMOVED*** else ***REMOVED***
      authClient.authorizeRequest(reqOpts, onAuthenticated);
    ***REMOVED***

    if (stream) ***REMOVED***
      return stream;
    ***REMOVED***

    return ***REMOVED***
      abort: function() ***REMOVED***
        if (activeRequest_) ***REMOVED***
          activeRequest_.abort();
          activeRequest_ = null;
        ***REMOVED***
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***

  makeAuthenticatedRequest.getCredentials = authClient.getCredentials.bind(
    authClient
  );

  makeAuthenticatedRequest.authClient = authClient;

  return makeAuthenticatedRequest;
***REMOVED***

util.makeAuthenticatedRequestFactory = makeAuthenticatedRequestFactory;

/**
 * Make a request through the `retryRequest` module with built-in error handling
 * and exponential back off.
 *
 * @param ***REMOVED***object***REMOVED*** reqOpts - Request options in the format `request` expects.
 * @param ***REMOVED***object=***REMOVED*** config - Configuration object.
 * @param ***REMOVED***boolean=***REMOVED*** config.autoRetry - Automatically retry requests if the
 *     response is related to rate limits or certain intermittent server errors.
 *     We will exponentially backoff subsequent requests by default. (default:
 *     true)
 * @param ***REMOVED***number=***REMOVED*** config.maxRetries - Maximum number of automatic retries
 *     attempted before returning the error. (default: 3)
 * @param ***REMOVED***function***REMOVED*** callback - The callback function.
 */
function makeRequest(reqOpts, config, callback) ***REMOVED***
  if (is.fn(config)) ***REMOVED***
    callback = config;
    config = ***REMOVED******REMOVED***;
  ***REMOVED***

  config = config || ***REMOVED******REMOVED***;

  var options = ***REMOVED***
    request: request,

    retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,

    shouldRetryFn: function(httpRespMessage) ***REMOVED***
      var err = util.parseHttpRespMessage(httpRespMessage).err;
      return err && util.shouldRetryRequest(err);
    ***REMOVED***,
  ***REMOVED***;

  if (config.stream) ***REMOVED***
    var dup = config.stream;
    var requestStream;
    var isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';

    if (isGetRequest) ***REMOVED***
      requestStream = retryRequest(reqOpts, options);
      dup.setReadable(requestStream);
    ***REMOVED*** else ***REMOVED***
      // Streaming writable HTTP requests cannot be retried.
      requestStream = request(reqOpts);
      dup.setWritable(requestStream);
    ***REMOVED***

    // Replay the Request events back to the stream.
    requestStream
      .on('error', dup.destroy.bind(dup))
      .on('response', dup.emit.bind(dup, 'response'))
      .on('complete', dup.emit.bind(dup, 'complete'));

    dup.abort = requestStream.abort;
  ***REMOVED*** else ***REMOVED***
    return retryRequest(reqOpts, options, function(err, response, body) ***REMOVED***
      util.handleResp(err, response, body, callback);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

util.makeRequest = makeRequest;

/**
 * Decorate the options about to be made in a request.
 *
 * @param ***REMOVED***object***REMOVED*** reqOpts - The options to be passed to `request`.
 * @param ***REMOVED***string***REMOVED*** projectId - The project ID.
 * @return ***REMOVED***object***REMOVED*** reqOpts - The decorated reqOpts.
 */
function decorateRequest(reqOpts, projectId) ***REMOVED***
  delete reqOpts.autoPaginate;
  delete reqOpts.autoPaginateVal;
  delete reqOpts.objectMode;

  if (is.object(reqOpts.qs)) ***REMOVED***
    delete reqOpts.qs.autoPaginate;
    delete reqOpts.qs.autoPaginateVal;
    reqOpts.qs = util.replaceProjectIdToken(reqOpts.qs, projectId);
  ***REMOVED***

  if (is.object(reqOpts.json)) ***REMOVED***
    delete reqOpts.json.autoPaginate;
    delete reqOpts.json.autoPaginateVal;
    reqOpts.json = util.replaceProjectIdToken(reqOpts.json, projectId);
  ***REMOVED***

  reqOpts.uri = util.replaceProjectIdToken(reqOpts.uri, projectId);

  return reqOpts;
***REMOVED***

util.decorateRequest = decorateRequest;

/**
 * Populate the `***REMOVED******REMOVED***projectId***REMOVED******REMOVED***` placeholder.
 *
 * @throws ***REMOVED***Error***REMOVED*** If a projectId is required, but one is not provided.
 *
 * @param ***REMOVED*******REMOVED*** - Any input value that may contain a placeholder. Arrays and
 *     objects will be looped.
 * @param ***REMOVED***string***REMOVED*** projectId - A projectId. If not provided
 * @return ***REMOVED*******REMOVED*** - The original argument with all placeholders populated.
 */
function replaceProjectIdToken(value, projectId) ***REMOVED***
  if (is.array(value)) ***REMOVED***
    value = value.map(function(val) ***REMOVED***
      return replaceProjectIdToken(val, projectId);
    ***REMOVED***);
  ***REMOVED***

  if (is.object(value) && is.fn(value.hasOwnProperty)) ***REMOVED***
    for (var opt in value) ***REMOVED***
      if (value.hasOwnProperty(opt)) ***REMOVED***
        value[opt] = replaceProjectIdToken(value[opt], projectId);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  if (is.string(value) && value.indexOf('***REMOVED******REMOVED***projectId***REMOVED******REMOVED***') > -1) ***REMOVED***
    if (!projectId || projectId === '***REMOVED******REMOVED***projectId***REMOVED******REMOVED***') ***REMOVED***
      throw util.missingProjectIdError;
    ***REMOVED***
    value = value.replace(/***REMOVED******REMOVED***projectId***REMOVED******REMOVED***/g, projectId);
  ***REMOVED***

  return value;
***REMOVED***

util.replaceProjectIdToken = replaceProjectIdToken;

/**
 * Extend a global configuration object with user options provided at the time
 * of sub-module instantiation.
 *
 * Connection details currently come in two ways: `credentials` or
 * `keyFilename`. Because of this, we have a special exception when overriding a
 * global configuration object. If a user provides either to the global
 * configuration, then provides another at submodule instantiation-time, the
 * latter is preferred.
 *
 * @param  ***REMOVED***object***REMOVED*** globalConfig - The global configuration object.
 * @param  ***REMOVED***object=***REMOVED*** overrides - The instantiation-time configuration object.
 * @return ***REMOVED***object***REMOVED***
 */
function extendGlobalConfig(globalConfig, overrides) ***REMOVED***
  globalConfig = globalConfig || ***REMOVED******REMOVED***;
  overrides = overrides || ***REMOVED******REMOVED***;

  var defaultConfig = ***REMOVED******REMOVED***;

  if (process.env.GCLOUD_PROJECT) ***REMOVED***
    defaultConfig.projectId = process.env.GCLOUD_PROJECT;
  ***REMOVED***

  var options = extend(***REMOVED******REMOVED***, globalConfig);

  var hasGlobalConnection = options.credentials || options.keyFilename;
  var isOverridingConnection = overrides.credentials || overrides.keyFilename;

  if (hasGlobalConnection && isOverridingConnection) ***REMOVED***
    delete options.credentials;
    delete options.keyFilename;
  ***REMOVED***

  var extendedConfig = extend(true, defaultConfig, options, overrides);

  // Preserve the original (not cloned) interceptors.
  extendedConfig.interceptors_ = globalConfig.interceptors_;

  return extendedConfig;
***REMOVED***

util.extendGlobalConfig = extendGlobalConfig;

/**
 * Merge and validate API configurations.
 *
 * @param ***REMOVED***object***REMOVED*** globalContext - gcloud-level context.
 * @param ***REMOVED***object***REMOVED*** globalContext.config_ - gcloud-level configuration.
 * @param ***REMOVED***object***REMOVED*** localConfig - Service-level configurations.
 * @return ***REMOVED***object***REMOVED*** config - Merged and validated configuration.
 */
function normalizeArguments(globalContext, localConfig) ***REMOVED***
  var globalConfig = globalContext && globalContext.config_;

  return util.extendGlobalConfig(globalConfig, localConfig);
***REMOVED***

util.normalizeArguments = normalizeArguments;

/**
 * Limit requests according to a `maxApiCalls` limit.
 *
 * @param ***REMOVED***function***REMOVED*** makeRequestFn - The function that will be called.
 * @param ***REMOVED***object=***REMOVED*** options - Configuration object.
 * @param ***REMOVED***number***REMOVED*** options.maxApiCalls - The maximum number of API calls to
 *     make.
 */
function createLimiter(makeRequestFn, options) ***REMOVED***
  var stream = streamEvents(through.obj());

  var requestsMade = 0;
  var requestsToMake = -1;

  options = options || ***REMOVED******REMOVED***;

  if (is.number(options.maxApiCalls)) ***REMOVED***
    requestsToMake = options.maxApiCalls;
  ***REMOVED***

  return ***REMOVED***
    makeRequest: function() ***REMOVED***
      requestsMade++;

      if (requestsToMake >= 0 && requestsMade > requestsToMake) ***REMOVED***
        stream.push(null);
        return;
      ***REMOVED***

      makeRequestFn.apply(null, arguments);

      return stream;
    ***REMOVED***,

    stream: stream,
  ***REMOVED***;
***REMOVED***

util.createLimiter = createLimiter;

function isCustomType(unknown, module) ***REMOVED***
  function getConstructorName(obj) ***REMOVED***
    return obj.constructor && obj.constructor.name.toLowerCase();
  ***REMOVED***

  var moduleNameParts = module.split('/');

  var parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();
  var subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();

  if (subModuleName && getConstructorName(unknown) !== subModuleName) ***REMOVED***
    return false;
  ***REMOVED***

  var walkingModule = unknown;
  do ***REMOVED***
    if (getConstructorName(walkingModule) === parentModuleName) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED*** while ((walkingModule = walkingModule.parent));

  return false;
***REMOVED***

util.isCustomType = isCustomType;

/**
 * Create a properly-formatted User-Agent string from a package.json file.
 *
 * @param ***REMOVED***object***REMOVED*** packageJson - A module's package.json file.
 * @return ***REMOVED***string***REMOVED*** userAgent - The formatted User-Agent string.
 */
function getUserAgentFromPackageJson(packageJson) ***REMOVED***
  var hyphenatedPackageName = packageJson.name
    .replace('@google-cloud', 'gcloud-node') // For legacy purposes.
    .replace('/', '-'); // For UA spec-compliance purposes.

  return hyphenatedPackageName + '/' + packageJson.version;
***REMOVED***

util.getUserAgentFromPackageJson = getUserAgentFromPackageJson;

/**
 * Wraps a callback style function to conditionally return a promise.
 *
 * @param ***REMOVED***function***REMOVED*** originalMethod - The method to promisify.
 * @param ***REMOVED***object=***REMOVED*** options - Promise options.
 * @param ***REMOVED***boolean***REMOVED*** options.singular - Resolve the promise with single arg
 *     instead of an array.
 * @return ***REMOVED***function***REMOVED*** wrapped
 */
function promisify(originalMethod, options) ***REMOVED***
  if (originalMethod.promisified_) ***REMOVED***
    return originalMethod;
  ***REMOVED***

  options = options || ***REMOVED******REMOVED***;

  var slice = Array.prototype.slice;

  var wrapper = function() ***REMOVED***
    var context = this;
    var last;

    for (last = arguments.length - 1; last >= 0; last--) ***REMOVED***
      var arg = arguments[last];

      if (is.undefined(arg)) ***REMOVED***
        continue; // skip trailing undefined.
      ***REMOVED***

      if (!is.fn(arg)) ***REMOVED***
        break; // non-callback last argument found.
      ***REMOVED***

      return originalMethod.apply(context, arguments);
    ***REMOVED***

    // peel trailing undefined.
    var args = slice.call(arguments, 0, last + 1);

    var PromiseCtor = Promise;

    // Because dedupe will likely create a single install of
    // @google-cloud/common to be shared amongst all modules, we need to
    // localize it at the Service level.
    if (context && context.Promise) ***REMOVED***
      PromiseCtor = context.Promise;
    ***REMOVED***

    return new PromiseCtor(function(resolve, reject) ***REMOVED***
      args.push(function() ***REMOVED***
        var callbackArgs = slice.call(arguments);
        var err = callbackArgs.shift();

        if (err) ***REMOVED***
          return reject(err);
        ***REMOVED***

        if (options.singular && callbackArgs.length === 1) ***REMOVED***
          resolve(callbackArgs[0]);
        ***REMOVED*** else ***REMOVED***
          resolve(callbackArgs);
        ***REMOVED***
      ***REMOVED***);

      originalMethod.apply(context, args);
    ***REMOVED***);
  ***REMOVED***;

  wrapper.promisified_ = true;
  return wrapper;
***REMOVED***

util.promisify = promisify;

/**
 * Promisifies certain Class methods. This will not promisify private or
 * streaming methods.
 *
 * @param ***REMOVED***module:common/service***REMOVED*** Class - Service class.
 * @param ***REMOVED***object=***REMOVED*** options - Configuration object.
 */
function promisifyAll(Class, options) ***REMOVED***
  var exclude = (options && options.exclude) || [];

  var methods = Object.keys(Class.prototype).filter(function(methodName) ***REMOVED***
    return (
      is.fn(Class.prototype[methodName]) && // is it a function?
      !/(^_|(Stream|_)|promise$)/.test(methodName) && // is it promisable?
      exclude.indexOf(methodName) === -1
    ); // is it blacklisted?
  ***REMOVED***);

  methods.forEach(function(methodName) ***REMOVED***
    var originalMethod = Class.prototype[methodName];

    if (!originalMethod.promisified_) ***REMOVED***
      Class.prototype[methodName] = util.promisify(originalMethod, options);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

util.promisifyAll = promisifyAll;
