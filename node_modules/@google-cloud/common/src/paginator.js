/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @module common/paginator
 */

'use strict';

var arrify = require('arrify');
var concat = require('concat-stream');
var extend = require('extend');
var is = require('is');
var split = require('split-array-stream');

/**
 * @type ***REMOVED***module:common/util***REMOVED***
 * @private
 */
var util = require('./util.js');

/*! Developer Documentation
 *
 * paginator is used to auto-paginate `nextQuery` methods as well as
 * streamifying them.
 *
 * Before:
 *
 *   search.query('done=true', function(err, results, nextQuery) ***REMOVED***
 *     search.query(nextQuery, function(err, results, nextQuery) ***REMOVED******REMOVED***);
 *   ***REMOVED***);
 *
 * After:
 *
 *   search.query('done=true', function(err, results) ***REMOVED******REMOVED***);
 *
 * Methods to extend should be written to accept callbacks and return a
 * `nextQuery`.
 */
var paginator = ***REMOVED******REMOVED***;

/**
 * Cache the original method, then overwrite it on the Class's prototype.
 *
 * @param ***REMOVED***function***REMOVED*** Class - The parent class of the methods to extend.
 * @param ***REMOVED***string|string[]***REMOVED*** methodNames - Name(s) of the methods to extend.
 */
paginator.extend = function(Class, methodNames) ***REMOVED***
  methodNames = arrify(methodNames);

  methodNames.forEach(function(methodName) ***REMOVED***
    var originalMethod = Class.prototype[methodName];

    // map the original method to a private member
    Class.prototype[methodName + '_'] = originalMethod;

    // overwrite the original to auto-paginate
    Class.prototype[methodName] = function() ***REMOVED***
      var parsedArguments = paginator.parseArguments_(arguments);
      return paginator.run_(parsedArguments, originalMethod.bind(this));
    ***REMOVED***;
  ***REMOVED***);
***REMOVED***;

/**
 * Wraps paginated API calls in a readable object stream.
 *
 * This method simply calls the nextQuery recursively, emitting results to a
 * stream. The stream ends when `nextQuery` is null.
 *
 * `maxResults` will act as a cap for how many results are fetched and emitted
 * to the stream.
 *
 * @param ***REMOVED***string***REMOVED*** methodName - Name of the method to streamify.
 * @return ***REMOVED***function***REMOVED*** - Wrapped function.
 */
paginator.streamify = function(methodName) ***REMOVED***
  return function() ***REMOVED***
    var parsedArguments = paginator.parseArguments_(arguments);
    var originalMethod = this[methodName + '_'] || this[methodName];

    return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));
  ***REMOVED***;
***REMOVED***;

/**
 * Parse a pseudo-array `arguments` for a query and callback.
 *
 * @param ***REMOVED***array***REMOVED*** args - The original `arguments` pseduo-array that the original
 *     method received.
 */
paginator.parseArguments_ = function(args) ***REMOVED***
  var query;
  var autoPaginate = true;
  var maxApiCalls = -1;
  var maxResults = -1;
  var callback;

  var firstArgument = args[0];
  var lastArgument = args[args.length - 1];

  if (is.fn(firstArgument)) ***REMOVED***
    callback = firstArgument;
  ***REMOVED*** else ***REMOVED***
    query = firstArgument;
  ***REMOVED***

  if (is.fn(lastArgument)) ***REMOVED***
    callback = lastArgument;
  ***REMOVED***

  if (is.object(query)) ***REMOVED***
    query = extend(true, ***REMOVED******REMOVED***, query);

    // Check if the user only asked for a certain amount of results.
    if (is.number(query.maxResults)) ***REMOVED***
      // `maxResults` is used API-wide.
      maxResults = query.maxResults;
    ***REMOVED*** else if (is.number(query.pageSize)) ***REMOVED***
      // `pageSize` is Pub/Sub's `maxResults`.
      maxResults = query.pageSize;
    ***REMOVED***

    if (is.number(query.maxApiCalls)) ***REMOVED***
      maxApiCalls = query.maxApiCalls;
      delete query.maxApiCalls;
    ***REMOVED***

    if (
      callback &&
      (maxResults !== -1 || // The user specified a limit.
        query.autoPaginate === false)
    ) ***REMOVED***
      autoPaginate = false;
    ***REMOVED***
  ***REMOVED***

  return ***REMOVED***
    query: query || ***REMOVED******REMOVED***,
    autoPaginate: autoPaginate,
    maxApiCalls: maxApiCalls,
    maxResults: maxResults,
    callback: callback,
  ***REMOVED***;
***REMOVED***;

/**
 * This simply checks to see if `autoPaginate` is set or not, if it's true
 * then we buffer all results, otherwise simply call the original method.
 *
 * @param ***REMOVED***array***REMOVED*** parsedArguments - Parsed arguments from the original method
 *     call.
 * @param ***REMOVED***object=|string=***REMOVED*** parsedArguments.query - Query object. This is most
 *     commonly an object, but to make the API more simple, it can also be a
 *     string in some places.
 * @param ***REMOVED***function=***REMOVED*** parsedArguments.callback - Callback function.
 * @param ***REMOVED***boolean***REMOVED*** parsedArguments.autoPaginate - Auto-pagination enabled.
 * @param ***REMOVED***boolean***REMOVED*** parsedArguments.maxApiCalls - Maximum API calls to make.
 * @param ***REMOVED***number***REMOVED*** parsedArguments.maxResults - Maximum results to return.
 * @param ***REMOVED***function***REMOVED*** originalMethod - The cached method that accepts a callback
 *     and returns `nextQuery` to receive more results.
 */
paginator.run_ = function(parsedArguments, originalMethod) ***REMOVED***
  var query = parsedArguments.query;
  var callback = parsedArguments.callback;
  var autoPaginate = parsedArguments.autoPaginate;

  if (autoPaginate) ***REMOVED***
    this.runAsStream_(parsedArguments, originalMethod)
      .on('error', callback)
      .pipe(
        concat(function(results) ***REMOVED***
          callback(null, results);
        ***REMOVED***)
      );
  ***REMOVED*** else ***REMOVED***
    originalMethod(query, callback);
  ***REMOVED***
***REMOVED***;

/**
 * This method simply calls the nextQuery recursively, emitting results to a
 * stream. The stream ends when `nextQuery` is null.
 *
 * `maxResults` will act as a cap for how many results are fetched and emitted
 * to the stream.
 *
 * @param ***REMOVED***object=|string=***REMOVED*** parsedArguments.query - Query object. This is most
 *     commonly an object, but to make the API more simple, it can also be a
 *     string in some places.
 * @param ***REMOVED***function=***REMOVED*** parsedArguments.callback - Callback function.
 * @param ***REMOVED***boolean***REMOVED*** parsedArguments.autoPaginate - Auto-pagination enabled.
 * @param ***REMOVED***boolean***REMOVED*** parsedArguments.maxApiCalls - Maximum API calls to make.
 * @param ***REMOVED***number***REMOVED*** parsedArguments.maxResults - Maximum results to return.
 * @param ***REMOVED***function***REMOVED*** originalMethod - The cached method that accepts a callback
 *     and returns `nextQuery` to receive more results.
 * @return ***REMOVED***stream***REMOVED*** - Readable object stream.
 */
paginator.runAsStream_ = function(parsedArguments, originalMethod) ***REMOVED***
  var query = parsedArguments.query;
  var resultsToSend = parsedArguments.maxResults;

  var limiter = util.createLimiter(makeRequest, ***REMOVED***
    maxApiCalls: parsedArguments.maxApiCalls,
  ***REMOVED***);

  var stream = limiter.stream;

  stream.once('reading', function() ***REMOVED***
    makeRequest(query);
  ***REMOVED***);

  function makeRequest(query) ***REMOVED***
    originalMethod(query, onResultSet);
  ***REMOVED***

  function onResultSet(err, results, nextQuery) ***REMOVED***
    if (err) ***REMOVED***
      stream.destroy(err);
      return;
    ***REMOVED***

    if (resultsToSend >= 0 && results.length > resultsToSend) ***REMOVED***
      results = results.splice(0, resultsToSend);
    ***REMOVED***

    resultsToSend -= results.length;

    split(results, stream, function(streamEnded) ***REMOVED***
      if (streamEnded) ***REMOVED***
        return;
      ***REMOVED***

      if (nextQuery && resultsToSend !== 0) ***REMOVED***
        limiter.makeRequest(nextQuery);
        return;
      ***REMOVED***

      stream.push(null);
    ***REMOVED***);
  ***REMOVED***

  return limiter.stream;
***REMOVED***;

module.exports = paginator;
