'use strict';
const EventEmitter = require('events');
const http = require('http');
const https = require('https');
const PassThrough = require('stream').PassThrough;
const urlLib = require('url');
const querystring = require('querystring');
const duplexer3 = require('duplexer3');
const isStream = require('is-stream');
const getStream = require('get-stream');
const timedOut = require('timed-out');
const urlParseLax = require('url-parse-lax');
const lowercaseKeys = require('lowercase-keys');
const isRedirect = require('is-redirect');
const unzipResponse = require('unzip-response');
const createErrorClass = require('create-error-class');
const isRetryAllowed = require('is-retry-allowed');
const Buffer = require('safe-buffer').Buffer;
const pkg = require('./package');

function requestAsEventEmitter(opts) ***REMOVED***
	opts = opts || ***REMOVED******REMOVED***;

	const ee = new EventEmitter();
	const requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);
	let redirectCount = 0;
	let retryCount = 0;
	let redirectUrl;

	const get = opts => ***REMOVED***
		const fn = opts.protocol === 'https:' ? https : http;

		const req = fn.request(opts, res => ***REMOVED***
			const statusCode = res.statusCode;

			if (isRedirect(statusCode) && opts.followRedirect && 'location' in res.headers && (opts.method === 'GET' || opts.method === 'HEAD')) ***REMOVED***
				res.resume();

				if (++redirectCount > 10) ***REMOVED***
					ee.emit('error', new got.MaxRedirectsError(statusCode, opts), null, res);
					return;
				***REMOVED***

				const bufferString = Buffer.from(res.headers.location, 'binary').toString();

				redirectUrl = urlLib.resolve(urlLib.format(opts), bufferString);
				const redirectOpts = Object.assign(***REMOVED******REMOVED***, opts, urlLib.parse(redirectUrl));

				ee.emit('redirect', res, redirectOpts);

				get(redirectOpts);

				return;
			***REMOVED***

			setImmediate(() => ***REMOVED***
				const response = typeof unzipResponse === 'function' && req.method !== 'HEAD' ? unzipResponse(res) : res;
				response.url = redirectUrl || requestUrl;
				response.requestUrl = requestUrl;

				ee.emit('response', response);
			***REMOVED***);
		***REMOVED***);

		req.once('error', err => ***REMOVED***
			const backoff = opts.retries(++retryCount, err);

			if (backoff) ***REMOVED***
				setTimeout(get, backoff, opts);
				return;
			***REMOVED***

			ee.emit('error', new got.RequestError(err, opts));
		***REMOVED***);

		if (opts.gotTimeout) ***REMOVED***
			timedOut(req, opts.gotTimeout);
		***REMOVED***

		setImmediate(() => ***REMOVED***
			ee.emit('request', req);
		***REMOVED***);
	***REMOVED***;

	get(opts);
	return ee;
***REMOVED***

function asPromise(opts) ***REMOVED***
	return new Promise((resolve, reject) => ***REMOVED***
		const ee = requestAsEventEmitter(opts);

		ee.on('request', req => ***REMOVED***
			if (isStream(opts.body)) ***REMOVED***
				opts.body.pipe(req);
				opts.body = undefined;
				return;
			***REMOVED***

			req.end(opts.body);
		***REMOVED***);

		ee.on('response', res => ***REMOVED***
			const stream = opts.encoding === null ? getStream.buffer(res) : getStream(res, opts);

			stream
				.catch(err => reject(new got.ReadError(err, opts)))
				.then(data => ***REMOVED***
					const statusCode = res.statusCode;
					const limitStatusCode = opts.followRedirect ? 299 : 399;

					res.body = data;

					if (opts.json && res.body) ***REMOVED***
						try ***REMOVED***
							res.body = JSON.parse(res.body);
						***REMOVED*** catch (e) ***REMOVED***
							throw new got.ParseError(e, statusCode, opts, data);
						***REMOVED***
					***REMOVED***

					if (statusCode < 200 || statusCode > limitStatusCode) ***REMOVED***
						throw new got.HTTPError(statusCode, opts);
					***REMOVED***

					resolve(res);
				***REMOVED***)
				.catch(err => ***REMOVED***
					Object.defineProperty(err, 'response', ***REMOVED***value: res***REMOVED***);
					reject(err);
				***REMOVED***);
		***REMOVED***);

		ee.on('error', reject);
	***REMOVED***);
***REMOVED***

function asStream(opts) ***REMOVED***
	const input = new PassThrough();
	const output = new PassThrough();
	const proxy = duplexer3(input, output);

	if (opts.json) ***REMOVED***
		throw new Error('got can not be used as stream when options.json is used');
	***REMOVED***

	if (opts.body) ***REMOVED***
		proxy.write = () => ***REMOVED***
			throw new Error('got\'s stream is not writable when options.body is used');
		***REMOVED***;
	***REMOVED***

	const ee = requestAsEventEmitter(opts);

	ee.on('request', req => ***REMOVED***
		proxy.emit('request', req);

		if (isStream(opts.body)) ***REMOVED***
			opts.body.pipe(req);
			return;
		***REMOVED***

		if (opts.body) ***REMOVED***
			req.end(opts.body);
			return;
		***REMOVED***

		if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') ***REMOVED***
			input.pipe(req);
			return;
		***REMOVED***

		req.end();
	***REMOVED***);

	ee.on('response', res => ***REMOVED***
		const statusCode = res.statusCode;

		res.pipe(output);

		if (statusCode < 200 || statusCode > 299) ***REMOVED***
			proxy.emit('error', new got.HTTPError(statusCode, opts), null, res);
			return;
		***REMOVED***

		proxy.emit('response', res);
	***REMOVED***);

	ee.on('redirect', proxy.emit.bind(proxy, 'redirect'));
	ee.on('error', proxy.emit.bind(proxy, 'error'));

	return proxy;
***REMOVED***

function normalizeArguments(url, opts) ***REMOVED***
	if (typeof url !== 'string' && typeof url !== 'object') ***REMOVED***
		throw new Error(`Parameter \`url\` must be a string or object, not $***REMOVED***typeof url***REMOVED***`);
	***REMOVED***

	if (typeof url === 'string') ***REMOVED***
		url = url.replace(/^unix:/, 'http://$&');
		url = urlParseLax(url);

		if (url.auth) ***REMOVED***
			throw new Error('Basic authentication must be done with auth option');
		***REMOVED***
	***REMOVED***

	opts = Object.assign(
		***REMOVED***
			protocol: 'http:',
			path: '',
			retries: 5
		***REMOVED***,
		url,
		opts
	);

	opts.headers = Object.assign(***REMOVED***
		'user-agent': `$***REMOVED***pkg.name***REMOVED***/$***REMOVED***pkg.version***REMOVED*** (https://github.com/sindresorhus/got)`,
		'accept-encoding': 'gzip,deflate'
	***REMOVED***, lowercaseKeys(opts.headers));

	const query = opts.query;

	if (query) ***REMOVED***
		if (typeof query !== 'string') ***REMOVED***
			opts.query = querystring.stringify(query);
		***REMOVED***

		opts.path = `$***REMOVED***opts.path.split('?')[0]***REMOVED***?$***REMOVED***opts.query***REMOVED***`;
		delete opts.query;
	***REMOVED***

	if (opts.json && opts.headers.accept === undefined) ***REMOVED***
		opts.headers.accept = 'application/json';
	***REMOVED***

	let body = opts.body;

	if (body) ***REMOVED***
		if (typeof body !== 'string' && !(body !== null && typeof body === 'object')) ***REMOVED***
			throw new Error('options.body must be a ReadableStream, string, Buffer or plain Object');
		***REMOVED***

		opts.method = opts.method || 'POST';

		if (isStream(body) && typeof body.getBoundary === 'function') ***REMOVED***
			// Special case for https://github.com/form-data/form-data
			opts.headers['content-type'] = opts.headers['content-type'] || `multipart/form-data; boundary=$***REMOVED***body.getBoundary()***REMOVED***`;
		***REMOVED*** else if (body !== null && typeof body === 'object' && !Buffer.isBuffer(body) && !isStream(body)) ***REMOVED***
			opts.headers['content-type'] = opts.headers['content-type'] || 'application/x-www-form-urlencoded';
			body = opts.body = querystring.stringify(body);
		***REMOVED***

		if (opts.headers['content-length'] === undefined && opts.headers['transfer-encoding'] === undefined && !isStream(body)) ***REMOVED***
			const length = typeof body === 'string' ? Buffer.byteLength(body) : body.length;
			opts.headers['content-length'] = length;
		***REMOVED***
	***REMOVED***

	opts.method = (opts.method || 'GET').toUpperCase();

	if (opts.hostname === 'unix') ***REMOVED***
		const matches = /(.+):(.+)/.exec(opts.path);

		if (matches) ***REMOVED***
			opts.socketPath = matches[1];
			opts.path = matches[2];
			opts.host = null;
		***REMOVED***
	***REMOVED***

	if (typeof opts.retries !== 'function') ***REMOVED***
		const retries = opts.retries;

		opts.retries = (iter, err) => ***REMOVED***
			if (iter > retries || !isRetryAllowed(err)) ***REMOVED***
				return 0;
			***REMOVED***

			const noise = Math.random() * 100;

			return ((1 << iter) * 1000) + noise;
		***REMOVED***;
	***REMOVED***

	if (opts.followRedirect === undefined) ***REMOVED***
		opts.followRedirect = true;
	***REMOVED***

	if (opts.timeout) ***REMOVED***
		opts.gotTimeout = opts.timeout;
		delete opts.timeout;
	***REMOVED***

	return opts;
***REMOVED***

function got(url, opts) ***REMOVED***
	try ***REMOVED***
		return asPromise(normalizeArguments(url, opts));
	***REMOVED*** catch (err) ***REMOVED***
		return Promise.reject(err);
	***REMOVED***
***REMOVED***

const helpers = [
	'get',
	'post',
	'put',
	'patch',
	'head',
	'delete'
];

helpers.forEach(el => ***REMOVED***
	got[el] = (url, opts) => got(url, Object.assign(***REMOVED******REMOVED***, opts, ***REMOVED***method: el***REMOVED***));
***REMOVED***);

got.stream = (url, opts) => asStream(normalizeArguments(url, opts));

for (const el of helpers) ***REMOVED***
	got.stream[el] = (url, opts) => got.stream(url, Object.assign(***REMOVED******REMOVED***, opts, ***REMOVED***method: el***REMOVED***));
***REMOVED***

function stdError(error, opts) ***REMOVED***
	if (error.code !== undefined) ***REMOVED***
		this.code = error.code;
	***REMOVED***

	Object.assign(this, ***REMOVED***
		message: error.message,
		host: opts.host,
		hostname: opts.hostname,
		method: opts.method,
		path: opts.path
	***REMOVED***);
***REMOVED***

got.RequestError = createErrorClass('RequestError', stdError);
got.ReadError = createErrorClass('ReadError', stdError);
got.ParseError = createErrorClass('ParseError', function (e, statusCode, opts, data) ***REMOVED***
	stdError.call(this, e, opts);
	this.statusCode = statusCode;
	this.statusMessage = http.STATUS_CODES[this.statusCode];
	this.message = `$***REMOVED***e.message***REMOVED*** in "$***REMOVED***urlLib.format(opts)***REMOVED***": \n$***REMOVED***data.slice(0, 77)***REMOVED***...`;
***REMOVED***);

got.HTTPError = createErrorClass('HTTPError', function (statusCode, opts) ***REMOVED***
	stdError.call(this, ***REMOVED******REMOVED***, opts);
	this.statusCode = statusCode;
	this.statusMessage = http.STATUS_CODES[this.statusCode];
	this.message = `Response code $***REMOVED***this.statusCode***REMOVED*** ($***REMOVED***this.statusMessage***REMOVED***)`;
***REMOVED***);

got.MaxRedirectsError = createErrorClass('MaxRedirectsError', function (statusCode, opts) ***REMOVED***
	stdError.call(this, ***REMOVED******REMOVED***, opts);
	this.statusCode = statusCode;
	this.statusMessage = http.STATUS_CODES[this.statusCode];
	this.message = 'Redirected 10 times. Aborting.';
***REMOVED***);

module.exports = got;
