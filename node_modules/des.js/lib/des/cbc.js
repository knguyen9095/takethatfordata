'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = ***REMOVED******REMOVED***;

function CBCState(iv) ***REMOVED***
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
***REMOVED***

function instantiate(Base) ***REMOVED***
  function CBC(options) ***REMOVED***
    Base.call(this, options);
    this._cbcInit();
  ***REMOVED***
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) ***REMOVED***
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  ***REMOVED***

  CBC.create = function create(options) ***REMOVED***
    return new CBC(options);
  ***REMOVED***;

  return CBC;
***REMOVED***

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() ***REMOVED***
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
***REMOVED***;

proto._update = function _update(inp, inOff, out, outOff) ***REMOVED***
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') ***REMOVED***
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  ***REMOVED*** else ***REMOVED***
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  ***REMOVED***
***REMOVED***;
