'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var des = require('../des');
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) ***REMOVED***
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') ***REMOVED***
    this.ciphers = [
      DES.create(***REMOVED*** type: 'encrypt', key: k1 ***REMOVED***),
      DES.create(***REMOVED*** type: 'decrypt', key: k2 ***REMOVED***),
      DES.create(***REMOVED*** type: 'encrypt', key: k3 ***REMOVED***)
    ];
  ***REMOVED*** else ***REMOVED***
    this.ciphers = [
      DES.create(***REMOVED*** type: 'decrypt', key: k3 ***REMOVED***),
      DES.create(***REMOVED*** type: 'encrypt', key: k2 ***REMOVED***),
      DES.create(***REMOVED*** type: 'decrypt', key: k1 ***REMOVED***)
    ];
  ***REMOVED***
***REMOVED***

function EDE(options) ***REMOVED***
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
***REMOVED***
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) ***REMOVED***
  return new EDE(options);
***REMOVED***;

EDE.prototype._update = function _update(inp, inOff, out, outOff) ***REMOVED***
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
***REMOVED***;

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;
