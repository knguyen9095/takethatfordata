/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
function globToRegExp(glob) ***REMOVED***
	// * [^\\\/]*
	// /**/ /.+/
	// ^* \./.+ (concord special)
	// ? [^\\\/]
	// [!...] [^...]
	// [^...] [^...]
	// / [\\\/]
	// ***REMOVED***...,...***REMOVED*** (...|...)
	// ?(...|...) (...|...)?
	// +(...|...) (...|...)+
	// *(...|...) (...|...)*
	// @(...|...) (...|...)
	if(/^\(.+\)$/.test(glob)) ***REMOVED***
		// allow to pass an RegExp in brackets
		return new RegExp(glob.substr(1, glob.length - 2));
	***REMOVED***
	var tokens = tokenize(glob);
	var process = createRoot();
	var regExpStr = tokens.map(process).join("");
	return new RegExp("^" + regExpStr + "$");
***REMOVED***

var SIMPLE_TOKENS = ***REMOVED***
	"@(": "one",
	"?(": "zero-one",
	"+(": "one-many",
	"*(": "zero-many",
	"|": "segment-sep",
	"/**/": "any-path-segments",
	"**": "any-path",
	"*": "any-path-segment",
	"?": "any-char",
	"***REMOVED***": "or",
	"/": "path-sep",
	",": "comma",
	")": "closing-segment",
	"***REMOVED***": "closing-or"
***REMOVED***;

function tokenize(glob) ***REMOVED***
	return glob.split(/([@?+*]\(|\/\*\*\/|\*\*|[?*]|\[[\!\^]?(?:[^\]\\]|\\.)+\]|\***REMOVED***|,|\/|[|)***REMOVED***])/g).map(function(item) ***REMOVED***
		if(!item)
			return null;
		var t = SIMPLE_TOKENS[item];
		if(t) ***REMOVED***
			return ***REMOVED***
				type: t
			***REMOVED***;
		***REMOVED***
		if(item[0] === "[") ***REMOVED***
			if(item[1] === "^" || item[1] === "!") ***REMOVED***
				return ***REMOVED***
					type: "inverted-char-set",
					value: item.substr(2, item.length - 3)
				***REMOVED***;
			***REMOVED*** else ***REMOVED***
				return ***REMOVED***
					type: "char-set",
					value: item.substr(1, item.length - 2)
				***REMOVED***;
			***REMOVED***
		***REMOVED***
		return ***REMOVED***
			type: "string",
			value: item
		***REMOVED***;
	***REMOVED***).filter(Boolean).concat(***REMOVED***
		type: "end"
	***REMOVED***);
***REMOVED***

function createRoot() ***REMOVED***
	var inOr = [];
	var process = createSeqment();
	var initial = true;
	return function(token) ***REMOVED***
		switch(token.type) ***REMOVED***
			case "or":
				inOr.push(initial);
				return "(";
			case "comma":
				if(inOr.length) ***REMOVED***
					initial = inOr[inOr.length - 1];
					return "|";
				***REMOVED*** else ***REMOVED***
					return process(***REMOVED***
						type: "string",
						value: ","
					***REMOVED***, initial);
				***REMOVED***
			case "closing-or":
				if(inOr.length === 0)
					throw new Error("Unmatched '***REMOVED***'");
				inOr.pop();
				return ")";
			case "end":
				if(inOr.length)
					throw new Error("Unmatched '***REMOVED***'");
				return process(token, initial);
			default:
				var result = process(token, initial);
				initial = false;
				return result;
		***REMOVED***
	***REMOVED***;
***REMOVED***

function createSeqment() ***REMOVED***
	var inSeqment = [];
	var process = createSimple();
	return function(token, initial) ***REMOVED***
		switch(token.type) ***REMOVED***
			case "one":
			case "one-many":
			case "zero-many":
			case "zero-one":
				inSeqment.push(token.type);
				return "(";
			case "segment-sep":
				if(inSeqment.length) ***REMOVED***
					return "|";
				***REMOVED*** else ***REMOVED***
					return process(***REMOVED***
						type: "string",
						value: "|"
					***REMOVED***, initial);
				***REMOVED***
			case "closing-segment":
				var segment = inSeqment.pop();
				switch(segment) ***REMOVED***
					case "one":
						return ")";
					case "one-many":
						return ")+";
					case "zero-many":
						return ")*";
					case "zero-one":
						return ")?";
				***REMOVED***
				throw new Error("Unexcepted segment " + segment);
			case "end":
				if(inSeqment.length > 0) ***REMOVED***
					throw new Error("Unmatched segment, missing ')'");
				***REMOVED***
				return process(token, initial);
			default:
				return process(token, initial);
		***REMOVED***
	***REMOVED***;
***REMOVED***

function createSimple() ***REMOVED***
	return function(token, initial) ***REMOVED***
		switch(token.type) ***REMOVED***
			case "path-sep":
				return "[\\\\/]+";
			case "any-path-segments":
				return "[\\\\/]+(?:(.+)[\\\\/]+)?";
			case "any-path":
				return "(.*)";
			case "any-path-segment":
				if(initial) ***REMOVED***
					return "\\.[\\\\/]+(?:.*[\\\\/]+)?([^\\\\/]+)";
				***REMOVED*** else ***REMOVED***
					return "([^\\\\/]*)";
				***REMOVED***
			case "any-char":
				return "[^\\\\/]";
			case "inverted-char-set":
				return "[^" + token.value + "]";
			case "char-set":
				return "[" + token.value + "]";
			case "string":
				return token.value.replace(/[-[\]***REMOVED******REMOVED***()*+?.,\\^$|#\s]/g, "\\$&");
			case "end":
				return "";
			default:
				throw new Error("Unsupported token '" + token.type + "'");
		***REMOVED***
	***REMOVED***;
***REMOVED***

exports.globToRegExp = globToRegExp;
