/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var Tapable = require("tapable");
var createInnerCallback = require("./createInnerCallback");

function Resolver(fileSystem) ***REMOVED***
	Tapable.call(this);
	this.fileSystem = fileSystem;
***REMOVED***
module.exports = Resolver;

Resolver.prototype = Object.create(Tapable.prototype);

Resolver.prototype.constructor = Resolver;

Resolver.prototype.resolveSync = function resolveSync(context, path, request) ***REMOVED***
	var err, result, sync = false;
	this.resolve(context, path, request, function(e, r) ***REMOVED***
		err = e;
		result = r;
		sync = true;
	***REMOVED***);
	if(!sync) throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
	if(err) throw err;
	return result;
***REMOVED***;

Resolver.prototype.resolve = function resolve(context, path, request, callback) ***REMOVED***
	if(arguments.length === 3) ***REMOVED***
		throw new Error("Signature changed: context parameter added");
	***REMOVED***
	var resolver = this;
	var obj = ***REMOVED***
		context: context,
		path: path,
		request: request
	***REMOVED***;

	var localMissing;
	var log;
	var message = "resolve '" + request + "' in '" + path + "'";

	function writeLog(msg) ***REMOVED***
		log.push(msg);
	***REMOVED***

	function logAsString() ***REMOVED***
		return log.join("\n");
	***REMOVED***

	function onError(err, result) ***REMOVED***
		if(callback.log) ***REMOVED***
			for(var i = 0; i < log.length; i++)
				callback.log(log[i]);
		***REMOVED***

		if(err) return callback(err);

		var error = new Error("Can't " + message);
		error.details = logAsString();
		error.missing = localMissing;
		resolver.applyPlugins("no-resolve", obj, error);
		return callback(error);
	***REMOVED***

	function onResolve(err, result) ***REMOVED***
		if(!err && result) ***REMOVED***
			return callback(null, result.path === false ? false : result.path + (result.query || ""), result);
		***REMOVED***

		localMissing = [];
		log = [];

		return resolver.doResolve("resolve", obj, message, createInnerCallback(onError, ***REMOVED***
			log: writeLog,
			missing: localMissing,
			stack: callback.stack
		***REMOVED***));
	***REMOVED***

	onResolve.missing = callback.missing;
	onResolve.stack = callback.stack;

	return this.doResolve("resolve", obj, message, onResolve);
***REMOVED***;

Resolver.prototype.doResolve = function doResolve(type, request, message, callback) ***REMOVED***
	var resolver = this;
	var stackLine = type + ": (" + request.path + ") " +
		(request.request || "") + (request.query || "") +
		(request.directory ? " directory" : "") +
		(request.module ? " module" : "");
	var newStack = [stackLine];
	if(callback.stack) ***REMOVED***
		newStack = callback.stack.concat(newStack);
		if(callback.stack.indexOf(stackLine) >= 0) ***REMOVED***
			// Prevent recursion
			var recursionError = new Error("Recursion in resolving\nStack:\n  " + newStack.join("\n  "));
			recursionError.recursion = true;
			if(callback.log) callback.log("abort resolving because of recursion");
			return callback(recursionError);
		***REMOVED***
	***REMOVED***
	resolver.applyPlugins("resolve-step", type, request);

	var beforePluginName = "before-" + type;
	if(resolver.hasPlugins(beforePluginName)) ***REMOVED***
		resolver.applyPluginsAsyncSeriesBailResult1(beforePluginName, request, createInnerCallback(beforeInnerCallback, ***REMOVED***
			log: callback.log,
			missing: callback.missing,
			stack: newStack
		***REMOVED***, message && ("before " + message), true));
	***REMOVED*** else ***REMOVED***
		runNormal();
	***REMOVED***

	function beforeInnerCallback(err, result) ***REMOVED***
		if(arguments.length > 0) ***REMOVED***
			if(err) return callback(err);
			if(result) return callback(null, result);
			return callback();
		***REMOVED***
		runNormal();
	***REMOVED***

	function runNormal() ***REMOVED***
		if(resolver.hasPlugins(type)) ***REMOVED***
			return resolver.applyPluginsAsyncSeriesBailResult1(type, request, createInnerCallback(innerCallback, ***REMOVED***
				log: callback.log,
				missing: callback.missing,
				stack: newStack
			***REMOVED***, message));
		***REMOVED*** else ***REMOVED***
			runAfter();
		***REMOVED***
	***REMOVED***

	function innerCallback(err, result) ***REMOVED***
		if(arguments.length > 0) ***REMOVED***
			if(err) return callback(err);
			if(result) return callback(null, result);
			return callback();
		***REMOVED***
		runAfter();
	***REMOVED***

	function runAfter() ***REMOVED***
		var afterPluginName = "after-" + type;
		if(resolver.hasPlugins(afterPluginName)) ***REMOVED***
			return resolver.applyPluginsAsyncSeriesBailResult1(afterPluginName, request, createInnerCallback(afterInnerCallback, ***REMOVED***
				log: callback.log,
				missing: callback.missing,
				stack: newStack
			***REMOVED***, message && ("after " + message), true));
		***REMOVED*** else ***REMOVED***
			callback();
		***REMOVED***
	***REMOVED***

	function afterInnerCallback(err, result) ***REMOVED***
		if(arguments.length > 0) ***REMOVED***
			if(err) return callback(err);
			if(result) return callback(null, result);
			return callback();
		***REMOVED***
		return callback();
	***REMOVED***
***REMOVED***;

Resolver.prototype.parse = function parse(identifier) ***REMOVED***
	if(identifier === "") return null;
	var part = ***REMOVED***
		request: "",
		query: "",
		module: false,
		directory: false,
		file: false
	***REMOVED***;
	var idxQuery = identifier.indexOf("?");
	if(idxQuery === 0) ***REMOVED***
		part.query = identifier;
	***REMOVED*** else if(idxQuery > 0) ***REMOVED***
		part.request = identifier.slice(0, idxQuery);
		part.query = identifier.slice(idxQuery);
	***REMOVED*** else ***REMOVED***
		part.request = identifier;
	***REMOVED***
	if(part.request) ***REMOVED***
		part.module = this.isModule(part.request);
		part.directory = this.isDirectory(part.request);
		if(part.directory) ***REMOVED***
			part.request = part.request.substr(0, part.request.length - 1);
		***REMOVED***
	***REMOVED***
	return part;
***REMOVED***;

var notModuleRegExp = /^\.$|^\.[\\\/]|^\.\.$|^\.\.[\/\\]|^\/|^[A-Z]:[\\\/]/i;
Resolver.prototype.isModule = function isModule(path) ***REMOVED***
	return !notModuleRegExp.test(path);
***REMOVED***;

var directoryRegExp = /[\/\\]$/i;
Resolver.prototype.isDirectory = function isDirectory(path) ***REMOVED***
	return directoryRegExp.test(path);
***REMOVED***;

var memoryFsJoin = require("memory-fs/lib/join");
var memoizedJoin = new Map();
Resolver.prototype.join = function(path, request) ***REMOVED***
	var cacheEntry;
	var pathCache = memoizedJoin.get(path);
	if(typeof pathCache === "undefined") ***REMOVED***
		memoizedJoin.set(path, pathCache = new Map());
	***REMOVED*** else ***REMOVED***
		cacheEntry = pathCache.get(request);
		if(typeof cacheEntry !== "undefined")
			return cacheEntry;
	***REMOVED***
	cacheEntry = memoryFsJoin(path, request);
	pathCache.set(request, cacheEntry);
	return cacheEntry;
***REMOVED***;

Resolver.prototype.normalize = require("memory-fs/lib/normalize");
