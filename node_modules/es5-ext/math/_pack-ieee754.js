/* eslint no-bitwise: "off" */
// Credit: https://github.com/paulmillr/es6-shim/

"use strict";

var abs = Math.abs
  , floor = Math.floor
  , log = Math.log
  , min = Math.min
  , pow = Math.pow
  , LN2 = Math.LN2
  , roundToEven;

roundToEven = function (num) ***REMOVED***
	var whole = floor(num), fraction = num - whole;
	if (fraction < 0.5) return whole;
	if (fraction > 0.5) return whole + 1;
	return whole % 2 ? whole + 1 : whole;
***REMOVED***;

// eslint-disable-next-line max-statements
module.exports = function (value, ebits, fbits) ***REMOVED***
	var bias = (1 << (ebits - 1)) - 1, sign, e, fraction, i, bits, str, bytes;

	// Compute sign, exponent, fraction
	if (isNaN(value)) ***REMOVED***
		// NaN
		// http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
		e = (1 << ebits) - 1;
		fraction = pow(2, fbits - 1);
		sign = 0;
	***REMOVED*** else if (value === Infinity || value === -Infinity) ***REMOVED***
		e = (1 << ebits) - 1;
		fraction = 0;
		sign = value < 0 ? 1 : 0;
	***REMOVED*** else if (value === 0) ***REMOVED***
		e = 0;
		fraction = 0;
		sign = 1 / value === -Infinity ? 1 : 0;
	***REMOVED*** else ***REMOVED***
		sign = value < 0;
		value = abs(value);

		if (value >= pow(2, 1 - bias)) ***REMOVED***
			e = min(floor(log(value) / LN2), 1023);
			fraction = roundToEven(value / pow(2, e) * pow(2, fbits));
			if (fraction / pow(2, fbits) >= 2) ***REMOVED***
				e += 1;
				fraction = 1;
			***REMOVED***
			if (e > bias) ***REMOVED***
				// Overflow
				e = (1 << ebits) - 1;
				fraction = 0;
			***REMOVED*** else ***REMOVED***
				// Normal
				e += bias;
				fraction -= pow(2, fbits);
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			// Subnormal
			e = 0;
			fraction = roundToEven(value / pow(2, 1 - bias - fbits));
		***REMOVED***
	***REMOVED***

	// Pack sign, exponent, fraction
	bits = [];
	for (i = fbits; i; i -= 1) ***REMOVED***
		bits.push(fraction % 2 ? 1 : 0);
		fraction = floor(fraction / 2);
	***REMOVED***
	for (i = ebits; i; i -= 1) ***REMOVED***
		bits.push(e % 2 ? 1 : 0);
		e = floor(e / 2);
	***REMOVED***
	bits.push(sign ? 1 : 0);
	bits.reverse();
	str = bits.join("");

	// Bits to bytes
	bytes = [];
	while (str.length) ***REMOVED***
		bytes.push(parseInt(str.substring(0, 8), 2));
		str = str.substring(8);
	***REMOVED***
	return bytes;
***REMOVED***;
