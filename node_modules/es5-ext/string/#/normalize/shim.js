/* eslint no-bitwise: "off", max-statements: "off", max-lines: "off" */

// Taken from: https://github.com/walling/unorm/blob/master/lib/unorm.js

/*
	* UnicodeNormalizer 1.0.0
	* Copyright (c) 2008 Matsuza
	* Dual licensed under the MIT (MIT-LICENSE.txt) and
	* GPL (GPL-LICENSE.txt) licenses.
	* $Date: 2008-06-05 16:44:17 +0200 (Thu, 05 Jun 2008) $
	* $Rev: 13309 $
*/

"use strict";

var primitiveSet = require("../../../object/primitive-set")
  , validValue   = require("../../../object/valid-value")
  , data         = require("./_data");

var floor = Math.floor
  , forms = primitiveSet("NFC", "NFD", "NFKC", "NFKD")
  , DEFAULT_FEATURE = [null, 0, ***REMOVED******REMOVED***]
  , CACHE_THRESHOLD = 10
  , SBase = 0xac00
  , LBase = 0x1100
  , VBase = 0x1161
  , TBase = 0x11a7
  , LCount = 19
  , VCount = 21
  , TCount = 28
  , NCount = VCount * TCount
  , SCount = LCount * NCount
  , UChar
  , cache = ***REMOVED******REMOVED***
  , cacheCounter = []
  , fromCache
  , fromData
  , fromCpOnly
  , fromRuleBasedJamo
  , fromCpFilter
  , strategies
  , UCharIterator
  , RecursDecompIterator
  , DecompIterator
  , CompIterator
  , createIterator
  , normalize;

UChar = function (cp, feature) ***REMOVED***
	this.codepoint = cp;
	this.feature = feature;
***REMOVED***;

// Strategies
(function () ***REMOVED***
	for (var i = 0; i <= 0xff; ++i) cacheCounter[i] = 0;
***REMOVED***());

fromCache = function (nextStep, cp, needFeature) ***REMOVED***
	var ret = cache[cp];
	if (!ret) ***REMOVED***
		ret = nextStep(cp, needFeature);
		if (Boolean(ret.feature) && ++cacheCounter[(cp >> 8) & 0xff] > CACHE_THRESHOLD) ***REMOVED***
			cache[cp] = ret;
		***REMOVED***
	***REMOVED***
	return ret;
***REMOVED***;

fromData = function (next, cp) ***REMOVED***
	var hash = cp & 0xff00, dunit = UChar.udata[hash] || ***REMOVED******REMOVED***, feature = dunit[cp];
	return feature ? new UChar(cp, feature) : new UChar(cp, DEFAULT_FEATURE);
***REMOVED***;
fromCpOnly = function (next, cp, needFeature) ***REMOVED***
	return needFeature ? next(cp, needFeature) : new UChar(cp, null);
***REMOVED***;

fromRuleBasedJamo = function (next, cp, needFeature) ***REMOVED***
	var char, base, i, arr, SIndex, TIndex, feature, j;
	if (cp < LBase || (LBase + LCount <= cp && cp < SBase) || SBase + SCount < cp) ***REMOVED***
		return next(cp, needFeature);
	***REMOVED***
	if (LBase <= cp && cp < LBase + LCount) ***REMOVED***
		char = ***REMOVED******REMOVED***;
		base = (cp - LBase) * VCount;
		for (i = 0; i < VCount; ++i) ***REMOVED***
			char[VBase + i] = SBase + TCount * (i + base);
		***REMOVED***
		arr = new Array(3);
		arr[2] = char;
		return new UChar(cp, arr);
	***REMOVED***

	SIndex = cp - SBase;
	TIndex = SIndex % TCount;
	feature = [];
	if (TIndex === 0) ***REMOVED***
		feature[0] = [LBase + floor(SIndex / NCount), VBase + floor(SIndex % NCount / TCount)];
		feature[2] = ***REMOVED******REMOVED***;
		for (j = 1; j < TCount; ++j) ***REMOVED***
			feature[2][TBase + j] = cp + j;
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		feature[0] = [SBase + SIndex - TIndex, TBase + TIndex];
	***REMOVED***
	return new UChar(cp, feature);
***REMOVED***;

fromCpFilter = function (next, cp, needFeature) ***REMOVED***
	return cp < 60 || (cp > 13311 && cp < 42607)
		? new UChar(cp, DEFAULT_FEATURE)
		: next(cp, needFeature);
***REMOVED***;

strategies = [fromCpFilter, fromCache, fromCpOnly, fromRuleBasedJamo, fromData];

UChar.fromCharCode = strategies.reduceRight(function (next, strategy) ***REMOVED***
	return function (cp, needFeature) ***REMOVED***
		return strategy(next, cp, needFeature);
	***REMOVED***;
***REMOVED***, null);

UChar.isHighSurrogate = function (cp) ***REMOVED***
	return cp >= 0xd800 && cp <= 0xdbff;
***REMOVED***;
UChar.isLowSurrogate = function (cp) ***REMOVED***
	return cp >= 0xdc00 && cp <= 0xdfff;
***REMOVED***;

UChar.prototype.prepFeature = function () ***REMOVED***
	if (!this.feature) ***REMOVED***
		this.feature = UChar.fromCharCode(this.codepoint, true).feature;
	***REMOVED***
***REMOVED***;

UChar.prototype.toString = function () ***REMOVED***
	var num;
	if (this.codepoint < 0x10000) return String.fromCharCode(this.codepoint);
	num = this.codepoint - 0x10000;
	return String.fromCharCode(floor(num / 0x400) + 0xd800, num % 0x400 + 0xdc00);
***REMOVED***;

UChar.prototype.getDecomp = function () ***REMOVED***
	this.prepFeature();
	return this.feature[0] || null;
***REMOVED***;

UChar.prototype.isCompatibility = function () ***REMOVED***
	this.prepFeature();
	return Boolean(this.feature[1]) && this.feature[1] & (1 << 8);
***REMOVED***;
UChar.prototype.isExclude = function () ***REMOVED***
	this.prepFeature();
	return Boolean(this.feature[1]) && this.feature[1] & (1 << 9);
***REMOVED***;
UChar.prototype.getCanonicalClass = function () ***REMOVED***
	this.prepFeature();
	return this.feature[1] ? this.feature[1] & 0xff : 0;
***REMOVED***;
UChar.prototype.getComposite = function (following) ***REMOVED***
	var cp;
	this.prepFeature();
	if (!this.feature[2]) return null;
	cp = this.feature[2][following.codepoint];
	return cp ? UChar.fromCharCode(cp) : null;
***REMOVED***;

UCharIterator = function (str) ***REMOVED***
	this.str = str;
	this.cursor = 0;
***REMOVED***;
UCharIterator.prototype.next = function () ***REMOVED***
	if (Boolean(this.str) && this.cursor < this.str.length) ***REMOVED***
		var cp = this.str.charCodeAt(this.cursor++), d;
		if (
			UChar.isHighSurrogate(cp) &&
			this.cursor < this.str.length &&
			UChar.isLowSurrogate(d = this.str.charCodeAt(this.cursor))
		) ***REMOVED***
			cp = (cp - 0xd800) * 0x400 + (d - 0xdc00) + 0x10000;
			++this.cursor;
		***REMOVED***
		return UChar.fromCharCode(cp);
	***REMOVED***
	this.str = null;
	return null;
***REMOVED***;

RecursDecompIterator = function (it, cano) ***REMOVED***
	this.it = it;
	this.canonical = cano;
	this.resBuf = [];
***REMOVED***;

RecursDecompIterator.prototype.next = function () ***REMOVED***
	var recursiveDecomp, uchar;
	recursiveDecomp = function (cano, ucharLoc) ***REMOVED***
		var decomp = ucharLoc.getDecomp(), ret, i, a, j;
		if (Boolean(decomp) && !(cano && ucharLoc.isCompatibility())) ***REMOVED***
			ret = [];
			for (i = 0; i < decomp.length; ++i) ***REMOVED***
				a = recursiveDecomp(cano, UChar.fromCharCode(decomp[i]));
				// Ret.concat(a); //<-why does not this work?
				// following block is a workaround.
				for (j = 0; j < a.length; ++j) ret.push(a[j]);
			***REMOVED***
			return ret;
		***REMOVED***
		return [ucharLoc];
	***REMOVED***;
	if (this.resBuf.length === 0) ***REMOVED***
		uchar = this.it.next();
		if (!uchar) return null;
		this.resBuf = recursiveDecomp(this.canonical, uchar);
	***REMOVED***
	return this.resBuf.shift();
***REMOVED***;

DecompIterator = function (it) ***REMOVED***
	this.it = it;
	this.resBuf = [];
***REMOVED***;

DecompIterator.prototype.next = function () ***REMOVED***
	var cc, uchar, inspt, uchar2, cc2;
	if (this.resBuf.length === 0) ***REMOVED***
		do ***REMOVED***
			uchar = this.it.next();
			if (!uchar) break;
			cc = uchar.getCanonicalClass();
			inspt = this.resBuf.length;
			if (cc !== 0) ***REMOVED***
				for (inspt; inspt > 0; --inspt) ***REMOVED***
					uchar2 = this.resBuf[inspt - 1];
					cc2 = uchar2.getCanonicalClass();
					// eslint-disable-next-line max-depth
					if (cc2 <= cc) break;
				***REMOVED***
			***REMOVED***
			this.resBuf.splice(inspt, 0, uchar);
		***REMOVED*** while (cc !== 0);
	***REMOVED***
	return this.resBuf.shift();
***REMOVED***;

CompIterator = function (it) ***REMOVED***
	this.it = it;
	this.procBuf = [];
	this.resBuf = [];
	this.lastClass = null;
***REMOVED***;

CompIterator.prototype.next = function () ***REMOVED***
	var uchar, starter, composite, cc;
	while (this.resBuf.length === 0) ***REMOVED***
		uchar = this.it.next();
		if (!uchar) ***REMOVED***
			this.resBuf = this.procBuf;
			this.procBuf = [];
			break;
		***REMOVED***
		if (this.procBuf.length === 0) ***REMOVED***
			this.lastClass = uchar.getCanonicalClass();
			this.procBuf.push(uchar);
		***REMOVED*** else ***REMOVED***
			starter = this.procBuf[0];
			composite = starter.getComposite(uchar);
			cc = uchar.getCanonicalClass();
			if (Boolean(composite) && (this.lastClass < cc || this.lastClass === 0)) ***REMOVED***
				this.procBuf[0] = composite;
			***REMOVED*** else ***REMOVED***
				if (cc === 0) ***REMOVED***
					this.resBuf = this.procBuf;
					this.procBuf = [];
				***REMOVED***
				this.lastClass = cc;
				this.procBuf.push(uchar);
			***REMOVED***
		***REMOVED***
	***REMOVED***
	return this.resBuf.shift();
***REMOVED***;

createIterator = function (mode, str) ***REMOVED***
	switch (mode) ***REMOVED***
		case "NFD":
			return new DecompIterator(new RecursDecompIterator(new UCharIterator(str), true));
		case "NFKD":
			return new DecompIterator(new RecursDecompIterator(new UCharIterator(str), false));
		case "NFC":
			return new CompIterator(
				new DecompIterator(new RecursDecompIterator(new UCharIterator(str), true))
			);
		case "NFKC":
			return new CompIterator(
				new DecompIterator(new RecursDecompIterator(new UCharIterator(str), false))
			);
		default:
			throw new Error(mode + " is invalid");
	***REMOVED***
***REMOVED***;
normalize = function (mode, str) ***REMOVED***
	var it = createIterator(mode, str), ret = "", uchar;
	while ((uchar = it.next())) ret += uchar.toString();
	return ret;
***REMOVED***;

/* Unicode data */
UChar.udata = data;

module.exports = function (/* Form*/) ***REMOVED***
	var str = String(validValue(this)), form = arguments[0];
	if (form === undefined) form = "NFC";
	else form = String(form);
	if (!forms[form]) throw new RangeError("Invalid normalization form: " + form);
	return normalize(form, str);
***REMOVED***;
