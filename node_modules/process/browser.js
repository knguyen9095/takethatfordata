// shim for using process in browser
var process = module.exports = ***REMOVED******REMOVED***;

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() ***REMOVED***
    throw new Error('setTimeout has not been defined');
***REMOVED***
function defaultClearTimeout () ***REMOVED***
    throw new Error('clearTimeout has not been defined');
***REMOVED***
(function () ***REMOVED***
    try ***REMOVED***
        if (typeof setTimeout === 'function') ***REMOVED***
            cachedSetTimeout = setTimeout;
        ***REMOVED*** else ***REMOVED***
            cachedSetTimeout = defaultSetTimout;
        ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***
        cachedSetTimeout = defaultSetTimout;
    ***REMOVED***
    try ***REMOVED***
        if (typeof clearTimeout === 'function') ***REMOVED***
            cachedClearTimeout = clearTimeout;
        ***REMOVED*** else ***REMOVED***
            cachedClearTimeout = defaultClearTimeout;
        ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***
        cachedClearTimeout = defaultClearTimeout;
    ***REMOVED***
***REMOVED*** ())
function runTimeout(fun) ***REMOVED***
    if (cachedSetTimeout === setTimeout) ***REMOVED***
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    ***REMOVED***
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) ***REMOVED***
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    ***REMOVED***
    try ***REMOVED***
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    ***REMOVED*** catch(e)***REMOVED***
        try ***REMOVED***
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        ***REMOVED*** catch(e)***REMOVED***
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        ***REMOVED***
    ***REMOVED***


***REMOVED***
function runClearTimeout(marker) ***REMOVED***
    if (cachedClearTimeout === clearTimeout) ***REMOVED***
        //normal enviroments in sane situations
        return clearTimeout(marker);
    ***REMOVED***
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) ***REMOVED***
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    ***REMOVED***
    try ***REMOVED***
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    ***REMOVED*** catch (e)***REMOVED***
        try ***REMOVED***
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        ***REMOVED*** catch (e)***REMOVED***
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        ***REMOVED***
    ***REMOVED***



***REMOVED***
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() ***REMOVED***
    if (!draining || !currentQueue) ***REMOVED***
        return;
    ***REMOVED***
    draining = false;
    if (currentQueue.length) ***REMOVED***
        queue = currentQueue.concat(queue);
    ***REMOVED*** else ***REMOVED***
        queueIndex = -1;
    ***REMOVED***
    if (queue.length) ***REMOVED***
        drainQueue();
    ***REMOVED***
***REMOVED***

function drainQueue() ***REMOVED***
    if (draining) ***REMOVED***
        return;
    ***REMOVED***
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) ***REMOVED***
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) ***REMOVED***
            if (currentQueue) ***REMOVED***
                currentQueue[queueIndex].run();
            ***REMOVED***
        ***REMOVED***
        queueIndex = -1;
        len = queue.length;
    ***REMOVED***
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
***REMOVED***

process.nextTick = function (fun) ***REMOVED***
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) ***REMOVED***
        for (var i = 1; i < arguments.length; i++) ***REMOVED***
            args[i - 1] = arguments[i];
        ***REMOVED***
    ***REMOVED***
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) ***REMOVED***
        runTimeout(drainQueue);
    ***REMOVED***
***REMOVED***;

// v8 likes predictible objects
function Item(fun, array) ***REMOVED***
    this.fun = fun;
    this.array = array;
***REMOVED***
Item.prototype.run = function () ***REMOVED***
    this.fun.apply(null, this.array);
***REMOVED***;
process.title = 'browser';
process.browser = true;
process.env = ***REMOVED******REMOVED***;
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = ***REMOVED******REMOVED***;

function noop() ***REMOVED******REMOVED***

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) ***REMOVED*** return [] ***REMOVED***

process.binding = function (name) ***REMOVED***
    throw new Error('process.binding is not supported');
***REMOVED***;

process.cwd = function () ***REMOVED*** return '/' ***REMOVED***;
process.chdir = function (dir) ***REMOVED***
    throw new Error('process.chdir is not supported');
***REMOVED***;
process.umask = function() ***REMOVED*** return 0; ***REMOVED***;
