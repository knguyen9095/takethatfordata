/*!
 * use <https://github.com/jonschlinkert/use>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var utils = require('./utils');

module.exports = function base(app, opts) ***REMOVED***
  if (!utils.isObject(app) && typeof app !== 'function') ***REMOVED***
    throw new TypeError('use: expect `app` be an object or function');
  ***REMOVED***

  if (!utils.isObject(opts)) ***REMOVED***
    opts = ***REMOVED******REMOVED***;
  ***REMOVED***

  var prop = utils.isString(opts.prop) ? opts.prop : 'fns';
  if (!Array.isArray(app[prop])) ***REMOVED***
    utils.define(app, prop, []);
  ***REMOVED***

  /**
   * Define a plugin function to be passed to use. The only
   * parameter exposed to the plugin is `app`, the object or function.
   * passed to `use(app)`. `app` is also exposed as `this` in plugins.
   *
   * Additionally, **if a plugin returns a function, the function will
   * be pushed onto the `fns` array**, allowing the plugin to be
   * called at a later point by the `run` method.
   *
   * ```js
   * var use = require('use');
   *
   * // define a plugin
   * function foo(app) ***REMOVED***
   *   // do stuff
   * ***REMOVED***
   *
   * var app = function()***REMOVED******REMOVED***;
   * use(app);
   *
   * // register plugins
   * app.use(foo);
   * app.use(bar);
   * app.use(baz);
   * ```
   * @name .use
   * @param ***REMOVED***Function***REMOVED*** `fn` plugin function to call
   * @api public
   */

  utils.define(app, 'use', use);

  /**
   * Run all plugins on `fns`. Any plugin that returns a function
   * when called by `use` is pushed onto the `fns` array.
   *
   * ```js
   * var config = ***REMOVED******REMOVED***;
   * app.run(config);
   * ```
   * @name .run
   * @param ***REMOVED***Object***REMOVED*** `value` Object to be modified by plugins.
   * @return ***REMOVED***Object***REMOVED*** Returns the object passed to `run`
   * @api public
   */

  utils.define(app, 'run', function(val) ***REMOVED***
    if (!utils.isObject(val)) return;
    decorate(val);

    var self = this || app;
    var fns = self[prop];
    var len = fns.length;
    var idx = -1;

    while (++idx < len) ***REMOVED***
      val.use(fns[idx]);
    ***REMOVED***
    return val;
  ***REMOVED***);

  /**
   * Call plugin `fn`. If a function is returned push it into the
   * `fns` array to be called by the `run` method.
   */

  function use(fn, options) ***REMOVED***
    if (typeof fn !== 'function') ***REMOVED***
      throw new TypeError('.use expects `fn` be a function');
    ***REMOVED***

    var self = this || app;
    if (typeof opts.fn === 'function') ***REMOVED***
      opts.fn.call(self, self, options);
    ***REMOVED***

    var plugin = fn.call(self, self);
    if (typeof plugin === 'function') ***REMOVED***
      var fns = self[prop];
      fns.push(plugin);
    ***REMOVED***
    return self;
  ***REMOVED***

  /**
   * Ensure the `.use` method exists on `val`
   */

  function decorate(val) ***REMOVED***
    if (!val.use || !val.run) ***REMOVED***
      base(val);
    ***REMOVED***
  ***REMOVED***

  return app;
***REMOVED***;
