/*?
 // --- Scope -----------------
 // Lang : Language expressions
*/
/**
 * Constructs a new Tokenizer.
 * @exports ProtoBuf.DotProto.Tokenizer
 * @class prototype tokenizer
 * @param ***REMOVED***string***REMOVED*** proto Proto to tokenize
 * @constructor
 */
var Tokenizer = function(proto) ***REMOVED***

    /**
     * Source to parse.
     * @type ***REMOVED***string***REMOVED***
     * @expose
     */
    this.source = proto+"";

    /**
     * Current index.
     * @type ***REMOVED***number***REMOVED***
     * @expose
     */
    this.index = 0;

    /**
     * Current line.
     * @type ***REMOVED***number***REMOVED***
     * @expose
     */
    this.line = 1;

    /**
     * Token stack.
     * @type ***REMOVED***!Array.<string>***REMOVED***
     * @expose
     */
    this.stack = [];

    /**
     * Opening character of the current string read, if any.
     * @type ***REMOVED***?string***REMOVED***
     * @private
     */
    this._stringOpen = null;
***REMOVED***;

/**
 * @alias ProtoBuf.DotProto.Tokenizer.prototype
 * @inner
 */
var TokenizerPrototype = Tokenizer.prototype;

/**
 * Reads a string beginning at the current index.
 * @return ***REMOVED***string***REMOVED***
 * @private
 */
TokenizerPrototype._readString = function() ***REMOVED***
    var re = this._stringOpen === '"'
        ? Lang.STRING_DQ
        : Lang.STRING_SQ;
    re.lastIndex = this.index - 1; // Include the open quote
    var match = re.exec(this.source);
    if (!match)
        throw Error("unterminated string");
    this.index = re.lastIndex;
    this.stack.push(this._stringOpen);
    this._stringOpen = null;
    return match[1];
***REMOVED***;

/**
 * Gets the next token and advances by one.
 * @return ***REMOVED***?string***REMOVED*** Token or `null` on EOF
 * @expose
 */
TokenizerPrototype.next = function() ***REMOVED***
    if (this.stack.length > 0)
        return this.stack.shift();
    if (this.index >= this.source.length)
        return null;
    if (this._stringOpen !== null)
        return this._readString();

    var repeat,
        prev,
        next;
    do ***REMOVED***
        repeat = false;

        // Strip white spaces
        while (Lang.WHITESPACE.test(next = this.source.charAt(this.index))) ***REMOVED***
            if (next === '\n')
                ++this.line;
            if (++this.index === this.source.length)
                return null;
        ***REMOVED***

        // Strip comments
        if (this.source.charAt(this.index) === '/') ***REMOVED***
            ++this.index;
            if (this.source.charAt(this.index) === '/') ***REMOVED*** // Line
                while (this.source.charAt(++this.index) !== '\n')
                    if (this.index == this.source.length)
                        return null;
                ++this.index;
                ++this.line;
                repeat = true;
            ***REMOVED*** else if ((next = this.source.charAt(this.index)) === '*') ***REMOVED*** /* Block */
                do ***REMOVED***
                    if (next === '\n')
                        ++this.line;
                    if (++this.index === this.source.length)
                        return null;
                    prev = next;
                    next = this.source.charAt(this.index);
                ***REMOVED*** while (prev !== '*' || next !== '/');
                ++this.index;
                repeat = true;
            ***REMOVED*** else
                return '/';
        ***REMOVED***
    ***REMOVED*** while (repeat);

    if (this.index === this.source.length)
        return null;

    // Read the next token
    var end = this.index;
    Lang.DELIM.lastIndex = 0;
    var delim = Lang.DELIM.test(this.source.charAt(end++));
    if (!delim)
        while(end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))
            ++end;
    var token = this.source.substring(this.index, this.index = end);
    if (token === '"' || token === "'")
        this._stringOpen = token;
    return token;
***REMOVED***;

/**
 * Peeks for the next token.
 * @return ***REMOVED***?string***REMOVED*** Token or `null` on EOF
 * @expose
 */
TokenizerPrototype.peek = function() ***REMOVED***
    if (this.stack.length === 0) ***REMOVED***
        var token = this.next();
        if (token === null)
            return null;
        this.stack.push(token);
    ***REMOVED***
    return this.stack[0];
***REMOVED***;

/**
 * Skips a specific token and throws if it differs.
 * @param ***REMOVED***string***REMOVED*** expected Expected token
 * @throws ***REMOVED***Error***REMOVED*** If the actual token differs
 */
TokenizerPrototype.skip = function(expected) ***REMOVED***
    var actual = this.next();
    if (actual !== expected)
        throw Error("illegal '"+actual+"', '"+expected+"' expected");
***REMOVED***;

/**
 * Omits an optional token.
 * @param ***REMOVED***string***REMOVED*** expected Expected optional token
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token exists
 */
TokenizerPrototype.omit = function(expected) ***REMOVED***
    if (this.peek() === expected) ***REMOVED***
        this.next();
        return true;
    ***REMOVED***
    return false;
***REMOVED***;

/**
 * Returns a string representation of this object.
 * @return ***REMOVED***string***REMOVED*** String representation as of "Tokenizer(index/length)"
 * @expose
 */
TokenizerPrototype.toString = function() ***REMOVED***
    return "Tokenizer ("+this.index+"/"+this.source.length+" at line "+this.line+")";
***REMOVED***;
