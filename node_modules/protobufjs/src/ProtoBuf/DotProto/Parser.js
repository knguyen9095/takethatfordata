/*?
 // --- Scope ----------------------
 // Lang      : Language expressions
 // Tokenizer : DotProto Tokenizer
 */
/**
 * Constructs a new Parser.
 * @exports ProtoBuf.DotProto.Parser
 * @class prototype parser
 * @param ***REMOVED***string***REMOVED*** source Source
 * @constructor
 */
var Parser = function(source) ***REMOVED***

    /**
     * Tokenizer.
     * @type ***REMOVED***!ProtoBuf.DotProto.Tokenizer***REMOVED***
     * @expose
     */
    this.tn = new Tokenizer(source);

    /**
     * Whether parsing proto3 or not.
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.proto3 = false;
***REMOVED***;

/**
 * @alias ProtoBuf.DotProto.Parser.prototype
 * @inner
 */
var ParserPrototype = Parser.prototype;

/**
 * Parses the source.
 * @returns ***REMOVED***!Object***REMOVED***
 * @throws ***REMOVED***Error***REMOVED*** If the source cannot be parsed
 * @expose
 */
ParserPrototype.parse = function() ***REMOVED***
    var topLevel = ***REMOVED***
        "name": "[ROOT]", // temporary
        "package": null,
        "messages": [],
        "enums": [],
        "imports": [],
        "options": ***REMOVED******REMOVED***,
        "services": []
        // "syntax": undefined
    ***REMOVED***;
    var token,
        head = true,
        weak;
    try ***REMOVED***
        while (token = this.tn.next()) ***REMOVED***
            switch (token) ***REMOVED***
                case 'package':
                    if (!head || topLevel["package"] !== null)
                        throw Error("unexpected 'package'");
                    token = this.tn.next();
                    if (!Lang.TYPEREF.test(token))
                        throw Error("illegal package name: " + token);
                    this.tn.skip(";");
                    topLevel["package"] = token;
                    break;
                case 'import':
                    if (!head)
                        throw Error("unexpected 'import'");
                    token = this.tn.peek();
                    if (token === "public" || (weak = token === "weak")) // token ignored
                        this.tn.next();
                    token = this._readString();
                    this.tn.skip(";");
                    if (!weak) // import ignored
                        topLevel["imports"].push(token);
                    break;
                case 'syntax':
                    if (!head)
                        throw Error("unexpected 'syntax'");
                    this.tn.skip("=");
                    if ((topLevel["syntax"] = this._readString()) === "proto3")
                        this.proto3 = true;
                    this.tn.skip(";");
                    break;
                case 'message':
                    this._parseMessage(topLevel, null);
                    head = false;
                    break;
                case 'enum':
                    this._parseEnum(topLevel);
                    head = false;
                    break;
                case 'option':
                    this._parseOption(topLevel);
                    break;
                case 'service':
                    this._parseService(topLevel);
                    break;
                case 'extend':
                    this._parseExtend(topLevel);
                    break;
                default:
                    throw Error("unexpected '" + token + "'");
            ***REMOVED***
        ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***
        e.message = "Parse error at line "+this.tn.line+": " + e.message;
        throw e;
    ***REMOVED***
    delete topLevel["name"];
    return topLevel;
***REMOVED***;

/**
 * Parses the specified source.
 * @returns ***REMOVED***!Object***REMOVED***
 * @throws ***REMOVED***Error***REMOVED*** If the source cannot be parsed
 * @expose
 */
Parser.parse = function(source) ***REMOVED***
    return new Parser(source).parse();
***REMOVED***;

// ----- Conversion ------

/**
 * Converts a numerical string to an id.
 * @param ***REMOVED***string***REMOVED*** value
 * @param ***REMOVED***boolean=***REMOVED*** mayBeNegative
 * @returns ***REMOVED***number***REMOVED***
 * @inner
 */
function mkId(value, mayBeNegative) ***REMOVED***
    var id = -1,
        sign = 1;
    if (value.charAt(0) == '-') ***REMOVED***
        sign = -1;
        value = value.substring(1);
    ***REMOVED***
    if (Lang.NUMBER_DEC.test(value))
        id = parseInt(value);
    else if (Lang.NUMBER_HEX.test(value))
        id = parseInt(value.substring(2), 16);
    else if (Lang.NUMBER_OCT.test(value))
        id = parseInt(value.substring(1), 8);
    else
        throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
    id = (sign*id)|0; // Force to 32bit
    if (!mayBeNegative && id < 0)
        throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
    return id;
***REMOVED***

/**
 * Converts a numerical string to a number.
 * @param ***REMOVED***string***REMOVED*** val
 * @returns ***REMOVED***number***REMOVED***
 * @inner
 */
function mkNumber(val) ***REMOVED***
    var sign = 1;
    if (val.charAt(0) == '-') ***REMOVED***
        sign = -1;
        val = val.substring(1);
    ***REMOVED***
    if (Lang.NUMBER_DEC.test(val))
        return sign * parseInt(val, 10);
    else if (Lang.NUMBER_HEX.test(val))
        return sign * parseInt(val.substring(2), 16);
    else if (Lang.NUMBER_OCT.test(val))
        return sign * parseInt(val.substring(1), 8);
    else if (val === 'inf')
        return sign * Infinity;
    else if (val === 'nan')
        return NaN;
    else if (Lang.NUMBER_FLT.test(val))
        return sign * parseFloat(val);
    throw Error("illegal number value: " + (sign < 0 ? '-' : '') + val);
***REMOVED***

// ----- Reading ------

/**
 * Reads a string.
 * @returns ***REMOVED***string***REMOVED***
 * @private
 */
ParserPrototype._readString = function() ***REMOVED***
    var value = "",
        token,
        delim;
    do ***REMOVED***
        delim = this.tn.next();
        if (delim !== "'" && delim !== '"')
            throw Error("illegal string delimiter: "+delim);
        value += this.tn.next();
        this.tn.skip(delim);
        token = this.tn.peek();
    ***REMOVED*** while (token === '"' || token === '"'); // multi line?
    return value;
***REMOVED***;

/**
 * Reads a value.
 * @param ***REMOVED***boolean=***REMOVED*** mayBeTypeRef
 * @returns ***REMOVED***number|boolean|string***REMOVED***
 * @private
 */
ParserPrototype._readValue = function(mayBeTypeRef) ***REMOVED***
    var token = this.tn.peek(),
        value;
    if (token === '"' || token === "'")
        return this._readString();
    this.tn.next();
    if (Lang.NUMBER.test(token))
        return mkNumber(token);
    if (Lang.BOOL.test(token))
        return (token.toLowerCase() === 'true');
    if (mayBeTypeRef && Lang.TYPEREF.test(token))
        return token;
    throw Error("illegal value: "+token);

***REMOVED***;

// ----- Parsing constructs -----

/**
 * Parses a namespace option.
 * @param ***REMOVED***!Object***REMOVED*** parent Parent definition
 * @param ***REMOVED***boolean=***REMOVED*** isList
 * @private
 */
ParserPrototype._parseOption = function(parent, isList) ***REMOVED***
    var token = this.tn.next(),
        custom = false;
    if (token === '(') ***REMOVED***
        custom = true;
        token = this.tn.next();
    ***REMOVED***
    if (!Lang.TYPEREF.test(token))
        // we can allow options of the form google.protobuf.* since they will just get ignored anyways
        // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?
            throw Error("illegal option name: "+token);
    var name = token;
    if (custom) ***REMOVED*** // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
        this.tn.skip(')');
        name = '('+name+')';
        token = this.tn.peek();
        if (Lang.FQTYPEREF.test(token)) ***REMOVED***
            name += token;
            this.tn.next();
        ***REMOVED***
    ***REMOVED***
    this.tn.skip('=');
    this._parseOptionValue(parent, name);
    if (!isList)
        this.tn.skip(";");
***REMOVED***;

/**
 * Sets an option on the specified options object.
 * @param ***REMOVED***!Object.<string,*>***REMOVED*** options
 * @param ***REMOVED***string***REMOVED*** name
 * @param ***REMOVED***string|number|boolean***REMOVED*** value
 * @inner
 */
function setOption(options, name, value) ***REMOVED***
    if (typeof options[name] === 'undefined')
        options[name] = value;
    else ***REMOVED***
        if (!Array.isArray(options[name]))
            options[name] = [ options[name] ];
        options[name].push(value);
    ***REMOVED***
***REMOVED***

/**
 * Parses an option value.
 * @param ***REMOVED***!Object***REMOVED*** parent
 * @param ***REMOVED***string***REMOVED*** name
 * @private
 */
ParserPrototype._parseOptionValue = function(parent, name) ***REMOVED***
    var token = this.tn.peek();
    if (token !== '***REMOVED***') ***REMOVED*** // Plain value
        setOption(parent["options"], name, this._readValue(true));
    ***REMOVED*** else ***REMOVED*** // Aggregate options
        this.tn.skip("***REMOVED***");
        while ((token = this.tn.next()) !== '***REMOVED***') ***REMOVED***
            if (!Lang.NAME.test(token))
                throw Error("illegal option name: " + name + "." + token);
            if (this.tn.omit(":"))
                setOption(parent["options"], name + "." + token, this._readValue(true));
            else
                this._parseOptionValue(parent, name + "." + token);
        ***REMOVED***
    ***REMOVED***
***REMOVED***;

/**
 * Parses a service definition.
 * @param ***REMOVED***!Object***REMOVED*** parent Parent definition
 * @private
 */
ParserPrototype._parseService = function(parent) ***REMOVED***
    var token = this.tn.next();
    if (!Lang.NAME.test(token))
        throw Error("illegal service name at line "+this.tn.line+": "+token);
    var name = token;
    var svc = ***REMOVED***
        "name": name,
        "rpc": ***REMOVED******REMOVED***,
        "options": ***REMOVED******REMOVED***
    ***REMOVED***;
    this.tn.skip("***REMOVED***");
    while ((token = this.tn.next()) !== '***REMOVED***') ***REMOVED***
        if (token === "option")
            this._parseOption(svc);
        else if (token === 'rpc')
            this._parseServiceRPC(svc);
        else
            throw Error("illegal service token: "+token);
    ***REMOVED***
    this.tn.omit(";");
    parent["services"].push(svc);
***REMOVED***;

/**
 * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
 * @param ***REMOVED***!Object***REMOVED*** svc Service definition
 * @private
 */
ParserPrototype._parseServiceRPC = function(svc) ***REMOVED***
    var type = "rpc",
        token = this.tn.next();
    if (!Lang.NAME.test(token))
        throw Error("illegal rpc service method name: "+token);
    var name = token;
    var method = ***REMOVED***
        "request": null,
        "response": null,
        "request_stream": false,
        "response_stream": false,
        "options": ***REMOVED******REMOVED***
    ***REMOVED***;
    this.tn.skip("(");
    token = this.tn.next();
    if (token.toLowerCase() === "stream") ***REMOVED***
      method["request_stream"] = true;
      token = this.tn.next();
    ***REMOVED***
    if (!Lang.TYPEREF.test(token))
        throw Error("illegal rpc service request type: "+token);
    method["request"] = token;
    this.tn.skip(")");
    token = this.tn.next();
    if (token.toLowerCase() !== "returns")
        throw Error("illegal rpc service request type delimiter: "+token);
    this.tn.skip("(");
    token = this.tn.next();
    if (token.toLowerCase() === "stream") ***REMOVED***
      method["response_stream"] = true;
      token = this.tn.next();
    ***REMOVED***
    method["response"] = token;
    this.tn.skip(")");
    token = this.tn.peek();
    if (token === '***REMOVED***') ***REMOVED***
        this.tn.next();
        while ((token = this.tn.next()) !== '***REMOVED***') ***REMOVED***
            if (token === 'option')
                this._parseOption(method);
            else
                throw Error("illegal rpc service token: " + token);
        ***REMOVED***
        this.tn.omit(";");
    ***REMOVED*** else
        this.tn.skip(";");
    if (typeof svc[type] === 'undefined')
        svc[type] = ***REMOVED******REMOVED***;
    svc[type][name] = method;
***REMOVED***;

/**
 * Parses a message definition.
 * @param ***REMOVED***!Object***REMOVED*** parent Parent definition
 * @param ***REMOVED***!Object=***REMOVED*** fld Field definition if this is a group
 * @returns ***REMOVED***!Object***REMOVED***
 * @private
 */
ParserPrototype._parseMessage = function(parent, fld) ***REMOVED***
    var isGroup = !!fld,
        token = this.tn.next();
    var msg = ***REMOVED***
        "name": "",
        "fields": [],
        "enums": [],
        "messages": [],
        "options": ***REMOVED******REMOVED***,
        "services": [],
        "oneofs": ***REMOVED******REMOVED***
        // "extensions": undefined
    ***REMOVED***;
    if (!Lang.NAME.test(token))
        throw Error("illegal "+(isGroup ? "group" : "message")+" name: "+token);
    msg["name"] = token;
    if (isGroup) ***REMOVED***
        this.tn.skip("=");
        fld["id"] = mkId(this.tn.next());
        msg["isGroup"] = true;
    ***REMOVED***
    token = this.tn.peek();
    if (token === '[' && fld)
        this._parseFieldOptions(fld);
    this.tn.skip("***REMOVED***");
    while ((token = this.tn.next()) !== '***REMOVED***') ***REMOVED***
        if (Lang.RULE.test(token))
            this._parseMessageField(msg, token);
        else if (token === "oneof")
            this._parseMessageOneOf(msg);
        else if (token === "enum")
            this._parseEnum(msg);
        else if (token === "message")
            this._parseMessage(msg);
        else if (token === "option")
            this._parseOption(msg);
        else if (token === "service")
            this._parseService(msg);
        else if (token === "extensions")
            if (msg.hasOwnProperty("extensions")) ***REMOVED***
                msg["extensions"] = msg["extensions"].concat(this._parseExtensionRanges())
            ***REMOVED*** else ***REMOVED***
                msg["extensions"] = this._parseExtensionRanges();
            ***REMOVED***
        else if (token === "reserved")
            this._parseIgnored(); // TODO
        else if (token === "extend")
            this._parseExtend(msg);
        else if (Lang.TYPEREF.test(token)) ***REMOVED***
            if (!this.proto3)
                throw Error("illegal field rule: "+token);
            this._parseMessageField(msg, "optional", token);
        ***REMOVED*** else
            throw Error("illegal message token: "+token);
    ***REMOVED***
    this.tn.omit(";");
    parent["messages"].push(msg);
    return msg;
***REMOVED***;

/**
 * Parses an ignored statement.
 * @private
 */
ParserPrototype._parseIgnored = function() ***REMOVED***
    while (this.tn.peek() !== ';')
        this.tn.next();
    this.tn.skip(";");
***REMOVED***;

/**
 * Parses a message field.
 * @param ***REMOVED***!Object***REMOVED*** msg Message definition
 * @param ***REMOVED***string***REMOVED*** rule Field rule
 * @param ***REMOVED***string=***REMOVED*** type Field type if already known (never known for maps)
 * @returns ***REMOVED***!Object***REMOVED*** Field descriptor
 * @private
 */
ParserPrototype._parseMessageField = function(msg, rule, type) ***REMOVED***
    if (!Lang.RULE.test(rule))
        throw Error("illegal message field rule: "+rule);
    var fld = ***REMOVED***
        "rule": rule,
        "type": "",
        "name": "",
        "options": ***REMOVED******REMOVED***,
        "id": 0
    ***REMOVED***;
    var token;
    if (rule === "map") ***REMOVED***

        if (type)
            throw Error("illegal type: " + type);
        this.tn.skip('<');
        token = this.tn.next();
        if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
            throw Error("illegal message field type: " + token);
        fld["keytype"] = token;
        this.tn.skip(',');
        token = this.tn.next();
        if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
            throw Error("illegal message field: " + token);
        fld["type"] = token;
        this.tn.skip('>');
        token = this.tn.next();
        if (!Lang.NAME.test(token))
            throw Error("illegal message field name: " + token);
        fld["name"] = token;
        this.tn.skip("=");
        fld["id"] = mkId(this.tn.next());
        token = this.tn.peek();
        if (token === '[')
            this._parseFieldOptions(fld);
        this.tn.skip(";");

    ***REMOVED*** else ***REMOVED***

        type = typeof type !== 'undefined' ? type : this.tn.next();

        if (type === "group") ***REMOVED***

            // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
            // code, you can treat this message just as if it had a Result type field called result (the latter name is
            // converted to lower-case so that it does not conflict with the former)."
            var grp = this._parseMessage(msg, fld);
            if (!/^[A-Z]/.test(grp["name"]))
                throw Error('illegal group name: '+grp["name"]);
            fld["type"] = grp["name"];
            fld["name"] = grp["name"].toLowerCase();
            this.tn.omit(";");

        ***REMOVED*** else ***REMOVED***

            if (!Lang.TYPE.test(type) && !Lang.TYPEREF.test(type))
                throw Error("illegal message field type: " + type);
            fld["type"] = type;
            token = this.tn.next();
            if (!Lang.NAME.test(token))
                throw Error("illegal message field name: " + token);
            fld["name"] = token;
            this.tn.skip("=");
            fld["id"] = mkId(this.tn.next());
            token = this.tn.peek();
            if (token === "[")
                this._parseFieldOptions(fld);
            this.tn.skip(";");

        ***REMOVED***
    ***REMOVED***
    msg["fields"].push(fld);
    return fld;
***REMOVED***;

/**
 * Parses a message oneof.
 * @param ***REMOVED***!Object***REMOVED*** msg Message definition
 * @private
 */
ParserPrototype._parseMessageOneOf = function(msg) ***REMOVED***
    var token = this.tn.next();
    if (!Lang.NAME.test(token))
        throw Error("illegal oneof name: "+token);
    var name = token,
        fld;
    var fields = [];
    this.tn.skip("***REMOVED***");
    while ((token = this.tn.next()) !== "***REMOVED***") ***REMOVED***
        fld = this._parseMessageField(msg, "optional", token);
        fld["oneof"] = name;
        fields.push(fld["id"]);
    ***REMOVED***
    this.tn.omit(";");
    msg["oneofs"][name] = fields;
***REMOVED***;

/**
 * Parses a set of field option definitions.
 * @param ***REMOVED***!Object***REMOVED*** fld Field definition
 * @private
 */
ParserPrototype._parseFieldOptions = function(fld) ***REMOVED***
    this.tn.skip("[");
    var token,
        first = true;
    while ((token = this.tn.peek()) !== ']') ***REMOVED***
        if (!first)
            this.tn.skip(",");
        this._parseOption(fld, true);
        first = false;
    ***REMOVED***
    this.tn.next();
***REMOVED***;

/**
 * Parses an enum.
 * @param ***REMOVED***!Object***REMOVED*** msg Message definition
 * @private
 */
ParserPrototype._parseEnum = function(msg) ***REMOVED***
    var enm = ***REMOVED***
        "name": "",
        "values": [],
        "options": ***REMOVED******REMOVED***
    ***REMOVED***;
    var token = this.tn.next();
    if (!Lang.NAME.test(token))
        throw Error("illegal name: "+token);
    enm["name"] = token;
    this.tn.skip("***REMOVED***");
    while ((token = this.tn.next()) !== '***REMOVED***') ***REMOVED***
        if (token === "option")
            this._parseOption(enm);
        else ***REMOVED***
            if (!Lang.NAME.test(token))
                throw Error("illegal name: "+token);
            this.tn.skip("=");
            var val = ***REMOVED***
                "name": token,
                "id": mkId(this.tn.next(), true)
            ***REMOVED***;
            token = this.tn.peek();
            if (token === "[")
                this._parseFieldOptions(***REMOVED*** "options": ***REMOVED******REMOVED*** ***REMOVED***);
            this.tn.skip(";");
            enm["values"].push(val);
        ***REMOVED***
    ***REMOVED***
    this.tn.omit(";");
    msg["enums"].push(enm);
***REMOVED***;

/**
 * Parses extension / reserved ranges.
 * @returns ***REMOVED***!Array.<!Array.<number>>***REMOVED***
 * @private
 */
ParserPrototype._parseExtensionRanges = function() ***REMOVED***
    var ranges = [];
    var token,
        range,
        value;
    do ***REMOVED***
        range = [];
        while (true) ***REMOVED***
            token = this.tn.next();
            switch (token) ***REMOVED***
                case "min":
                    value = ProtoBuf.ID_MIN;
                    break;
                case "max":
                    value = ProtoBuf.ID_MAX;
                    break;
                default:
                    value = mkNumber(token);
                    break;
            ***REMOVED***
            range.push(value);
            if (range.length === 2)
                break;
            if (this.tn.peek() !== "to") ***REMOVED***
                range.push(value);
                break;
            ***REMOVED***
            this.tn.next();
        ***REMOVED***
        ranges.push(range);
    ***REMOVED*** while (this.tn.omit(","));
    this.tn.skip(";");
    return ranges;
***REMOVED***;

/**
 * Parses an extend block.
 * @param ***REMOVED***!Object***REMOVED*** parent Parent object
 * @private
 */
ParserPrototype._parseExtend = function(parent) ***REMOVED***
    var token = this.tn.next();
    if (!Lang.TYPEREF.test(token))
        throw Error("illegal extend reference: "+token);
    var ext = ***REMOVED***
        "ref": token,
        "fields": []
    ***REMOVED***;
    this.tn.skip("***REMOVED***");
    while ((token = this.tn.next()) !== '***REMOVED***') ***REMOVED***
        if (Lang.RULE.test(token))
            this._parseMessageField(ext, token);
        else if (Lang.TYPEREF.test(token)) ***REMOVED***
            if (!this.proto3)
                throw Error("illegal field rule: "+token);
            this._parseMessageField(ext, "optional", token);
        ***REMOVED*** else
            throw Error("illegal extend token: "+token);
    ***REMOVED***
    this.tn.omit(";");
    parent["messages"].push(ext);
    return ext;
***REMOVED***;

// ----- General -----

/**
 * Returns a string representation of this parser.
 * @returns ***REMOVED***string***REMOVED***
 */
ParserPrototype.toString = function() ***REMOVED***
    return "Parser at line "+this.tn.line;
***REMOVED***;
