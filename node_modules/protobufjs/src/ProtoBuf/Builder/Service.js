/*?
 // --- Scope ------------------
 // T : Reflect.Service instance
 */
/**
 * Constructs a new runtime Service.
 * @name ProtoBuf.Builder.Service
 * @param ***REMOVED***function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=***REMOVED*** rpcImpl RPC implementation receiving the method name and the message
 * @class Barebone of all runtime services.
 * @constructor
 * @throws ***REMOVED***Error***REMOVED*** If the service cannot be created
 */
var Service = function(rpcImpl) ***REMOVED***
    ProtoBuf.Builder.Service.call(this);

    /**
     * Service implementation.
     * @name ProtoBuf.Builder.Service#rpcImpl
     * @type ***REMOVED***!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))***REMOVED***
     * @expose
     */
    this.rpcImpl = rpcImpl || function(name, msg, callback) ***REMOVED***
        // This is what a user has to implement: A function receiving the method name, the actual message to
        // send (type checked) and the callback that's either provided with the error as its first
        // argument or null and the actual response message.
        setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
    ***REMOVED***;
***REMOVED***;

/**
 * @alias ProtoBuf.Builder.Service.prototype
 * @inner
 */
var ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);

/**
 * Asynchronously performs an RPC call using the given RPC implementation.
 * @name ProtoBuf.Builder.Service.[Method]
 * @function
 * @param ***REMOVED***!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))***REMOVED*** rpcImpl RPC implementation
 * @param ***REMOVED***ProtoBuf.Builder.Message***REMOVED*** req Request
 * @param ***REMOVED***function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)***REMOVED*** callback Callback receiving
 *  the error if any and the response either as a pre-parsed message or as its raw bytes
 * @abstract
 */

/**
 * Asynchronously performs an RPC call using the instance's RPC implementation.
 * @name ProtoBuf.Builder.Service#[Method]
 * @function
 * @param ***REMOVED***ProtoBuf.Builder.Message***REMOVED*** req Request
 * @param ***REMOVED***function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)***REMOVED*** callback Callback receiving
 *  the error if any and the response either as a pre-parsed message or as its raw bytes
 * @abstract
 */

var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
for (var i=0; i<rpc.length; i++) ***REMOVED***
    (function(method) ***REMOVED***

        // service#Method(message, callback)
        ServicePrototype[method.name] = function(req, callback) ***REMOVED***
            try ***REMOVED***
                try ***REMOVED***
                    // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
                    req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));
                ***REMOVED*** catch (err) ***REMOVED***
                    if (!(err instanceof TypeError))
                        throw err;
                ***REMOVED***
                if (req === null || typeof req !== 'object')
                    throw Error("Illegal arguments");
                if (!(req instanceof method.resolvedRequestType.clazz))
                    req = new method.resolvedRequestType.clazz(req);
                this.rpcImpl(method.fqn(), req, function(err, res) ***REMOVED*** // Assumes that this is properly async
                    if (err) ***REMOVED***
                        callback(err);
                        return;
                    ***REMOVED***
                    // Coalesce to empty string when service response has empty content
                    if (res === null)
                        res = ''
                    try ***REMOVED*** res = method.resolvedResponseType.clazz.decode(res); ***REMOVED*** catch (notABuffer) ***REMOVED******REMOVED***
                    if (!res || !(res instanceof method.resolvedResponseType.clazz)) ***REMOVED***
                        callback(Error("Illegal response type received in service method "+ T.name+"#"+method.name));
                        return;
                    ***REMOVED***
                    callback(null, res);
                ***REMOVED***);
            ***REMOVED*** catch (err) ***REMOVED***
                setTimeout(callback.bind(this, err), 0);
            ***REMOVED***
        ***REMOVED***;

        // Service.Method(rpcImpl, message, callback)
        Service[method.name] = function(rpcImpl, req, callback) ***REMOVED***
            new Service(rpcImpl)[method.name](req, callback);
        ***REMOVED***;

        if (Object.defineProperty)
            Object.defineProperty(Service[method.name], "$options", ***REMOVED*** "value": method.buildOpt() ***REMOVED***),
            Object.defineProperty(ServicePrototype[method.name], "$options", ***REMOVED*** "value": Service[method.name]["$options"] ***REMOVED***);
    ***REMOVED***)(rpc[i]);
***REMOVED***

// Properties

/**
 * Service options.
 * @name ProtoBuf.Builder.Service.$options
 * @type ***REMOVED***Object.<string,*>***REMOVED***
 * @expose
 */
var $optionsS; // cc needs this

/**
 * Service options.
 * @name ProtoBuf.Builder.Service#$options
 * @type ***REMOVED***Object.<string,*>***REMOVED***
 * @expose
 */
var $options;

/**
 * Reflection type.
 * @name ProtoBuf.Builder.Service.$type
 * @type ***REMOVED***!ProtoBuf.Reflect.Service***REMOVED***
 * @expose
 */
var $typeS;

/**
 * Reflection type.
 * @name ProtoBuf.Builder.Service#$type
 * @type ***REMOVED***!ProtoBuf.Reflect.Service***REMOVED***
 * @expose
 */
var $type;

if (Object.defineProperty)
    Object.defineProperty(Service, "$options", ***REMOVED*** "value": T.buildOpt() ***REMOVED***),
    Object.defineProperty(ServicePrototype, "$options", ***REMOVED*** "value": Service["$options"] ***REMOVED***),
    Object.defineProperty(Service, "$type", ***REMOVED*** "value": T ***REMOVED***),
    Object.defineProperty(ServicePrototype, "$type", ***REMOVED*** "value": T ***REMOVED***);
