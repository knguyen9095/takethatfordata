/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const base64VLQ = require("./base64-vlq");
const getNumberOfLines = require("./helpers").getNumberOfLines;
const getUnfinishedLine = require("./helpers").getUnfinishedLine;

const LINE_MAPPING = ";AACA";

class SourceNode ***REMOVED***

	constructor(generatedCode, source, originalSource, startingLine) ***REMOVED***
		this.generatedCode = generatedCode;
		this.originalSource = originalSource;
		this.source = source;
		this.startingLine = startingLine || 1;
		this._numberOfLines = getNumberOfLines(this.generatedCode);
		this._endsWithNewLine = generatedCode[generatedCode.length - 1] === "\n";
	***REMOVED***

	clone() ***REMOVED***
		return new SourceNode(this.generatedCode, this.source, this.originalSource, this.startingLine);
	***REMOVED***

	getGeneratedCode() ***REMOVED***
		return this.generatedCode;
	***REMOVED***

	addGeneratedCode(code) ***REMOVED***
		this.generatedCode += code;
		this._numberOfLines += getNumberOfLines(code);
		this._endsWithNewLine = code[code.length - 1] === "\n";
	***REMOVED***

	getMappings(mappingsContext) ***REMOVED***
		if(!this.generatedCode)
			return "";
		const lines = this._numberOfLines;
		const sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);
		let mappings = "A"; // generated column 0
		if(mappingsContext.unfinishedGeneratedLine)
			mappings = "," + base64VLQ.encode(mappingsContext.unfinishedGeneratedLine);
		mappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index
		mappings += base64VLQ.encode(this.startingLine - mappingsContext.currentOriginalLine); // original line index
		mappings += "A"; // original column 0
		mappingsContext.currentSource = sourceIdx;
		mappingsContext.currentOriginalLine = this.startingLine + lines - 1;
		const unfinishedGeneratedLine = mappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode)
		mappings += Array(lines).join(LINE_MAPPING);
		if(unfinishedGeneratedLine === 0) ***REMOVED***
			mappings += ";";
		***REMOVED*** else ***REMOVED***
			if(lines !== 0) ***REMOVED***
				mappings += LINE_MAPPING;
			***REMOVED***
			mappingsContext.currentOriginalLine++;
		***REMOVED***
		return mappings;
	***REMOVED***

	mapGeneratedCode(fn) ***REMOVED***
		throw new Error("Cannot map generated code on a SourceMap. Normalize to SingleLineNode first.");
	***REMOVED***

	getNormalizedNodes() ***REMOVED***
		var results = [];
		var currentLine = this.startingLine;
		var generatedCode = this.generatedCode;
		var index = 0;
		var indexEnd = generatedCode.length;
		while(index < indexEnd) ***REMOVED***
			// get one generated line
			var nextLine = generatedCode.indexOf("\n", index) + 1;
			if(nextLine === 0) nextLine = indexEnd;
			var lineGenerated = generatedCode.substr(index, nextLine - index);

			results.push(new SingleLineNode(lineGenerated, this.source, this.originalSource, currentLine));

			// move cursors
			index = nextLine;
			currentLine++;
		***REMOVED***
		return results;
	***REMOVED***

	merge(otherNode) ***REMOVED***
		if(otherNode instanceof SourceNode) ***REMOVED***
			return this.mergeSourceNode(otherNode);
		***REMOVED*** else if(otherNode instanceof SingleLineNode) ***REMOVED***
			return this.mergeSingleLineNode(otherNode);
		***REMOVED***
		return false;
	***REMOVED***

	mergeSourceNode(otherNode) ***REMOVED***
		if(this.source === otherNode.source &&
			this._endsWithNewLine &&
			this.startingLine + this._numberOfLines === otherNode.startingLine) ***REMOVED***
			this.generatedCode += otherNode.generatedCode;
			this._numberOfLines += otherNode._numberOfLines;
			this._endsWithNewLine = otherNode._endsWithNewLine;
			return this;
		***REMOVED***
		return false;
	***REMOVED***

	mergeSingleLineNode(otherNode) ***REMOVED***
		if(this.source === otherNode.source &&
			this._endsWithNewLine &&
			this.startingLine + this._numberOfLines === otherNode.line &&
			otherNode._numberOfLines <= 1) ***REMOVED***
			this.addSingleLineNode(otherNode);
			return this;
		***REMOVED***
		return false;
	***REMOVED***

	addSingleLineNode(otherNode) ***REMOVED***
		this.generatedCode += otherNode.generatedCode;
		this._numberOfLines += otherNode._numberOfLines
		this._endsWithNewLine = otherNode._endsWithNewLine;
	***REMOVED***
***REMOVED***

module.exports = SourceNode;
const SingleLineNode = require("./SingleLineNode"); // circular dependency
