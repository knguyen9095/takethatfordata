/**
 * A javascript implementation of a cryptographically-secure
 * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
 * here though the use of SHA-256 is not enforced; when generating an
 * a PRNG context, the hashing algorithm and block cipher used for
 * the generator are specified via a plugin.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./util');

var _crypto = null;
if(forge.util.isNodejs && !forge.options.usePureJavaScript &&
  !process.versions['node-webkit']) ***REMOVED***
  _crypto = require('crypto');
***REMOVED***

/* PRNG API */
var prng = module.exports = forge.prng = forge.prng || ***REMOVED******REMOVED***;

/**
 * Creates a new PRNG context.
 *
 * A PRNG plugin must be passed in that will provide:
 *
 * 1. A function that initializes the key and seed of a PRNG context. It
 *   will be given a 16 byte key and a 16 byte seed. Any key expansion
 *   or transformation of the seed from a byte string into an array of
 *   integers (or similar) should be performed.
 * 2. The cryptographic function used by the generator. It takes a key and
 *   a seed.
 * 3. A seed increment function. It takes the seed and returns seed + 1.
 * 4. An api to create a message digest.
 *
 * For an example, see random.js.
 *
 * @param plugin the PRNG plugin to use.
 */
prng.create = function(plugin) ***REMOVED***
  var ctx = ***REMOVED***
    plugin: plugin,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0
  ***REMOVED***;

  // create 32 entropy pools (each is a message digest)
  var md = plugin.md;
  var pools = new Array(32);
  for(var i = 0; i < 32; ++i) ***REMOVED***
    pools[i] = md.create();
  ***REMOVED***
  ctx.pools = pools;

  // entropy pools are written to cyclically, starting at index 0
  ctx.pool = 0;

  /**
   * Generates random bytes. The bytes may be generated synchronously or
   * asynchronously. Web workers must use the asynchronous interface or
   * else the behavior is undefined.
   *
   * @param count the number of random bytes to generate.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */
  ctx.generate = function(count, callback) ***REMOVED***
    // do synchronously
    if(!callback) ***REMOVED***
      return ctx.generateSync(count);
    ***REMOVED***

    // simple generator using counter-based CBC
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b = forge.util.createBuffer();

    // reset key for every request
    ctx.key = null;

    generate();

    function generate(err) ***REMOVED***
      if(err) ***REMOVED***
        return callback(err);
      ***REMOVED***

      // sufficient bytes generated
      if(b.length() >= count) ***REMOVED***
        return callback(null, b.getBytes(count));
      ***REMOVED***

      // if amount of data generated is greater than 1 MiB, trigger reseed
      if(ctx.generated > 0xfffff) ***REMOVED***
        ctx.key = null;
      ***REMOVED***

      if(ctx.key === null) ***REMOVED***
        // prevent stack overflow
        return forge.util.nextTick(function() ***REMOVED***
          _reseed(generate);
        ***REMOVED***);
      ***REMOVED***

      // generate the random bytes
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes);

      // generate bytes for a new key and seed
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));

      forge.util.setImmediate(generate);
    ***REMOVED***
  ***REMOVED***;

  /**
   * Generates random bytes synchronously.
   *
   * @param count the number of random bytes to generate.
   *
   * @return count random bytes as a string.
   */
  ctx.generateSync = function(count) ***REMOVED***
    // simple generator using counter-based CBC
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;

    // reset key for every request
    ctx.key = null;

    var b = forge.util.createBuffer();
    while(b.length() < count) ***REMOVED***
      // if amount of data generated is greater than 1 MiB, trigger reseed
      if(ctx.generated > 0xfffff) ***REMOVED***
        ctx.key = null;
      ***REMOVED***

      if(ctx.key === null) ***REMOVED***
        _reseedSync();
      ***REMOVED***

      // generate the random bytes
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes);

      // generate bytes for a new key and seed
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    ***REMOVED***

    return b.getBytes(count);
  ***REMOVED***;

  /**
   * Private function that asynchronously reseeds a generator.
   *
   * @param callback(err) called once the operation completes.
   */
  function _reseed(callback) ***REMOVED***
    if(ctx.pools[0].messageLength >= 32) ***REMOVED***
      _seed();
      return callback();
    ***REMOVED***
    // not enough seed data...
    var needed = (32 - ctx.pools[0].messageLength) << 5;
    ctx.seedFile(needed, function(err, bytes) ***REMOVED***
      if(err) ***REMOVED***
        return callback(err);
      ***REMOVED***
      ctx.collect(bytes);
      _seed();
      callback();
    ***REMOVED***);
  ***REMOVED***

  /**
   * Private function that synchronously reseeds a generator.
   */
  function _reseedSync() ***REMOVED***
    if(ctx.pools[0].messageLength >= 32) ***REMOVED***
      return _seed();
    ***REMOVED***
    // not enough seed data...
    var needed = (32 - ctx.pools[0].messageLength) << 5;
    ctx.collect(ctx.seedFileSync(needed));
    _seed();
  ***REMOVED***

  /**
   * Private function that seeds a generator once enough bytes are available.
   */
  function _seed() ***REMOVED***
    // create a plugin-based message digest
    var md = ctx.plugin.md.create();

    // digest pool 0's entropy and restart it
    md.update(ctx.pools[0].digest().getBytes());
    ctx.pools[0].start();

    // digest the entropy of other pools whose index k meet the
    // condition '2^k mod n == 0' where n is the number of reseeds
    var k = 1;
    for(var i = 1; i < 32; ++i) ***REMOVED***
      // prevent signed numbers from being used
      k = (k === 31) ? 0x80000000 : (k << 2);
      if(k % ctx.reseeds === 0) ***REMOVED***
        md.update(ctx.pools[i].digest().getBytes());
        ctx.pools[i].start();
      ***REMOVED***
    ***REMOVED***

    // get digest for key bytes and iterate again for seed bytes
    var keyBytes = md.digest().getBytes();
    md.start();
    md.update(keyBytes);
    var seedBytes = md.digest().getBytes();

    // update
    ctx.key = ctx.plugin.formatKey(keyBytes);
    ctx.seed = ctx.plugin.formatSeed(seedBytes);
    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;
    ctx.generated = 0;
  ***REMOVED***

  /**
   * The built-in default seedFile. This seedFile is used when entropy
   * is needed immediately.
   *
   * @param needed the number of bytes that are needed.
   *
   * @return the random bytes.
   */
  function defaultSeedFile(needed) ***REMOVED***
    // use window.crypto.getRandomValues strong source of entropy if available
    var getRandomValues = null;
    if(typeof window !== 'undefined') ***REMOVED***
      var _crypto = window.crypto || window.msCrypto;
      if(_crypto && _crypto.getRandomValues) ***REMOVED***
        getRandomValues = function(arr) ***REMOVED***
          return _crypto.getRandomValues(arr);
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***

    var b = forge.util.createBuffer();
    if(getRandomValues) ***REMOVED***
      while(b.length() < needed) ***REMOVED***
        // max byte length is 65536 before QuotaExceededError is thrown
        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues
        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
        var entropy = new Uint32Array(Math.floor(count));
        try ***REMOVED***
          getRandomValues(entropy);
          for(var i = 0; i < entropy.length; ++i) ***REMOVED***
            b.putInt32(entropy[i]);
          ***REMOVED***
        ***REMOVED*** catch(e) ***REMOVED***
          /* only ignore QuotaExceededError */
          if(!(typeof QuotaExceededError !== 'undefined' &&
            e instanceof QuotaExceededError)) ***REMOVED***
            throw e;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    // be sad and add some weak random data
    if(b.length() < needed) ***REMOVED***
      /* Draws from Park-Miller "minimal standard" 31 bit PRNG,
      implemented with David G. Carta's optimization: with 32 bit math
      and without division (Public Domain). */
      var hi, lo, next;
      var seed = Math.floor(Math.random() * 0x010000);
      while(b.length() < needed) ***REMOVED***
        lo = 16807 * (seed & 0xFFFF);
        hi = 16807 * (seed >> 16);
        lo += (hi & 0x7FFF) << 16;
        lo += hi >> 15;
        lo = (lo & 0x7FFFFFFF) + (lo >> 31);
        seed = lo & 0xFFFFFFFF;

        // consume lower 3 bytes of seed
        for(var i = 0; i < 3; ++i) ***REMOVED***
          // throw in more pseudo random
          next = seed >>> (i << 3);
          next ^= Math.floor(Math.random() * 0x0100);
          b.putByte(String.fromCharCode(next & 0xFF));
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    return b.getBytes(needed);
  ***REMOVED***
  // initialize seed file APIs
  if(_crypto) ***REMOVED***
    // use nodejs async API
    ctx.seedFile = function(needed, callback) ***REMOVED***
      _crypto.randomBytes(needed, function(err, bytes) ***REMOVED***
        if(err) ***REMOVED***
          return callback(err);
        ***REMOVED***
        callback(null, bytes.toString());
      ***REMOVED***);
    ***REMOVED***;
    // use nodejs sync API
    ctx.seedFileSync = function(needed) ***REMOVED***
      return _crypto.randomBytes(needed).toString();
    ***REMOVED***;
  ***REMOVED*** else ***REMOVED***
    ctx.seedFile = function(needed, callback) ***REMOVED***
      try ***REMOVED***
        callback(null, defaultSeedFile(needed));
      ***REMOVED*** catch(e) ***REMOVED***
        callback(e);
      ***REMOVED***
    ***REMOVED***;
    ctx.seedFileSync = defaultSeedFile;
  ***REMOVED***

  /**
   * Adds entropy to a prng ctx's accumulator.
   *
   * @param bytes the bytes of entropy as a string.
   */
  ctx.collect = function(bytes) ***REMOVED***
    // iterate over pools distributing entropy cyclically
    var count = bytes.length;
    for(var i = 0; i < count; ++i) ***REMOVED***
      ctx.pools[ctx.pool].update(bytes.substr(i, 1));
      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;
    ***REMOVED***
  ***REMOVED***;

  /**
   * Collects an integer of n bits.
   *
   * @param i the integer entropy.
   * @param n the number of bits in the integer.
   */
  ctx.collectInt = function(i, n) ***REMOVED***
    var bytes = '';
    for(var x = 0; x < n; x += 8) ***REMOVED***
      bytes += String.fromCharCode((i >> x) & 0xFF);
    ***REMOVED***
    ctx.collect(bytes);
  ***REMOVED***;

  /**
   * Registers a Web Worker to receive immediate entropy from the main thread.
   * This method is required until Web Workers can access the native crypto
   * API. This method should be called twice for each created worker, once in
   * the main thread, and once in the worker itself.
   *
   * @param worker the worker to register.
   */
  ctx.registerWorker = function(worker) ***REMOVED***
    // worker receives random bytes
    if(worker === self) ***REMOVED***
      ctx.seedFile = function(needed, callback) ***REMOVED***
        function listener(e) ***REMOVED***
          var data = e.data;
          if(data.forge && data.forge.prng) ***REMOVED***
            self.removeEventListener('message', listener);
            callback(data.forge.prng.err, data.forge.prng.bytes);
          ***REMOVED***
        ***REMOVED***
        self.addEventListener('message', listener);
        self.postMessage(***REMOVED***forge: ***REMOVED***prng: ***REMOVED***needed: needed***REMOVED******REMOVED******REMOVED***);
      ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
      // main thread sends random bytes upon request
      var listener = function(e) ***REMOVED***
        var data = e.data;
        if(data.forge && data.forge.prng) ***REMOVED***
          ctx.seedFile(data.forge.prng.needed, function(err, bytes) ***REMOVED***
            worker.postMessage(***REMOVED***forge: ***REMOVED***prng: ***REMOVED***err: err, bytes: bytes***REMOVED******REMOVED******REMOVED***);
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***;
      // TODO: do we need to remove the event listener when the worker dies?
      worker.addEventListener('message', listener);
    ***REMOVED***
  ***REMOVED***;

  return ctx;
***REMOVED***;
