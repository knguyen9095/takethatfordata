/*********************************************************************
 * NAN - Native Abstractions for Node.js
 *
 * Copyright (c) 2017 NAN contributors
 *
 * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>
 ********************************************************************/

#ifndef NAN_PERSISTENT_PRE_12_INL_H_
#define NAN_PERSISTENT_PRE_12_INL_H_

template<typename T>
class PersistentBase ***REMOVED***
  v8::Persistent<T> persistent;
  template<typename U>
  friend v8::Local<U> New(const PersistentBase<U> &p);
  template<typename U, typename M>
  friend v8::Local<U> New(const Persistent<U, M> &p);
  template<typename U>
  friend v8::Local<U> New(const Global<U> &p);
  template<typename S> friend class ReturnValue;

 public:
  inline PersistentBase() :
      persistent() ***REMOVED******REMOVED***

  inline void Reset() ***REMOVED***
    persistent.Dispose();
    persistent.Clear();
  ***REMOVED***

  template<typename S>
  inline void Reset(const v8::Local<S> &other) ***REMOVED***
    TYPE_CHECK(T, S);

    if (!persistent.IsEmpty()) ***REMOVED***
      persistent.Dispose();
    ***REMOVED***

    if (other.IsEmpty()) ***REMOVED***
      persistent.Clear();
    ***REMOVED*** else ***REMOVED***
      persistent = v8::Persistent<T>::New(other);
    ***REMOVED***
  ***REMOVED***

  template<typename S>
  inline void Reset(const PersistentBase<S> &other) ***REMOVED***
    TYPE_CHECK(T, S);

    if (!persistent.IsEmpty()) ***REMOVED***
      persistent.Dispose();
    ***REMOVED***

    if (other.IsEmpty()) ***REMOVED***
      persistent.Clear();
    ***REMOVED*** else ***REMOVED***
      persistent = v8::Persistent<T>::New(other.persistent);
    ***REMOVED***
  ***REMOVED***

  inline bool IsEmpty() const ***REMOVED*** return persistent.IsEmpty(); ***REMOVED***

  inline void Empty() ***REMOVED*** persistent.Clear(); ***REMOVED***

  template<typename S>
  inline bool operator==(const PersistentBase<S> &that) const ***REMOVED***
    return this->persistent == that.persistent;
  ***REMOVED***

  template<typename S>
  inline bool operator==(const v8::Local<S> &that) const ***REMOVED***
    return this->persistent == that;
  ***REMOVED***

  template<typename S>
  inline bool operator!=(const PersistentBase<S> &that) const ***REMOVED***
    return !operator==(that);
  ***REMOVED***

  template<typename S>
  inline bool operator!=(const v8::Local<S> &that) const ***REMOVED***
    return !operator==(that);
  ***REMOVED***

  template<typename P>
  inline void SetWeak(
    P *parameter
    , typename WeakCallbackInfo<P>::Callback callback
    , WeakCallbackType type);

  inline void ClearWeak() ***REMOVED*** persistent.ClearWeak(); ***REMOVED***

  inline void MarkIndependent() ***REMOVED*** persistent.MarkIndependent(); ***REMOVED***

  inline bool IsIndependent() const ***REMOVED*** return persistent.IsIndependent(); ***REMOVED***

  inline bool IsNearDeath() const ***REMOVED*** return persistent.IsNearDeath(); ***REMOVED***

  inline bool IsWeak() const ***REMOVED*** return persistent.IsWeak(); ***REMOVED***

 private:
  inline explicit PersistentBase(v8::Persistent<T> that) :
      persistent(that) ***REMOVED*** ***REMOVED***
  inline explicit PersistentBase(T *val) : persistent(val) ***REMOVED******REMOVED***
  template<typename S, typename M> friend class Persistent;
  template<typename S> friend class Global;
  friend class ObjectWrap;
***REMOVED***;

template<typename T>
class NonCopyablePersistentTraits ***REMOVED***
 public:
  typedef Persistent<T, NonCopyablePersistentTraits<T> >
      NonCopyablePersistent;
  static const bool kResetInDestructor = false;
  template<typename S, typename M>
  inline static void Copy(const Persistent<S, M> &source,
                             NonCopyablePersistent *dest) ***REMOVED***
    Uncompilable<v8::Object>();
  ***REMOVED***

  template<typename O> inline static void Uncompilable() ***REMOVED***
    TYPE_CHECK(O, v8::Primitive);
  ***REMOVED***
***REMOVED***;

template<typename T>
struct CopyablePersistentTraits ***REMOVED***
  typedef Persistent<T, CopyablePersistentTraits<T> > CopyablePersistent;
  static const bool kResetInDestructor = true;
  template<typename S, typename M>
  static inline void Copy(const Persistent<S, M> &source,
                             CopyablePersistent *dest) ***REMOVED******REMOVED***
***REMOVED***;

template<typename T, typename M> class Persistent :
    public PersistentBase<T> ***REMOVED***
 public:
  inline Persistent() ***REMOVED******REMOVED***

  template<typename S> inline Persistent(v8::Handle<S> that)
      : PersistentBase<T>(v8::Persistent<T>::New(that)) ***REMOVED***
    TYPE_CHECK(T, S);
  ***REMOVED***

  inline Persistent(const Persistent &that) : PersistentBase<T>() ***REMOVED***
    Copy(that);
  ***REMOVED***

  template<typename S, typename M2>
  inline Persistent(const Persistent<S, M2> &that) :
      PersistentBase<T>() ***REMOVED***
    Copy(that);
  ***REMOVED***

  inline Persistent &operator=(const Persistent &that) ***REMOVED***
    Copy(that);
    return *this;
  ***REMOVED***

  template <class S, class M2>
  inline Persistent &operator=(const Persistent<S, M2> &that) ***REMOVED***
    Copy(that);
    return *this;
  ***REMOVED***

  inline ~Persistent() ***REMOVED***
    if (M::kResetInDestructor) this->Reset();
  ***REMOVED***

 private:
  inline T *operator*() const ***REMOVED*** return *PersistentBase<T>::persistent; ***REMOVED***

  template<typename S, typename M2>
  inline void Copy(const Persistent<S, M2> &that) ***REMOVED***
    TYPE_CHECK(T, S);

    this->Reset();

    if (!that.IsEmpty()) ***REMOVED***
      this->persistent = v8::Persistent<T>::New(that.persistent);
      M::Copy(that, this);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

template<typename T>
class Global : public PersistentBase<T> ***REMOVED***
  struct RValue ***REMOVED***
    inline explicit RValue(Global* obj) : object(obj) ***REMOVED******REMOVED***
    Global* object;
  ***REMOVED***;

 public:
  inline Global() : PersistentBase<T>(0) ***REMOVED*** ***REMOVED***

  template <typename S>
  inline Global(v8::Local<S> that)  // NOLINT(runtime/explicit)
      : PersistentBase<T>(v8::Persistent<T>::New(that)) ***REMOVED***
    TYPE_CHECK(T, S);
  ***REMOVED***

  template <typename S>
  inline Global(const PersistentBase<S> &that)  // NOLINT(runtime/explicit)
    : PersistentBase<T>(that) ***REMOVED***
    TYPE_CHECK(T, S);
  ***REMOVED***
  /**
   * Move constructor.
   */
  inline Global(RValue rvalue)  // NOLINT(runtime/explicit)
    : PersistentBase<T>(rvalue.object->persistent) ***REMOVED***
    rvalue.object->Reset();
  ***REMOVED***
  inline ~Global() ***REMOVED*** this->Reset(); ***REMOVED***
  /**
   * Move via assignment.
   */
  template<typename S>
  inline Global &operator=(Global<S> rhs) ***REMOVED***
    TYPE_CHECK(T, S);
    this->Reset(rhs.persistent);
    rhs.Reset();
    return *this;
  ***REMOVED***
  /**
   * Cast operator for moves.
   */
  inline operator RValue() ***REMOVED*** return RValue(this); ***REMOVED***
  /**
   * Pass allows returning uniques from functions, etc.
   */
  Global Pass() ***REMOVED*** return Global(RValue(this)); ***REMOVED***

 private:
  Global(Global &);
  void operator=(Global &);
  template<typename S> friend class ReturnValue;
***REMOVED***;

#endif  // NAN_PERSISTENT_PRE_12_INL_H_
