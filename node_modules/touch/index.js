'use strict'

const EE = require('events').EventEmitter
const cons = require('constants')
const fs = require('fs')

module.exports = (f, options, cb) => ***REMOVED***
  if (typeof options === 'function')
    cb = options, options = ***REMOVED******REMOVED***

  const p = new Promise((res, rej) => ***REMOVED***
    new Touch(validOpts(options, f, null))
      .on('done', res).on('error', rej)
  ***REMOVED***)

  return cb ? p.then(res => cb(null, res), cb) : p
***REMOVED***

module.exports.sync = module.exports.touchSync = (f, options) =>
  (new TouchSync(validOpts(options, f, null)), undefined)

module.exports.ftouch = (fd, options, cb) => ***REMOVED***
  if (typeof options === 'function')
    cb = options, options = ***REMOVED******REMOVED***

  const p = new Promise((res, rej) => ***REMOVED***
    new Touch(validOpts(options, null, fd))
      .on('done', res).on('error', rej)
  ***REMOVED***)

  return cb ? p.then(res => cb(null, res), cb) : p
***REMOVED***

module.exports.ftouchSync = (fd, opt) =>
  (new TouchSync(validOpts(opt, null, fd)), undefined)

const validOpts = (options, path, fd) => ***REMOVED***
  options = Object.create(options || ***REMOVED******REMOVED***)
  options.fd = fd
  options.path = path

  // ***REMOVED***mtime: true***REMOVED***, ***REMOVED***ctime: true***REMOVED***
  // If set to something else, then treat as epoch ms value
  const now = parseInt(new Date(options.time || Date.now()).getTime() / 1000)
  if (!options.atime && !options.mtime)
    options.atime = options.mtime = now
  else ***REMOVED***
    if (true === options.atime)
      options.atime = now

    if (true === options.mtime)
      options.mtime = now
  ***REMOVED***

  let oflags = 0
  if (!options.force)
    oflags = oflags | cons.O_RDWR

  if (!options.nocreate)
    oflags = oflags | cons.O_CREAT

  options.oflags = oflags
  return options
***REMOVED***

class Touch extends EE ***REMOVED***
  constructor (options) ***REMOVED***
    super(options)
    this.fd = options.fd
    this.path = options.path
    this.atime = options.atime
    this.mtime = options.mtime
    this.ref = options.ref
    this.nocreate = !!options.nocreate
    this.force = !!options.force
    this.closeAfter = options.closeAfter
    this.oflags = options.oflags
    this.options = options

    if (typeof this.fd !== 'number') ***REMOVED***
      this.closeAfter = true
      this.open()
    ***REMOVED*** else
      this.onopen(null, this.fd)
  ***REMOVED***

  emit (ev, data) ***REMOVED***
    // we only emit when either done or erroring
    // in both cases, need to close
    this.close()
    return super.emit(ev, data)
  ***REMOVED***

  close () ***REMOVED***
    if (typeof this.fd === 'number' && this.closeAfter)
      fs.close(this.fd, () => ***REMOVED******REMOVED***)
  ***REMOVED***

  open () ***REMOVED***
    fs.open(this.path, this.oflags, (er, fd) => this.onopen(er, fd))
  ***REMOVED***

  onopen (er, fd) ***REMOVED***
    if (er) ***REMOVED***
      if (er.code === 'EISDIR')
        this.onopen(null, null)
      else if (er.code === 'ENOENT' && this.nocreate)
        this.emit('done')
      else
        this.emit('error', er)
    ***REMOVED*** else ***REMOVED***
      this.fd = fd
      if (this.ref)
        this.statref()
      else if (!this.atime || !this.mtime)
        this.fstat()
      else
        this.futimes()
    ***REMOVED***
  ***REMOVED***

  statref () ***REMOVED***
    fs.stat(this.ref, (er, st) => ***REMOVED***
      if (er)
        this.emit('error', er)
      else
        this.onstatref(st)
    ***REMOVED***)
  ***REMOVED***

  onstatref (st) ***REMOVED***
    this.atime = this.atime && parseInt(st.atime.getTime()/1000, 10)
    this.mtime = this.mtime && parseInt(st.mtime.getTime()/1000, 10)
    if (!this.atime || !this.mtime)
      this.fstat()
    else
      this.futimes()
  ***REMOVED***

  fstat () ***REMOVED***
    const stat = this.fd ? 'fstat' : 'stat'
    const target = this.fd || this.path
    fs[stat](target, (er, st) => ***REMOVED***
      if (er)
        this.emit('error', er)
      else
        this.onfstat(st)
    ***REMOVED***)
  ***REMOVED***

  onfstat (st) ***REMOVED***
    if (typeof this.atime !== 'number')
      this.atime = parseInt(st.atime.getTime()/1000, 10)

    if (typeof this.mtime !== 'number')
      this.mtime = parseInt(st.mtime.getTime()/1000, 10)

    this.futimes()
  ***REMOVED***

  futimes () ***REMOVED***
    const utimes = this.fd ? 'futimes' : 'utimes'
    const target = this.fd || this.path
    fs[utimes](target, ''+this.atime, ''+this.mtime, er => ***REMOVED***
      if (er)
        this.emit('error', er)
      else
        this.emit('done')
    ***REMOVED***)
  ***REMOVED***
***REMOVED***

class TouchSync extends Touch ***REMOVED***
  open () ***REMOVED***
    try ***REMOVED***
      this.onopen(null, fs.openSync(this.path, this.oflags))
    ***REMOVED*** catch (er) ***REMOVED***
      this.onopen(er)
    ***REMOVED***
  ***REMOVED***

  statref () ***REMOVED***
    let threw = true
    try ***REMOVED***
      this.onstatref(fs.statSync(this.ref))
      threw = false
    ***REMOVED*** finally ***REMOVED***
      if (threw)
        this.close()
    ***REMOVED***
  ***REMOVED***

  fstat () ***REMOVED***
    let threw = true
    const stat = this.fd ? 'fstatSync' : 'statSync'
    const target = this.fd || this.path
    try ***REMOVED***
      this.onfstat(fs[stat](target))
      threw = false
    ***REMOVED*** finally ***REMOVED***
      if (threw)
        this.close()
    ***REMOVED***
  ***REMOVED***

  futimes () ***REMOVED***
    let threw = true
    const utimes = this.fd ? 'futimesSync' : 'utimesSync'
    const target = this.fd || this.path
    try ***REMOVED***
      fs[utimes](target, this.atime, this.mtime)
      threw = false
    ***REMOVED*** finally ***REMOVED***
      if (threw)
        this.close()
    ***REMOVED***
    this.emit('done')
  ***REMOVED***

  close () ***REMOVED***
    if (typeof this.fd === 'number' && this.closeAfter)
      try ***REMOVED*** fs.closeSync(this.fd) ***REMOVED*** catch (er) ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED***
