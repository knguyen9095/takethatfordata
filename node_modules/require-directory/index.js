'use strict';

var fs = require('fs'),
  join = require('path').join,
  resolve = require('path').resolve,
  dirname = require('path').dirname,
  defaultOptions = ***REMOVED***
    extensions: ['js', 'json', 'coffee'],
    recurse: true,
    rename: function (name) ***REMOVED***
      return name;
    ***REMOVED***,
    visit: function (obj) ***REMOVED***
      return obj;
    ***REMOVED***
  ***REMOVED***;

function checkFileInclusion(path, filename, options) ***REMOVED***
  return (
    // verify file has valid extension
    (new RegExp('\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&

    // if options.include is a RegExp, evaluate it and make sure the path passes
    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&

    // if options.include is a function, evaluate it and make sure the path passes
    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&

    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass
    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&

    // if options.exclude is a function, evaluate it and make sure the path doesn't pass
    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))
  );
***REMOVED***

function requireDirectory(m, path, options) ***REMOVED***
  var retval = ***REMOVED******REMOVED***;

  // path is optional
  if (path && !options && typeof path !== 'string') ***REMOVED***
    options = path;
    path = null;
  ***REMOVED***

  // default options
  options = options || ***REMOVED******REMOVED***;
  for (var prop in defaultOptions) ***REMOVED***
    if (typeof options[prop] === 'undefined') ***REMOVED***
      options[prop] = defaultOptions[prop];
    ***REMOVED***
  ***REMOVED***

  // if no path was passed in, assume the equivelant of __dirname from caller
  // otherwise, resolve path relative to the equivalent of __dirname
  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);

  // get the path of each file in specified directory, append to current tree node, recurse
  fs.readdirSync(path).forEach(function (filename) ***REMOVED***
    var joined = join(path, filename),
      files,
      key,
      obj;

    if (fs.statSync(joined).isDirectory() && options.recurse) ***REMOVED***
      // this node is a directory; recurse
      files = requireDirectory(m, joined, options);
      // exclude empty directories
      if (Object.keys(files).length) ***REMOVED***
        retval[options.rename(filename, joined, filename)] = files;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) ***REMOVED***
        // hash node key shouldn't include file extension
        key = filename.substring(0, filename.lastIndexOf('.'));
        obj = m.require(joined);
        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  return retval;
***REMOVED***

module.exports = requireDirectory;
module.exports.defaults = defaultOptions;
