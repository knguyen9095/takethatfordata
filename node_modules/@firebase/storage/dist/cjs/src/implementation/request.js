"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
/**
 * @fileoverview Defines methods used to actually send HTTP requests from
 * abstract representations.
 */
var app_1 = require("@firebase/app");
var array = require("./array");
var backoff = require("./backoff");
var errorsExports = require("./error");
var object = require("./object");
var promiseimpl = require("./promise_external");
var type = require("./type");
var UrlUtils = require("./url");
var XhrIoExports = require("./xhrio");
/**
 * @struct
 * @template T
 */
var NetworkRequest = /** @class */ (function () ***REMOVED***
    function NetworkRequest(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) ***REMOVED***
        this.pendingXhr_ = null;
        this.backoffId_ = null;
        this.resolve_ = null;
        this.reject_ = null;
        this.canceled_ = false;
        this.appDelete_ = false;
        this.url_ = url;
        this.method_ = method;
        this.headers_ = headers;
        this.body_ = body;
        this.successCodes_ = successCodes.slice();
        this.additionalRetryCodes_ = additionalRetryCodes.slice();
        this.callback_ = callback;
        this.errorCallback_ = errorCallback;
        this.progressCallback_ = progressCallback;
        this.timeout_ = timeout;
        this.pool_ = pool;
        var self = this;
        this.promise_ = promiseimpl.make(function (resolve, reject) ***REMOVED***
            self.resolve_ = resolve;
            self.reject_ = reject;
            self.start_();
        ***REMOVED***);
    ***REMOVED***
    /**
     * Actually starts the retry loop.
     */
    NetworkRequest.prototype.start_ = function () ***REMOVED***
        var self = this;
        function doTheRequest(backoffCallback, canceled) ***REMOVED***
            if (canceled) ***REMOVED***
                backoffCallback(false, new RequestEndStatus(false, null, true));
                return;
            ***REMOVED***
            var xhr = self.pool_.createXhrIo();
            self.pendingXhr_ = xhr;
            function progressListener(progressEvent) ***REMOVED***
                var loaded = progressEvent.loaded;
                var total = progressEvent.lengthComputable ? progressEvent.total : -1;
                if (self.progressCallback_ !== null) ***REMOVED***
                    self.progressCallback_(loaded, total);
                ***REMOVED***
            ***REMOVED***
            if (self.progressCallback_ !== null) ***REMOVED***
                xhr.addUploadProgressListener(progressListener);
            ***REMOVED***
            xhr
                .send(self.url_, self.method_, self.body_, self.headers_)
                .then(function (xhr) ***REMOVED***
                if (self.progressCallback_ !== null) ***REMOVED***
                    xhr.removeUploadProgressListener(progressListener);
                ***REMOVED***
                self.pendingXhr_ = null;
                xhr = xhr;
                var hitServer = xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;
                var status = xhr.getStatus();
                if (!hitServer || self.isRetryStatusCode_(status)) ***REMOVED***
                    var wasCanceled = xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;
                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
                    return;
                ***REMOVED***
                var successCode = array.contains(self.successCodes_, status);
                backoffCallback(true, new RequestEndStatus(successCode, xhr));
            ***REMOVED***);
        ***REMOVED***
        /**
         * @param requestWentThrough True if the request eventually went
         *     through, false if it hit the retry limit or was canceled.
         */
        function backoffDone(requestWentThrough, status) ***REMOVED***
            var resolve = self.resolve_;
            var reject = self.reject_;
            var xhr = status.xhr;
            if (status.wasSuccessCode) ***REMOVED***
                try ***REMOVED***
                    var result = self.callback_(xhr, xhr.getResponseText());
                    if (type.isJustDef(result)) ***REMOVED***
                        resolve(result);
                    ***REMOVED***
                    else ***REMOVED***
                        resolve();
                    ***REMOVED***
                ***REMOVED***
                catch (e) ***REMOVED***
                    reject(e);
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                if (xhr !== null) ***REMOVED***
                    var err = errorsExports.unknown();
                    err.setServerResponseProp(xhr.getResponseText());
                    if (self.errorCallback_) ***REMOVED***
                        reject(self.errorCallback_(xhr, err));
                    ***REMOVED***
                    else ***REMOVED***
                        reject(err);
                    ***REMOVED***
                ***REMOVED***
                else ***REMOVED***
                    if (status.canceled) ***REMOVED***
                        var err = self.appDelete_
                            ? errorsExports.appDeleted()
                            : errorsExports.canceled();
                        reject(err);
                    ***REMOVED***
                    else ***REMOVED***
                        var err = errorsExports.retryLimitExceeded();
                        reject(err);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        if (this.canceled_) ***REMOVED***
            backoffDone(false, new RequestEndStatus(false, null, true));
        ***REMOVED***
        else ***REMOVED***
            this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    NetworkRequest.prototype.getPromise = function () ***REMOVED***
        return this.promise_;
    ***REMOVED***;
    /** @inheritDoc */
    NetworkRequest.prototype.cancel = function (appDelete) ***REMOVED***
        this.canceled_ = true;
        this.appDelete_ = appDelete || false;
        if (this.backoffId_ !== null) ***REMOVED***
            backoff.stop(this.backoffId_);
        ***REMOVED***
        if (this.pendingXhr_ !== null) ***REMOVED***
            this.pendingXhr_.abort();
        ***REMOVED***
    ***REMOVED***;
    NetworkRequest.prototype.isRetryStatusCode_ = function (status) ***REMOVED***
        // The codes for which to retry came from this page:
        // https://cloud.google.com/storage/docs/exponential-backoff
        var isFiveHundredCode = status >= 500 && status < 600;
        var extraRetryCodes = [
            // Request Timeout: web server didn't receive full request in time.
            408,
            // Too Many Requests: you're getting rate-limited, basically.
            429
        ];
        var isExtraRetryCode = array.contains(extraRetryCodes, status);
        var isRequestSpecificRetryCode = array.contains(this.additionalRetryCodes_, status);
        return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
    ***REMOVED***;
    return NetworkRequest;
***REMOVED***());
/**
 * A collection of information about the result of a network request.
 * @param opt_canceled Defaults to false.
 * @struct
 */
var RequestEndStatus = /** @class */ (function () ***REMOVED***
    function RequestEndStatus(wasSuccessCode, xhr, opt_canceled) ***REMOVED***
        this.wasSuccessCode = wasSuccessCode;
        this.xhr = xhr;
        this.canceled = !!opt_canceled;
    ***REMOVED***
    return RequestEndStatus;
***REMOVED***());
exports.RequestEndStatus = RequestEndStatus;
function addAuthHeader_(headers, authToken) ***REMOVED***
    if (authToken !== null && authToken.length > 0) ***REMOVED***
        headers['Authorization'] = 'Firebase ' + authToken;
    ***REMOVED***
***REMOVED***
exports.addAuthHeader_ = addAuthHeader_;
function addVersionHeader_(headers) ***REMOVED***
    var number = typeof app_1.default !== 'undefined' ? app_1.default.SDK_VERSION : 'AppManager';
    headers['X-Firebase-Storage-Version'] = 'webjs/' + number;
***REMOVED***
exports.addVersionHeader_ = addVersionHeader_;
/**
 * @template T
 */
function makeRequest(requestInfo, authToken, pool) ***REMOVED***
    var queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);
    var url = requestInfo.url + queryPart;
    var headers = object.clone(requestInfo.headers);
    addAuthHeader_(headers, authToken);
    addVersionHeader_(headers);
    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
***REMOVED***
exports.makeRequest = makeRequest;

//# sourceMappingURL=request.js.map
