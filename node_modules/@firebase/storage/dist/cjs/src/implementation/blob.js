"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
/**
 * @file Provides a Blob-like wrapper for various binary types (including the
 * native Blob type). This makes it possible to upload types like ArrayBuffers,
 * making uploads possible in environments without the native Blob type.
 */
var fs = require("./fs");
var string = require("./string");
var string_1 = require("./string");
var type = require("./type");
/**
 * @param opt_elideCopy If true, doesn't copy mutable input data
 *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be
 *     modified after this blob's construction.
 */
var FbsBlob = /** @class */ (function () ***REMOVED***
    function FbsBlob(data, opt_elideCopy) ***REMOVED***
        var size = 0;
        var blobType = '';
        if (type.isNativeBlob(data)) ***REMOVED***
            this.data_ = data;
            size = data.size;
            blobType = data.type;
        ***REMOVED***
        else if (data instanceof ArrayBuffer) ***REMOVED***
            if (opt_elideCopy) ***REMOVED***
                this.data_ = new Uint8Array(data);
            ***REMOVED***
            else ***REMOVED***
                this.data_ = new Uint8Array(data.byteLength);
                this.data_.set(new Uint8Array(data));
            ***REMOVED***
            size = this.data_.length;
        ***REMOVED***
        else if (data instanceof Uint8Array) ***REMOVED***
            if (opt_elideCopy) ***REMOVED***
                this.data_ = data;
            ***REMOVED***
            else ***REMOVED***
                this.data_ = new Uint8Array(data.length);
                this.data_.set(data);
            ***REMOVED***
            size = data.length;
        ***REMOVED***
        this.size_ = size;
        this.type_ = blobType;
    ***REMOVED***
    FbsBlob.prototype.size = function () ***REMOVED***
        return this.size_;
    ***REMOVED***;
    FbsBlob.prototype.type = function () ***REMOVED***
        return this.type_;
    ***REMOVED***;
    FbsBlob.prototype.slice = function (startByte, endByte) ***REMOVED***
        if (type.isNativeBlob(this.data_)) ***REMOVED***
            var realBlob = this.data_;
            var sliced = fs.sliceBlob(realBlob, startByte, endByte);
            if (sliced === null) ***REMOVED***
                return null;
            ***REMOVED***
            return new FbsBlob(sliced);
        ***REMOVED***
        else ***REMOVED***
            var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
            return new FbsBlob(slice, true);
        ***REMOVED***
    ***REMOVED***;
    FbsBlob.getBlob = function () ***REMOVED***
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            var_args[_i] = arguments[_i];
        ***REMOVED***
        if (type.isNativeBlobDefined()) ***REMOVED***
            var blobby = var_args.map(function (val) ***REMOVED***
                if (val instanceof FbsBlob) ***REMOVED***
                    return val.data_;
                ***REMOVED***
                else ***REMOVED***
                    return val;
                ***REMOVED***
            ***REMOVED***);
            return new FbsBlob(fs.getBlob.apply(null, blobby));
        ***REMOVED***
        else ***REMOVED***
            var uint8Arrays = var_args.map(function (val) ***REMOVED***
                if (type.isString(val)) ***REMOVED***
                    return string.dataFromString(string_1.StringFormat.RAW, val).data;
                ***REMOVED***
                else ***REMOVED***
                    // Blobs don't exist, so this has to be a Uint8Array.
                    return val.data_;
                ***REMOVED***
            ***REMOVED***);
            var finalLength_1 = 0;
            uint8Arrays.forEach(function (array) ***REMOVED***
                finalLength_1 += array.byteLength;
            ***REMOVED***);
            var merged_1 = new Uint8Array(finalLength_1);
            var index_1 = 0;
            uint8Arrays.forEach(function (array) ***REMOVED***
                for (var i = 0; i < array.length; i++) ***REMOVED***
                    merged_1[index_1++] = array[i];
                ***REMOVED***
            ***REMOVED***);
            return new FbsBlob(merged_1, true);
        ***REMOVED***
    ***REMOVED***;
    FbsBlob.prototype.uploadData = function () ***REMOVED***
        return this.data_;
    ***REMOVED***;
    return FbsBlob;
***REMOVED***());
exports.FbsBlob = FbsBlob;

//# sourceMappingURL=blob.js.map
