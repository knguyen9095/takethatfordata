"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var constants = require("./constants");
var errorsExports = require("./error");
var failrequest_1 = require("./failrequest");
var location_1 = require("./location");
var promiseimpl = require("./promise_external");
var requestmap_1 = require("./requestmap");
var type = require("./type");
/**
 * @param app If null, getAuthToken always resolves with null.
 * @param service The storage service associated with this auth wrapper.
 *     Untyped to avoid circular type dependencies.
 * @struct
 */
var AuthWrapper = /** @class */ (function () ***REMOVED***
    function AuthWrapper(app, maker, requestMaker, service, pool) ***REMOVED***
        this.bucket_ = null;
        this.deleted_ = false;
        this.app_ = app;
        if (this.app_ !== null) ***REMOVED***
            var options = this.app_.options;
            if (type.isDef(options)) ***REMOVED***
                this.bucket_ = AuthWrapper.extractBucket_(options);
            ***REMOVED***
        ***REMOVED***
        this.storageRefMaker_ = maker;
        this.requestMaker_ = requestMaker;
        this.pool_ = pool;
        this.service_ = service;
        this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;
        this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;
        this.requestMap_ = new requestmap_1.RequestMap();
    ***REMOVED***
    AuthWrapper.extractBucket_ = function (config) ***REMOVED***
        var bucketString = config[constants.configOption] || null;
        if (bucketString == null) ***REMOVED***
            return null;
        ***REMOVED***
        var loc = location_1.Location.makeFromBucketSpec(bucketString);
        return loc.bucket;
    ***REMOVED***;
    AuthWrapper.prototype.getAuthToken = function () ***REMOVED***
        // TODO(andysoto): remove ifDef checks after firebase-app implements stubs
        // (b/28673818).
        if (this.app_ !== null &&
            type.isDef(this.app_.INTERNAL) &&
            type.isDef(this.app_.INTERNAL.getToken)) ***REMOVED***
            return this.app_.INTERNAL.getToken().then(function (response) ***REMOVED***
                if (response !== null) ***REMOVED***
                    return response.accessToken;
                ***REMOVED***
                else ***REMOVED***
                    return null;
                ***REMOVED***
            ***REMOVED***, function (_error) ***REMOVED***
                return null;
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            return promiseimpl.resolve(null);
        ***REMOVED***
    ***REMOVED***;
    AuthWrapper.prototype.bucket = function () ***REMOVED***
        if (this.deleted_) ***REMOVED***
            throw errorsExports.appDeleted();
        ***REMOVED***
        else ***REMOVED***
            return this.bucket_;
        ***REMOVED***
    ***REMOVED***;
    /**
     * The service associated with this auth wrapper. Untyped to avoid circular
     * type dependencies.
     */
    AuthWrapper.prototype.service = function () ***REMOVED***
        return this.service_;
    ***REMOVED***;
    /**
     * Returns a new firebaseStorage.Reference object referencing this AuthWrapper
     * at the given Location.
     * @param loc The Location.
     * @return Actually a firebaseStorage.Reference, typing not allowed
     *     because of circular dependency problems.
     */
    AuthWrapper.prototype.makeStorageReference = function (loc) ***REMOVED***
        return this.storageRefMaker_(this, loc);
    ***REMOVED***;
    AuthWrapper.prototype.makeRequest = function (requestInfo, authToken) ***REMOVED***
        if (!this.deleted_) ***REMOVED***
            var request = this.requestMaker_(requestInfo, authToken, this.pool_);
            this.requestMap_.addRequest(request);
            return request;
        ***REMOVED***
        else ***REMOVED***
            return new failrequest_1.FailRequest(errorsExports.appDeleted());
        ***REMOVED***
    ***REMOVED***;
    /**
     * Stop running requests and prevent more from being created.
     */
    AuthWrapper.prototype.deleteApp = function () ***REMOVED***
        this.deleted_ = true;
        this.app_ = null;
        this.requestMap_.clear();
    ***REMOVED***;
    AuthWrapper.prototype.maxUploadRetryTime = function () ***REMOVED***
        return this.maxUploadRetryTime_;
    ***REMOVED***;
    AuthWrapper.prototype.setMaxUploadRetryTime = function (time) ***REMOVED***
        this.maxUploadRetryTime_ = time;
    ***REMOVED***;
    AuthWrapper.prototype.maxOperationRetryTime = function () ***REMOVED***
        return this.maxOperationRetryTime_;
    ***REMOVED***;
    AuthWrapper.prototype.setMaxOperationRetryTime = function (time) ***REMOVED***
        this.maxOperationRetryTime_ = time;
    ***REMOVED***;
    return AuthWrapper;
***REMOVED***());
exports.AuthWrapper = AuthWrapper;

//# sourceMappingURL=authwrapper.js.map
