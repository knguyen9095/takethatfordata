"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
/**
 * @fileoverview Defines the Firebase Storage Reference class.
 */
var args = require("./implementation/args");
var blob_1 = require("./implementation/blob");
var errorsExports = require("./implementation/error");
var location_1 = require("./implementation/location");
var metadata = require("./implementation/metadata");
var object = require("./implementation/object");
var path = require("./implementation/path");
var requests = require("./implementation/requests");
var fbsString = require("./implementation/string");
var string_1 = require("./implementation/string");
var type = require("./implementation/type");
var task_1 = require("./task");
/**
 * Provides methods to interact with a bucket in the Firebase Storage service.
 * @param location An fbs.location, or the URL at
 *     which to base this object, in one of the following forms:
 *         gs://<bucket>/<object-path>
 *         http[s]://firebasestorage.googleapis.com/
 *                     <api-version>/b/<bucket>/o/<object-path>
 *     Any query or fragment strings will be ignored in the http[s]
 *     format. If no value is passed, the storage object will use a URL based on
 *     the project ID of the base firebase.App instance.
 */
var Reference = /** @class */ (function () ***REMOVED***
    function Reference(authWrapper, location) ***REMOVED***
        this.authWrapper = authWrapper;
        if (location instanceof location_1.Location) ***REMOVED***
            this.location = location;
        ***REMOVED***
        else ***REMOVED***
            this.location = location_1.Location.makeFromUrl(location);
        ***REMOVED***
    ***REMOVED***
    /**
     * @return The URL for the bucket and path this object references,
     *     in the form gs://<bucket>/<object-path>
     * @override
     */
    Reference.prototype.toString = function () ***REMOVED***
        args.validate('toString', [], arguments);
        return 'gs://' + this.location.bucket + '/' + this.location.path;
    ***REMOVED***;
    Reference.prototype.newRef = function (authWrapper, location) ***REMOVED***
        return new Reference(authWrapper, location);
    ***REMOVED***;
    Reference.prototype.mappings = function () ***REMOVED***
        return metadata.getMappings();
    ***REMOVED***;
    /**
     * @return A reference to the object obtained by
     *     appending childPath, removing any duplicate, beginning, or trailing
     *     slashes.
     */
    Reference.prototype.child = function (childPath) ***REMOVED***
        args.validate('child', [args.stringSpec()], arguments);
        var newPath = path.child(this.location.path, childPath);
        var location = new location_1.Location(this.location.bucket, newPath);
        return this.newRef(this.authWrapper, location);
    ***REMOVED***;
    Object.defineProperty(Reference.prototype, "parent", ***REMOVED***
        /**
         * @return A reference to the parent of the
         *     current object, or null if the current object is the root.
         */
        get: function () ***REMOVED***
            var newPath = path.parent(this.location.path);
            if (newPath === null) ***REMOVED***
                return null;
            ***REMOVED***
            var location = new location_1.Location(this.location.bucket, newPath);
            return this.newRef(this.authWrapper, location);
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Reference.prototype, "root", ***REMOVED***
        /**
         * @return An reference to the root of this
         *     object's bucket.
         */
        get: function () ***REMOVED***
            var location = new location_1.Location(this.location.bucket, '');
            return this.newRef(this.authWrapper, location);
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Reference.prototype, "bucket", ***REMOVED***
        get: function () ***REMOVED***
            return this.location.bucket;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Reference.prototype, "fullPath", ***REMOVED***
        get: function () ***REMOVED***
            return this.location.path;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Reference.prototype, "name", ***REMOVED***
        get: function () ***REMOVED***
            return path.lastComponent(this.location.path);
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Reference.prototype, "storage", ***REMOVED***
        get: function () ***REMOVED***
            return this.authWrapper.service();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /**
     * Uploads a blob to this object's location.
     * @param data The blob to upload.
     * @return An UploadTask that lets you control and
     *     observe the upload.
     */
    Reference.prototype.put = function (data, metadata) ***REMOVED***
        if (metadata === void 0) ***REMOVED*** metadata = null; ***REMOVED***
        args.validate('put', [args.uploadDataSpec(), args.metadataSpec(true)], arguments);
        this.throwIfRoot_('put');
        return new task_1.UploadTask(this, this.authWrapper, this.location, this.mappings(), new blob_1.FbsBlob(data), metadata);
    ***REMOVED***;
    /**
     * Uploads a string to this object's location.
     * @param string The string to upload.
     * @param opt_format The format of the string to upload.
     * @return An UploadTask that lets you control and
     *     observe the upload.
     */
    Reference.prototype.putString = function (string, format, opt_metadata) ***REMOVED***
        if (format === void 0) ***REMOVED*** format = string_1.StringFormat.RAW; ***REMOVED***
        args.validate('putString', [
            args.stringSpec(),
            args.stringSpec(fbsString.formatValidator, true),
            args.metadataSpec(true)
        ], arguments);
        this.throwIfRoot_('putString');
        var data = fbsString.dataFromString(format, string);
        var metadata = object.clone(opt_metadata);
        if (!type.isDef(metadata['contentType']) && type.isDef(data.contentType)) ***REMOVED***
            metadata['contentType'] = data.contentType;
        ***REMOVED***
        return new task_1.UploadTask(this, this.authWrapper, this.location, this.mappings(), new blob_1.FbsBlob(data.data, true), metadata);
    ***REMOVED***;
    /**
     * Deletes the object at this location.
     * @return A promise that resolves if the deletion succeeds.
     */
    Reference.prototype.delete = function () ***REMOVED***
        args.validate('delete', [], arguments);
        this.throwIfRoot_('delete');
        var self = this;
        return this.authWrapper.getAuthToken().then(function (authToken) ***REMOVED***
            var requestInfo = requests.deleteObject(self.authWrapper, self.location);
            return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        ***REMOVED***);
    ***REMOVED***;
    /**
     *     A promise that resolves with the metadata for this object. If this
     *     object doesn't exist or metadata cannot be retreived, the promise is
     *     rejected.
     */
    Reference.prototype.getMetadata = function () ***REMOVED***
        args.validate('getMetadata', [], arguments);
        this.throwIfRoot_('getMetadata');
        var self = this;
        return this.authWrapper.getAuthToken().then(function (authToken) ***REMOVED***
            var requestInfo = requests.getMetadata(self.authWrapper, self.location, self.mappings());
            return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Updates the metadata for this object.
     * @param metadata The new metadata for the object.
     *     Only values that have been explicitly set will be changed. Explicitly
     *     setting a value to null will remove the metadata.
     * @return A promise that resolves
     *     with the new metadata for this object.
     *     @see firebaseStorage.Reference.prototype.getMetadata
     */
    Reference.prototype.updateMetadata = function (metadata) ***REMOVED***
        args.validate('updateMetadata', [args.metadataSpec()], arguments);
        this.throwIfRoot_('updateMetadata');
        var self = this;
        return this.authWrapper.getAuthToken().then(function (authToken) ***REMOVED***
            var requestInfo = requests.updateMetadata(self.authWrapper, self.location, metadata, self.mappings());
            return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        ***REMOVED***);
    ***REMOVED***;
    /**
     * @return A promise that resolves with the download
     *     URL for this object.
     */
    Reference.prototype.getDownloadURL = function () ***REMOVED***
        args.validate('getDownloadURL', [], arguments);
        this.throwIfRoot_('getDownloadURL');
        return this.getMetadata().then(function (metadata) ***REMOVED***
            var url = metadata['downloadURLs'][0];
            if (type.isDef(url)) ***REMOVED***
                return url;
            ***REMOVED***
            else ***REMOVED***
                throw errorsExports.noDownloadURL();
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    Reference.prototype.throwIfRoot_ = function (name) ***REMOVED***
        if (this.location.path === '') ***REMOVED***
            throw errorsExports.invalidRootOperation(name);
        ***REMOVED***
    ***REMOVED***;
    return Reference;
***REMOVED***());
exports.Reference = Reference;

//# sourceMappingURL=reference.js.map
