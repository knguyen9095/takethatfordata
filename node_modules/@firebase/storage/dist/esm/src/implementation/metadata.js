/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as json from './json';
import ***REMOVED*** Location ***REMOVED*** from './location';
import * as path from './path';
import * as type from './type';
import * as UrlUtils from './url';
export function noXform_(metadata, value) ***REMOVED***
    return value;
***REMOVED***
/**
 * @struct
 */
var Mapping = /** @class */ (function () ***REMOVED***
    function Mapping(server, opt_local, opt_writable, opt_xform) ***REMOVED***
        this.server = server;
        this.local = opt_local || server;
        this.writable = !!opt_writable;
        this.xform = opt_xform || noXform_;
    ***REMOVED***
    return Mapping;
***REMOVED***());
export ***REMOVED*** Mapping ***REMOVED***;
var mappings_ = null;
export function xformPath(fullPath) ***REMOVED***
    var valid = type.isString(fullPath);
    if (!valid || fullPath.length < 2) ***REMOVED***
        return fullPath;
    ***REMOVED***
    else ***REMOVED***
        fullPath = fullPath;
        return path.lastComponent(fullPath);
    ***REMOVED***
***REMOVED***
export function getMappings() ***REMOVED***
    if (mappings_) ***REMOVED***
        return mappings_;
    ***REMOVED***
    var mappings = [];
    mappings.push(new Mapping('bucket'));
    mappings.push(new Mapping('generation'));
    mappings.push(new Mapping('metageneration'));
    mappings.push(new Mapping('name', 'fullPath', true));
    function mappingsXformPath(metadata, fullPath) ***REMOVED***
        return xformPath(fullPath);
    ***REMOVED***
    var nameMapping = new Mapping('name');
    nameMapping.xform = mappingsXformPath;
    mappings.push(nameMapping);
    /**
     * Coerces the second param to a number, if it is defined.
     */
    function xformSize(metadata, size) ***REMOVED***
        if (type.isDef(size)) ***REMOVED***
            return +size;
        ***REMOVED***
        else ***REMOVED***
            return size;
        ***REMOVED***
    ***REMOVED***
    var sizeMapping = new Mapping('size');
    sizeMapping.xform = xformSize;
    mappings.push(sizeMapping);
    mappings.push(new Mapping('timeCreated'));
    mappings.push(new Mapping('updated'));
    mappings.push(new Mapping('md5Hash', null, true));
    mappings.push(new Mapping('cacheControl', null, true));
    mappings.push(new Mapping('contentDisposition', null, true));
    mappings.push(new Mapping('contentEncoding', null, true));
    mappings.push(new Mapping('contentLanguage', null, true));
    mappings.push(new Mapping('contentType', null, true));
    mappings.push(new Mapping('metadata', 'customMetadata', true));
    /**
     * Transforms a comma-separated string of tokens into a list of download
     * URLs.
     */
    function xformTokens(metadata, tokens) ***REMOVED***
        var valid = type.isString(tokens) && tokens.length > 0;
        if (!valid) ***REMOVED***
            // This can happen if objects are uploaded through GCS and retrieved
            // through list, so we don't want to throw an Error.
            return [];
        ***REMOVED***
        var encode = encodeURIComponent;
        var tokensList = tokens.split(',');
        var urls = tokensList.map(function (token) ***REMOVED***
            var bucket = metadata['bucket'];
            var path = metadata['fullPath'];
            var urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);
            var base = UrlUtils.makeDownloadUrl(urlPart);
            var queryString = UrlUtils.makeQueryString(***REMOVED***
                alt: 'media',
                token: token
            ***REMOVED***);
            return base + queryString;
        ***REMOVED***);
        return urls;
    ***REMOVED***
    mappings.push(new Mapping('downloadTokens', 'downloadURLs', false, xformTokens));
    mappings_ = mappings;
    return mappings_;
***REMOVED***
export function addRef(metadata, authWrapper) ***REMOVED***
    function generateRef() ***REMOVED***
        var bucket = metadata['bucket'];
        var path = metadata['fullPath'];
        var loc = new Location(bucket, path);
        return authWrapper.makeStorageReference(loc);
    ***REMOVED***
    Object.defineProperty(metadata, 'ref', ***REMOVED*** get: generateRef ***REMOVED***);
***REMOVED***
export function fromResource(authWrapper, resource, mappings) ***REMOVED***
    var metadata = ***REMOVED******REMOVED***;
    metadata['type'] = 'file';
    var len = mappings.length;
    for (var i = 0; i < len; i++) ***REMOVED***
        var mapping = mappings[i];
        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
    ***REMOVED***
    addRef(metadata, authWrapper);
    return metadata;
***REMOVED***
export function fromResourceString(authWrapper, resourceString, mappings) ***REMOVED***
    var obj = json.jsonObjectOrNull(resourceString);
    if (obj === null) ***REMOVED***
        return null;
    ***REMOVED***
    var resource = obj;
    return fromResource(authWrapper, resource, mappings);
***REMOVED***
export function toResourceString(metadata, mappings) ***REMOVED***
    var resource = ***REMOVED******REMOVED***;
    var len = mappings.length;
    for (var i = 0; i < len; i++) ***REMOVED***
        var mapping = mappings[i];
        if (mapping.writable) ***REMOVED***
            resource[mapping.server] = metadata[mapping.local];
        ***REMOVED***
    ***REMOVED***
    return JSON.stringify(resource);
***REMOVED***
export function metadataValidator(p) ***REMOVED***
    var validType = p && type.isObject(p);
    if (!validType) ***REMOVED***
        throw 'Expected Metadata object.';
    ***REMOVED***
    for (var key in p) ***REMOVED***
        var val = p[key];
        if (key === 'customMetadata') ***REMOVED***
            if (!type.isObject(val)) ***REMOVED***
                throw 'Expected object for \'customMetadata\' mapping.';
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            if (type.isNonNullObject(val)) ***REMOVED***
                throw "Mapping for '" + key + "' cannot be an object.";
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***

//# sourceMappingURL=metadata.js.map
