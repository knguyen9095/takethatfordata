/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param f May be invoked
 *     before the function returns.
 * @param callback Get all the arguments passed to the function
 *     passed to f, including the initial boolean.
 */
export function start(f, callback, timeout) ***REMOVED***
    // TODO(andysoto): make this code cleaner (probably refactor into an actual
    // type instead of a bunch of functions with state shared in the closure)
    var waitSeconds = 1;
    // Would type this as "number" but that doesn't work for Node so ¯\_(ツ)_/¯
    var timeoutId = null;
    var hitTimeout = false;
    var cancelState = 0;
    function canceled() ***REMOVED***
        return cancelState === 2;
    ***REMOVED***
    var triggeredCallback = false;
    function triggerCallback() ***REMOVED***
        if (!triggeredCallback) ***REMOVED***
            triggeredCallback = true;
            callback.apply(null, arguments);
        ***REMOVED***
    ***REMOVED***
    function callWithDelay(millis) ***REMOVED***
        timeoutId = setTimeout(function () ***REMOVED***
            timeoutId = null;
            f(handler, canceled());
        ***REMOVED***, millis);
    ***REMOVED***
    function handler(success) ***REMOVED***
        var var_args = [];
        for (var _i = 1; _i < arguments.length; _i++) ***REMOVED***
            var_args[_i - 1] = arguments[_i];
        ***REMOVED***
        if (triggeredCallback) ***REMOVED***
            return;
        ***REMOVED***
        if (success) ***REMOVED***
            triggerCallback.apply(null, arguments);
            return;
        ***REMOVED***
        var mustStop = canceled() || hitTimeout;
        if (mustStop) ***REMOVED***
            triggerCallback.apply(null, arguments);
            return;
        ***REMOVED***
        if (waitSeconds < 64) ***REMOVED***
            /* TODO(andysoto): don't back off so quickly if we know we're offline. */
            waitSeconds *= 2;
        ***REMOVED***
        var waitMillis;
        if (cancelState === 1) ***REMOVED***
            cancelState = 2;
            waitMillis = 0;
        ***REMOVED***
        else ***REMOVED***
            waitMillis = (waitSeconds + Math.random()) * 1000;
        ***REMOVED***
        callWithDelay(waitMillis);
    ***REMOVED***
    var stopped = false;
    function stop(wasTimeout) ***REMOVED***
        if (stopped) ***REMOVED***
            return;
        ***REMOVED***
        stopped = true;
        if (triggeredCallback) ***REMOVED***
            return;
        ***REMOVED***
        if (timeoutId !== null) ***REMOVED***
            if (!wasTimeout) ***REMOVED***
                cancelState = 2;
            ***REMOVED***
            clearTimeout(timeoutId);
            callWithDelay(0);
        ***REMOVED***
        else ***REMOVED***
            if (!wasTimeout) ***REMOVED***
                cancelState = 1;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    callWithDelay(0);
    setTimeout(function () ***REMOVED***
        hitTimeout = true;
        stop(true);
    ***REMOVED***, timeout);
    return stop;
***REMOVED***
/**
 * Stops the retry loop from repeating.
 * If the function is currently "in between" retries, it is invoked immediately
 * with the second parameter as "true". Otherwise, it will be invoked once more
 * after the current invocation finishes iff the current invocation would have
 * triggered another retry.
 */
export function stop(id) ***REMOVED***
    id(false);
***REMOVED***

//# sourceMappingURL=backoff.js.map
