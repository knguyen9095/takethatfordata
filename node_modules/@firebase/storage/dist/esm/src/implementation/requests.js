/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as array from './array';
import ***REMOVED*** FbsBlob ***REMOVED*** from './blob';
import * as errorsExports from './error';
import * as MetadataUtils from './metadata';
import * as object from './object';
import ***REMOVED*** RequestInfo ***REMOVED*** from './requestinfo';
import * as type from './type';
import * as UrlUtils from './url';
/**
 * Throws the UNKNOWN FirebaseStorageError if cndn is false.
 */
export function handlerCheck(cndn) ***REMOVED***
    if (!cndn) ***REMOVED***
        throw errorsExports.unknown();
    ***REMOVED***
***REMOVED***
export function metadataHandler(authWrapper, mappings) ***REMOVED***
    function handler(xhr, text) ***REMOVED***
        var metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);
        handlerCheck(metadata !== null);
        return metadata;
    ***REMOVED***
    return handler;
***REMOVED***
export function sharedErrorHandler(location) ***REMOVED***
    function errorHandler(xhr, err) ***REMOVED***
        var newErr;
        if (xhr.getStatus() === 401) ***REMOVED***
            newErr = errorsExports.unauthenticated();
        ***REMOVED***
        else ***REMOVED***
            if (xhr.getStatus() === 402) ***REMOVED***
                newErr = errorsExports.quotaExceeded(location.bucket);
            ***REMOVED***
            else ***REMOVED***
                if (xhr.getStatus() === 403) ***REMOVED***
                    newErr = errorsExports.unauthorized(location.path);
                ***REMOVED***
                else ***REMOVED***
                    newErr = err;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        newErr.setServerResponseProp(err.serverResponseProp());
        return newErr;
    ***REMOVED***
    return errorHandler;
***REMOVED***
export function objectErrorHandler(location) ***REMOVED***
    var shared = sharedErrorHandler(location);
    function errorHandler(xhr, err) ***REMOVED***
        var newErr = shared(xhr, err);
        if (xhr.getStatus() === 404) ***REMOVED***
            newErr = errorsExports.objectNotFound(location.path);
        ***REMOVED***
        newErr.setServerResponseProp(err.serverResponseProp());
        return newErr;
    ***REMOVED***
    return errorHandler;
***REMOVED***
export function getMetadata(authWrapper, location, mappings) ***REMOVED***
    var urlPart = location.fullServerUrl();
    var url = UrlUtils.makeNormalUrl(urlPart);
    var method = 'GET';
    var timeout = authWrapper.maxOperationRetryTime();
    var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
***REMOVED***
export function updateMetadata(authWrapper, location, metadata, mappings) ***REMOVED***
    var urlPart = location.fullServerUrl();
    var url = UrlUtils.makeNormalUrl(urlPart);
    var method = 'PATCH';
    var body = MetadataUtils.toResourceString(metadata, mappings);
    var headers = ***REMOVED*** 'Content-Type': 'application/json; charset=utf-8' ***REMOVED***;
    var timeout = authWrapper.maxOperationRetryTime();
    var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);
    requestInfo.headers = headers;
    requestInfo.body = body;
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
***REMOVED***
export function deleteObject(authWrapper, location) ***REMOVED***
    var urlPart = location.fullServerUrl();
    var url = UrlUtils.makeNormalUrl(urlPart);
    var method = 'DELETE';
    var timeout = authWrapper.maxOperationRetryTime();
    function handler(xhr, text) ***REMOVED*** ***REMOVED***
    var requestInfo = new RequestInfo(url, method, handler, timeout);
    requestInfo.successCodes = [200, 204];
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
***REMOVED***
export function determineContentType_(metadata, blob) ***REMOVED***
    return ((metadata && metadata['contentType']) ||
        (blob && blob.type()) ||
        'application/octet-stream');
***REMOVED***
export function metadataForUpload_(location, blob, opt_metadata) ***REMOVED***
    var metadata = object.clone(opt_metadata);
    metadata['fullPath'] = location.path;
    metadata['size'] = blob.size();
    if (!metadata['contentType']) ***REMOVED***
        metadata['contentType'] = determineContentType_(null, blob);
    ***REMOVED***
    return metadata;
***REMOVED***
export function multipartUpload(authWrapper, location, mappings, blob, opt_metadata) ***REMOVED***
    var urlPart = location.bucketOnlyServerUrl();
    var headers = ***REMOVED***
        'X-Goog-Upload-Protocol': 'multipart'
    ***REMOVED***;
    function genBoundary() ***REMOVED***
        var str = '';
        for (var i = 0; i < 2; i++) ***REMOVED***
            str =
                str +
                    Math.random()
                        .toString()
                        .slice(2);
        ***REMOVED***
        return str;
    ***REMOVED***
    var boundary = genBoundary();
    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;
    var metadata = metadataForUpload_(location, blob, opt_metadata);
    var metadataString = MetadataUtils.toResourceString(metadata, mappings);
    var preBlobPart = '--' +
        boundary +
        '\r\n' +
        'Content-Type: application/json; charset=utf-8\r\n\r\n' +
        metadataString +
        '\r\n--' +
        boundary +
        '\r\n' +
        'Content-Type: ' +
        metadata['contentType'] +
        '\r\n\r\n';
    var postBlobPart = '\r\n--' + boundary + '--';
    var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
    if (body === null) ***REMOVED***
        throw errorsExports.cannotSliceBlob();
    ***REMOVED***
    var urlParams = ***REMOVED*** name: metadata['fullPath'] ***REMOVED***;
    var url = UrlUtils.makeUploadUrl(urlPart);
    var method = 'POST';
    var timeout = authWrapper.maxUploadRetryTime();
    var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);
    requestInfo.urlParams = urlParams;
    requestInfo.headers = headers;
    requestInfo.body = body.uploadData();
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
***REMOVED***
/**
 * @param current The number of bytes that have been uploaded so far.
 * @param total The total number of bytes in the upload.
 * @param opt_finalized True if the server has finished the upload.
 * @param opt_metadata The upload metadata, should
 *     only be passed if opt_finalized is true.
 * @struct
 */
var ResumableUploadStatus = /** @class */ (function () ***REMOVED***
    function ResumableUploadStatus(current, total, finalized, metadata) ***REMOVED***
        this.current = current;
        this.total = total;
        this.finalized = !!finalized;
        this.metadata = metadata || null;
    ***REMOVED***
    return ResumableUploadStatus;
***REMOVED***());
export ***REMOVED*** ResumableUploadStatus ***REMOVED***;
export function checkResumeHeader_(xhr, opt_allowed) ***REMOVED***
    var status;
    try ***REMOVED***
        status = xhr.getResponseHeader('X-Goog-Upload-Status');
    ***REMOVED***
    catch (e) ***REMOVED***
        handlerCheck(false);
    ***REMOVED***
    var allowed = opt_allowed || ['active'];
    handlerCheck(array.contains(allowed, status));
    return status;
***REMOVED***
export function createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) ***REMOVED***
    var urlPart = location.bucketOnlyServerUrl();
    var metadata = metadataForUpload_(location, blob, opt_metadata);
    var urlParams = ***REMOVED*** name: metadata['fullPath'] ***REMOVED***;
    var url = UrlUtils.makeUploadUrl(urlPart);
    var method = 'POST';
    var headers = ***REMOVED***
        'X-Goog-Upload-Protocol': 'resumable',
        'X-Goog-Upload-Command': 'start',
        'X-Goog-Upload-Header-Content-Length': blob.size(),
        'X-Goog-Upload-Header-Content-Type': metadata['contentType'],
        'Content-Type': 'application/json; charset=utf-8'
    ***REMOVED***;
    var body = MetadataUtils.toResourceString(metadata, mappings);
    var timeout = authWrapper.maxUploadRetryTime();
    function handler(xhr, text) ***REMOVED***
        checkResumeHeader_(xhr);
        var url;
        try ***REMOVED***
            url = xhr.getResponseHeader('X-Goog-Upload-URL');
        ***REMOVED***
        catch (e) ***REMOVED***
            handlerCheck(false);
        ***REMOVED***
        handlerCheck(type.isString(url));
        return url;
    ***REMOVED***
    var requestInfo = new RequestInfo(url, method, handler, timeout);
    requestInfo.urlParams = urlParams;
    requestInfo.headers = headers;
    requestInfo.body = body;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
***REMOVED***
/**
 * @param url From a call to fbs.requests.createResumableUpload.
 */
export function getResumableUploadStatus(authWrapper, location, url, blob) ***REMOVED***
    var headers = ***REMOVED*** 'X-Goog-Upload-Command': 'query' ***REMOVED***;
    function handler(xhr, text) ***REMOVED***
        var status = checkResumeHeader_(xhr, ['active', 'final']);
        var sizeString;
        try ***REMOVED***
            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');
        ***REMOVED***
        catch (e) ***REMOVED***
            handlerCheck(false);
        ***REMOVED***
        var size = parseInt(sizeString, 10);
        handlerCheck(!isNaN(size));
        return new ResumableUploadStatus(size, blob.size(), status === 'final');
    ***REMOVED***
    var method = 'POST';
    var timeout = authWrapper.maxUploadRetryTime();
    var requestInfo = new RequestInfo(url, method, handler, timeout);
    requestInfo.headers = headers;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
***REMOVED***
/**
 * Any uploads via the resumable upload API must transfer a number of bytes
 * that is a multiple of this number.
 */
export var resumableUploadChunkSize = 256 * 1024;
/**
 * @param url From a call to fbs.requests.createResumableUpload.
 * @param chunkSize Number of bytes to upload.
 * @param opt_status The previous status.
 *     If not passed or null, we start from the beginning.
 * @throws fbs.Error If the upload is already complete, the passed in status
 *     has a final size inconsistent with the blob, or the blob cannot be sliced
 *     for upload.
 */
export function continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) ***REMOVED***
    // TODO(andysoto): standardize on internal asserts
    // assert(!(opt_status && opt_status.finalized));
    var status = new ResumableUploadStatus(0, 0);
    if (opt_status) ***REMOVED***
        status.current = opt_status.current;
        status.total = opt_status.total;
    ***REMOVED***
    else ***REMOVED***
        status.current = 0;
        status.total = blob.size();
    ***REMOVED***
    if (blob.size() !== status.total) ***REMOVED***
        throw errorsExports.serverFileWrongSize();
    ***REMOVED***
    var bytesLeft = status.total - status.current;
    var bytesToUpload = bytesLeft;
    if (chunkSize > 0) ***REMOVED***
        bytesToUpload = Math.min(bytesToUpload, chunkSize);
    ***REMOVED***
    var startByte = status.current;
    var endByte = startByte + bytesToUpload;
    var uploadCommand = bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';
    var headers = ***REMOVED***
        'X-Goog-Upload-Command': uploadCommand,
        'X-Goog-Upload-Offset': status.current
    ***REMOVED***;
    var body = blob.slice(startByte, endByte);
    if (body === null) ***REMOVED***
        throw errorsExports.cannotSliceBlob();
    ***REMOVED***
    function handler(xhr, text) ***REMOVED***
        // TODO(andysoto): Verify the MD5 of each uploaded range:
        // the 'x-range-md5' header comes back with status code 308 responses.
        // We'll only be able to bail out though, because you can't re-upload a
        // range that you previously uploaded.
        var uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);
        var newCurrent = status.current + bytesToUpload;
        var size = blob.size();
        var metadata;
        if (uploadStatus === 'final') ***REMOVED***
            metadata = metadataHandler(authWrapper, mappings)(xhr, text);
        ***REMOVED***
        else ***REMOVED***
            metadata = null;
        ***REMOVED***
        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);
    ***REMOVED***
    var method = 'POST';
    var timeout = authWrapper.maxUploadRetryTime();
    var requestInfo = new RequestInfo(url, method, handler, timeout);
    requestInfo.headers = headers;
    requestInfo.body = body.uploadData();
    requestInfo.progressCallback = opt_progressCallback || null;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
***REMOVED***

//# sourceMappingURL=requests.js.map
