/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Defines types for interacting with blob transfer tasks.
 */
import ***REMOVED*** InternalTaskState ***REMOVED*** from './implementation/taskenums';
import ***REMOVED*** Observer ***REMOVED*** from './implementation/observer';
import ***REMOVED*** TaskEvent, TaskState ***REMOVED*** from './implementation/taskenums';
import ***REMOVED*** UploadTaskSnapshot ***REMOVED*** from './tasksnapshot';
import * as fbsArgs from './implementation/args';
import * as fbsArray from './implementation/array';
import ***REMOVED*** async as fbsAsync ***REMOVED*** from './implementation/async';
import * as errors from './implementation/error';
import * as fbsPromiseimpl from './implementation/promise_external';
import * as fbsRequests from './implementation/requests';
import * as fbsTaskEnums from './implementation/taskenums';
import * as typeUtils from './implementation/type';
/**
 * Represents a blob being uploaded. Can be used to pause/resume/cancel the
 * upload and manage callbacks for various events.
 */
var UploadTask = /** @class */ (function () ***REMOVED***
    /**
     * @param ref The firebaseStorage.Reference object this task came
     *     from, untyped to avoid cyclic dependencies.
     * @param blob The blob to upload.
     */
    function UploadTask(ref, authWrapper, location, mappings, blob, metadata) ***REMOVED***
        if (metadata === void 0) ***REMOVED*** metadata = null; ***REMOVED***
        var _this = this;
        this.transferred_ = 0;
        this.needToFetchStatus_ = false;
        this.needToFetchMetadata_ = false;
        this.observers_ = [];
        this.error_ = null;
        this.uploadUrl_ = null;
        this.request_ = null;
        this.chunkMultiplier_ = 1;
        this.resolve_ = null;
        this.reject_ = null;
        this.ref_ = ref;
        this.authWrapper_ = authWrapper;
        this.location_ = location;
        this.blob_ = blob;
        this.metadata_ = metadata;
        this.mappings_ = mappings;
        this.resumable_ = this.shouldDoResumable_(this.blob_);
        this.state_ = InternalTaskState.RUNNING;
        this.errorHandler_ = function (error) ***REMOVED***
            _this.request_ = null;
            _this.chunkMultiplier_ = 1;
            if (error.codeEquals(errors.Code.CANCELED)) ***REMOVED***
                _this.needToFetchStatus_ = true;
                _this.completeTransitions_();
            ***REMOVED***
            else ***REMOVED***
                _this.error_ = error;
                _this.transition_(InternalTaskState.ERROR);
            ***REMOVED***
        ***REMOVED***;
        this.metadataErrorHandler_ = function (error) ***REMOVED***
            _this.request_ = null;
            if (error.codeEquals(errors.Code.CANCELED)) ***REMOVED***
                _this.completeTransitions_();
            ***REMOVED***
            else ***REMOVED***
                _this.error_ = error;
                _this.transition_(InternalTaskState.ERROR);
            ***REMOVED***
        ***REMOVED***;
        this.promise_ = fbsPromiseimpl.make(function (resolve, reject) ***REMOVED***
            _this.resolve_ = resolve;
            _this.reject_ = reject;
            _this.start_();
        ***REMOVED***);
        // Prevent uncaught rejections on the internal promise from bubbling out
        // to the top level with a dummy handler.
        this.promise_.then(null, function () ***REMOVED*** ***REMOVED***);
    ***REMOVED***
    UploadTask.prototype.makeProgressCallback_ = function () ***REMOVED***
        var _this = this;
        var sizeBefore = this.transferred_;
        return function (loaded, total) ***REMOVED***
            _this.updateProgress_(sizeBefore + loaded);
        ***REMOVED***;
    ***REMOVED***;
    UploadTask.prototype.shouldDoResumable_ = function (blob) ***REMOVED***
        return blob.size() > 256 * 1024;
    ***REMOVED***;
    UploadTask.prototype.start_ = function () ***REMOVED***
        if (this.state_ !== InternalTaskState.RUNNING) ***REMOVED***
            // This can happen if someone pauses us in a resume callback, for example.
            return;
        ***REMOVED***
        if (this.request_ !== null) ***REMOVED***
            return;
        ***REMOVED***
        if (this.resumable_) ***REMOVED***
            if (this.uploadUrl_ === null) ***REMOVED***
                this.createResumable_();
            ***REMOVED***
            else ***REMOVED***
                if (this.needToFetchStatus_) ***REMOVED***
                    this.fetchStatus_();
                ***REMOVED***
                else ***REMOVED***
                    if (this.needToFetchMetadata_) ***REMOVED***
                        // Happens if we miss the metadata on upload completion.
                        this.fetchMetadata_();
                    ***REMOVED***
                    else ***REMOVED***
                        this.continueUpload_();
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            this.oneShotUpload_();
        ***REMOVED***
    ***REMOVED***;
    UploadTask.prototype.resolveToken_ = function (callback) ***REMOVED***
        var _this = this;
        this.authWrapper_.getAuthToken().then(function (authToken) ***REMOVED***
            switch (_this.state_) ***REMOVED***
                case InternalTaskState.RUNNING:
                    callback(authToken);
                    break;
                case InternalTaskState.CANCELING:
                    _this.transition_(InternalTaskState.CANCELED);
                    break;
                case InternalTaskState.PAUSING:
                    _this.transition_(InternalTaskState.PAUSED);
                    break;
                default:
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    // TODO(andysoto): assert false
    UploadTask.prototype.createResumable_ = function () ***REMOVED***
        var _this = this;
        this.resolveToken_(function (authToken) ***REMOVED***
            var requestInfo = fbsRequests.createResumableUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
            var createRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = createRequest;
            createRequest.getPromise().then(function (url) ***REMOVED***
                _this.request_ = null;
                _this.uploadUrl_ = url;
                _this.needToFetchStatus_ = false;
                _this.completeTransitions_();
            ***REMOVED***, _this.errorHandler_);
        ***REMOVED***);
    ***REMOVED***;
    UploadTask.prototype.fetchStatus_ = function () ***REMOVED***
        var _this = this;
        // TODO(andysoto): assert(this.uploadUrl_ !== null);
        var url = this.uploadUrl_;
        this.resolveToken_(function (authToken) ***REMOVED***
            var requestInfo = fbsRequests.getResumableUploadStatus(_this.authWrapper_, _this.location_, url, _this.blob_);
            var statusRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = statusRequest;
            statusRequest.getPromise().then(function (status) ***REMOVED***
                status = status;
                _this.request_ = null;
                _this.updateProgress_(status.current);
                _this.needToFetchStatus_ = false;
                if (status.finalized) ***REMOVED***
                    _this.needToFetchMetadata_ = true;
                ***REMOVED***
                _this.completeTransitions_();
            ***REMOVED***, _this.errorHandler_);
        ***REMOVED***);
    ***REMOVED***;
    UploadTask.prototype.continueUpload_ = function () ***REMOVED***
        var _this = this;
        var chunkSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;
        var status = new fbsRequests.ResumableUploadStatus(this.transferred_, this.blob_.size());
        // TODO(andysoto): assert(this.uploadUrl_ !== null);
        var url = this.uploadUrl_;
        this.resolveToken_(function (authToken) ***REMOVED***
            var requestInfo;
            try ***REMOVED***
                requestInfo = fbsRequests.continueResumableUpload(_this.location_, _this.authWrapper_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());
            ***REMOVED***
            catch (e) ***REMOVED***
                _this.error_ = e;
                _this.transition_(InternalTaskState.ERROR);
                return;
            ***REMOVED***
            var uploadRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = uploadRequest;
            uploadRequest
                .getPromise()
                .then(function (newStatus) ***REMOVED***
                _this.increaseMultiplier_();
                _this.request_ = null;
                _this.updateProgress_(newStatus.current);
                if (newStatus.finalized) ***REMOVED***
                    _this.metadata_ = newStatus.metadata;
                    _this.transition_(InternalTaskState.SUCCESS);
                ***REMOVED***
                else ***REMOVED***
                    _this.completeTransitions_();
                ***REMOVED***
            ***REMOVED***, _this.errorHandler_);
        ***REMOVED***);
    ***REMOVED***;
    UploadTask.prototype.increaseMultiplier_ = function () ***REMOVED***
        var currentSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;
        // Max chunk size is 32M.
        if (currentSize < 32 * 1024 * 1024) ***REMOVED***
            this.chunkMultiplier_ *= 2;
        ***REMOVED***
    ***REMOVED***;
    UploadTask.prototype.fetchMetadata_ = function () ***REMOVED***
        var _this = this;
        this.resolveToken_(function (authToken) ***REMOVED***
            var requestInfo = fbsRequests.getMetadata(_this.authWrapper_, _this.location_, _this.mappings_);
            var metadataRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = metadataRequest;
            metadataRequest.getPromise().then(function (metadata) ***REMOVED***
                _this.request_ = null;
                _this.metadata_ = metadata;
                _this.transition_(InternalTaskState.SUCCESS);
            ***REMOVED***, _this.metadataErrorHandler_);
        ***REMOVED***);
    ***REMOVED***;
    UploadTask.prototype.oneShotUpload_ = function () ***REMOVED***
        var _this = this;
        this.resolveToken_(function (authToken) ***REMOVED***
            var requestInfo = fbsRequests.multipartUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
            var multipartRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = multipartRequest;
            multipartRequest.getPromise().then(function (metadata) ***REMOVED***
                _this.request_ = null;
                _this.metadata_ = metadata;
                _this.updateProgress_(_this.blob_.size());
                _this.transition_(InternalTaskState.SUCCESS);
            ***REMOVED***, _this.errorHandler_);
        ***REMOVED***);
    ***REMOVED***;
    UploadTask.prototype.updateProgress_ = function (transferred) ***REMOVED***
        var old = this.transferred_;
        this.transferred_ = transferred;
        // A progress update can make the "transferred" value smaller (e.g. a
        // partial upload not completed by server, after which the "transferred"
        // value may reset to the value at the beginning of the request).
        if (this.transferred_ !== old) ***REMOVED***
            this.notifyObservers_();
        ***REMOVED***
    ***REMOVED***;
    UploadTask.prototype.transition_ = function (state) ***REMOVED***
        if (this.state_ === state) ***REMOVED***
            return;
        ***REMOVED***
        switch (state) ***REMOVED***
            case InternalTaskState.CANCELING:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING);
                this.state_ = state;
                if (this.request_ !== null) ***REMOVED***
                    this.request_.cancel();
                ***REMOVED***
                break;
            case InternalTaskState.PAUSING:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING);
                this.state_ = state;
                if (this.request_ !== null) ***REMOVED***
                    this.request_.cancel();
                ***REMOVED***
                break;
            case InternalTaskState.RUNNING:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSED ||
                //        this.state_ === InternalTaskState.PAUSING);
                var wasPaused = this.state_ === InternalTaskState.PAUSED;
                this.state_ = state;
                if (wasPaused) ***REMOVED***
                    this.notifyObservers_();
                    this.start_();
                ***REMOVED***
                break;
            case InternalTaskState.PAUSED:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSING);
                this.state_ = state;
                this.notifyObservers_();
                break;
            case InternalTaskState.CANCELED:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSED ||
                //        this.state_ === InternalTaskState.CANCELING);
                this.error_ = errors.canceled();
                this.state_ = state;
                this.notifyObservers_();
                break;
            case InternalTaskState.ERROR:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING ||
                //        this.state_ === InternalTaskState.CANCELING);
                this.state_ = state;
                this.notifyObservers_();
                break;
            case InternalTaskState.SUCCESS:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING ||
                //        this.state_ === InternalTaskState.CANCELING);
                this.state_ = state;
                this.notifyObservers_();
                break;
        ***REMOVED***
    ***REMOVED***;
    UploadTask.prototype.completeTransitions_ = function () ***REMOVED***
        switch (this.state_) ***REMOVED***
            case InternalTaskState.PAUSING:
                this.transition_(InternalTaskState.PAUSED);
                break;
            case InternalTaskState.CANCELING:
                this.transition_(InternalTaskState.CANCELED);
                break;
            case InternalTaskState.RUNNING:
                this.start_();
                break;
            default:
                // TODO(andysoto): assert(false);
                break;
        ***REMOVED***
    ***REMOVED***;
    Object.defineProperty(UploadTask.prototype, "snapshot", ***REMOVED***
        get: function () ***REMOVED***
            var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);
            return new UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /**
     * Adds a callback for an event.
     * @param type The type of event to listen for.
     */
    UploadTask.prototype.on = function (type, nextOrObserver, error, completed) ***REMOVED***
        if (nextOrObserver === void 0) ***REMOVED*** nextOrObserver = undefined; ***REMOVED***
        if (error === void 0) ***REMOVED*** error = undefined; ***REMOVED***
        if (completed === void 0) ***REMOVED*** completed = undefined; ***REMOVED***
        function typeValidator(_p) ***REMOVED***
            if (type !== TaskEvent.STATE_CHANGED) ***REMOVED***
                throw "Expected one of the event types: [" + TaskEvent.STATE_CHANGED + "].";
            ***REMOVED***
        ***REMOVED***
        var nextOrObserverMessage = 'Expected a function or an Object with one of ' +
            '`next`, `error`, `complete` properties.';
        var nextValidator = fbsArgs.nullFunctionSpec(true).validator;
        var observerValidator = fbsArgs.looseObjectSpec(null, true).validator;
        function nextOrObserverValidator(p) ***REMOVED***
            try ***REMOVED***
                nextValidator(p);
                return;
            ***REMOVED***
            catch (e) ***REMOVED*** ***REMOVED***
            try ***REMOVED***
                observerValidator(p);
                var anyDefined = typeUtils.isJustDef(p['next']) ||
                    typeUtils.isJustDef(p['error']) ||
                    typeUtils.isJustDef(p['complete']);
                if (!anyDefined) ***REMOVED***
                    throw '';
                ***REMOVED***
                return;
            ***REMOVED***
            catch (e) ***REMOVED***
                throw nextOrObserverMessage;
            ***REMOVED***
        ***REMOVED***
        var specs = [
            fbsArgs.stringSpec(typeValidator),
            fbsArgs.looseObjectSpec(nextOrObserverValidator, true),
            fbsArgs.nullFunctionSpec(true),
            fbsArgs.nullFunctionSpec(true)
        ];
        fbsArgs.validate('on', specs, arguments);
        var self = this;
        function makeBinder(specs) ***REMOVED***
            function binder(nextOrObserver, error, opt_complete) ***REMOVED***
                if (specs !== null) ***REMOVED***
                    fbsArgs.validate('on', specs, arguments);
                ***REMOVED***
                var observer = new Observer(nextOrObserver, error, completed);
                self.addObserver_(observer);
                return function () ***REMOVED***
                    self.removeObserver_(observer);
                ***REMOVED***;
            ***REMOVED***
            return binder;
        ***REMOVED***
        function binderNextOrObserverValidator(p) ***REMOVED***
            if (p === null) ***REMOVED***
                throw nextOrObserverMessage;
            ***REMOVED***
            nextOrObserverValidator(p);
        ***REMOVED***
        var binderSpecs = [
            fbsArgs.looseObjectSpec(binderNextOrObserverValidator),
            fbsArgs.nullFunctionSpec(true),
            fbsArgs.nullFunctionSpec(true)
        ];
        var typeOnly = !(typeUtils.isJustDef(nextOrObserver) ||
            typeUtils.isJustDef(error) ||
            typeUtils.isJustDef(completed));
        if (typeOnly) ***REMOVED***
            return makeBinder(binderSpecs);
        ***REMOVED***
        else ***REMOVED***
            return makeBinder(null)(nextOrObserver, error, completed);
        ***REMOVED***
    ***REMOVED***;
    /**
     * This object behaves like a Promise, and resolves with its snapshot data
     * when the upload completes.
     * @param onFulfilled The fulfillment callback. Promise chaining works as normal.
     * @param onRejected The rejection callback.
     */
    UploadTask.prototype.then = function (onFulfilled, onRejected) ***REMOVED***
        // These casts are needed so that TypeScript can infer the types of the
        // resulting Promise.
        return this.promise_.then(onFulfilled, onRejected);
    ***REMOVED***;
    /**
     * Equivalent to calling `then(null, onRejected)`.
     */
    UploadTask.prototype.catch = function (onRejected) ***REMOVED***
        return this.then(null, onRejected);
    ***REMOVED***;
    /**
     * Adds the given observer.
     */
    UploadTask.prototype.addObserver_ = function (observer) ***REMOVED***
        this.observers_.push(observer);
        this.notifyObserver_(observer);
    ***REMOVED***;
    /**
     * Removes the given observer.
     */
    UploadTask.prototype.removeObserver_ = function (observer) ***REMOVED***
        fbsArray.remove(this.observers_, observer);
    ***REMOVED***;
    UploadTask.prototype.notifyObservers_ = function () ***REMOVED***
        var _this = this;
        this.finishPromise_();
        var observers = fbsArray.clone(this.observers_);
        observers.forEach(function (observer) ***REMOVED***
            _this.notifyObserver_(observer);
        ***REMOVED***);
    ***REMOVED***;
    UploadTask.prototype.finishPromise_ = function () ***REMOVED***
        if (this.resolve_ !== null) ***REMOVED***
            var triggered = true;
            switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) ***REMOVED***
                case TaskState.SUCCESS:
                    fbsAsync(this.resolve_.bind(null, this.snapshot))();
                    break;
                case TaskState.CANCELED:
                case TaskState.ERROR:
                    var toCall = this.reject_;
                    fbsAsync(toCall.bind(null, this.error_))();
                    break;
                default:
                    triggered = false;
                    break;
            ***REMOVED***
            if (triggered) ***REMOVED***
                this.resolve_ = null;
                this.reject_ = null;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    UploadTask.prototype.notifyObserver_ = function (observer) ***REMOVED***
        var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);
        switch (externalState) ***REMOVED***
            case TaskState.RUNNING:
            case TaskState.PAUSED:
                if (observer.next !== null) ***REMOVED***
                    fbsAsync(observer.next.bind(observer, this.snapshot))();
                ***REMOVED***
                break;
            case TaskState.SUCCESS:
                if (observer.complete !== null) ***REMOVED***
                    fbsAsync(observer.complete.bind(observer))();
                ***REMOVED***
                break;
            case TaskState.CANCELED:
            case TaskState.ERROR:
                if (observer.error !== null) ***REMOVED***
                    fbsAsync(observer.error.bind(observer, this.error_))();
                ***REMOVED***
                break;
            default:
                // TODO(andysoto): assert(false);
                if (observer.error !== null) ***REMOVED***
                    fbsAsync(observer.error.bind(observer, this.error_))();
                ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Resumes a paused task. Has no effect on a currently running or failed task.
     * @return True if the operation took effect, false if ignored.
     */
    UploadTask.prototype.resume = function () ***REMOVED***
        fbsArgs.validate('resume', [], arguments);
        var valid = this.state_ === InternalTaskState.PAUSED ||
            this.state_ === InternalTaskState.PAUSING;
        if (valid) ***REMOVED***
            this.transition_(InternalTaskState.RUNNING);
        ***REMOVED***
        return valid;
    ***REMOVED***;
    /**
     * Pauses a currently running task. Has no effect on a paused or failed task.
     * @return True if the operation took effect, false if ignored.
     */
    UploadTask.prototype.pause = function () ***REMOVED***
        fbsArgs.validate('pause', [], arguments);
        var valid = this.state_ === InternalTaskState.RUNNING;
        if (valid) ***REMOVED***
            this.transition_(InternalTaskState.PAUSING);
        ***REMOVED***
        return valid;
    ***REMOVED***;
    /**
     * Cancels a currently running or paused task. Has no effect on a complete or
     * failed task.
     * @return True if the operation took effect, false if ignored.
     */
    UploadTask.prototype.cancel = function () ***REMOVED***
        fbsArgs.validate('cancel', [], arguments);
        var valid = this.state_ === InternalTaskState.RUNNING ||
            this.state_ === InternalTaskState.PAUSING;
        if (valid) ***REMOVED***
            this.transition_(InternalTaskState.CANCELING);
        ***REMOVED***
        return valid;
    ***REMOVED***;
    return UploadTask;
***REMOVED***());
export ***REMOVED*** UploadTask ***REMOVED***;

//# sourceMappingURL=task.js.map
