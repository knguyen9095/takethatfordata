/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var db_interface_1 = require("./db-interface");
var errors_1 = require("./errors");
var array_buffer_to_base64_1 = require("../helpers/array-buffer-to-base64");
var FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';
var DB_VERSION = 1;
/** @record */
function ValidateInput() ***REMOVED*** ***REMOVED***
/** @type ***REMOVED***string|undefined***REMOVED*** */
ValidateInput.prototype.fcmToken;
/** @type ***REMOVED***string|undefined***REMOVED*** */
ValidateInput.prototype.swScope;
/** @type ***REMOVED***string|undefined***REMOVED*** */
ValidateInput.prototype.vapidKey;
/** @type ***REMOVED***PushSubscription|undefined***REMOVED*** */
ValidateInput.prototype.subscription;
/** @type ***REMOVED***string|undefined***REMOVED*** */
ValidateInput.prototype.fcmSenderId;
/** @type ***REMOVED***string|undefined***REMOVED*** */
ValidateInput.prototype.fcmPushSet;
var TokenDetailsModel = /** @class */ (function (_super) ***REMOVED***
    __extends(TokenDetailsModel, _super);
    function TokenDetailsModel() ***REMOVED***
        return _super.call(this, TokenDetailsModel.dbName, DB_VERSION) || this;
    ***REMOVED***
    Object.defineProperty(TokenDetailsModel, "dbName", ***REMOVED***
        get: function () ***REMOVED***
            return 'fcm_token_details_db';
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /**
     * @override
     */
    TokenDetailsModel.prototype.onDBUpgrade = function (db) ***REMOVED***
        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, ***REMOVED***
            keyPath: 'swScope'
        ***REMOVED***);
        // Make sure the sender ID can be searched
        objectStore.createIndex('fcmSenderId', 'fcmSenderId', ***REMOVED***
            unique: false
        ***REMOVED***);
        objectStore.createIndex('fcmToken', 'fcmToken', ***REMOVED***
            unique: true
        ***REMOVED***);
    ***REMOVED***;
    /**
     * This method takes an object and will check for known arguments and
     * validate the input.
     * @private
     * @param ***REMOVED***!ValidateInput***REMOVED*** input
     * @return ***REMOVED***!Promise***REMOVED*** Returns promise that resolves if input is valid,
     * rejects otherwise.
     */
    TokenDetailsModel.prototype.validateInputs_ = function (input) ***REMOVED***
        if (input.fcmToken) ***REMOVED***
            if (typeof input.fcmToken !== 'string' || input.fcmToken.length === 0) ***REMOVED***
                return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_TOKEN));
            ***REMOVED***
        ***REMOVED***
        if (input.swScope) ***REMOVED***
            if (typeof input.swScope !== 'string' || input.swScope.length === 0) ***REMOVED***
                return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_SCOPE));
            ***REMOVED***
        ***REMOVED***
        if (input.vapidKey) ***REMOVED***
            if (typeof input.vapidKey !== 'string' || input.vapidKey.length === 0) ***REMOVED***
                return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_VAPID_KEY));
            ***REMOVED***
        ***REMOVED***
        if (input.subscription) ***REMOVED***
            if (!(input.subscription instanceof PushSubscription)) ***REMOVED***
                return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_SUBSCRIPTION));
            ***REMOVED***
        ***REMOVED***
        if (input.fcmSenderId) ***REMOVED***
            if (typeof input.fcmSenderId !== 'string' ||
                input.fcmSenderId.length === 0) ***REMOVED***
                return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_SENDER_ID));
            ***REMOVED***
        ***REMOVED***
        if (input.fcmPushSet) ***REMOVED***
            if (typeof input.fcmPushSet !== 'string' ||
                input.fcmPushSet.length === 0) ***REMOVED***
                return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_PUSH_SET));
            ***REMOVED***
        ***REMOVED***
        return Promise.resolve();
    ***REMOVED***;
    /**
     * Given a token, this method will look up the details in indexedDB.
     * @param ***REMOVED***string***REMOVED*** fcmToken
     * @return ***REMOVED***Promise<Object>***REMOVED*** The details associated with that token.
     */
    TokenDetailsModel.prototype.getTokenDetailsFromToken = function (fcmToken) ***REMOVED***
        var _this = this;
        if (!fcmToken) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_TOKEN));
        ***REMOVED***
        return this.validateInputs_(***REMOVED*** fcmToken: fcmToken ***REMOVED***)
            .then(function () ***REMOVED***
            return _this.openDatabase();
        ***REMOVED***)
            .then(function (db) ***REMOVED***
            return new Promise(function (resolve, reject) ***REMOVED***
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var index = objectStore.index('fcmToken');
                var request = index.get(fcmToken);
                request.onerror = function (event) ***REMOVED***
                    reject(event.target.error);
                ***REMOVED***;
                request.onsuccess = function (event) ***REMOVED***
                    var result = event.target.result
                        ? event.target.result
                        : null;
                    resolve(result);
                ***REMOVED***;
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Given a service worker scope, this method will look up the details in
     * indexedDB.
     * @public
     * @param ***REMOVED***string***REMOVED*** swScope
     * @return ***REMOVED***Promise<Object>***REMOVED*** The details associated with that token.
     */
    TokenDetailsModel.prototype.getTokenDetailsFromSWScope = function (swScope) ***REMOVED***
        var _this = this;
        if (!swScope) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_SCOPE));
        ***REMOVED***
        return this.validateInputs_(***REMOVED*** swScope: swScope ***REMOVED***)
            .then(function () ***REMOVED***
            return _this.openDatabase();
        ***REMOVED***)
            .then(function (db) ***REMOVED***
            return new Promise(function (resolve, reject) ***REMOVED***
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var scopeRequest = objectStore.get(swScope);
                scopeRequest.onerror = function (event) ***REMOVED***
                    reject(event.target.error);
                ***REMOVED***;
                scopeRequest.onsuccess = function (event) ***REMOVED***
                    var result = event.target.result
                        ? event.target.result
                        : null;
                    resolve(result);
                ***REMOVED***;
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Save the details for the fcm token for re-use at a later date.
     * @param ***REMOVED******REMOVED***swScope: !string, vapidKey: !string,
     * subscription: !PushSubscription, fcmSenderId: !string, fcmToken: !string,
     * fcmPushSet: !string***REMOVED******REMOVED*** input A plain js object containing args to save.
     * @return ***REMOVED***Promise<void>***REMOVED***
     */
    TokenDetailsModel.prototype.saveTokenDetails = function (_a) ***REMOVED***
        var _this = this;
        var swScope = _a.swScope, vapidKey = _a.vapidKey, subscription = _a.subscription, fcmSenderId = _a.fcmSenderId, fcmToken = _a.fcmToken, fcmPushSet = _a.fcmPushSet;
        if (!swScope) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_SCOPE));
        ***REMOVED***
        if (!vapidKey) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_VAPID_KEY));
        ***REMOVED***
        if (!subscription) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_SUBSCRIPTION));
        ***REMOVED***
        if (!fcmSenderId) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_SENDER_ID));
        ***REMOVED***
        if (!fcmToken) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_TOKEN));
        ***REMOVED***
        if (!fcmPushSet) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_PUSH_SET));
        ***REMOVED***
        return this.validateInputs_(***REMOVED***
            swScope: swScope,
            vapidKey: vapidKey,
            subscription: subscription,
            fcmSenderId: fcmSenderId,
            fcmToken: fcmToken,
            fcmPushSet: fcmPushSet
        ***REMOVED***)
            .then(function () ***REMOVED***
            return _this.openDatabase();
        ***REMOVED***)
            .then(function (db) ***REMOVED***
            /**
             * @dict
             */
            var details = ***REMOVED***
                swScope: swScope,
                vapidKey: vapidKey,
                endpoint: subscription.endpoint,
                auth: array_buffer_to_base64_1.default(subscription['getKey']('auth')),
                p256dh: array_buffer_to_base64_1.default(subscription['getKey']('p256dh')),
                fcmSenderId: fcmSenderId,
                fcmToken: fcmToken,
                fcmPushSet: fcmPushSet
            ***REMOVED***;
            return new Promise(function (resolve, reject) ***REMOVED***
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], _this.TRANSACTION_READ_WRITE);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var request = objectStore.put(details);
                request.onerror = function (event) ***REMOVED***
                    reject(event.target.error);
                ***REMOVED***;
                request.onsuccess = function (event) ***REMOVED***
                    resolve();
                ***REMOVED***;
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * This method deletes details of the current FCM token.
     * It's returning a promise in case we need to move to an async
     * method for deleting at a later date.
     * @param ***REMOVED***string***REMOVED*** token Token to be deleted
     * @return ***REMOVED***Promise<Object>***REMOVED*** Resolves once the FCM token details have been
     * deleted and returns the deleted details.
     */
    TokenDetailsModel.prototype.deleteToken = function (token) ***REMOVED***
        var _this = this;
        if (typeof token !== 'string' || token.length === 0) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.INVALID_DELETE_TOKEN));
        ***REMOVED***
        return this.getTokenDetailsFromToken(token).then(function (details) ***REMOVED***
            if (!details) ***REMOVED***
                throw _this.errorFactory_.create(errors_1.default.codes.DELETE_TOKEN_NOT_FOUND);
            ***REMOVED***
            return _this.openDatabase().then(function (db) ***REMOVED***
                return new Promise(function (resolve, reject) ***REMOVED***
                    var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], _this.TRANSACTION_READ_WRITE);
                    var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                    var request = objectStore.delete(details['swScope']);
                    request.onerror = function (event) ***REMOVED***
                        reject(event.target.error);
                    ***REMOVED***;
                    request.onsuccess = function (event) ***REMOVED***
                        if (event.target.result === 0) ***REMOVED***
                            reject(_this.errorFactory_.create(errors_1.default.codes.FAILED_TO_DELETE_TOKEN));
                            return;
                        ***REMOVED***
                        resolve(details);
                    ***REMOVED***;
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    return TokenDetailsModel;
***REMOVED***(db_interface_1.default));
exports.default = TokenDetailsModel;

//# sourceMappingURL=token-details-model.js.map
