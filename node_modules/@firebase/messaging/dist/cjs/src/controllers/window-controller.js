/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var controller_interface_1 = require("./controller-interface");
var errors_1 = require("../models/errors");
var worker_page_message_1 = require("../models/worker-page-message");
var default_sw_1 = require("../models/default-sw");
var notification_permission_1 = require("../models/notification-permission");
var util_1 = require("@firebase/util");
var WindowController = /** @class */ (function (_super) ***REMOVED***
    __extends(WindowController, _super);
    /**
     * A service that provides a MessagingService instance.
     * @param ***REMOVED***!firebase.app.App***REMOVED*** app
     */
    function WindowController(app) ***REMOVED***
        var _this = _super.call(this, app) || this;
        _this.messageObserver_ = null;
        _this.onMessage_ = util_1.createSubscribe(function (observer) ***REMOVED***
            _this.messageObserver_ = observer;
        ***REMOVED***);
        _this.tokenRefreshObserver_ = null;
        _this.onTokenRefresh_ = util_1.createSubscribe(function (observer) ***REMOVED***
            _this.tokenRefreshObserver_ = observer;
        ***REMOVED***);
        _this.setupSWMessageListener_();
        return _this;
    ***REMOVED***
    /**
     * This method returns an FCM token if it can be generated.
     * The return promise will reject if the browser doesn't support
     * FCM, if permission is denied for notifications or it's not
     * possible to generate a token.
     * @export
     * @return ***REMOVED***Promise<string> | Promise<null>***REMOVED*** Returns a promise the
     * resolves to an FCM token or null if permission isn't granted.
     */
    WindowController.prototype.getToken = function () ***REMOVED***
        var _this = this;
        // Check that the required API's are available
        if (!this.isSupported_()) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.UNSUPPORTED_BROWSER));
        ***REMOVED***
        return this.manifestCheck_().then(function () ***REMOVED***
            return _super.prototype.getToken.call(_this);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * The method checks that a manifest is defined and has the correct GCM
     * sender ID.
     * @private
     * @return ***REMOVED***Promise***REMOVED*** Returns a promise that resolves if the manifest matches
     * our required sender ID
     */
    WindowController.prototype.manifestCheck_ = function () ***REMOVED***
        var _this = this;
        if (this.manifestCheckPromise_) ***REMOVED***
            return this.manifestCheckPromise_;
        ***REMOVED***
        var manifestTag = document.querySelector('link[rel="manifest"]');
        if (!manifestTag) ***REMOVED***
            this.manifestCheckPromise_ = Promise.resolve();
        ***REMOVED***
        else ***REMOVED***
            this.manifestCheckPromise_ = fetch(manifestTag.href)
                .then(function (response) ***REMOVED***
                return response.json();
            ***REMOVED***)
                .catch(function () ***REMOVED***
                // If the download or parsing fails allow check.
                // We only want to error if we KNOW that the gcm_sender_id is incorrect.
                return Promise.resolve();
            ***REMOVED***)
                .then(function (manifestContent) ***REMOVED***
                if (!manifestContent) ***REMOVED***
                    return;
                ***REMOVED***
                if (!manifestContent['gcm_sender_id']) ***REMOVED***
                    return;
                ***REMOVED***
                if (manifestContent['gcm_sender_id'] !== '103953800507') ***REMOVED***
                    throw _this.errorFactory_.create(errors_1.default.codes.INCORRECT_GCM_SENDER_ID);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
        return this.manifestCheckPromise_;
    ***REMOVED***;
    /**
     * Request permission if it is not currently granted
     * @export
     * @returns ***REMOVED***Promise***REMOVED*** Resolves if the permission was granted, otherwise
     * rejects
     */
    WindowController.prototype.requestPermission = function () ***REMOVED***
        var _this = this;
        if (Notification.permission === notification_permission_1.default.granted) ***REMOVED***
            return Promise.resolve();
        ***REMOVED***
        return new Promise(function (resolve, reject) ***REMOVED***
            var managePermissionResult = function (result) ***REMOVED***
                if (result === notification_permission_1.default.granted) ***REMOVED***
                    return resolve();
                ***REMOVED***
                else if (result === notification_permission_1.default.denied) ***REMOVED***
                    return reject(_this.errorFactory_.create(errors_1.default.codes.PERMISSION_BLOCKED));
                ***REMOVED***
                else ***REMOVED***
                    return reject(_this.errorFactory_.create(errors_1.default.codes.PERMISSION_DEFAULT));
                ***REMOVED***
            ***REMOVED***;
            // The Notification.requestPermission API was changed to
            // return a promise so now have to handle both in case
            // browsers stop support callbacks for promised version
            var permissionPromise = Notification.requestPermission(function (result) ***REMOVED***
                if (permissionPromise) ***REMOVED***
                    // Let the promise manage this
                    return;
                ***REMOVED***
                managePermissionResult(result);
            ***REMOVED***);
            if (permissionPromise) ***REMOVED***
                // Prefer the promise version as it's the future API.
                permissionPromise.then(managePermissionResult);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /**
     * This method allows a developer to override the default service worker and
     * instead use a custom service worker.
     * @export
     * @param ***REMOVED***!ServiceWorkerRegistration***REMOVED*** registration The service worker
     * registration that should be used to receive the push messages.
     */
    WindowController.prototype.useServiceWorker = function (registration) ***REMOVED***
        if (!(registration instanceof ServiceWorkerRegistration)) ***REMOVED***
            throw this.errorFactory_.create(errors_1.default.codes.SW_REGISTRATION_EXPECTED);
        ***REMOVED***
        if (typeof this.registrationToUse_ !== 'undefined') ***REMOVED***
            throw this.errorFactory_.create(errors_1.default.codes.USE_SW_BEFORE_GET_TOKEN);
        ***REMOVED***
        this.registrationToUse_ = registration;
    ***REMOVED***;
    /**
     * @export
     * @param ***REMOVED***!firebase.Observer|function(*)***REMOVED*** nextOrObserver An observer object
     * or a function triggered on message.
     * @param ***REMOVED***function(!Error)=***REMOVED*** optError Optional A function triggered on
     * message error.
     * @param ***REMOVED***function()=***REMOVED*** optCompleted Optional function triggered when the
     * observer is removed.
     * @return ***REMOVED***!function()***REMOVED*** The unsubscribe function for the observer.
     */
    WindowController.prototype.onMessage = function (nextOrObserver, optError, optCompleted) ***REMOVED***
        return this.onMessage_(nextOrObserver, optError, optCompleted);
    ***REMOVED***;
    /**
     * @export
     * @param ***REMOVED***!firebase.Observer|function()***REMOVED*** nextOrObserver An observer object
     * or a function triggered on token refresh.
     * @param ***REMOVED***function(!Error)=***REMOVED*** optError Optional A function
     * triggered on token refresh error.
     * @param ***REMOVED***function()=***REMOVED*** optCompleted Optional function triggered when the
     * observer is removed.
     * @return ***REMOVED***!function()***REMOVED*** The unsubscribe function for the observer.
     */
    WindowController.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) ***REMOVED***
        return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);
    ***REMOVED***;
    /**
     * Given a registration, wait for the service worker it relates to
     * become activer
     * @private
     * @param  ***REMOVED***ServiceWorkerRegistration***REMOVED*** registration Registration to wait
     * for service worker to become active
     * @return ***REMOVED***Promise<!ServiceWorkerRegistration>***REMOVED*** Wait for service worker
     * registration to become active
     */
    WindowController.prototype.waitForRegistrationToActivate_ = function (registration) ***REMOVED***
        var _this = this;
        var serviceWorker = registration.installing || registration.waiting || registration.active;
        return new Promise(function (resolve, reject) ***REMOVED***
            if (!serviceWorker) ***REMOVED***
                // This is a rare scenario but has occured in firefox
                reject(_this.errorFactory_.create(errors_1.default.codes.NO_SW_IN_REG));
                return;
            ***REMOVED***
            // Because the Promise function is called on next tick there is a
            // small chance that the worker became active or redundant already.
            if (serviceWorker.state === 'activated') ***REMOVED***
                resolve(registration);
                return;
            ***REMOVED***
            if (serviceWorker.state === 'redundant') ***REMOVED***
                reject(_this.errorFactory_.create(errors_1.default.codes.SW_REG_REDUNDANT));
                return;
            ***REMOVED***
            var stateChangeListener = function () ***REMOVED***
                if (serviceWorker.state === 'activated') ***REMOVED***
                    resolve(registration);
                ***REMOVED***
                else if (serviceWorker.state === 'redundant') ***REMOVED***
                    reject(_this.errorFactory_.create(errors_1.default.codes.SW_REG_REDUNDANT));
                ***REMOVED***
                else ***REMOVED***
                    // Return early and wait to next state change
                    return;
                ***REMOVED***
                serviceWorker.removeEventListener('statechange', stateChangeListener);
            ***REMOVED***;
            serviceWorker.addEventListener('statechange', stateChangeListener);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * This will regiater the default service worker and return the registration
     * @private
     * @return ***REMOVED***Promise<!ServiceWorkerRegistration>***REMOVED*** The service worker
     * registration to be used for the push service.
     */
    WindowController.prototype.getSWRegistration_ = function () ***REMOVED***
        var _this = this;
        if (this.registrationToUse_) ***REMOVED***
            return this.waitForRegistrationToActivate_(this.registrationToUse_);
        ***REMOVED***
        // Make the registration null so we know useServiceWorker will not
        // use a new service worker as registrationToUse_ is no longer undefined
        this.registrationToUse_ = null;
        return navigator.serviceWorker
            .register(default_sw_1.default.path, ***REMOVED***
            scope: default_sw_1.default.scope
        ***REMOVED***)
            .catch(function (err) ***REMOVED***
            throw _this.errorFactory_.create(errors_1.default.codes.FAILED_DEFAULT_REGISTRATION, ***REMOVED***
                browserErrorMessage: err.message
            ***REMOVED***);
        ***REMOVED***)
            .then(function (registration) ***REMOVED***
            return _this.waitForRegistrationToActivate_(registration).then(function () ***REMOVED***
                _this.registrationToUse_ = registration;
                // We update after activation due to an issue with Firefox v49 where
                // a race condition occassionally causes the service work to not
                // install
                registration.update();
                return registration;
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * This method will set up a message listener to handle
     * events from the service worker that should trigger
     * events in the page.
     *
     * @private
     */
    WindowController.prototype.setupSWMessageListener_ = function () ***REMOVED***
        var _this = this;
        if (!('serviceWorker' in navigator)) ***REMOVED***
            return;
        ***REMOVED***
        navigator.serviceWorker.addEventListener('message', function (event) ***REMOVED***
            if (!event.data || !event.data[worker_page_message_1.default.PARAMS.TYPE_OF_MSG]) ***REMOVED***
                // Not a message from FCM
                return;
            ***REMOVED***
            var workerPageMessage = event.data;
            switch (workerPageMessage[worker_page_message_1.default.PARAMS.TYPE_OF_MSG]) ***REMOVED***
                case worker_page_message_1.default.TYPES_OF_MSG.PUSH_MSG_RECEIVED:
                case worker_page_message_1.default.TYPES_OF_MSG.NOTIFICATION_CLICKED:
                    var pushMessage = workerPageMessage[worker_page_message_1.default.PARAMS.DATA];
                    _this.messageObserver_.next(pushMessage);
                    break;
                default:
                    // Noop.
                    break;
            ***REMOVED***
        ***REMOVED***, false);
    ***REMOVED***;
    /**
     * Checks to see if the required API's are valid or not.
     * @private
     * @return ***REMOVED***boolean***REMOVED*** Returns true if the desired APIs are available.
     */
    WindowController.prototype.isSupported_ = function () ***REMOVED***
        return ('serviceWorker' in navigator &&
            'PushManager' in window &&
            'Notification' in window &&
            'fetch' in window &&
            ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&
            PushSubscription.prototype.hasOwnProperty('getKey'));
    ***REMOVED***;
    return WindowController;
***REMOVED***(controller_interface_1.default));
exports.default = WindowController;

//# sourceMappingURL=window-controller.js.map
