/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
import ***REMOVED*** ErrorFactory ***REMOVED*** from '@firebase/util';
import Errors from './errors';
import arrayBufferToBase64 from '../helpers/array-buffer-to-base64';
import FCMDetails from './fcm-details';
var FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';
var FCM_TOKEN_DETAILS_DB_VERSION = 1;
var TokenManager = /** @class */ (function () ***REMOVED***
    function TokenManager() ***REMOVED***
        this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);
        this.openDbPromise_ = null;
    ***REMOVED***
    /**
     * Get the indexedDB as a promsie.
     * @private
     * @return ***REMOVED***Promise<IDBDatabase>***REMOVED*** The IndexedDB database
     */
    TokenManager.prototype.openDatabase_ = function () ***REMOVED***
        if (this.openDbPromise_) ***REMOVED***
            return this.openDbPromise_;
        ***REMOVED***
        this.openDbPromise_ = new Promise(function (resolve, reject) ***REMOVED***
            var request = indexedDB.open(TokenManager.DB_NAME, FCM_TOKEN_DETAILS_DB_VERSION);
            request.onerror = function (event) ***REMOVED***
                reject(event.target.error);
            ***REMOVED***;
            request.onsuccess = function (event) ***REMOVED***
                resolve(event.target.result);
            ***REMOVED***;
            request.onupgradeneeded = function (event) ***REMOVED***
                var db = event.target.result;
                var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, ***REMOVED***
                    keyPath: 'swScope'
                ***REMOVED***);
                // Make sure the sender ID can be searched
                objectStore.createIndex('fcmSenderId', 'fcmSenderId', ***REMOVED***
                    unique: false
                ***REMOVED***);
                objectStore.createIndex('fcmToken', 'fcmToken', ***REMOVED***
                    unique: true
                ***REMOVED***);
            ***REMOVED***;
        ***REMOVED***);
        return this.openDbPromise_;
    ***REMOVED***;
    /**
     * Close the currently open database.
     * @return ***REMOVED***Promise<?>***REMOVED*** Returns the result of the promise chain.
     */
    TokenManager.prototype.closeDatabase = function () ***REMOVED***
        var _this = this;
        if (this.openDbPromise_) ***REMOVED***
            return this.openDbPromise_.then(function (db) ***REMOVED***
                db.close();
                _this.openDbPromise_ = null;
            ***REMOVED***);
        ***REMOVED***
        return Promise.resolve();
    ***REMOVED***;
    /**
     * Given a token, this method will look up the details in indexedDB.
     * @public
     * @param ***REMOVED***string***REMOVED*** fcmToken
     * @return ***REMOVED***Promise<Object>***REMOVED*** The details associated with that token.
     */
    TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) ***REMOVED***
        return this.openDatabase_().then(function (db) ***REMOVED***
            return new Promise(function (resolve, reject) ***REMOVED***
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var index = objectStore.index('fcmToken');
                var request = index.get(fcmToken);
                request.onerror = function (event) ***REMOVED***
                    reject(event.target.error);
                ***REMOVED***;
                request.onsuccess = function (event) ***REMOVED***
                    resolve(event.target.result);
                ***REMOVED***;
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) ***REMOVED***
        return this.openDatabase_().then(function (db) ***REMOVED***
            return new Promise(function (resolve, reject) ***REMOVED***
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var scopeRequest = objectStore.get(swScope);
                scopeRequest.onerror = function (event) ***REMOVED***
                    reject(event.target.error);
                ***REMOVED***;
                scopeRequest.onsuccess = function (event) ***REMOVED***
                    resolve(event.target.result);
                ***REMOVED***;
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) ***REMOVED***
        return this.openDatabase_().then(function (db) ***REMOVED***
            return new Promise(function (resolve, reject) ***REMOVED***
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var senderIdTokens = [];
                var cursorRequest = objectStore.openCursor();
                cursorRequest.onerror = function (event) ***REMOVED***
                    reject(event.target.error);
                ***REMOVED***;
                cursorRequest.onsuccess = function (event) ***REMOVED***
                    var cursor = event.target.result;
                    if (cursor) ***REMOVED***
                        if (cursor.value['fcmSenderId'] === senderId) ***REMOVED***
                            senderIdTokens.push(cursor.value);
                        ***REMOVED***
                        cursor.continue();
                    ***REMOVED***
                    else ***REMOVED***
                        resolve(senderIdTokens);
                    ***REMOVED***
                ***REMOVED***;
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Given a PushSubscription and messagingSenderId, get an FCM token.
     * @public
     * @param  ***REMOVED***string***REMOVED*** senderId The 'messagingSenderId' to tie the token to.
     * @param  ***REMOVED***PushSubscription***REMOVED*** subscription The PushSusbcription to "federate".
     * @param  ***REMOVED***string=***REMOVED*** pushSet If defined this will swap the subscription for
     * matching FCM token.
     * @return ***REMOVED***Promise<!Object>***REMOVED*** Returns the FCM token to be used in place
     * of the PushSubscription.
     */
    TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) ***REMOVED***
        var _this = this;
        var p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));
        var auth = arrayBufferToBase64(subscription['getKey']('auth'));
        var fcmSubscribeBody = "authorized_entity=" + senderId + "&" +
            ("endpoint=" + subscription.endpoint + "&") +
            ("encryption_key=" + p256dh + "&") +
            ("encryption_auth=" + auth);
        if (pushSet) ***REMOVED***
            fcmSubscribeBody += "&pushSet=" + pushSet;
        ***REMOVED***
        var headers = new Headers();
        headers.append('Content-Type', 'application/x-www-form-urlencoded');
        var subscribeOptions = ***REMOVED***
            method: 'POST',
            headers: headers,
            body: fcmSubscribeBody
        ***REMOVED***;
        return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions)
            .then(function (response) ***REMOVED*** return response.json(); ***REMOVED***)
            .then(function (response) ***REMOVED***
            var fcmTokenResponse = response;
            if (fcmTokenResponse['error']) ***REMOVED***
                var message = fcmTokenResponse['error']['message'];
                throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, ***REMOVED***
                    message: message
                ***REMOVED***);
            ***REMOVED***
            if (!fcmTokenResponse['token']) ***REMOVED***
                throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);
            ***REMOVED***
            if (!fcmTokenResponse['pushSet']) ***REMOVED***
                throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);
            ***REMOVED***
            return ***REMOVED***
                token: fcmTokenResponse['token'],
                pushSet: fcmTokenResponse['pushSet']
            ***REMOVED***;
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Checks the that fields in the PushSubscription are equivalent to the
     * details stores in the masterTokenDetails.
     * @private
     * @param  ***REMOVED***PushSubscription***REMOVED*** subscription The push subscription we expect
     * the master token to match.
     * @param  ***REMOVED***Object***REMOVED***  masterTokenDetails The saved details we wish to compare
     * with the PushSubscription
     * @return ***REMOVED***boolean***REMOVED*** true if the subscription and token details are
     * equivalent.
     */
    TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) ***REMOVED***
        // getKey() isn't defined in the PushSubscription externs file, hence
        // subscription['getKey']('<key name>').
        return (subscription.endpoint === masterTokenDetails['endpoint'] &&
            arrayBufferToBase64(subscription['getKey']('auth')) ===
                masterTokenDetails['auth'] &&
            arrayBufferToBase64(subscription['getKey']('p256dh')) ===
                masterTokenDetails['p256dh']);
    ***REMOVED***;
    /**
     * Save the details for the fcm token for re-use at a later date.
     * @private
     * @param  ***REMOVED***string***REMOVED*** senderId The 'messagingSenderId' used for this project
     * @param  ***REMOVED***ServiceWorkerRegistration***REMOVED*** swRegistration The service worker
     * used to subscribe the user for web push
     * @param  ***REMOVED***PushSubscription***REMOVED*** subscription The push subscription passed to
     * FCM for the current token.
     * @param  ***REMOVED***string***REMOVED*** fcmToken The FCM token currently used on this
     * device.
     * @param  ***REMOVED***string***REMOVED*** fcmPushSet The FCM push tied to the fcm token.
     * @return ***REMOVED***Promise<void>***REMOVED***
     */
    TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) ***REMOVED***
        var details = ***REMOVED***
            swScope: swRegistration.scope,
            endpoint: subscription.endpoint,
            auth: arrayBufferToBase64(subscription['getKey']('auth')),
            p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),
            fcmToken: fcmToken,
            fcmPushSet: fcmPushSet,
            fcmSenderId: senderId
        ***REMOVED***;
        return this.openDatabase_().then(function (db) ***REMOVED***
            return new Promise(function (resolve, reject) ***REMOVED***
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var request = objectStore.put(details);
                request.onerror = function (event) ***REMOVED***
                    reject(event.target.error);
                ***REMOVED***;
                request.onsuccess = function (event) ***REMOVED***
                    resolve();
                ***REMOVED***;
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Returns the saved FCM Token if one is available and still valid,
     * otherwise `null` is returned.
     * @param ***REMOVED***string***REMOVED*** senderId This should be the sender ID associated with the
     * FCM Token being retrieved.
     * @param ***REMOVED***ServiceWorkerRegistration***REMOVED*** swRegistration Registration to be used
     * to subscribe the user to push.
     * @return ***REMOVED***Promise<string> | Promise***REMOVED*** Returns the saved FCM Token if
     * avilable and valid.
     * @export
     */
    TokenManager.prototype.getSavedToken = function (senderId, swRegistration) ***REMOVED***
        var _this = this;
        if (!(swRegistration instanceof ServiceWorkerRegistration)) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));
        ***REMOVED***
        if (typeof senderId !== 'string' || senderId.length === 0) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));
        ***REMOVED***
        return this.getAllTokenDetailsForSenderId_(senderId)
            .then(function (allTokenDetails) ***REMOVED***
            if (allTokenDetails.length === 0) ***REMOVED***
                return;
            ***REMOVED***
            var index = allTokenDetails.findIndex(function (tokenDetails) ***REMOVED***
                return (swRegistration.scope === tokenDetails['swScope'] &&
                    senderId === tokenDetails['fcmSenderId']);
            ***REMOVED***);
            if (index === -1) ***REMOVED***
                return;
            ***REMOVED***
            return allTokenDetails[index];
        ***REMOVED***)
            .then(function (tokenDetails) ***REMOVED***
            if (!tokenDetails) ***REMOVED***
                return;
            ***REMOVED***
            return swRegistration.pushManager
                .getSubscription()
                .catch(function (err) ***REMOVED***
                throw _this.errorFactory_.create(Errors.codes.GET_SUBSCRIPTION_FAILED);
            ***REMOVED***)
                .then(function (subscription) ***REMOVED***
                if (subscription &&
                    _this.isSameSubscription_(subscription, tokenDetails)) ***REMOVED***
                    return tokenDetails['fcmToken'];
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Creates a new FCM token.
     */
    TokenManager.prototype.createToken = function (senderId, swRegistration) ***REMOVED***
        var _this = this;
        if (typeof senderId !== 'string' || senderId.length === 0) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));
        ***REMOVED***
        if (!(swRegistration instanceof ServiceWorkerRegistration)) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));
        ***REMOVED***
        // Check for existing subscription first
        var subscription;
        var fcmTokenDetails;
        return swRegistration.pushManager
            .getSubscription()
            .then(function (subscription) ***REMOVED***
            if (subscription) ***REMOVED***
                return subscription;
            ***REMOVED***
            return swRegistration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);
        ***REMOVED***)
            .then(function (sub) ***REMOVED***
            subscription = sub;
            return _this.subscribeToFCM(senderId, subscription);
        ***REMOVED***)
            .then(function (tokenDetails) ***REMOVED***
            fcmTokenDetails = tokenDetails;
            return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);
        ***REMOVED***)
            .then(function () ***REMOVED*** return fcmTokenDetails['token']; ***REMOVED***);
    ***REMOVED***;
    /**
     * This method deletes details of the current FCM token.
     * It's returning a promise in case we need to move to an async
     * method for deleting at a later date.
     * @param ***REMOVED***string***REMOVED*** token Token to be deleted
     * @return ***REMOVED***Promise<Object>***REMOVED*** Resolves once the FCM token details have been
     * deleted and returns the deleted details.
     */
    TokenManager.prototype.deleteToken = function (token) ***REMOVED***
        var _this = this;
        if (typeof token !== 'string' || token.length === 0) ***REMOVED***
            return Promise.reject(this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN));
        ***REMOVED***
        return this.getTokenDetailsFromToken(token).then(function (details) ***REMOVED***
            if (!details) ***REMOVED***
                throw _this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);
            ***REMOVED***
            return _this.openDatabase_().then(function (db) ***REMOVED***
                return new Promise(function (resolve, reject) ***REMOVED***
                    var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');
                    var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                    var request = objectStore.delete(details['swScope']);
                    request.onerror = function (event) ***REMOVED***
                        reject(event.target.error);
                    ***REMOVED***;
                    request.onsuccess = function (event) ***REMOVED***
                        if (event.target.result === 0) ***REMOVED***
                            reject(_this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN));
                            return;
                        ***REMOVED***
                        resolve(details);
                    ***REMOVED***;
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    return TokenManager;
***REMOVED***());
export default TokenManager;

//# sourceMappingURL=token-manager.js.map
