/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
import ControllerInterface from './controller-interface';
import Errors from '../models/errors';
import WorkerPageMessage from '../models/worker-page-message';
import FCMDetails from '../models/fcm-details';
var FCM_MSG = 'FCM_MSG';
var SWController = /** @class */ (function (_super) ***REMOVED***
    __extends(SWController, _super);
    function SWController(app) ***REMOVED***
        var _this = _super.call(this, app) || this;
        self.addEventListener('push', function (e) ***REMOVED*** return _this.onPush_(e); ***REMOVED***, false);
        self.addEventListener('pushsubscriptionchange', function (e) ***REMOVED*** return _this.onSubChange_(e); ***REMOVED***, false);
        self.addEventListener('notificationclick', function (e) ***REMOVED*** return _this.onNotificationClick_(e); ***REMOVED***, false);
        /**
         * @private
         * @type ***REMOVED***function(Object)|null***REMOVED***
         */
        _this.bgMessageHandler_ = null;
        return _this;
    ***REMOVED***
    /**
     * A handler for push events that shows notifications based on the content of
     * the payload.
     *
     * The payload must be a JSON-encoded Object with a `notification` key. The
     * value of the `notification` property will be used as the NotificationOptions
     * object passed to showNotification. Additionally, the `title` property of the
     * notification object will be used as the title.
     *
     * If there is no notification data in the payload then no notification will be
     * shown.
     * @private
     */
    SWController.prototype.onPush_ = function (event) ***REMOVED***
        var _this = this;
        var msgPayload;
        try ***REMOVED***
            msgPayload = event.data.json();
        ***REMOVED***
        catch (err) ***REMOVED***
            // Not JSON so not an FCM message
            return;
        ***REMOVED***
        var handleMsgPromise = this.hasVisibleClients_().then(function (hasVisibleClients) ***REMOVED***
            if (hasVisibleClients) ***REMOVED***
                // Do not need to show a notification.
                if (msgPayload.notification || _this.bgMessageHandler_) ***REMOVED***
                    // Send to page
                    return _this.sendMessageToWindowClients_(msgPayload);
                ***REMOVED***
                return;
            ***REMOVED***
            var notificationDetails = _this.getNotificationData_(msgPayload);
            if (notificationDetails) ***REMOVED***
                var notificationTitle = notificationDetails.title || '';
                return self.registration.showNotification(notificationTitle, notificationDetails);
            ***REMOVED***
            else if (_this.bgMessageHandler_) ***REMOVED***
                return _this.bgMessageHandler_(msgPayload);
            ***REMOVED***
        ***REMOVED***);
        event.waitUntil(handleMsgPromise);
    ***REMOVED***;
    /**
     * @private
     */
    SWController.prototype.onSubChange_ = function (event) ***REMOVED***
        var _this = this;
        var promiseChain = this.getToken().then(function (token) ***REMOVED***
            if (!token) ***REMOVED***
                // We can't resubscribe if we don't have an FCM token for this scope.
                throw _this.errorFactory_.create(Errors.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE);
            ***REMOVED***
            var tokenDetails = null;
            var tokenManager = _this.getTokenManager();
            return tokenManager
                .getTokenDetailsFromToken(token)
                .then(function (details) ***REMOVED***
                tokenDetails = details;
                if (!tokenDetails) ***REMOVED***
                    throw _this.errorFactory_.create(Errors.codes.INVALID_SAVED_TOKEN);
                ***REMOVED***
                // Attempt to get a new subscription
                return self.registration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);
            ***REMOVED***)
                .then(function (newSubscription) ***REMOVED***
                // Send new subscription to FCM.
                return tokenManager.subscribeToFCM(tokenDetails.fcmSenderId, newSubscription, tokenDetails.fcmPushSet);
            ***REMOVED***)
                .catch(function (err) ***REMOVED***
                // The best thing we can do is log this to the terminal so
                // developers might notice the error.
                return tokenManager.deleteToken(tokenDetails.fcmToken).then(function () ***REMOVED***
                    throw _this.errorFactory_.create(Errors.codes.UNABLE_TO_RESUBSCRIBE, ***REMOVED***
                        message: err
                    ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***);
        event.waitUntil(promiseChain);
    ***REMOVED***;
    /**
     * @private
     */
    SWController.prototype.onNotificationClick_ = function (event) ***REMOVED***
        var _this = this;
        if (!(event.notification &&
            event.notification.data &&
            event.notification.data[FCM_MSG])) ***REMOVED***
            // Not an FCM notification, do nothing.
            return;
        ***REMOVED***
        // Prevent other listeners from receiving the event
        event.stopImmediatePropagation();
        event.notification.close();
        var msgPayload = event.notification.data[FCM_MSG];
        var clickAction = msgPayload['notification']['click_action'];
        if (!clickAction) ***REMOVED***
            // Nothing to do.
            return;
        ***REMOVED***
        var promiseChain = this.getWindowClient_(clickAction)
            .then(function (windowClient) ***REMOVED***
            if (!windowClient) ***REMOVED***
                // Unable to find window client so need to open one.
                return self.clients.openWindow(clickAction);
            ***REMOVED***
            return windowClient;
        ***REMOVED***)
            .then(function (windowClient) ***REMOVED***
            if (!windowClient) ***REMOVED***
                // Window Client will not be returned if it's for a third party origin.
                return;
            ***REMOVED***
            // Delete notification data from payload before sending to the page.
            var notificationData = msgPayload['notification'];
            delete msgPayload['notification'];
            var internalMsg = WorkerPageMessage.createNewMsg(WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED, msgPayload);
            // Attempt to send a message to the client to handle the data
            // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728
            return _this.attemptToMessageClient_(windowClient, internalMsg);
        ***REMOVED***);
        event.waitUntil(promiseChain);
    ***REMOVED***;
    /**
     * @private
     * @param ***REMOVED***Object***REMOVED*** msgPayload
     * @return ***REMOVED***NotificationOptions|undefined***REMOVED***
     */
    SWController.prototype.getNotificationData_ = function (msgPayload) ***REMOVED***
        if (!msgPayload) ***REMOVED***
            return;
        ***REMOVED***
        if (typeof msgPayload.notification !== 'object') ***REMOVED***
            return;
        ***REMOVED***
        var notificationInformation = Object.assign(***REMOVED******REMOVED***, msgPayload.notification);
        // Put the message payload under FCM_MSG name so we can identify the
        // notification as being an FCM notification vs a notification from
        // somewhere else (i.e. normal web push or developer generated
        // notification).
        notificationInformation['data'] = (_a = ***REMOVED******REMOVED***,
            _a[FCM_MSG] = msgPayload,
            _a);
        return notificationInformation;
        var _a;
    ***REMOVED***;
    /**
     * Calling setBackgroundMessageHandler will opt in to some specific
     * behaviours.
     * 1.) If a notification doesn't need to be shown due to a window already
     * being visible, then push messages will be sent to the page.
     * 2.) If a notification needs to be shown, and the message contains no
     * notification data this method will be called
     * and the promise it returns will be passed to event.waitUntil.
     * If you do not set this callback then all push messages will let and the
     * developer can handle them in a their own 'push' event callback
     * @export
     * @param ***REMOVED***function(Object)***REMOVED*** callback The callback to be called when a push
     * message is received and a notification must be shown. The callback will
     * be given the data from the push message.
     */
    SWController.prototype.setBackgroundMessageHandler = function (callback) ***REMOVED***
        if (callback && typeof callback !== 'function') ***REMOVED***
            throw this.errorFactory_.create(Errors.codes.BG_HANDLER_FUNCTION_EXPECTED);
        ***REMOVED***
        this.bgMessageHandler_ = callback;
    ***REMOVED***;
    /**
     * @private
     * @param ***REMOVED***string***REMOVED*** url The URL to look for when focusing a client.
     * @return ***REMOVED***Object***REMOVED*** Returns an existing window client or a newly opened
     * WindowClient.
     */
    SWController.prototype.getWindowClient_ = function (url) ***REMOVED***
        // Use URL to normalize the URL when comparing to windowClients.
        // This at least handles whether to include trailing slashes or not
        var parsedURL = new URL(url).href;
        return self.clients
            .matchAll(***REMOVED***
            type: 'window',
            includeUncontrolled: true
        ***REMOVED***)
            .then(function (clientList) ***REMOVED***
            var suitableClient = null;
            for (var i = 0; i < clientList.length; i++) ***REMOVED***
                var parsedClientUrl = new URL(clientList[i].url).href;
                if (parsedClientUrl === parsedURL) ***REMOVED***
                    suitableClient = clientList[i];
                    break;
                ***REMOVED***
            ***REMOVED***
            if (suitableClient) ***REMOVED***
                suitableClient.focus();
                return suitableClient;
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /**
     * This message will attempt to send the message to a window client.
     * @private
     * @param ***REMOVED***Object***REMOVED*** client The WindowClient to send the message to.
     * @param ***REMOVED***Object***REMOVED*** message The message to send to the client.
     * @returns ***REMOVED***Promise***REMOVED*** Returns a promise that resolves after sending the
     * message. This does not guarantee that the message was successfully
     * received.
     */
    SWController.prototype.attemptToMessageClient_ = function (client, message) ***REMOVED***
        var _this = this;
        return new Promise(function (resolve, reject) ***REMOVED***
            if (!client) ***REMOVED***
                return reject(_this.errorFactory_.create(Errors.codes.NO_WINDOW_CLIENT_TO_MSG));
            ***REMOVED***
            client.postMessage(message);
            resolve();
        ***REMOVED***);
    ***REMOVED***;
    /**
     * @private
     * @returns ***REMOVED***Promise<boolean>***REMOVED*** If there is currently a visible WindowClient,
     * this method will resolve to true, otherwise false.
     */
    SWController.prototype.hasVisibleClients_ = function () ***REMOVED***
        return self.clients
            .matchAll(***REMOVED***
            type: 'window',
            includeUncontrolled: true
        ***REMOVED***)
            .then(function (clientList) ***REMOVED***
            return clientList.some(function (client) ***REMOVED*** return client.visibilityState === 'visible'; ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * @private
     * @param ***REMOVED***Object***REMOVED*** msgPayload The data from the push event that should be sent
     * to all available pages.
     * @returns ***REMOVED***Promise***REMOVED*** Returns a promise that resolves once the message
     * has been sent to all WindowClients.
     */
    SWController.prototype.sendMessageToWindowClients_ = function (msgPayload) ***REMOVED***
        var _this = this;
        return self.clients
            .matchAll(***REMOVED***
            type: 'window',
            includeUncontrolled: true
        ***REMOVED***)
            .then(function (clientList) ***REMOVED***
            var internalMsg = WorkerPageMessage.createNewMsg(WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED, msgPayload);
            return Promise.all(clientList.map(function (client) ***REMOVED***
                return _this.attemptToMessageClient_(client, internalMsg);
            ***REMOVED***));
        ***REMOVED***);
    ***REMOVED***;
    /**
     * This will register the default service worker and return the registration.
     * @private
     * @return ***REMOVED***Promise<!ServiceWorkerRegistration>***REMOVED*** The service worker
     * registration to be used for the push service.
     */
    SWController.prototype.getSWRegistration_ = function () ***REMOVED***
        return Promise.resolve(self.registration);
    ***REMOVED***;
    return SWController;
***REMOVED***(ControllerInterface));
export default SWController;

//# sourceMappingURL=sw-controller.js.map
