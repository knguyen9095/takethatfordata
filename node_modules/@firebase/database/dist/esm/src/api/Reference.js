/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
import ***REMOVED*** OnDisconnect ***REMOVED*** from './onDisconnect';
import ***REMOVED*** TransactionResult ***REMOVED*** from './TransactionResult';
import ***REMOVED*** warn ***REMOVED*** from '../core/util/util';
import ***REMOVED*** nextPushId ***REMOVED*** from '../core/util/NextPushId';
import ***REMOVED*** Query ***REMOVED*** from './Query';
import ***REMOVED*** Repo ***REMOVED*** from '../core/Repo';
import ***REMOVED*** Path ***REMOVED*** from '../core/util/Path';
import ***REMOVED*** QueryParams ***REMOVED*** from '../core/view/QueryParams';
import ***REMOVED*** validateRootPathString, validatePathString, validateFirebaseMergeDataArg, validateBoolean, validatePriority, validateFirebaseDataArg, validateWritablePath ***REMOVED*** from '../core/util/validation';
import ***REMOVED*** validateArgCount, validateCallback ***REMOVED*** from '@firebase/util';
import ***REMOVED*** Deferred ***REMOVED*** from '@firebase/util';
import ***REMOVED*** SyncPoint ***REMOVED*** from '../core/SyncPoint';
var Reference = /** @class */ (function (_super) ***REMOVED***
    __extends(Reference, _super);
    /**
     * Call options:
     *   new Reference(Repo, Path) or
     *   new Reference(url: string, string|RepoManager)
     *
     * Externally - this is the firebase.database.Reference type.
     *
     * @param ***REMOVED***!Repo***REMOVED*** repo
     * @param ***REMOVED***(!Path)***REMOVED*** path
     * @extends ***REMOVED***Query***REMOVED***
     */
    function Reference(repo, path) ***REMOVED***
        var _this = this;
        if (!(repo instanceof Repo)) ***REMOVED***
            throw new Error('new Reference() no longer supported - use app.database().');
        ***REMOVED***
        // call Query's constructor, passing in the repo and path.
        _this = _super.call(this, repo, path, QueryParams.DEFAULT, false) || this;
        return _this;
    ***REMOVED***
    /** @return ***REMOVED***?string***REMOVED*** */
    Reference.prototype.getKey = function () ***REMOVED***
        validateArgCount('Reference.key', 0, 0, arguments.length);
        if (this.path.isEmpty())
            return null;
        else
            return this.path.getBack();
    ***REMOVED***;
    /**
     * @param ***REMOVED***!(string|Path)***REMOVED*** pathString
     * @return ***REMOVED***!Reference***REMOVED***
     */
    Reference.prototype.child = function (pathString) ***REMOVED***
        validateArgCount('Reference.child', 1, 1, arguments.length);
        if (typeof pathString === 'number') ***REMOVED***
            pathString = String(pathString);
        ***REMOVED***
        else if (!(pathString instanceof Path)) ***REMOVED***
            if (this.path.getFront() === null)
                validateRootPathString('Reference.child', 1, pathString, false);
            else
                validatePathString('Reference.child', 1, pathString, false);
        ***REMOVED***
        return new Reference(this.repo, this.path.child(pathString));
    ***REMOVED***;
    /** @return ***REMOVED***?Reference***REMOVED*** */
    Reference.prototype.getParent = function () ***REMOVED***
        validateArgCount('Reference.parent', 0, 0, arguments.length);
        var parentPath = this.path.parent();
        return parentPath === null ? null : new Reference(this.repo, parentPath);
    ***REMOVED***;
    /** @return ***REMOVED***!Reference***REMOVED*** */
    Reference.prototype.getRoot = function () ***REMOVED***
        validateArgCount('Reference.root', 0, 0, arguments.length);
        var ref = this;
        while (ref.getParent() !== null) ***REMOVED***
            ref = ref.getParent();
        ***REMOVED***
        return ref;
    ***REMOVED***;
    /** @return ***REMOVED***!Database***REMOVED*** */
    Reference.prototype.databaseProp = function () ***REMOVED***
        return this.repo.database;
    ***REMOVED***;
    /**
     * @param ***REMOVED*******REMOVED*** newVal
     * @param ***REMOVED***function(?Error)=***REMOVED*** onComplete
     * @return ***REMOVED***!Promise***REMOVED***
     */
    Reference.prototype.set = function (newVal, onComplete) ***REMOVED***
        validateArgCount('Reference.set', 1, 2, arguments.length);
        validateWritablePath('Reference.set', this.path);
        validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);
        validateCallback('Reference.set', 2, onComplete, true);
        var deferred = new Deferred();
        this.repo.setWithPriority(this.path, newVal, 
        /*priority=*/ null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Object***REMOVED*** objectToMerge
     * @param ***REMOVED***function(?Error)=***REMOVED*** onComplete
     * @return ***REMOVED***!Promise***REMOVED***
     */
    Reference.prototype.update = function (objectToMerge, onComplete) ***REMOVED***
        validateArgCount('Reference.update', 1, 2, arguments.length);
        validateWritablePath('Reference.update', this.path);
        if (Array.isArray(objectToMerge)) ***REMOVED***
            var newObjectToMerge = ***REMOVED******REMOVED***;
            for (var i = 0; i < objectToMerge.length; ++i) ***REMOVED***
                newObjectToMerge['' + i] = objectToMerge[i];
            ***REMOVED***
            objectToMerge = newObjectToMerge;
            warn('Passing an Array to Firebase.update() is deprecated. ' +
                'Use set() if you want to overwrite the existing data, or ' +
                'an Object with integer keys if you really do want to ' +
                'only update some of the children.');
        ***REMOVED***
        validateFirebaseMergeDataArg('Reference.update', 1, objectToMerge, this.path, false);
        validateCallback('Reference.update', 2, onComplete, true);
        var deferred = new Deferred();
        this.repo.update(this.path, objectToMerge, deferred.wrapCallback(onComplete));
        return deferred.promise;
    ***REMOVED***;
    /**
     * @param ***REMOVED*******REMOVED*** newVal
     * @param ***REMOVED***string|number|null***REMOVED*** newPriority
     * @param ***REMOVED***function(?Error)=***REMOVED*** onComplete
     * @return ***REMOVED***!Promise***REMOVED***
     */
    Reference.prototype.setWithPriority = function (newVal, newPriority, onComplete) ***REMOVED***
        validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);
        validateWritablePath('Reference.setWithPriority', this.path);
        validateFirebaseDataArg('Reference.setWithPriority', 1, newVal, this.path, false);
        validatePriority('Reference.setWithPriority', 2, newPriority, false);
        validateCallback('Reference.setWithPriority', 3, onComplete, true);
        if (this.getKey() === '.length' || this.getKey() === '.keys')
            throw 'Reference.setWithPriority failed: ' +
                this.getKey() +
                ' is a read-only object.';
        var deferred = new Deferred();
        this.repo.setWithPriority(this.path, newVal, newPriority, deferred.wrapCallback(onComplete));
        return deferred.promise;
    ***REMOVED***;
    /**
     * @param ***REMOVED***function(?Error)=***REMOVED*** onComplete
     * @return ***REMOVED***!Promise***REMOVED***
     */
    Reference.prototype.remove = function (onComplete) ***REMOVED***
        validateArgCount('Reference.remove', 0, 1, arguments.length);
        validateWritablePath('Reference.remove', this.path);
        validateCallback('Reference.remove', 1, onComplete, true);
        return this.set(null, onComplete);
    ***REMOVED***;
    /**
     * @param ***REMOVED***function(*):****REMOVED*** transactionUpdate
     * @param ***REMOVED***(function(?Error, boolean, ?DataSnapshot))=***REMOVED*** onComplete
     * @param ***REMOVED***boolean=***REMOVED*** applyLocally
     * @return ***REMOVED***!Promise***REMOVED***
     */
    Reference.prototype.transaction = function (transactionUpdate, onComplete, applyLocally) ***REMOVED***
        validateArgCount('Reference.transaction', 1, 3, arguments.length);
        validateWritablePath('Reference.transaction', this.path);
        validateCallback('Reference.transaction', 1, transactionUpdate, false);
        validateCallback('Reference.transaction', 2, onComplete, true);
        // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how
        // to expose it.
        validateBoolean('Reference.transaction', 3, applyLocally, true);
        if (this.getKey() === '.length' || this.getKey() === '.keys')
            throw 'Reference.transaction failed: ' +
                this.getKey() +
                ' is a read-only object.';
        if (applyLocally === undefined)
            applyLocally = true;
        var deferred = new Deferred();
        if (typeof onComplete === 'function') ***REMOVED***
            deferred.promise.catch(function () ***REMOVED*** ***REMOVED***);
        ***REMOVED***
        var promiseComplete = function (error, committed, snapshot) ***REMOVED***
            if (error) ***REMOVED***
                deferred.reject(error);
            ***REMOVED***
            else ***REMOVED***
                deferred.resolve(new TransactionResult(committed, snapshot));
            ***REMOVED***
            if (typeof onComplete === 'function') ***REMOVED***
                onComplete(error, committed, snapshot);
            ***REMOVED***
        ***REMOVED***;
        this.repo.startTransaction(this.path, transactionUpdate, promiseComplete, applyLocally);
        return deferred.promise;
    ***REMOVED***;
    /**
     * @param ***REMOVED***string|number|null***REMOVED*** priority
     * @param ***REMOVED***function(?Error)=***REMOVED*** onComplete
     * @return ***REMOVED***!Promise***REMOVED***
     */
    Reference.prototype.setPriority = function (priority, onComplete) ***REMOVED***
        validateArgCount('Reference.setPriority', 1, 2, arguments.length);
        validateWritablePath('Reference.setPriority', this.path);
        validatePriority('Reference.setPriority', 1, priority, false);
        validateCallback('Reference.setPriority', 2, onComplete, true);
        var deferred = new Deferred();
        this.repo.setWithPriority(this.path.child('.priority'), priority, null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    ***REMOVED***;
    /**
     * @param ***REMOVED****=***REMOVED*** value
     * @param ***REMOVED***function(?Error)=***REMOVED*** onComplete
     * @return ***REMOVED***!Reference***REMOVED***
     */
    Reference.prototype.push = function (value, onComplete) ***REMOVED***
        validateArgCount('Reference.push', 0, 2, arguments.length);
        validateWritablePath('Reference.push', this.path);
        validateFirebaseDataArg('Reference.push', 1, value, this.path, true);
        validateCallback('Reference.push', 2, onComplete, true);
        var now = this.repo.serverTime();
        var name = nextPushId(now);
        // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.
        // We use child() to create handles to two different references. The first is turned into a
        // ThennableReference below by adding then() and catch() methods and is used as the
        // return value of push(). The second remains a regular Reference and is used as the fulfilled
        // value of the first ThennableReference.
        var thennablePushRef = this.child(name);
        var pushRef = this.child(name);
        var promise;
        if (value != null) ***REMOVED***
            promise = thennablePushRef.set(value, onComplete).then(function () ***REMOVED*** return pushRef; ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            promise = Promise.resolve(pushRef);
        ***REMOVED***
        thennablePushRef.then = promise.then.bind(promise);
        thennablePushRef.catch = promise.then.bind(promise, undefined);
        if (typeof onComplete === 'function') ***REMOVED***
            promise.catch(function () ***REMOVED*** ***REMOVED***);
        ***REMOVED***
        return thennablePushRef;
    ***REMOVED***;
    /**
     * @return ***REMOVED***!OnDisconnect***REMOVED***
     */
    Reference.prototype.onDisconnect = function () ***REMOVED***
        validateWritablePath('Reference.onDisconnect', this.path);
        return new OnDisconnect(this.repo, this.path);
    ***REMOVED***;
    Object.defineProperty(Reference.prototype, "database", ***REMOVED***
        get: function () ***REMOVED***
            return this.databaseProp();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Reference.prototype, "key", ***REMOVED***
        get: function () ***REMOVED***
            return this.getKey();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Reference.prototype, "parent", ***REMOVED***
        get: function () ***REMOVED***
            return this.getParent();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Reference.prototype, "root", ***REMOVED***
        get: function () ***REMOVED***
            return this.getRoot();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    return Reference;
***REMOVED***(Query));
export ***REMOVED*** Reference ***REMOVED***;
/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */
Query.__referenceConstructor = Reference;
SyncPoint.__referenceConstructor = Reference;

//# sourceMappingURL=Reference.js.map
