/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** assert ***REMOVED*** from '@firebase/util';
import ***REMOVED*** KEY_INDEX ***REMOVED*** from '../core/snap/indexes/KeyIndex';
import ***REMOVED*** PRIORITY_INDEX ***REMOVED*** from '../core/snap/indexes/PriorityIndex';
import ***REMOVED*** VALUE_INDEX ***REMOVED*** from '../core/snap/indexes/ValueIndex';
import ***REMOVED*** PathIndex ***REMOVED*** from '../core/snap/indexes/PathIndex';
import ***REMOVED*** MIN_NAME, MAX_NAME, ObjectToUniqueKey ***REMOVED*** from '../core/util/util';
import ***REMOVED*** Path ***REMOVED*** from '../core/util/Path';
import ***REMOVED*** isValidPriority, validateEventType, validatePathString, validateFirebaseDataArg, validateKey ***REMOVED*** from '../core/util/validation';
import ***REMOVED*** errorPrefix, validateArgCount, validateCallback, validateContextObject ***REMOVED*** from '@firebase/util';
import ***REMOVED*** ValueEventRegistration, ChildEventRegistration ***REMOVED*** from '../core/view/EventRegistration';
import ***REMOVED*** Deferred ***REMOVED*** from '@firebase/util';
var __referenceConstructor;
/**
 * A Query represents a filter to be applied to a firebase location.  This object purely represents the
 * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.
 *
 * Since every Firebase reference is a query, Firebase inherits from this object.
 */
var Query = /** @class */ (function () ***REMOVED***
    function Query(repo, path, queryParams_, orderByCalled_) ***REMOVED***
        this.repo = repo;
        this.path = path;
        this.queryParams_ = queryParams_;
        this.orderByCalled_ = orderByCalled_;
    ***REMOVED***
    Object.defineProperty(Query, "__referenceConstructor", ***REMOVED***
        get: function () ***REMOVED***
            assert(__referenceConstructor, 'Reference.ts has not been loaded');
            return __referenceConstructor;
        ***REMOVED***,
        set: function (val) ***REMOVED***
            __referenceConstructor = val;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /**
     * Validates start/end values for queries.
     * @param ***REMOVED***!QueryParams***REMOVED*** params
     * @private
     */
    Query.validateQueryEndpoints_ = function (params) ***REMOVED***
        var startNode = null;
        var endNode = null;
        if (params.hasStart()) ***REMOVED***
            startNode = params.getIndexStartValue();
        ***REMOVED***
        if (params.hasEnd()) ***REMOVED***
            endNode = params.getIndexEndValue();
        ***REMOVED***
        if (params.getIndex() === KEY_INDEX) ***REMOVED***
            var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +
                'startAt(), endAt(), or equalTo().';
            var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' +
                'or equalTo() must be a string.';
            if (params.hasStart()) ***REMOVED***
                var startName = params.getIndexStartName();
                if (startName != MIN_NAME) ***REMOVED***
                    throw new Error(tooManyArgsError);
                ***REMOVED***
                else if (typeof startNode !== 'string') ***REMOVED***
                    throw new Error(wrongArgTypeError);
                ***REMOVED***
            ***REMOVED***
            if (params.hasEnd()) ***REMOVED***
                var endName = params.getIndexEndName();
                if (endName != MAX_NAME) ***REMOVED***
                    throw new Error(tooManyArgsError);
                ***REMOVED***
                else if (typeof endNode !== 'string') ***REMOVED***
                    throw new Error(wrongArgTypeError);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        else if (params.getIndex() === PRIORITY_INDEX) ***REMOVED***
            if ((startNode != null && !isValidPriority(startNode)) ||
                (endNode != null && !isValidPriority(endNode))) ***REMOVED***
                throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +
                    'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            assert(params.getIndex() instanceof PathIndex ||
                params.getIndex() === VALUE_INDEX, 'unknown index type.');
            if ((startNode != null && typeof startNode === 'object') ||
                (endNode != null && typeof endNode === 'object')) ***REMOVED***
                throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +
                    'an object.');
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Validates that limit* has been called with the correct combination of parameters
     * @param ***REMOVED***!QueryParams***REMOVED*** params
     * @private
     */
    Query.validateLimit_ = function (params) ***REMOVED***
        if (params.hasStart() &&
            params.hasEnd() &&
            params.hasLimit() &&
            !params.hasAnchoredLimit()) ***REMOVED***
            throw new Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");
        ***REMOVED***
    ***REMOVED***;
    /**
     * Validates that no other order by call has been made
     * @param ***REMOVED***!string***REMOVED*** fnName
     * @private
     */
    Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) ***REMOVED***
        if (this.orderByCalled_ === true) ***REMOVED***
            throw new Error(fnName + ": You can't combine multiple orderBy calls.");
        ***REMOVED***
    ***REMOVED***;
    /**
     * @return ***REMOVED***!QueryParams***REMOVED***
     */
    Query.prototype.getQueryParams = function () ***REMOVED***
        return this.queryParams_;
    ***REMOVED***;
    /**
     * @return ***REMOVED***!Reference***REMOVED***
     */
    Query.prototype.getRef = function () ***REMOVED***
        validateArgCount('Query.ref', 0, 0, arguments.length);
        // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.
        // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this
        // method gets called.
        return new Query.__referenceConstructor(this.repo, this.path);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!string***REMOVED*** eventType
     * @param ***REMOVED***!function(DataSnapshot, string=)***REMOVED*** callback
     * @param ***REMOVED***(function(Error)|Object)=***REMOVED*** cancelCallbackOrContext
     * @param ***REMOVED***Object=***REMOVED*** context
     * @return ***REMOVED***!function(DataSnapshot, string=)***REMOVED***
     */
    Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) ***REMOVED***
        validateArgCount('Query.on', 2, 4, arguments.length);
        validateEventType('Query.on', 1, eventType, false);
        validateCallback('Query.on', 2, callback, false);
        var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);
        if (eventType === 'value') ***REMOVED***
            this.onValueEvent(callback, ret.cancel, ret.context);
        ***REMOVED***
        else ***REMOVED***
            var callbacks = ***REMOVED******REMOVED***;
            callbacks[eventType] = callback;
            this.onChildEvent(callbacks, ret.cancel, ret.context);
        ***REMOVED***
        return callback;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!function(!DataSnapshot)***REMOVED*** callback
     * @param ***REMOVED***?function(Error)***REMOVED*** cancelCallback
     * @param ***REMOVED***?Object***REMOVED*** context
     * @protected
     */
    Query.prototype.onValueEvent = function (callback, cancelCallback, context) ***REMOVED***
        var container = new ValueEventRegistration(callback, cancelCallback || null, context || null);
        this.repo.addEventCallbackForQuery(this, container);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Object.<string, !function(!DataSnapshot, ?string)>***REMOVED*** callbacks
     * @param ***REMOVED***?function(Error)***REMOVED*** cancelCallback
     * @param ***REMOVED***?Object***REMOVED*** context
     * @protected
     */
    Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) ***REMOVED***
        var container = new ChildEventRegistration(callbacks, cancelCallback, context);
        this.repo.addEventCallbackForQuery(this, container);
    ***REMOVED***;
    /**
     * @param ***REMOVED***string=***REMOVED*** eventType
     * @param ***REMOVED***(function(!DataSnapshot, ?string=))=***REMOVED*** callback
     * @param ***REMOVED***Object=***REMOVED*** context
     */
    Query.prototype.off = function (eventType, callback, context) ***REMOVED***
        validateArgCount('Query.off', 0, 3, arguments.length);
        validateEventType('Query.off', 1, eventType, true);
        validateCallback('Query.off', 2, callback, true);
        validateContextObject('Query.off', 3, context, true);
        var container = null;
        var callbacks = null;
        if (eventType === 'value') ***REMOVED***
            var valueCallback = callback || null;
            container = new ValueEventRegistration(valueCallback, null, context || null);
        ***REMOVED***
        else if (eventType) ***REMOVED***
            if (callback) ***REMOVED***
                callbacks = ***REMOVED******REMOVED***;
                callbacks[eventType] = callback;
            ***REMOVED***
            container = new ChildEventRegistration(callbacks, null, context || null);
        ***REMOVED***
        this.repo.removeEventCallbackForQuery(this, container);
    ***REMOVED***;
    /**
     * Attaches a listener, waits for the first event, and then removes the listener
     * @param ***REMOVED***!string***REMOVED*** eventType
     * @param ***REMOVED***!function(!DataSnapshot, string=)***REMOVED*** userCallback
     * @param cancelOrContext
     * @param context
     * @return ***REMOVED***!firebase.Promise***REMOVED***
     */
    Query.prototype.once = function (eventType, userCallback, cancelOrContext, context) ***REMOVED***
        var _this = this;
        validateArgCount('Query.once', 1, 4, arguments.length);
        validateEventType('Query.once', 1, eventType, false);
        validateCallback('Query.once', 2, userCallback, true);
        var ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context);
        // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)
        // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change
        // because the API currently expects callbacks will be called synchronously if the data is cached, but this is
        // against the Promise specification.
        var firstCall = true;
        var deferred = new Deferred();
        // A dummy error handler in case a user wasn't expecting promises
        deferred.promise.catch(function () ***REMOVED*** ***REMOVED***);
        var onceCallback = function (snapshot) ***REMOVED***
            // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)
            // triggers multiple events (e.g. child_added or child_changed).
            if (firstCall) ***REMOVED***
                firstCall = false;
                _this.off(eventType, onceCallback);
                if (userCallback) ***REMOVED***
                    userCallback.bind(ret.context)(snapshot);
                ***REMOVED***
                deferred.resolve(snapshot);
            ***REMOVED***
        ***REMOVED***;
        this.on(eventType, onceCallback, 
        /*cancel=*/ function (err) ***REMOVED***
            _this.off(eventType, onceCallback);
            if (ret.cancel)
                ret.cancel.bind(ret.context)(err);
            deferred.reject(err);
        ***REMOVED***);
        return deferred.promise;
    ***REMOVED***;
    /**
     * Set a limit and anchor it to the start of the window.
     * @param ***REMOVED***!number***REMOVED*** limit
     * @return ***REMOVED***!Query***REMOVED***
     */
    Query.prototype.limitToFirst = function (limit) ***REMOVED***
        validateArgCount('Query.limitToFirst', 1, 1, arguments.length);
        if (typeof limit !== 'number' ||
            Math.floor(limit) !== limit ||
            limit <= 0) ***REMOVED***
            throw new Error('Query.limitToFirst: First argument must be a positive integer.');
        ***REMOVED***
        if (this.queryParams_.hasLimit()) ***REMOVED***
            throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' +
                'limitToFirst, or limitToLast).');
        ***REMOVED***
        return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);
    ***REMOVED***;
    /**
     * Set a limit and anchor it to the end of the window.
     * @param ***REMOVED***!number***REMOVED*** limit
     * @return ***REMOVED***!Query***REMOVED***
     */
    Query.prototype.limitToLast = function (limit) ***REMOVED***
        validateArgCount('Query.limitToLast', 1, 1, arguments.length);
        if (typeof limit !== 'number' ||
            Math.floor(limit) !== limit ||
            limit <= 0) ***REMOVED***
            throw new Error('Query.limitToLast: First argument must be a positive integer.');
        ***REMOVED***
        if (this.queryParams_.hasLimit()) ***REMOVED***
            throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' +
                'limitToFirst, or limitToLast).');
        ***REMOVED***
        return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);
    ***REMOVED***;
    /**
     * Given a child path, return a new query ordered by the specified grandchild path.
     * @param ***REMOVED***!string***REMOVED*** path
     * @return ***REMOVED***!Query***REMOVED***
     */
    Query.prototype.orderByChild = function (path) ***REMOVED***
        validateArgCount('Query.orderByChild', 1, 1, arguments.length);
        if (path === '$key') ***REMOVED***
            throw new Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');
        ***REMOVED***
        else if (path === '$priority') ***REMOVED***
            throw new Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');
        ***REMOVED***
        else if (path === '$value') ***REMOVED***
            throw new Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');
        ***REMOVED***
        validatePathString('Query.orderByChild', 1, path, false);
        this.validateNoPreviousOrderByCall_('Query.orderByChild');
        var parsedPath = new Path(path);
        if (parsedPath.isEmpty()) ***REMOVED***
            throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');
        ***REMOVED***
        var index = new PathIndex(parsedPath);
        var newParams = this.queryParams_.orderBy(index);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    ***REMOVED***;
    /**
     * Return a new query ordered by the KeyIndex
     * @return ***REMOVED***!Query***REMOVED***
     */
    Query.prototype.orderByKey = function () ***REMOVED***
        validateArgCount('Query.orderByKey', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByKey');
        var newParams = this.queryParams_.orderBy(KEY_INDEX);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    ***REMOVED***;
    /**
     * Return a new query ordered by the PriorityIndex
     * @return ***REMOVED***!Query***REMOVED***
     */
    Query.prototype.orderByPriority = function () ***REMOVED***
        validateArgCount('Query.orderByPriority', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByPriority');
        var newParams = this.queryParams_.orderBy(PRIORITY_INDEX);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    ***REMOVED***;
    /**
     * Return a new query ordered by the ValueIndex
     * @return ***REMOVED***!Query***REMOVED***
     */
    Query.prototype.orderByValue = function () ***REMOVED***
        validateArgCount('Query.orderByValue', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByValue');
        var newParams = this.queryParams_.orderBy(VALUE_INDEX);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    ***REMOVED***;
    /**
     * @param ***REMOVED***number|string|boolean|null***REMOVED*** value
     * @param ***REMOVED***?string=***REMOVED*** name
     * @return ***REMOVED***!Query***REMOVED***
     */
    Query.prototype.startAt = function (value, name) ***REMOVED***
        if (value === void 0) ***REMOVED*** value = null; ***REMOVED***
        validateArgCount('Query.startAt', 0, 2, arguments.length);
        validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);
        validateKey('Query.startAt', 2, name, true);
        var newParams = this.queryParams_.startAt(value, name);
        Query.validateLimit_(newParams);
        Query.validateQueryEndpoints_(newParams);
        if (this.queryParams_.hasStart()) ***REMOVED***
            throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' +
                'or equalTo).');
        ***REMOVED***
        // Calling with no params tells us to start at the beginning.
        if (value === undefined) ***REMOVED***
            value = null;
            name = null;
        ***REMOVED***
        return new Query(this.repo, this.path, newParams, this.orderByCalled_);
    ***REMOVED***;
    /**
     * @param ***REMOVED***number|string|boolean|null***REMOVED*** value
     * @param ***REMOVED***?string=***REMOVED*** name
     * @return ***REMOVED***!Query***REMOVED***
     */
    Query.prototype.endAt = function (value, name) ***REMOVED***
        if (value === void 0) ***REMOVED*** value = null; ***REMOVED***
        validateArgCount('Query.endAt', 0, 2, arguments.length);
        validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);
        validateKey('Query.endAt', 2, name, true);
        var newParams = this.queryParams_.endAt(value, name);
        Query.validateLimit_(newParams);
        Query.validateQueryEndpoints_(newParams);
        if (this.queryParams_.hasEnd()) ***REMOVED***
            throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' +
                'equalTo).');
        ***REMOVED***
        return new Query(this.repo, this.path, newParams, this.orderByCalled_);
    ***REMOVED***;
    /**
     * Load the selection of children with exactly the specified value, and, optionally,
     * the specified name.
     * @param ***REMOVED***number|string|boolean|null***REMOVED*** value
     * @param ***REMOVED***string=***REMOVED*** name
     * @return ***REMOVED***!Query***REMOVED***
     */
    Query.prototype.equalTo = function (value, name) ***REMOVED***
        validateArgCount('Query.equalTo', 1, 2, arguments.length);
        validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);
        validateKey('Query.equalTo', 2, name, true);
        if (this.queryParams_.hasStart()) ***REMOVED***
            throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' +
                'equalTo).');
        ***REMOVED***
        if (this.queryParams_.hasEnd()) ***REMOVED***
            throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' +
                'equalTo).');
        ***REMOVED***
        return this.startAt(value, name).endAt(value, name);
    ***REMOVED***;
    /**
     * @return ***REMOVED***!string***REMOVED*** URL for this location.
     */
    Query.prototype.toString = function () ***REMOVED***
        validateArgCount('Query.toString', 0, 0, arguments.length);
        return this.repo.toString() + this.path.toUrlEncodedString();
    ***REMOVED***;
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users.
    Query.prototype.toJSON = function () ***REMOVED***
        // An optional spacer argument is unnecessary for a string.
        validateArgCount('Query.toJSON', 0, 1, arguments.length);
        return this.toString();
    ***REMOVED***;
    /**
     * An object representation of the query parameters used by this Query.
     * @return ***REMOVED***!Object***REMOVED***
     */
    Query.prototype.queryObject = function () ***REMOVED***
        return this.queryParams_.getQueryObject();
    ***REMOVED***;
    /**
     * @return ***REMOVED***!string***REMOVED***
     */
    Query.prototype.queryIdentifier = function () ***REMOVED***
        var obj = this.queryObject();
        var id = ObjectToUniqueKey(obj);
        return id === '***REMOVED******REMOVED***' ? 'default' : id;
    ***REMOVED***;
    /**
     * Return true if this query and the provided query are equivalent; otherwise, return false.
     * @param ***REMOVED***Query***REMOVED*** other
     * @return ***REMOVED***boolean***REMOVED***
     */
    Query.prototype.isEqual = function (other) ***REMOVED***
        validateArgCount('Query.isEqual', 1, 1, arguments.length);
        if (!(other instanceof Query)) ***REMOVED***
            var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';
            throw new Error(error);
        ***REMOVED***
        var sameRepo = this.repo === other.repo;
        var samePath = this.path.equals(other.path);
        var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();
        return sameRepo && samePath && sameQueryIdentifier;
    ***REMOVED***;
    /**
     * Helper used by .on and .once to extract the context and or cancel arguments.
     * @param ***REMOVED***!string***REMOVED*** fnName The function name (on or once)
     * @param ***REMOVED***(function(Error)|Object)=***REMOVED*** cancelOrContext
     * @param ***REMOVED***Object=***REMOVED*** context
     * @return ***REMOVED******REMOVED***cancel: ?function(Error), context: ?Object***REMOVED******REMOVED***
     * @private
     */
    Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) ***REMOVED***
        var ret = ***REMOVED*** cancel: null, context: null ***REMOVED***;
        if (cancelOrContext && context) ***REMOVED***
            ret.cancel = cancelOrContext;
            validateCallback(fnName, 3, ret.cancel, true);
            ret.context = context;
            validateContextObject(fnName, 4, ret.context, true);
        ***REMOVED***
        else if (cancelOrContext) ***REMOVED***
            // we have either a cancel callback or a context.
            if (typeof cancelOrContext === 'object' && cancelOrContext !== null) ***REMOVED***
                // it's a context!
                ret.context = cancelOrContext;
            ***REMOVED***
            else if (typeof cancelOrContext === 'function') ***REMOVED***
                ret.cancel = cancelOrContext;
            ***REMOVED***
            else ***REMOVED***
                throw new Error(errorPrefix(fnName, 3, true) +
                    ' must either be a cancel callback or a context object.');
            ***REMOVED***
        ***REMOVED***
        return ret;
    ***REMOVED***;
    Object.defineProperty(Query.prototype, "ref", ***REMOVED***
        get: function () ***REMOVED***
            return this.getRef();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    return Query;
***REMOVED***());
export ***REMOVED*** Query ***REMOVED***;

//# sourceMappingURL=Query.js.map
