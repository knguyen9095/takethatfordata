/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** assert ***REMOVED*** from '@firebase/util';
import ***REMOVED*** errorForServerCode ***REMOVED*** from './util/util';
import ***REMOVED*** AckUserWrite ***REMOVED*** from './operation/AckUserWrite';
import ***REMOVED*** ChildrenNode ***REMOVED*** from './snap/ChildrenNode';
import ***REMOVED*** forEach, safeGet ***REMOVED*** from '@firebase/util';
import ***REMOVED*** ImmutableTree ***REMOVED*** from './util/ImmutableTree';
import ***REMOVED*** ListenComplete ***REMOVED*** from './operation/ListenComplete';
import ***REMOVED*** Merge ***REMOVED*** from './operation/Merge';
import ***REMOVED*** OperationSource ***REMOVED*** from './operation/Operation';
import ***REMOVED*** Overwrite ***REMOVED*** from './operation/Overwrite';
import ***REMOVED*** Path ***REMOVED*** from './util/Path';
import ***REMOVED*** SyncPoint ***REMOVED*** from './SyncPoint';
import ***REMOVED*** WriteTree ***REMOVED*** from './WriteTree';
/**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 * @constructor
 */
var SyncTree = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***!ListenProvider***REMOVED*** listenProvider_ Used by SyncTree to start / stop listening
     *   to server data.
     */
    function SyncTree(listenProvider_) ***REMOVED***
        this.listenProvider_ = listenProvider_;
        /**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         * @type ***REMOVED***!ImmutableTree.<!SyncPoint>***REMOVED***
         * @private
         */
        this.syncPointTree_ = ImmutableTree.Empty;
        /**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         * @type ***REMOVED***!WriteTree***REMOVED***
         * @private
         */
        this.pendingWriteTree_ = new WriteTree();
        this.tagToQueryMap_ = ***REMOVED******REMOVED***;
        this.queryToTagMap_ = ***REMOVED******REMOVED***;
    ***REMOVED***
    /**
     * Apply the data changes for a user-generated set() or transaction() call.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Node***REMOVED*** newData
     * @param ***REMOVED***number***REMOVED*** writeId
     * @param ***REMOVED***boolean=***REMOVED*** visible
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.applyUserOverwrite = function (path, newData, writeId, visible) ***REMOVED***
        // Record pending write.
        this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);
        if (!visible) ***REMOVED***
            return [];
        ***REMOVED***
        else ***REMOVED***
            return this.applyOperationToSyncPoints_(new Overwrite(OperationSource.User, path, newData));
        ***REMOVED***
    ***REMOVED***;
    /**
     * Apply the data from a user-generated update() call
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Object.<string, !Node>***REMOVED*** changedChildren
     * @param ***REMOVED***!number***REMOVED*** writeId
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.applyUserMerge = function (path, changedChildren, writeId) ***REMOVED***
        // Record pending merge.
        this.pendingWriteTree_.addMerge(path, changedChildren, writeId);
        var changeTree = ImmutableTree.fromObject(changedChildren);
        return this.applyOperationToSyncPoints_(new Merge(OperationSource.User, path, changeTree));
    ***REMOVED***;
    /**
     * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
     *
     * @param ***REMOVED***!number***REMOVED*** writeId
     * @param ***REMOVED***boolean=***REMOVED*** revert True if the given write failed and needs to be reverted
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.ackUserWrite = function (writeId, revert) ***REMOVED***
        if (revert === void 0) ***REMOVED*** revert = false; ***REMOVED***
        var write = this.pendingWriteTree_.getWrite(writeId);
        var needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);
        if (!needToReevaluate) ***REMOVED***
            return [];
        ***REMOVED***
        else ***REMOVED***
            var affectedTree_1 = ImmutableTree.Empty;
            if (write.snap != null) ***REMOVED***
                // overwrite
                affectedTree_1 = affectedTree_1.set(Path.Empty, true);
            ***REMOVED***
            else ***REMOVED***
                forEach(write.children, function (pathString, node) ***REMOVED***
                    affectedTree_1 = affectedTree_1.set(new Path(pathString), node);
                ***REMOVED***);
            ***REMOVED***
            return this.applyOperationToSyncPoints_(new AckUserWrite(write.path, affectedTree_1, revert));
        ***REMOVED***
    ***REMOVED***;
    /**
     * Apply new server data for the specified path..
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Node***REMOVED*** newData
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.applyServerOverwrite = function (path, newData) ***REMOVED***
        return this.applyOperationToSyncPoints_(new Overwrite(OperationSource.Server, path, newData));
    ***REMOVED***;
    /**
     * Apply new server data to be merged in at the specified path.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Object.<string, !Node>***REMOVED*** changedChildren
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.applyServerMerge = function (path, changedChildren) ***REMOVED***
        var changeTree = ImmutableTree.fromObject(changedChildren);
        return this.applyOperationToSyncPoints_(new Merge(OperationSource.Server, path, changeTree));
    ***REMOVED***;
    /**
     * Apply a listen complete for a query
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.applyListenComplete = function (path) ***REMOVED***
        return this.applyOperationToSyncPoints_(new ListenComplete(OperationSource.Server, path));
    ***REMOVED***;
    /**
     * Apply new server data for the specified tagged query.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Node***REMOVED*** snap
     * @param ***REMOVED***!number***REMOVED*** tag
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.applyTaggedQueryOverwrite = function (path, snap, tag) ***REMOVED***
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey != null) ***REMOVED***
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path.relativePath(queryPath, path);
            var op = new Overwrite(OperationSource.forServerTaggedQuery(queryId), relativePath, snap);
            return this.applyTaggedOperation_(queryPath, op);
        ***REMOVED***
        else ***REMOVED***
            // Query must have been removed already
            return [];
        ***REMOVED***
    ***REMOVED***;
    /**
     * Apply server data to be merged in for the specified tagged query.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Object.<string, !Node>***REMOVED*** changedChildren
     * @param ***REMOVED***!number***REMOVED*** tag
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.applyTaggedQueryMerge = function (path, changedChildren, tag) ***REMOVED***
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey) ***REMOVED***
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path.relativePath(queryPath, path);
            var changeTree = ImmutableTree.fromObject(changedChildren);
            var op = new Merge(OperationSource.forServerTaggedQuery(queryId), relativePath, changeTree);
            return this.applyTaggedOperation_(queryPath, op);
        ***REMOVED***
        else ***REMOVED***
            // We've already removed the query. No big deal, ignore the update
            return [];
        ***REMOVED***
    ***REMOVED***;
    /**
     * Apply a listen complete for a tagged query
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!number***REMOVED*** tag
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.applyTaggedListenComplete = function (path, tag) ***REMOVED***
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey) ***REMOVED***
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path.relativePath(queryPath, path);
            var op = new ListenComplete(OperationSource.forServerTaggedQuery(queryId), relativePath);
            return this.applyTaggedOperation_(queryPath, op);
        ***REMOVED***
        else ***REMOVED***
            // We've already removed the query. No big deal, ignore the update
            return [];
        ***REMOVED***
    ***REMOVED***;
    /**
     * Add an event callback for the specified query.
     *
     * @param ***REMOVED***!Query***REMOVED*** query
     * @param ***REMOVED***!EventRegistration***REMOVED*** eventRegistration
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncTree.prototype.addEventRegistration = function (query, eventRegistration) ***REMOVED***
        var path = query.path;
        var serverCache = null;
        var foundAncestorDefaultView = false;
        // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
        // Consider optimizing this once there's a better understanding of what actual behavior will be.
        this.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) ***REMOVED***
            var relativePath = Path.relativePath(pathToSyncPoint, path);
            serverCache = serverCache || sp.getCompleteServerCache(relativePath);
            foundAncestorDefaultView =
                foundAncestorDefaultView || sp.hasCompleteView();
        ***REMOVED***);
        var syncPoint = this.syncPointTree_.get(path);
        if (!syncPoint) ***REMOVED***
            syncPoint = new SyncPoint();
            this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);
        ***REMOVED***
        else ***REMOVED***
            foundAncestorDefaultView =
                foundAncestorDefaultView || syncPoint.hasCompleteView();
            serverCache = serverCache || syncPoint.getCompleteServerCache(Path.Empty);
        ***REMOVED***
        var serverCacheComplete;
        if (serverCache != null) ***REMOVED***
            serverCacheComplete = true;
        ***REMOVED***
        else ***REMOVED***
            serverCacheComplete = false;
            serverCache = ChildrenNode.EMPTY_NODE;
            var subtree = this.syncPointTree_.subtree(path);
            subtree.foreachChild(function (childName, childSyncPoint) ***REMOVED***
                var completeCache = childSyncPoint.getCompleteServerCache(Path.Empty);
                if (completeCache) ***REMOVED***
                    serverCache = serverCache.updateImmediateChild(childName, completeCache);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
        var viewAlreadyExists = syncPoint.viewExistsForQuery(query);
        if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) ***REMOVED***
            // We need to track a tag for this query
            var queryKey = SyncTree.makeQueryKey_(query);
            assert(!(queryKey in this.queryToTagMap_), 'View does not exist, but we have a tag');
            var tag = SyncTree.getNextQueryTag_();
            this.queryToTagMap_[queryKey] = tag;
            // Coerce to string to avoid sparse arrays.
            this.tagToQueryMap_['_' + tag] = queryKey;
        ***REMOVED***
        var writesCache = this.pendingWriteTree_.childWrites(path);
        var events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);
        if (!viewAlreadyExists && !foundAncestorDefaultView) ***REMOVED***
            var view /** @type !View */ = syncPoint.viewForQuery(query);
            events = events.concat(this.setupListener_(query, view));
        ***REMOVED***
        return events;
    ***REMOVED***;
    /**
     * Remove event callback(s).
     *
     * If query is the default query, we'll check all queries for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
     *
     * @param ***REMOVED***!Query***REMOVED*** query
     * @param ***REMOVED***?EventRegistration***REMOVED*** eventRegistration If null, all callbacks are removed.
     * @param ***REMOVED***Error=***REMOVED*** cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Cancel events, if cancelError was provided.
     */
    SyncTree.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) ***REMOVED***
        var _this = this;
        // Find the syncPoint first. Then deal with whether or not it has matching listeners
        var path = query.path;
        var maybeSyncPoint = this.syncPointTree_.get(path);
        var cancelEvents = [];
        // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
        // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
        // not loadsAllData().
        if (maybeSyncPoint &&
            (query.queryIdentifier() === 'default' ||
                maybeSyncPoint.viewExistsForQuery(query))) ***REMOVED***
            /**
             * @type ***REMOVED******REMOVED***removed: !Array.<!Query>, events: !Array.<!Event>***REMOVED******REMOVED***
             */
            var removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);
            if (maybeSyncPoint.isEmpty()) ***REMOVED***
                this.syncPointTree_ = this.syncPointTree_.remove(path);
            ***REMOVED***
            var removed = removedAndEvents.removed;
            cancelEvents = removedAndEvents.events;
            // We may have just removed one of many listeners and can short-circuit this whole process
            // We may also not have removed a default listener, in which case all of the descendant listeners should already be
            // properly set up.
            //
            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
            // queryId === 'default'
            var removingDefault = -1 !==
                removed.findIndex(function (query) ***REMOVED***
                    return query.getQueryParams().loadsAllData();
                ***REMOVED***);
            var covered = this.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) ***REMOVED***
                return parentSyncPoint.hasCompleteView();
            ***REMOVED***);
            if (removingDefault && !covered) ***REMOVED***
                var subtree = this.syncPointTree_.subtree(path);
                // There are potentially child listeners. Determine what if any listens we need to send before executing the
                // removal
                if (!subtree.isEmpty()) ***REMOVED***
                    // We need to fold over our subtree and collect the listeners to send
                    var newViews = this.collectDistinctViewsForSubTree_(subtree);
                    // Ok, we've collected all the listens we need. Set them up.
                    for (var i = 0; i < newViews.length; ++i) ***REMOVED***
                        var view = newViews[i], newQuery = view.getQuery();
                        var listener = this.createListenerForView_(view);
                        this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery), listener.hashFn, listener.onComplete);
                    ***REMOVED***
                ***REMOVED***
                else ***REMOVED***
                    // There's nothing below us, so nothing we need to start listening on
                ***REMOVED***
            ***REMOVED***
            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.
            // Also, note that if we have a cancelError, it's already been removed at the provider level.
            if (!covered && removed.length > 0 && !cancelError) ***REMOVED***
                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
                // default. Otherwise, we need to iterate through and cancel each individual query
                if (removingDefault) ***REMOVED***
                    // We don't tag default listeners
                    var defaultTag = null;
                    this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);
                ***REMOVED***
                else ***REMOVED***
                    removed.forEach(function (queryToRemove) ***REMOVED***
                        var tagToRemove = _this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];
                        _this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
            // Now, clear all of the tags we're tracking for the removed listens
            this.removeTags_(removed);
        ***REMOVED***
        else ***REMOVED***
            // No-op, this listener must've been already removed
        ***REMOVED***
        return cancelEvents;
    ***REMOVED***;
    /**
     * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above
     * it, but as this is only used by transaction code, that should always be the case anyways.
     *
     * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
     * @param ***REMOVED***!Path***REMOVED*** path The path to the data we want
     * @param ***REMOVED***Array.<number>=***REMOVED*** writeIdsToExclude A specific set to be excluded
     * @return ***REMOVED***?Node***REMOVED***
     */
    SyncTree.prototype.calcCompleteEventCache = function (path, writeIdsToExclude) ***REMOVED***
        var includeHiddenSets = true;
        var writeTree = this.pendingWriteTree_;
        var serverCache = this.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) ***REMOVED***
            var relativePath = Path.relativePath(pathSoFar, path);
            var serverCache = syncPoint.getCompleteServerCache(relativePath);
            if (serverCache) ***REMOVED***
                return serverCache;
            ***REMOVED***
        ***REMOVED***);
        return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);
    ***REMOVED***;
    /**
     * This collapses multiple unfiltered views into a single view, since we only need a single
     * listener for them.
     *
     * @param ***REMOVED***!ImmutableTree.<!SyncPoint>***REMOVED*** subtree
     * @return ***REMOVED***!Array.<!View>***REMOVED***
     * @private
     */
    SyncTree.prototype.collectDistinctViewsForSubTree_ = function (subtree) ***REMOVED***
        return subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) ***REMOVED***
            if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) ***REMOVED***
                var completeView = maybeChildSyncPoint.getCompleteView();
                return [completeView];
            ***REMOVED***
            else ***REMOVED***
                // No complete view here, flatten any deeper listens into an array
                var views_1 = [];
                if (maybeChildSyncPoint) ***REMOVED***
                    views_1 = maybeChildSyncPoint.getQueryViews();
                ***REMOVED***
                forEach(childMap, function (key, childViews) ***REMOVED***
                    views_1 = views_1.concat(childViews);
                ***REMOVED***);
                return views_1;
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Array.<!Query>***REMOVED*** queries
     * @private
     */
    SyncTree.prototype.removeTags_ = function (queries) ***REMOVED***
        for (var j = 0; j < queries.length; ++j) ***REMOVED***
            var removedQuery = queries[j];
            if (!removedQuery.getQueryParams().loadsAllData()) ***REMOVED***
                // We should have a tag for this
                var removedQueryKey = SyncTree.makeQueryKey_(removedQuery);
                var removedQueryTag = this.queryToTagMap_[removedQueryKey];
                delete this.queryToTagMap_[removedQueryKey];
                delete this.tagToQueryMap_['_' + removedQueryTag];
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Normalizes a query to a query we send the server for listening
     * @param ***REMOVED***!Query***REMOVED*** query
     * @return ***REMOVED***!Query***REMOVED*** The normalized query
     * @private
     */
    SyncTree.queryForListening_ = function (query) ***REMOVED***
        if (query.getQueryParams().loadsAllData() &&
            !query.getQueryParams().isDefault()) ***REMOVED***
            // We treat queries that load all data as default queries
            // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
            // from Query
            return /** @type ***REMOVED***!Query***REMOVED*** */ query.getRef();
        ***REMOVED***
        else ***REMOVED***
            return query;
        ***REMOVED***
    ***REMOVED***;
    /**
     * For a given new listen, manage the de-duplication of outstanding subscriptions.
     *
     * @param ***REMOVED***!Query***REMOVED*** query
     * @param ***REMOVED***!View***REMOVED*** view
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** This method can return events to support synchronous data sources
     * @private
     */
    SyncTree.prototype.setupListener_ = function (query, view) ***REMOVED***
        var path = query.path;
        var tag = this.tagForQuery_(query);
        var listener = this.createListenerForView_(view);
        var events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn, listener.onComplete);
        var subtree = this.syncPointTree_.subtree(path);
        // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
        // may need to shadow other listens as well.
        if (tag) ***REMOVED***
            assert(!subtree.value.hasCompleteView(), "If we're adding a query, it shouldn't be shadowed");
        ***REMOVED***
        else ***REMOVED***
            // Shadow everything at or below this location, this is a default listener.
            var queriesToStop = subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) ***REMOVED***
                if (!relativePath.isEmpty() &&
                    maybeChildSyncPoint &&
                    maybeChildSyncPoint.hasCompleteView()) ***REMOVED***
                    return [maybeChildSyncPoint.getCompleteView().getQuery()];
                ***REMOVED***
                else ***REMOVED***
                    // No default listener here, flatten any deeper queries into an array
                    var queries_1 = [];
                    if (maybeChildSyncPoint) ***REMOVED***
                        queries_1 = queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function (view) ***REMOVED*** return view.getQuery(); ***REMOVED***));
                    ***REMOVED***
                    forEach(childMap, function (key, childQueries) ***REMOVED***
                        queries_1 = queries_1.concat(childQueries);
                    ***REMOVED***);
                    return queries_1;
                ***REMOVED***
            ***REMOVED***);
            for (var i = 0; i < queriesToStop.length; ++i) ***REMOVED***
                var queryToStop = queriesToStop[i];
                this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));
            ***REMOVED***
        ***REMOVED***
        return events;
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***!View***REMOVED*** view
     * @return ***REMOVED******REMOVED***hashFn: function(), onComplete: function(!string, *)***REMOVED******REMOVED***
     * @private
     */
    SyncTree.prototype.createListenerForView_ = function (view) ***REMOVED***
        var _this = this;
        var query = view.getQuery();
        var tag = this.tagForQuery_(query);
        return ***REMOVED***
            hashFn: function () ***REMOVED***
                var cache = view.getServerCache() || ChildrenNode.EMPTY_NODE;
                return cache.hash();
            ***REMOVED***,
            onComplete: function (status) ***REMOVED***
                if (status === 'ok') ***REMOVED***
                    if (tag) ***REMOVED***
                        return _this.applyTaggedListenComplete(query.path, tag);
                    ***REMOVED***
                    else ***REMOVED***
                        return _this.applyListenComplete(query.path);
                    ***REMOVED***
                ***REMOVED***
                else ***REMOVED***
                    // If a listen failed, kill all of the listeners here, not just the one that triggered the error.
                    // Note that this may need to be scoped to just this listener if we change permissions on filtered children
                    var error = errorForServerCode(status, query);
                    return _this.removeEventRegistration(query, 
                    /*eventRegistration*/ null, error);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***;
    /**
     * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
     * @private
     * @param ***REMOVED***!Query***REMOVED*** query
     * @return ***REMOVED***string***REMOVED***
     */
    SyncTree.makeQueryKey_ = function (query) ***REMOVED***
        return query.path.toString() + '$' + query.queryIdentifier();
    ***REMOVED***;
    /**
     * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
     * @private
     * @param ***REMOVED***!string***REMOVED*** queryKey
     * @return ***REMOVED******REMOVED***queryId: !string, path: !Path***REMOVED******REMOVED***
     */
    SyncTree.parseQueryKey_ = function (queryKey) ***REMOVED***
        var splitIndex = queryKey.indexOf('$');
        assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');
        return ***REMOVED***
            queryId: queryKey.substr(splitIndex + 1),
            path: new Path(queryKey.substr(0, splitIndex))
        ***REMOVED***;
    ***REMOVED***;
    /**
     * Return the query associated with the given tag, if we have one
     * @param ***REMOVED***!number***REMOVED*** tag
     * @return ***REMOVED***?string***REMOVED***
     * @private
     */
    SyncTree.prototype.queryKeyForTag_ = function (tag) ***REMOVED***
        return this.tagToQueryMap_['_' + tag];
    ***REMOVED***;
    /**
     * Return the tag associated with the given query.
     * @param ***REMOVED***!Query***REMOVED*** query
     * @return ***REMOVED***?number***REMOVED***
     * @private
     */
    SyncTree.prototype.tagForQuery_ = function (query) ***REMOVED***
        var queryKey = SyncTree.makeQueryKey_(query);
        return safeGet(this.queryToTagMap_, queryKey);
    ***REMOVED***;
    /**
     * Static accessor for query tags.
     * @return ***REMOVED***number***REMOVED***
     * @private
     */
    SyncTree.getNextQueryTag_ = function () ***REMOVED***
        return SyncTree.nextQueryTag_++;
    ***REMOVED***;
    /**
     * A helper method to apply tagged operations
     *
     * @param ***REMOVED***!Path***REMOVED*** queryPath
     * @param ***REMOVED***!Operation***REMOVED*** operation
     * @return ***REMOVED***!Array.<!Event>***REMOVED***
     * @private
     */
    SyncTree.prototype.applyTaggedOperation_ = function (queryPath, operation) ***REMOVED***
        var syncPoint = this.syncPointTree_.get(queryPath);
        assert(syncPoint, "Missing sync point for query tag that we're tracking");
        var writesCache = this.pendingWriteTree_.childWrites(queryPath);
        return syncPoint.applyOperation(operation, writesCache, 
        /*serverCache=*/ null);
    ***REMOVED***;
    /**
     * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
     *
     * NOTES:
     * - Descendant SyncPoints will be visited first (since we raise events depth-first).
  
     * - We call applyOperation() on each SyncPoint passing three things:
     *   1. A version of the Operation that has been made relative to the SyncPoint location.
     *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
     *   3. A snapshot Node with cached server data, if we have it.
  
     * - We concatenate all of the events returned by each SyncPoint and return the result.
     *
     * @param ***REMOVED***!Operation***REMOVED*** operation
     * @return ***REMOVED***!Array.<!Event>***REMOVED***
     * @private
     */
    SyncTree.prototype.applyOperationToSyncPoints_ = function (operation) ***REMOVED***
        return this.applyOperationHelper_(operation, this.syncPointTree_, 
        /*serverCache=*/ null, this.pendingWriteTree_.childWrites(Path.Empty));
    ***REMOVED***;
    /**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param ***REMOVED***!Operation***REMOVED*** operation
     * @param ***REMOVED***ImmutableTree.<!SyncPoint>***REMOVED*** syncPointTree
     * @param ***REMOVED***?Node***REMOVED*** serverCache
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @return ***REMOVED***!Array.<!Event>***REMOVED***
     */
    SyncTree.prototype.applyOperationHelper_ = function (operation, syncPointTree, serverCache, writesCache) ***REMOVED***
        if (operation.path.isEmpty()) ***REMOVED***
            return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
        ***REMOVED***
        else ***REMOVED***
            var syncPoint = syncPointTree.get(Path.Empty);
            // If we don't have cached server data, see if we can get it from this SyncPoint.
            if (serverCache == null && syncPoint != null) ***REMOVED***
                serverCache = syncPoint.getCompleteServerCache(Path.Empty);
            ***REMOVED***
            var events = [];
            var childName = operation.path.getFront();
            var childOperation = operation.operationForChild(childName);
            var childTree = syncPointTree.children.get(childName);
            if (childTree && childOperation) ***REMOVED***
                var childServerCache = serverCache
                    ? serverCache.getImmediateChild(childName)
                    : null;
                var childWritesCache = writesCache.child(childName);
                events = events.concat(this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
            ***REMOVED***
            if (syncPoint) ***REMOVED***
                events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));
            ***REMOVED***
            return events;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param ***REMOVED***!Operation***REMOVED*** operation
     * @param ***REMOVED***ImmutableTree.<!SyncPoint>***REMOVED*** syncPointTree
     * @param ***REMOVED***?Node***REMOVED*** serverCache
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @return ***REMOVED***!Array.<!Event>***REMOVED***
     */
    SyncTree.prototype.applyOperationDescendantsHelper_ = function (operation, syncPointTree, serverCache, writesCache) ***REMOVED***
        var _this = this;
        var syncPoint = syncPointTree.get(Path.Empty);
        // If we don't have cached server data, see if we can get it from this SyncPoint.
        if (serverCache == null && syncPoint != null) ***REMOVED***
            serverCache = syncPoint.getCompleteServerCache(Path.Empty);
        ***REMOVED***
        var events = [];
        syncPointTree.children.inorderTraversal(function (childName, childTree) ***REMOVED***
            var childServerCache = serverCache
                ? serverCache.getImmediateChild(childName)
                : null;
            var childWritesCache = writesCache.child(childName);
            var childOperation = operation.operationForChild(childName);
            if (childOperation) ***REMOVED***
                events = events.concat(_this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
            ***REMOVED***
        ***REMOVED***);
        if (syncPoint) ***REMOVED***
            events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));
        ***REMOVED***
        return events;
    ***REMOVED***;
    /**
     * Static tracker for next query tag.
     * @type ***REMOVED***number***REMOVED***
     * @private
     */
    SyncTree.nextQueryTag_ = 1;
    return SyncTree;
***REMOVED***());
export ***REMOVED*** SyncTree ***REMOVED***;

//# sourceMappingURL=SyncTree.js.map
