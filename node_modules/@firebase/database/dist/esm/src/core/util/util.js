/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** assert ***REMOVED*** from '@firebase/util';
import ***REMOVED*** forEach ***REMOVED*** from '@firebase/util';
import ***REMOVED*** base64 ***REMOVED*** from '@firebase/util';
import ***REMOVED*** Sha1 ***REMOVED*** from '@firebase/util';
import ***REMOVED*** stringToByteArray ***REMOVED*** from '@firebase/util';
import ***REMOVED*** stringify ***REMOVED*** from '@firebase/util';
import ***REMOVED*** SessionStorage ***REMOVED*** from '../storage/storage';
import ***REMOVED*** isNodeSdk ***REMOVED*** from '@firebase/util';
/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 * @type ***REMOVED***function(): number***REMOVED*** Generated ID.
 */
export var LUIDGenerator = (function () ***REMOVED***
    var id = 1;
    return function () ***REMOVED***
        return id++;
    ***REMOVED***;
***REMOVED***)();
/**
 * Sha1 hash of the input string
 * @param ***REMOVED***!string***REMOVED*** str The string to hash
 * @return ***REMOVED***!string***REMOVED*** The resulting hash
 */
export var sha1 = function (str) ***REMOVED***
    var utf8Bytes = stringToByteArray(str);
    var sha1 = new Sha1();
    sha1.update(utf8Bytes);
    var sha1Bytes = sha1.digest();
    return base64.encodeByteArray(sha1Bytes);
***REMOVED***;
/**
 * @param ***REMOVED***...****REMOVED*** var_args
 * @return ***REMOVED***string***REMOVED***
 * @private
 */
var buildLogMessage_ = function () ***REMOVED***
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
        var_args[_i] = arguments[_i];
    ***REMOVED***
    var message = '';
    for (var i = 0; i < var_args.length; i++) ***REMOVED***
        if (Array.isArray(var_args[i]) ||
            (var_args[i] &&
                typeof var_args[i] === 'object' &&
                typeof var_args[i].length === 'number')) ***REMOVED***
            message += buildLogMessage_.apply(null, var_args[i]);
        ***REMOVED***
        else if (typeof var_args[i] === 'object') ***REMOVED***
            message += stringify(var_args[i]);
        ***REMOVED***
        else ***REMOVED***
            message += var_args[i];
        ***REMOVED***
        message += ' ';
    ***REMOVED***
    return message;
***REMOVED***;
/**
 * Use this for all debug messages in Firebase.
 * @type ***REMOVED***?function(string)***REMOVED***
 */
export var logger = null;
/**
 * Flag to check for log availability on first log message
 * @type ***REMOVED***boolean***REMOVED***
 * @private
 */
var firstLog_ = true;
/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param ***REMOVED***boolean|?function(string)***REMOVED*** logger_ A flag to turn on logging, or a custom logger
 * @param ***REMOVED***boolean=***REMOVED*** persistent Whether or not to persist logging settings across refreshes
 */
export var enableLogging = function (logger_, persistent) ***REMOVED***
    assert(!persistent || (logger_ === true || logger_ === false), "Can't turn on custom loggers persistently.");
    if (logger_ === true) ***REMOVED***
        if (typeof console !== 'undefined') ***REMOVED***
            if (typeof console.log === 'function') ***REMOVED***
                logger = console.log.bind(console);
            ***REMOVED***
            else if (typeof console.log === 'object') ***REMOVED***
                // IE does this.
                logger = function (message) ***REMOVED***
                    console.log(message);
                ***REMOVED***;
            ***REMOVED***
        ***REMOVED***
        if (persistent)
            SessionStorage.set('logging_enabled', true);
    ***REMOVED***
    else if (typeof logger_ === 'function') ***REMOVED***
        logger = logger_;
    ***REMOVED***
    else ***REMOVED***
        logger = null;
        SessionStorage.remove('logging_enabled');
    ***REMOVED***
***REMOVED***;
/**
 *
 * @param ***REMOVED***...(string|Arguments)***REMOVED*** var_args
 */
export var log = function () ***REMOVED***
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
        var_args[_i] = arguments[_i];
    ***REMOVED***
    if (firstLog_ === true) ***REMOVED***
        firstLog_ = false;
        if (logger === null && SessionStorage.get('logging_enabled') === true)
            enableLogging(true);
    ***REMOVED***
    if (logger) ***REMOVED***
        var message = buildLogMessage_.apply(null, var_args);
        logger(message);
    ***REMOVED***
***REMOVED***;
/**
 * @param ***REMOVED***!string***REMOVED*** prefix
 * @return ***REMOVED***function(...[*])***REMOVED***
 */
export var logWrapper = function (prefix) ***REMOVED***
    return function () ***REMOVED***
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            var_args[_i] = arguments[_i];
        ***REMOVED***
        log.apply(void 0, [prefix].concat(var_args));
    ***REMOVED***;
***REMOVED***;
/**
 * @param ***REMOVED***...string***REMOVED*** var_args
 */
export var error = function () ***REMOVED***
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
        var_args[_i] = arguments[_i];
    ***REMOVED***
    if (typeof console !== 'undefined') ***REMOVED***
        var message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_.apply(void 0, var_args);
        if (typeof console.error !== 'undefined') ***REMOVED***
            console.error(message);
        ***REMOVED***
        else ***REMOVED***
            console.log(message);
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
/**
 * @param ***REMOVED***...string***REMOVED*** var_args
 */
export var fatal = function () ***REMOVED***
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
        var_args[_i] = arguments[_i];
    ***REMOVED***
    var message = buildLogMessage_.apply(void 0, var_args);
    throw new Error('FIREBASE FATAL ERROR: ' + message);
***REMOVED***;
/**
 * @param ***REMOVED***...****REMOVED*** var_args
 */
export var warn = function () ***REMOVED***
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
        var_args[_i] = arguments[_i];
    ***REMOVED***
    if (typeof console !== 'undefined') ***REMOVED***
        var message = 'FIREBASE WARNING: ' + buildLogMessage_.apply(void 0, var_args);
        if (typeof console.warn !== 'undefined') ***REMOVED***
            console.warn(message);
        ***REMOVED***
        else ***REMOVED***
            console.log(message);
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */
export var warnIfPageIsSecure = function () ***REMOVED***
    // Be very careful accessing browser globals. Who knows what may or may not exist.
    if (typeof window !== 'undefined' &&
        window.location &&
        window.location.protocol &&
        window.location.protocol.indexOf('https:') !== -1) ***REMOVED***
        warn('Insecure Firebase access from a secure page. ' +
            'Please use https in calls to new Firebase().');
    ***REMOVED***
***REMOVED***;
/**
 * @param ***REMOVED***!String***REMOVED*** methodName
 */
export var warnAboutUnsupportedMethod = function (methodName) ***REMOVED***
    warn(methodName +
        ' is unsupported and will likely change soon.  ' +
        'Please do not use.');
***REMOVED***;
/**
 * Returns true if data is NaN, or +/- Infinity.
 * @param ***REMOVED*******REMOVED*** data
 * @return ***REMOVED***boolean***REMOVED***
 */
export var isInvalidJSONNumber = function (data) ***REMOVED***
    return (typeof data === 'number' &&
        (data != data || // NaN
            data == Number.POSITIVE_INFINITY ||
            data == Number.NEGATIVE_INFINITY));
***REMOVED***;
/**
 * @param ***REMOVED***function()***REMOVED*** fn
 */
export var executeWhenDOMReady = function (fn) ***REMOVED***
    if (isNodeSdk() || document.readyState === 'complete') ***REMOVED***
        fn();
    ***REMOVED***
    else ***REMOVED***
        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
        // fire before onload), but fall back to onload.
        var called_1 = false;
        var wrappedFn_1 = function () ***REMOVED***
            if (!document.body) ***REMOVED***
                setTimeout(wrappedFn_1, Math.floor(10));
                return;
            ***REMOVED***
            if (!called_1) ***REMOVED***
                called_1 = true;
                fn();
            ***REMOVED***
        ***REMOVED***;
        if (document.addEventListener) ***REMOVED***
            document.addEventListener('DOMContentLoaded', wrappedFn_1, false);
            // fallback to onload.
            window.addEventListener('load', wrappedFn_1, false);
        ***REMOVED***
        else if (document.attachEvent) ***REMOVED***
            // IE.
            document.attachEvent('onreadystatechange', function () ***REMOVED***
                if (document.readyState === 'complete')
                    wrappedFn_1();
            ***REMOVED***);
            // fallback to onload.
            window.attachEvent('onload', wrappedFn_1);
            // jQuery has an extra hack for IE that we could employ (based on
            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
            // I'm hoping we don't need it.
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 * @type ***REMOVED***!string***REMOVED***
 */
export var MIN_NAME = '[MIN_NAME]';
/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 * @type ***REMOVED***!string***REMOVED***
 */
export var MAX_NAME = '[MAX_NAME]';
/**
 * Compares valid Firebase key names, plus min and max name
 * @param ***REMOVED***!string***REMOVED*** a
 * @param ***REMOVED***!string***REMOVED*** b
 * @return ***REMOVED***!number***REMOVED***
 */
export var nameCompare = function (a, b) ***REMOVED***
    if (a === b) ***REMOVED***
        return 0;
    ***REMOVED***
    else if (a === MIN_NAME || b === MAX_NAME) ***REMOVED***
        return -1;
    ***REMOVED***
    else if (b === MIN_NAME || a === MAX_NAME) ***REMOVED***
        return 1;
    ***REMOVED***
    else ***REMOVED***
        var aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
        if (aAsInt !== null) ***REMOVED***
            if (bAsInt !== null) ***REMOVED***
                return aAsInt - bAsInt == 0 ? a.length - b.length : aAsInt - bAsInt;
            ***REMOVED***
            else ***REMOVED***
                return -1;
            ***REMOVED***
        ***REMOVED***
        else if (bAsInt !== null) ***REMOVED***
            return 1;
        ***REMOVED***
        else ***REMOVED***
            return a < b ? -1 : 1;
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
/**
 * @param ***REMOVED***!string***REMOVED*** a
 * @param ***REMOVED***!string***REMOVED*** b
 * @return ***REMOVED***!number***REMOVED*** comparison result.
 */
export var stringCompare = function (a, b) ***REMOVED***
    if (a === b) ***REMOVED***
        return 0;
    ***REMOVED***
    else if (a < b) ***REMOVED***
        return -1;
    ***REMOVED***
    else ***REMOVED***
        return 1;
    ***REMOVED***
***REMOVED***;
/**
 * @param ***REMOVED***string***REMOVED*** key
 * @param ***REMOVED***Object***REMOVED*** obj
 * @return ***REMOVED*******REMOVED***
 */
export var requireKey = function (key, obj) ***REMOVED***
    if (obj && key in obj) ***REMOVED***
        return obj[key];
    ***REMOVED***
    else ***REMOVED***
        throw new Error('Missing required key (' + key + ') in object: ' + stringify(obj));
    ***REMOVED***
***REMOVED***;
/**
 * @param ***REMOVED*******REMOVED*** obj
 * @return ***REMOVED***string***REMOVED***
 */
export var ObjectToUniqueKey = function (obj) ***REMOVED***
    if (typeof obj !== 'object' || obj === null)
        return stringify(obj);
    var keys = [];
    for (var k in obj) ***REMOVED***
        keys.push(k);
    ***REMOVED***
    // Export as json, but with the keys sorted.
    keys.sort();
    var key = '***REMOVED***';
    for (var i = 0; i < keys.length; i++) ***REMOVED***
        if (i !== 0)
            key += ',';
        key += stringify(keys[i]);
        key += ':';
        key += ObjectToUniqueKey(obj[keys[i]]);
    ***REMOVED***
    key += '***REMOVED***';
    return key;
***REMOVED***;
/**
 * Splits a string into a number of smaller segments of maximum size
 * @param ***REMOVED***!string***REMOVED*** str The string
 * @param ***REMOVED***!number***REMOVED*** segsize The maximum number of chars in the string.
 * @return ***REMOVED***Array.<string>***REMOVED*** The string, split into appropriately-sized chunks
 */
export var splitStringBySize = function (str, segsize) ***REMOVED***
    var len = str.length;
    if (len <= segsize) ***REMOVED***
        return [str];
    ***REMOVED***
    var dataSegs = [];
    for (var c = 0; c < len; c += segsize) ***REMOVED***
        if (c + segsize > len) ***REMOVED***
            dataSegs.push(str.substring(c, len));
        ***REMOVED***
        else ***REMOVED***
            dataSegs.push(str.substring(c, c + segsize));
        ***REMOVED***
    ***REMOVED***
    return dataSegs;
***REMOVED***;
/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param ***REMOVED***!(Object|Array)***REMOVED*** obj The object or array to iterate over
 * @param ***REMOVED***function(?, ?)***REMOVED*** fn The function to apply
 */
export var each = function (obj, fn) ***REMOVED***
    if (Array.isArray(obj)) ***REMOVED***
        for (var i = 0; i < obj.length; ++i) ***REMOVED***
            fn(i, obj[i]);
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
        /**
         * in the conversion of code we removed the goog.object.forEach
         * function which did a value,key callback. We standardized on
         * a single impl that does a key, value callback. So we invert
         * to not have to touch the `each` code points
         */
        forEach(obj, function (key, val) ***REMOVED*** return fn(val, key); ***REMOVED***);
    ***REMOVED***
***REMOVED***;
/**
 * Like goog.bind, but doesn't bother to create a closure if opt_context is null/undefined.
 * @param ***REMOVED***function(*)***REMOVED*** callback Callback function.
 * @param ***REMOVED***?Object=***REMOVED*** context Optional context to bind to.
 * @return ***REMOVED***function(*)***REMOVED***
 */
export var bindCallback = function (callback, context) ***REMOVED***
    return context ? callback.bind(context) : callback;
***REMOVED***;
/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param ***REMOVED***!number***REMOVED*** v A double
 * @return ***REMOVED***string***REMOVED***
 */
export var doubleToIEEE754String = function (v) ***REMOVED***
    assert(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL
    var ebits = 11, fbits = 52;
    var bias = (1 << (ebits - 1)) - 1, s, e, f, ln, i, bits, str;
    // Compute sign, exponent, fraction
    // Skip NaN / Infinity handling --MJL.
    if (v === 0) ***REMOVED***
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
    ***REMOVED***
    else ***REMOVED***
        s = v < 0;
        v = Math.abs(v);
        if (v >= Math.pow(2, 1 - bias)) ***REMOVED***
            // Normalized
            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
            e = ln + bias;
            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
        ***REMOVED***
        else ***REMOVED***
            // Denormalized
            e = 0;
            f = Math.round(v / Math.pow(2, 1 - bias - fbits));
        ***REMOVED***
    ***REMOVED***
    // Pack sign, exponent, fraction
    bits = [];
    for (i = fbits; i; i -= 1) ***REMOVED***
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
    ***REMOVED***
    for (i = ebits; i; i -= 1) ***REMOVED***
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
    ***REMOVED***
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');
    // Return the data as a hex string. --MJL
    var hexByteString = '';
    for (i = 0; i < 64; i += 8) ***REMOVED***
        var hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1)
            hexByte = '0' + hexByte;
        hexByteString = hexByteString + hexByte;
    ***REMOVED***
    return hexByteString.toLowerCase();
***REMOVED***;
/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 * @return ***REMOVED***boolean***REMOVED***
 */
export var isChromeExtensionContentScript = function () ***REMOVED***
    return !!(typeof window === 'object' &&
        window['chrome'] &&
        window['chrome']['extension'] &&
        !/^chrome/.test(window.location.href));
***REMOVED***;
/**
 * Used to detect if we're in a Windows 8 Store app.
 * @return ***REMOVED***boolean***REMOVED***
 */
export var isWindowsStoreApp = function () ***REMOVED***
    // Check for the presence of a couple WinRT globals
    return typeof Windows === 'object' && typeof Windows.UI === 'object';
***REMOVED***;
/**
 * Converts a server error code to a Javascript Error
 * @param ***REMOVED***!string***REMOVED*** code
 * @param ***REMOVED***!Query***REMOVED*** query
 * @return ***REMOVED***Error***REMOVED***
 */
export var errorForServerCode = function (code, query) ***REMOVED***
    var reason = 'Unknown Error';
    if (code === 'too_big') ***REMOVED***
        reason =
            'The data requested exceeds the maximum size ' +
                'that can be accessed with a single request.';
    ***REMOVED***
    else if (code == 'permission_denied') ***REMOVED***
        reason = "Client doesn't have permission to access the desired data.";
    ***REMOVED***
    else if (code == 'unavailable') ***REMOVED***
        reason = 'The service is unavailable';
    ***REMOVED***
    var error = new Error(code + ' at ' + query.path.toString() + ': ' + reason);
    error.code = code.toUpperCase();
    return error;
***REMOVED***;
/**
 * Used to test for integer-looking strings
 * @type ***REMOVED***RegExp***REMOVED***
 * @private
 */
export var INTEGER_REGEXP_ = new RegExp('^-?\\d***REMOVED***1,10***REMOVED***$');
/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 * @param ***REMOVED***!string***REMOVED*** str
 * @return ***REMOVED***?number***REMOVED***
 */
export var tryParseInt = function (str) ***REMOVED***
    if (INTEGER_REGEXP_.test(str)) ***REMOVED***
        var intVal = Number(str);
        if (intVal >= -2147483648 && intVal <= 2147483647) ***REMOVED***
            return intVal;
        ***REMOVED***
    ***REMOVED***
    return null;
***REMOVED***;
/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param ***REMOVED***!function()***REMOVED*** fn The code to guard.
 */
export var exceptionGuard = function (fn) ***REMOVED***
    try ***REMOVED***
        fn();
    ***REMOVED***
    catch (e) ***REMOVED***
        // Re-throw exception when it's safe.
        setTimeout(function () ***REMOVED***
            // It used to be that "throw e" would result in a good console error with
            // relevant context, but as of Chrome 39, you just get the firebase.js
            // file/line number where we re-throw it, which is useless. So we log
            // e.stack explicitly.
            var stack = e.stack || '';
            warn('Exception was thrown by user callback.', stack);
            throw e;
        ***REMOVED***, Math.floor(0));
    ***REMOVED***
***REMOVED***;
/**
 * Helper function to safely call opt_callback with the specified arguments.  It:
 * 1. Turns into a no-op if opt_callback is null or undefined.
 * 2. Wraps the call inside exceptionGuard to prevent exceptions from breaking our state.
 *
 * @param ***REMOVED***?Function=***REMOVED*** callback Optional onComplete callback.
 * @param ***REMOVED***...****REMOVED*** var_args Arbitrary args to be passed to opt_onComplete
 */
export var callUserCallback = function (callback) ***REMOVED***
    var var_args = [];
    for (var _i = 1; _i < arguments.length; _i++) ***REMOVED***
        var_args[_i - 1] = arguments[_i];
    ***REMOVED***
    if (typeof callback === 'function') ***REMOVED***
        exceptionGuard(function () ***REMOVED***
            callback.apply(void 0, var_args);
        ***REMOVED***);
    ***REMOVED***
***REMOVED***;
/**
 * @return ***REMOVED***boolean***REMOVED*** true if we think we're currently being crawled.
 */
export var beingCrawled = function () ***REMOVED***
    var userAgent = (typeof window === 'object' &&
        window['navigator'] &&
        window['navigator']['userAgent']) ||
        '';
    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
    // believe to support JavaScript/AJAX rendering.
    // NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
    // would have seen the page" is flaky if we don't treat it as a crawler.
    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);
***REMOVED***;
/**
 * Export a property of an object using a getter function.
 *
 * @param ***REMOVED***!Object***REMOVED*** object
 * @param ***REMOVED***string***REMOVED*** name
 * @param ***REMOVED***!function(): ****REMOVED*** fnGet
 */
export var exportPropGetter = function (object, name, fnGet) ***REMOVED***
    Object.defineProperty(object, name, ***REMOVED*** get: fnGet ***REMOVED***);
***REMOVED***;
/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param ***REMOVED***Function***REMOVED*** fn Function to run.
 * @param ***REMOVED***number***REMOVED*** time Milliseconds to wait before running.
 * @return ***REMOVED***number|Object***REMOVED*** The setTimeout() return value.
 */
export var setTimeoutNonBlocking = function (fn, time) ***REMOVED***
    var timeout = setTimeout(fn, time);
    if (typeof timeout === 'object' && timeout['unref']) ***REMOVED***
        timeout['unref']();
    ***REMOVED***
    return timeout;
***REMOVED***;

//# sourceMappingURL=util.js.map
