/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** SortedMap ***REMOVED*** from './SortedMap';
import ***REMOVED*** Path ***REMOVED*** from './Path';
import ***REMOVED*** stringCompare ***REMOVED*** from './util';
import ***REMOVED*** forEach ***REMOVED*** from '@firebase/util';
var emptyChildrenSingleton;
/**
 * Singleton empty children collection.
 *
 * @const
 * @type ***REMOVED***!SortedMap.<string, !ImmutableTree.<?>>***REMOVED***
 */
var EmptyChildren = function () ***REMOVED***
    if (!emptyChildrenSingleton) ***REMOVED***
        emptyChildrenSingleton = new SortedMap(stringCompare);
    ***REMOVED***
    return emptyChildrenSingleton;
***REMOVED***;
/**
 * A tree with immutable elements.
 */
var ImmutableTree = /** @class */ (function () ***REMOVED***
    /**
     * @template T
     * @param ***REMOVED***?T***REMOVED*** value
     * @param ***REMOVED***SortedMap.<string, !ImmutableTree.<T>>=***REMOVED*** children
     */
    function ImmutableTree(value, children) ***REMOVED***
        if (children === void 0) ***REMOVED*** children = EmptyChildren(); ***REMOVED***
        this.value = value;
        this.children = children;
    ***REMOVED***
    /**
     * @template T
     * @param ***REMOVED***!Object.<string, !T>***REMOVED*** obj
     * @return ***REMOVED***!ImmutableTree.<!T>***REMOVED***
     */
    ImmutableTree.fromObject = function (obj) ***REMOVED***
        var tree = ImmutableTree.Empty;
        forEach(obj, function (childPath, childSnap) ***REMOVED***
            tree = tree.set(new Path(childPath), childSnap);
        ***REMOVED***);
        return tree;
    ***REMOVED***;
    /**
     * True if the value is empty and there are no children
     * @return ***REMOVED***boolean***REMOVED***
     */
    ImmutableTree.prototype.isEmpty = function () ***REMOVED***
        return this.value === null && this.children.isEmpty();
    ***REMOVED***;
    /**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of ***REMOVED***path: value:***REMOVED*** objects
     * on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param ***REMOVED***!Path***REMOVED*** relativePath The remainder of the path
     * @param ***REMOVED***function(T):boolean***REMOVED*** predicate The predicate to satisfy to return a
     *   node
     * @return ***REMOVED***?***REMOVED***path:!Path, value:!T***REMOVED******REMOVED***
     */
    ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) ***REMOVED***
        if (this.value != null && predicate(this.value)) ***REMOVED***
            return ***REMOVED*** path: Path.Empty, value: this.value ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            if (relativePath.isEmpty()) ***REMOVED***
                return null;
            ***REMOVED***
            else ***REMOVED***
                var front = relativePath.getFront();
                var child = this.children.get(front);
                if (child !== null) ***REMOVED***
                    var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);
                    if (childExistingPathAndValue != null) ***REMOVED***
                        var fullPath = new Path(front).child(childExistingPathAndValue.path);
                        return ***REMOVED*** path: fullPath, value: childExistingPathAndValue.value ***REMOVED***;
                    ***REMOVED***
                    else ***REMOVED***
                        return null;
                    ***REMOVED***
                ***REMOVED***
                else ***REMOVED***
                    return null;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     * @param ***REMOVED***!Path***REMOVED*** relativePath
     * @return ***REMOVED***?***REMOVED***path: !Path, value: !T***REMOVED******REMOVED***
     */
    ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) ***REMOVED***
        return this.findRootMostMatchingPathAndValue(relativePath, function () ***REMOVED*** return true; ***REMOVED***);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** relativePath
     * @return ***REMOVED***!ImmutableTree.<T>***REMOVED*** The subtree at the given path
     */
    ImmutableTree.prototype.subtree = function (relativePath) ***REMOVED***
        if (relativePath.isEmpty()) ***REMOVED***
            return this;
        ***REMOVED***
        else ***REMOVED***
            var front = relativePath.getFront();
            var childTree = this.children.get(front);
            if (childTree !== null) ***REMOVED***
                return childTree.subtree(relativePath.popFront());
            ***REMOVED***
            else ***REMOVED***
                return ImmutableTree.Empty;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Sets a value at the specified path.
     *
     * @param ***REMOVED***!Path***REMOVED*** relativePath Path to set value at.
     * @param ***REMOVED***?T***REMOVED*** toSet Value to set.
     * @return ***REMOVED***!ImmutableTree.<T>***REMOVED*** Resulting tree.
     */
    ImmutableTree.prototype.set = function (relativePath, toSet) ***REMOVED***
        if (relativePath.isEmpty()) ***REMOVED***
            return new ImmutableTree(toSet, this.children);
        ***REMOVED***
        else ***REMOVED***
            var front = relativePath.getFront();
            var child = this.children.get(front) || ImmutableTree.Empty;
            var newChild = child.set(relativePath.popFront(), toSet);
            var newChildren = this.children.insert(front, newChild);
            return new ImmutableTree(this.value, newChildren);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Removes the value at the specified path.
     *
     * @param ***REMOVED***!Path***REMOVED*** relativePath Path to value to remove.
     * @return ***REMOVED***!ImmutableTree.<T>***REMOVED*** Resulting tree.
     */
    ImmutableTree.prototype.remove = function (relativePath) ***REMOVED***
        if (relativePath.isEmpty()) ***REMOVED***
            if (this.children.isEmpty()) ***REMOVED***
                return ImmutableTree.Empty;
            ***REMOVED***
            else ***REMOVED***
                return new ImmutableTree(null, this.children);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            var front = relativePath.getFront();
            var child = this.children.get(front);
            if (child) ***REMOVED***
                var newChild = child.remove(relativePath.popFront());
                var newChildren = void 0;
                if (newChild.isEmpty()) ***REMOVED***
                    newChildren = this.children.remove(front);
                ***REMOVED***
                else ***REMOVED***
                    newChildren = this.children.insert(front, newChild);
                ***REMOVED***
                if (this.value === null && newChildren.isEmpty()) ***REMOVED***
                    return ImmutableTree.Empty;
                ***REMOVED***
                else ***REMOVED***
                    return new ImmutableTree(this.value, newChildren);
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                return this;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Gets a value from the tree.
     *
     * @param ***REMOVED***!Path***REMOVED*** relativePath Path to get value for.
     * @return ***REMOVED***?T***REMOVED*** Value at path, or null.
     */
    ImmutableTree.prototype.get = function (relativePath) ***REMOVED***
        if (relativePath.isEmpty()) ***REMOVED***
            return this.value;
        ***REMOVED***
        else ***REMOVED***
            var front = relativePath.getFront();
            var child = this.children.get(front);
            if (child) ***REMOVED***
                return child.get(relativePath.popFront());
            ***REMOVED***
            else ***REMOVED***
                return null;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param ***REMOVED***!Path***REMOVED*** relativePath Path to replace subtree for.
     * @param ***REMOVED***!ImmutableTree***REMOVED*** newTree New tree.
     * @return ***REMOVED***!ImmutableTree***REMOVED*** Resulting tree.
     */
    ImmutableTree.prototype.setTree = function (relativePath, newTree) ***REMOVED***
        if (relativePath.isEmpty()) ***REMOVED***
            return newTree;
        ***REMOVED***
        else ***REMOVED***
            var front = relativePath.getFront();
            var child = this.children.get(front) || ImmutableTree.Empty;
            var newChild = child.setTree(relativePath.popFront(), newTree);
            var newChildren = void 0;
            if (newChild.isEmpty()) ***REMOVED***
                newChildren = this.children.remove(front);
            ***REMOVED***
            else ***REMOVED***
                newChildren = this.children.insert(front, newChild);
            ***REMOVED***
            return new ImmutableTree(this.value, newChildren);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     * @template V
     * @param ***REMOVED***function(Path, ?T, Object.<string, V>):V***REMOVED*** fn
     * @return ***REMOVED***V***REMOVED***
     */
    ImmutableTree.prototype.fold = function (fn) ***REMOVED***
        return this.fold_(Path.Empty, fn);
    ***REMOVED***;
    /**
     * Recursive helper for public-facing fold() method
     * @template V
     * @param ***REMOVED***!Path***REMOVED*** pathSoFar
     * @param ***REMOVED***function(Path, ?T, Object.<string, V>):V***REMOVED*** fn
     * @return ***REMOVED***V***REMOVED***
     * @private
     */
    ImmutableTree.prototype.fold_ = function (pathSoFar, fn) ***REMOVED***
        var accum = ***REMOVED******REMOVED***;
        this.children.inorderTraversal(function (childKey, childTree) ***REMOVED***
            accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);
        ***REMOVED***);
        return fn(pathSoFar, this.value, accum);
    ***REMOVED***;
    /**
     * Find the first matching value on the given path. Return the result of applying f to it.
     * @template V
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!function(!Path, !T):?V***REMOVED*** f
     * @return ***REMOVED***?V***REMOVED***
     */
    ImmutableTree.prototype.findOnPath = function (path, f) ***REMOVED***
        return this.findOnPath_(path, Path.Empty, f);
    ***REMOVED***;
    ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) ***REMOVED***
        var result = this.value ? f(pathSoFar, this.value) : false;
        if (result) ***REMOVED***
            return result;
        ***REMOVED***
        else ***REMOVED***
            if (pathToFollow.isEmpty()) ***REMOVED***
                return null;
            ***REMOVED***
            else ***REMOVED***
                var front = pathToFollow.getFront();
                var nextChild = this.children.get(front);
                if (nextChild) ***REMOVED***
                    return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);
                ***REMOVED***
                else ***REMOVED***
                    return null;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!function(!Path, !T)***REMOVED*** f
     * @returns ***REMOVED***!ImmutableTree.<T>***REMOVED***
     */
    ImmutableTree.prototype.foreachOnPath = function (path, f) ***REMOVED***
        return this.foreachOnPath_(path, Path.Empty, f);
    ***REMOVED***;
    ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) ***REMOVED***
        if (pathToFollow.isEmpty()) ***REMOVED***
            return this;
        ***REMOVED***
        else ***REMOVED***
            if (this.value) ***REMOVED***
                f(currentRelativePath, this.value);
            ***REMOVED***
            var front = pathToFollow.getFront();
            var nextChild = this.children.get(front);
            if (nextChild) ***REMOVED***
                return nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f);
            ***REMOVED***
            else ***REMOVED***
                return ImmutableTree.Empty;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param ***REMOVED***function(!Path, !T)***REMOVED*** f A function to be called with
     *   the path from the root of the tree to a node, and the value at that node.
     *   Called in depth-first order.
     */
    ImmutableTree.prototype.foreach = function (f) ***REMOVED***
        this.foreach_(Path.Empty, f);
    ***REMOVED***;
    ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) ***REMOVED***
        this.children.inorderTraversal(function (childName, childTree) ***REMOVED***
            childTree.foreach_(currentRelativePath.child(childName), f);
        ***REMOVED***);
        if (this.value) ***REMOVED***
            f(currentRelativePath, this.value);
        ***REMOVED***
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***function(string, !T)***REMOVED*** f
     */
    ImmutableTree.prototype.foreachChild = function (f) ***REMOVED***
        this.children.inorderTraversal(function (childName, childTree) ***REMOVED***
            if (childTree.value) ***REMOVED***
                f(childName, childTree.value);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    ImmutableTree.Empty = new ImmutableTree(null);
    return ImmutableTree;
***REMOVED***());
export ***REMOVED*** ImmutableTree ***REMOVED***;

//# sourceMappingURL=ImmutableTree.js.map
