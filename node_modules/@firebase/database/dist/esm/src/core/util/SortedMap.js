/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An iterator over an LLRBNode.
 */
var SortedMapIterator = /** @class */ (function () ***REMOVED***
    /**
     * @template K, V, T
     * @param ***REMOVED***LLRBNode|LLRBEmptyNode***REMOVED*** node Node to iterate.
     * @param ***REMOVED***?K***REMOVED*** startKey
     * @param ***REMOVED***function(K, K): number***REMOVED*** comparator
     * @param ***REMOVED***boolean***REMOVED*** isReverse_ Whether or not to iterate in reverse
     * @param ***REMOVED***(function(K, V):T)=***REMOVED*** resultGenerator_
     */
    function SortedMapIterator(node, startKey, comparator, isReverse_, resultGenerator_) ***REMOVED***
        if (resultGenerator_ === void 0) ***REMOVED*** resultGenerator_ = null; ***REMOVED***
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        /** @private
         * @type ***REMOVED***Array.<!LLRBNode>***REMOVED***
         */
        this.nodeStack_ = [];
        var cmp = 1;
        while (!node.isEmpty()) ***REMOVED***
            node = node;
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse_)
                cmp *= -1;
            if (cmp < 0) ***REMOVED***
                // This node is less than our start key. ignore it
                if (this.isReverse_) ***REMOVED***
                    node = node.left;
                ***REMOVED***
                else ***REMOVED***
                    node = node.right;
                ***REMOVED***
            ***REMOVED***
            else if (cmp === 0) ***REMOVED***
                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;
                this.nodeStack_.push(node);
                break;
            ***REMOVED***
            else ***REMOVED***
                // This node is greater than our start key, add it to the stack and move to the next one
                this.nodeStack_.push(node);
                if (this.isReverse_) ***REMOVED***
                    node = node.right;
                ***REMOVED***
                else ***REMOVED***
                    node = node.left;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    SortedMapIterator.prototype.getNext = function () ***REMOVED***
        if (this.nodeStack_.length === 0)
            return null;
        var node = this.nodeStack_.pop();
        var result;
        if (this.resultGenerator_)
            result = this.resultGenerator_(node.key, node.value);
        else
            result = ***REMOVED*** key: node.key, value: node.value ***REMOVED***;
        if (this.isReverse_) ***REMOVED***
            node = node.left;
            while (!node.isEmpty()) ***REMOVED***
                this.nodeStack_.push(node);
                node = node.right;
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            node = node.right;
            while (!node.isEmpty()) ***REMOVED***
                this.nodeStack_.push(node);
                node = node.left;
            ***REMOVED***
        ***REMOVED***
        return result;
    ***REMOVED***;
    SortedMapIterator.prototype.hasNext = function () ***REMOVED***
        return this.nodeStack_.length > 0;
    ***REMOVED***;
    SortedMapIterator.prototype.peek = function () ***REMOVED***
        if (this.nodeStack_.length === 0)
            return null;
        var node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) ***REMOVED***
            return this.resultGenerator_(node.key, node.value);
        ***REMOVED***
        else ***REMOVED***
            return ***REMOVED*** key: node.key, value: node.value ***REMOVED***;
        ***REMOVED***
    ***REMOVED***;
    return SortedMapIterator;
***REMOVED***());
export ***REMOVED*** SortedMapIterator ***REMOVED***;
/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
var LLRBNode = /** @class */ (function () ***REMOVED***
    /**
     * @template K, V
     * @param ***REMOVED***!K***REMOVED*** key Key associated with this node.
     * @param ***REMOVED***!V***REMOVED*** value Value associated with this node.
     * @param ***REMOVED***?boolean***REMOVED*** color Whether this node is red.
     * @param ***REMOVED***?(LLRBNode|LLRBEmptyNode)=***REMOVED*** left Left child.
     * @param ***REMOVED***?(LLRBNode|LLRBEmptyNode)=***REMOVED*** right Right child.
     */
    function LLRBNode(key, value, color, left, right) ***REMOVED***
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left =
            left != null ? left : SortedMap.EMPTY_NODE;
        this.right =
            right != null ? right : SortedMap.EMPTY_NODE;
    ***REMOVED***
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param ***REMOVED***?K***REMOVED*** key New key for the node, or null.
     * @param ***REMOVED***?V***REMOVED*** value New value for the node, or null.
     * @param ***REMOVED***?boolean***REMOVED*** color New color for the node, or null.
     * @param ***REMOVED***?LLRBNode|LLRBEmptyNode***REMOVED*** left New left child for the node, or null.
     * @param ***REMOVED***?LLRBNode|LLRBEmptyNode***REMOVED*** right New right child for the node, or null.
     * @return ***REMOVED***!LLRBNode***REMOVED*** The node copy.
     */
    LLRBNode.prototype.copy = function (key, value, color, left, right) ***REMOVED***
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    ***REMOVED***;
    /**
     * @return ***REMOVED***number***REMOVED*** The total number of nodes in the tree.
     */
    LLRBNode.prototype.count = function () ***REMOVED***
        return this.left.count() + 1 + this.right.count();
    ***REMOVED***;
    /**
     * @return ***REMOVED***boolean***REMOVED*** True if the tree is empty.
     */
    LLRBNode.prototype.isEmpty = function () ***REMOVED***
        return false;
    ***REMOVED***;
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param ***REMOVED***function(!K, !V):****REMOVED*** action Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @return ***REMOVED*******REMOVED*** The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    LLRBNode.prototype.inorderTraversal = function (action) ***REMOVED***
        return (this.left.inorderTraversal(action) ||
            action(this.key, this.value) ||
            this.right.inorderTraversal(action));
    ***REMOVED***;
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param ***REMOVED***function(!Object, !Object)***REMOVED*** action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return ***REMOVED*******REMOVED*** True if traversal was aborted.
     */
    LLRBNode.prototype.reverseTraversal = function (action) ***REMOVED***
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
    ***REMOVED***;
    /**
     * @return ***REMOVED***!Object***REMOVED*** The minimum node in the tree.
     * @private
     */
    LLRBNode.prototype.min_ = function () ***REMOVED***
        if (this.left.isEmpty()) ***REMOVED***
            return this;
        ***REMOVED***
        else ***REMOVED***
            return this.left.min_();
        ***REMOVED***
    ***REMOVED***;
    /**
     * @return ***REMOVED***!K***REMOVED*** The maximum key in the tree.
     */
    LLRBNode.prototype.minKey = function () ***REMOVED***
        return this.min_().key;
    ***REMOVED***;
    /**
     * @return ***REMOVED***!K***REMOVED*** The maximum key in the tree.
     */
    LLRBNode.prototype.maxKey = function () ***REMOVED***
        if (this.right.isEmpty()) ***REMOVED***
            return this.key;
        ***REMOVED***
        else ***REMOVED***
            return this.right.maxKey();
        ***REMOVED***
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***!Object***REMOVED*** key Key to insert.
     * @param ***REMOVED***!Object***REMOVED*** value Value to insert.
     * @param ***REMOVED***Comparator***REMOVED*** comparator Comparator.
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, with the key/value added.
     */
    LLRBNode.prototype.insert = function (key, value, comparator) ***REMOVED***
        var cmp, n;
        n = this;
        cmp = comparator(key, n.key);
        if (cmp < 0) ***REMOVED***
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        ***REMOVED***
        else if (cmp === 0) ***REMOVED***
            n = n.copy(null, value, null, null, null);
        ***REMOVED***
        else ***REMOVED***
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        ***REMOVED***
        return n.fixUp_();
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***!LLRBNode|LLRBEmptyNode***REMOVED*** New tree, with the minimum key removed.
     */
    LLRBNode.prototype.removeMin_ = function () ***REMOVED***
        if (this.left.isEmpty()) ***REMOVED***
            return SortedMap.EMPTY_NODE;
        ***REMOVED***
        var n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_())
            n = n.moveRedLeft_();
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Object***REMOVED*** key The key of the item to remove.
     * @param ***REMOVED***Comparator***REMOVED*** comparator Comparator.
     * @return ***REMOVED***!LLRBNode|LLRBEmptyNode***REMOVED*** New tree, with the specified item removed.
     */
    LLRBNode.prototype.remove = function (key, comparator) ***REMOVED***
        var n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) ***REMOVED***
            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) ***REMOVED***
                n = n.moveRedLeft_();
            ***REMOVED***
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        ***REMOVED***
        else ***REMOVED***
            if (n.left.isRed_())
                n = n.rotateRight_();
            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) ***REMOVED***
                n = n.moveRedRight_();
            ***REMOVED***
            if (comparator(key, n.key) === 0) ***REMOVED***
                if (n.right.isEmpty()) ***REMOVED***
                    return SortedMap.EMPTY_NODE;
                ***REMOVED***
                else ***REMOVED***
                    smallest = n.right.min_();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
                ***REMOVED***
            ***REMOVED***
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        ***REMOVED***
        return n.fixUp_();
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***boolean***REMOVED*** Whether this is a RED node.
     */
    LLRBNode.prototype.isRed_ = function () ***REMOVED***
        return this.color;
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree after performing any needed rotations.
     */
    LLRBNode.prototype.fixUp_ = function () ***REMOVED***
        var n = this;
        if (n.right.isRed_() && !n.left.isRed_())
            n = n.rotateLeft_();
        if (n.left.isRed_() && n.left.left.isRed_())
            n = n.rotateRight_();
        if (n.left.isRed_() && n.right.isRed_())
            n = n.colorFlip_();
        return n;
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after moveRedLeft.
     */
    LLRBNode.prototype.moveRedLeft_ = function () ***REMOVED***
        var n = this.colorFlip_();
        if (n.right.left.isRed_()) ***REMOVED***
            n = n.copy(null, null, null, null, n.right.rotateRight_());
            n = n.rotateLeft_();
            n = n.colorFlip_();
        ***REMOVED***
        return n;
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after moveRedRight.
     */
    LLRBNode.prototype.moveRedRight_ = function () ***REMOVED***
        var n = this.colorFlip_();
        if (n.left.left.isRed_()) ***REMOVED***
            n = n.rotateRight_();
            n = n.colorFlip_();
        ***REMOVED***
        return n;
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after rotateLeft.
     */
    LLRBNode.prototype.rotateLeft_ = function () ***REMOVED***
        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after rotateRight.
     */
    LLRBNode.prototype.rotateRight_ = function () ***REMOVED***
        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after colorFlip.
     */
    LLRBNode.prototype.colorFlip_ = function () ***REMOVED***
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
    ***REMOVED***;
    /**
     * For testing.
     *
     * @private
     * @return ***REMOVED***boolean***REMOVED*** True if all is well.
     */
    LLRBNode.prototype.checkMaxDepth_ = function () ***REMOVED***
        var blackDepth = this.check_();
        return Math.pow(2.0, blackDepth) <= this.count() + 1;
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***number***REMOVED*** Not sure what this returns exactly. :-).
     */
    LLRBNode.prototype.check_ = function () ***REMOVED***
        var blackDepth;
        if (this.isRed_() && this.left.isRed_()) ***REMOVED***
            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');
        ***REMOVED***
        if (this.right.isRed_()) ***REMOVED***
            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');
        ***REMOVED***
        blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) ***REMOVED***
            throw new Error('Black depths differ');
        ***REMOVED***
        else ***REMOVED***
            return blackDepth + (this.isRed_() ? 0 : 1);
        ***REMOVED***
    ***REMOVED***;
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    return LLRBNode;
***REMOVED***());
export ***REMOVED*** LLRBNode ***REMOVED***;
/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
var LLRBEmptyNode = /** @class */ (function () ***REMOVED***
    function LLRBEmptyNode() ***REMOVED***
    ***REMOVED***
    /**
     * Returns a copy of the current node.
     *
     * @return ***REMOVED***!LLRBEmptyNode***REMOVED*** The node copy.
     */
    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) ***REMOVED***
        return this;
    ***REMOVED***;
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param ***REMOVED***!K***REMOVED*** key Key to be added.
     * @param ***REMOVED***!V***REMOVED*** value Value to be added.
     * @param ***REMOVED***Comparator***REMOVED*** comparator Comparator.
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, with item added.
     */
    LLRBEmptyNode.prototype.insert = function (key, value, comparator) ***REMOVED***
        return new LLRBNode(key, value, null);
    ***REMOVED***;
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param ***REMOVED***!K***REMOVED*** key The key to remove.
     * @param ***REMOVED***Comparator***REMOVED*** comparator Comparator.
     * @return ***REMOVED***!LLRBEmptyNode***REMOVED*** New tree, with item removed.
     */
    LLRBEmptyNode.prototype.remove = function (key, comparator) ***REMOVED***
        return this;
    ***REMOVED***;
    /**
     * @return ***REMOVED***number***REMOVED*** The total number of nodes in the tree.
     */
    LLRBEmptyNode.prototype.count = function () ***REMOVED***
        return 0;
    ***REMOVED***;
    /**
     * @return ***REMOVED***boolean***REMOVED*** True if the tree is empty.
     */
    LLRBEmptyNode.prototype.isEmpty = function () ***REMOVED***
        return true;
    ***REMOVED***;
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param ***REMOVED***function(!K, !V):****REMOVED*** action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return ***REMOVED***boolean***REMOVED*** True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.inorderTraversal = function (action) ***REMOVED***
        return false;
    ***REMOVED***;
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param ***REMOVED***function(!K, !V)***REMOVED*** action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return ***REMOVED***boolean***REMOVED*** True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.reverseTraversal = function (action) ***REMOVED***
        return false;
    ***REMOVED***;
    /**
     * @return ***REMOVED***null***REMOVED***
     */
    LLRBEmptyNode.prototype.minKey = function () ***REMOVED***
        return null;
    ***REMOVED***;
    /**
     * @return ***REMOVED***null***REMOVED***
     */
    LLRBEmptyNode.prototype.maxKey = function () ***REMOVED***
        return null;
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***number***REMOVED*** Not sure what this returns exactly. :-).
     */
    LLRBEmptyNode.prototype.check_ = function () ***REMOVED***
        return 0;
    ***REMOVED***;
    /**
     * @private
     * @return ***REMOVED***boolean***REMOVED*** Whether this node is red.
     */
    LLRBEmptyNode.prototype.isRed_ = function () ***REMOVED***
        return false;
    ***REMOVED***;
    return LLRBEmptyNode;
***REMOVED***());
export ***REMOVED*** LLRBEmptyNode ***REMOVED***;
/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
var SortedMap = /** @class */ (function () ***REMOVED***
    /**
     * @template K, V
     * @param ***REMOVED***function(K, K):number***REMOVED*** comparator_ Key comparator.
     * @param ***REMOVED***LLRBNode=***REMOVED*** root_ (Optional) Root node for the map.
     */
    function SortedMap(comparator_, root_) ***REMOVED***
        if (root_ === void 0) ***REMOVED*** root_ = SortedMap.EMPTY_NODE; ***REMOVED***
        this.comparator_ = comparator_;
        this.root_ = root_;
    ***REMOVED***
    /**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param ***REMOVED***!K***REMOVED*** key Key to be added.
     * @param ***REMOVED***!V***REMOVED*** value Value to be added.
     * @return ***REMOVED***!SortedMap.<K, V>***REMOVED*** New map, with item added.
     */
    SortedMap.prototype.insert = function (key, value) ***REMOVED***
        return new SortedMap(this.comparator_, this.root_
            .insert(key, value, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    ***REMOVED***;
    /**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param ***REMOVED***!K***REMOVED*** key The key to remove.
     * @return ***REMOVED***!SortedMap.<K, V>***REMOVED*** New map, with item removed.
     */
    SortedMap.prototype.remove = function (key) ***REMOVED***
        return new SortedMap(this.comparator_, this.root_
            .remove(key, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    ***REMOVED***;
    /**
     * Returns the value of the node with the given key, or null.
     *
     * @param ***REMOVED***!K***REMOVED*** key The key to look up.
     * @return ***REMOVED***?V***REMOVED*** The value of the node with the given key, or null if the
     * key doesn't exist.
     */
    SortedMap.prototype.get = function (key) ***REMOVED***
        var cmp;
        var node = this.root_;
        while (!node.isEmpty()) ***REMOVED***
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) ***REMOVED***
                return node.value;
            ***REMOVED***
            else if (cmp < 0) ***REMOVED***
                node = node.left;
            ***REMOVED***
            else if (cmp > 0) ***REMOVED***
                node = node.right;
            ***REMOVED***
        ***REMOVED***
        return null;
    ***REMOVED***;
    /**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param ***REMOVED***K***REMOVED*** key The key to find the predecessor of
     * @return ***REMOVED***?K***REMOVED*** The predecessor key.
     */
    SortedMap.prototype.getPredecessorKey = function (key) ***REMOVED***
        var cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) ***REMOVED***
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) ***REMOVED***
                if (!node.left.isEmpty()) ***REMOVED***
                    node = node.left;
                    while (!node.right.isEmpty())
                        node = node.right;
                    return node.key;
                ***REMOVED***
                else if (rightParent) ***REMOVED***
                    return rightParent.key;
                ***REMOVED***
                else ***REMOVED***
                    return null; // first item.
                ***REMOVED***
            ***REMOVED***
            else if (cmp < 0) ***REMOVED***
                node = node.left;
            ***REMOVED***
            else if (cmp > 0) ***REMOVED***
                rightParent = node;
                node = node.right;
            ***REMOVED***
        ***REMOVED***
        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');
    ***REMOVED***;
    /**
     * @return ***REMOVED***boolean***REMOVED*** True if the map is empty.
     */
    SortedMap.prototype.isEmpty = function () ***REMOVED***
        return this.root_.isEmpty();
    ***REMOVED***;
    /**
     * @return ***REMOVED***number***REMOVED*** The total number of nodes in the map.
     */
    SortedMap.prototype.count = function () ***REMOVED***
        return this.root_.count();
    ***REMOVED***;
    /**
     * @return ***REMOVED***?K***REMOVED*** The minimum key in the map.
     */
    SortedMap.prototype.minKey = function () ***REMOVED***
        return this.root_.minKey();
    ***REMOVED***;
    /**
     * @return ***REMOVED***?K***REMOVED*** The maximum key in the map.
     */
    SortedMap.prototype.maxKey = function () ***REMOVED***
        return this.root_.maxKey();
    ***REMOVED***;
    /**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param ***REMOVED***function(!K, !V):****REMOVED*** action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return ***REMOVED*******REMOVED*** The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    SortedMap.prototype.inorderTraversal = function (action) ***REMOVED***
        return this.root_.inorderTraversal(action);
    ***REMOVED***;
    /**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param ***REMOVED***function(!Object, !Object)***REMOVED*** action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return ***REMOVED*******REMOVED*** True if the traversal was aborted.
     */
    SortedMap.prototype.reverseTraversal = function (action) ***REMOVED***
        return this.root_.reverseTraversal(action);
    ***REMOVED***;
    /**
     * Returns an iterator over the SortedMap.
     * @template T
     * @param ***REMOVED***(function(K, V):T)=***REMOVED*** resultGenerator
     * @return ***REMOVED***SortedMapIterator.<K, V, T>***REMOVED*** The iterator.
     */
    SortedMap.prototype.getIterator = function (resultGenerator) ***REMOVED***
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
    ***REMOVED***;
    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) ***REMOVED***
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
    ***REMOVED***;
    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) ***REMOVED***
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
    ***REMOVED***;
    SortedMap.prototype.getReverseIterator = function (resultGenerator) ***REMOVED***
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
    ***REMOVED***;
    /**
     * Always use the same empty node, to reduce memory.
     * @const
     */
    SortedMap.EMPTY_NODE = new LLRBEmptyNode();
    return SortedMap;
***REMOVED***());
export ***REMOVED*** SortedMap ***REMOVED***;

//# sourceMappingURL=SortedMap.js.map
