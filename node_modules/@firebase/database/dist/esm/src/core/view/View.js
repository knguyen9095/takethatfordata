/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** IndexedFilter ***REMOVED*** from './filter/IndexedFilter';
import ***REMOVED*** ViewProcessor ***REMOVED*** from './ViewProcessor';
import ***REMOVED*** ChildrenNode ***REMOVED*** from '../snap/ChildrenNode';
import ***REMOVED*** CacheNode ***REMOVED*** from './CacheNode';
import ***REMOVED*** ViewCache ***REMOVED*** from './ViewCache';
import ***REMOVED*** EventGenerator ***REMOVED*** from './EventGenerator';
import ***REMOVED*** assert ***REMOVED*** from '@firebase/util';
import ***REMOVED*** OperationType ***REMOVED*** from '../operation/Operation';
import ***REMOVED*** Change ***REMOVED*** from './Change';
import ***REMOVED*** PRIORITY_INDEX ***REMOVED*** from '../snap/indexes/PriorityIndex';
/**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 * @constructor
 */
var View = /** @class */ (function () ***REMOVED***
    /**
     *
     * @param ***REMOVED***!Query***REMOVED*** query_
     * @param ***REMOVED***!ViewCache***REMOVED*** initialViewCache
     */
    function View(query_, initialViewCache) ***REMOVED***
        this.query_ = query_;
        this.eventRegistrations_ = [];
        var params = this.query_.getQueryParams();
        var indexFilter = new IndexedFilter(params.getIndex());
        var filter = params.getNodeFilter();
        /**
         * @type ***REMOVED***ViewProcessor***REMOVED***
         * @private
         */
        this.processor_ = new ViewProcessor(filter);
        var initialServerCache = initialViewCache.getServerCache();
        var initialEventCache = initialViewCache.getEventCache();
        // Don't filter server node with other filter than index, wait for tagged listen
        var serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
        var eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
        var newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        var newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        /**
         * @type ***REMOVED***!ViewCache***REMOVED***
         * @private
         */
        this.viewCache_ = new ViewCache(newEventCache, newServerCache);
        /**
         * @type ***REMOVED***!EventGenerator***REMOVED***
         * @private
         */
        this.eventGenerator_ = new EventGenerator(this.query_);
    ***REMOVED***
    /**
     * @return ***REMOVED***!Query***REMOVED***
     */
    View.prototype.getQuery = function () ***REMOVED***
        return this.query_;
    ***REMOVED***;
    /**
     * @return ***REMOVED***?Node***REMOVED***
     */
    View.prototype.getServerCache = function () ***REMOVED***
        return this.viewCache_.getServerCache().getNode();
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***?Node***REMOVED***
     */
    View.prototype.getCompleteServerCache = function (path) ***REMOVED***
        var cache = this.viewCache_.getCompleteServerSnap();
        if (cache) ***REMOVED***
            // If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
            // we need to see if it contains the child we're interested in.
            if (this.query_.getQueryParams().loadsAllData() ||
                (!path.isEmpty() && !cache.getImmediateChild(path.getFront()).isEmpty())) ***REMOVED***
                return cache.getChild(path);
            ***REMOVED***
        ***REMOVED***
        return null;
    ***REMOVED***;
    /**
     * @return ***REMOVED***boolean***REMOVED***
     */
    View.prototype.isEmpty = function () ***REMOVED***
        return this.eventRegistrations_.length === 0;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!EventRegistration***REMOVED*** eventRegistration
     */
    View.prototype.addEventRegistration = function (eventRegistration) ***REMOVED***
        this.eventRegistrations_.push(eventRegistration);
    ***REMOVED***;
    /**
     * @param ***REMOVED***?EventRegistration***REMOVED*** eventRegistration If null, remove all callbacks.
     * @param ***REMOVED***Error=***REMOVED*** cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Cancel events, if cancelError was provided.
     */
    View.prototype.removeEventRegistration = function (eventRegistration, cancelError) ***REMOVED***
        var cancelEvents = [];
        if (cancelError) ***REMOVED***
            assert(eventRegistration == null, 'A cancel should cancel all event registrations.');
            var path_1 = this.query_.path;
            this.eventRegistrations_.forEach(function (registration) ***REMOVED***
                cancelError /** @type ***REMOVED***!Error***REMOVED*** */ = cancelError;
                var maybeEvent = registration.createCancelEvent(cancelError, path_1);
                if (maybeEvent) ***REMOVED***
                    cancelEvents.push(maybeEvent);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
        if (eventRegistration) ***REMOVED***
            var remaining = [];
            for (var i = 0; i < this.eventRegistrations_.length; ++i) ***REMOVED***
                var existing = this.eventRegistrations_[i];
                if (!existing.matches(eventRegistration)) ***REMOVED***
                    remaining.push(existing);
                ***REMOVED***
                else if (eventRegistration.hasAnyCallback()) ***REMOVED***
                    // We're removing just this one
                    remaining = remaining.concat(this.eventRegistrations_.slice(i + 1));
                    break;
                ***REMOVED***
            ***REMOVED***
            this.eventRegistrations_ = remaining;
        ***REMOVED***
        else ***REMOVED***
            this.eventRegistrations_ = [];
        ***REMOVED***
        return cancelEvents;
    ***REMOVED***;
    /**
     * Applies the given Operation, updates our cache, and returns the appropriate events.
     *
     * @param ***REMOVED***!Operation***REMOVED*** operation
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** completeServerCache
     * @return ***REMOVED***!Array.<!Event>***REMOVED***
     */
    View.prototype.applyOperation = function (operation, writesCache, completeServerCache) ***REMOVED***
        if (operation.type === OperationType.MERGE &&
            operation.source.queryId !== null) ***REMOVED***
            assert(this.viewCache_.getCompleteServerSnap(), 'We should always have a full cache before handling merges');
            assert(this.viewCache_.getCompleteEventSnap(), 'Missing event cache, even though we have a server cache');
        ***REMOVED***
        var oldViewCache = this.viewCache_;
        var result = this.processor_.applyOperation(oldViewCache, operation, writesCache, completeServerCache);
        this.processor_.assertIndexed(result.viewCache);
        assert(result.viewCache.getServerCache().isFullyInitialized() ||
            !oldViewCache.getServerCache().isFullyInitialized(), 'Once a server snap is complete, it should never go back');
        this.viewCache_ = result.viewCache;
        return this.generateEventsForChanges_(result.changes, result.viewCache.getEventCache().getNode(), null);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!EventRegistration***REMOVED*** registration
     * @return ***REMOVED***!Array.<!Event>***REMOVED***
     */
    View.prototype.getInitialEvents = function (registration) ***REMOVED***
        var eventSnap = this.viewCache_.getEventCache();
        var initialChanges = [];
        if (!eventSnap.getNode().isLeafNode()) ***REMOVED***
            var eventNode = eventSnap.getNode();
            eventNode.forEachChild(PRIORITY_INDEX, function (key, childNode) ***REMOVED***
                initialChanges.push(Change.childAddedChange(key, childNode));
            ***REMOVED***);
        ***REMOVED***
        if (eventSnap.isFullyInitialized()) ***REMOVED***
            initialChanges.push(Change.valueChange(eventSnap.getNode()));
        ***REMOVED***
        return this.generateEventsForChanges_(initialChanges, eventSnap.getNode(), registration);
    ***REMOVED***;
    /**
     * @private
     * @param ***REMOVED***!Array.<!Change>***REMOVED*** changes
     * @param ***REMOVED***!Node***REMOVED*** eventCache
     * @param ***REMOVED***EventRegistration=***REMOVED*** eventRegistration
     * @return ***REMOVED***!Array.<!Event>***REMOVED***
     */
    View.prototype.generateEventsForChanges_ = function (changes, eventCache, eventRegistration) ***REMOVED***
        var registrations = eventRegistration
            ? [eventRegistration]
            : this.eventRegistrations_;
        return this.eventGenerator_.generateEventsForChanges(changes, eventCache, registrations);
    ***REMOVED***;
    return View;
***REMOVED***());
export ***REMOVED*** View ***REMOVED***;

//# sourceMappingURL=View.js.map
