/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** getValues, safeGet ***REMOVED*** from '@firebase/util';
import ***REMOVED*** Change ***REMOVED*** from './Change';
import ***REMOVED*** assert, assertionError ***REMOVED*** from '@firebase/util';
/**
 * @constructor
 */
var ChildChangeAccumulator = /** @class */ (function () ***REMOVED***
    function ChildChangeAccumulator() ***REMOVED***
        this.changeMap_ = ***REMOVED******REMOVED***;
    ***REMOVED***
    /**
     * @param ***REMOVED***!Change***REMOVED*** change
     */
    ChildChangeAccumulator.prototype.trackChildChange = function (change) ***REMOVED***
        var type = change.type;
        var childKey /** @type ***REMOVED***!string***REMOVED*** */ = change.childName;
        assert(type == Change.CHILD_ADDED ||
            type == Change.CHILD_CHANGED ||
            type == Change.CHILD_REMOVED, 'Only child changes supported for tracking');
        assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');
        var oldChange = safeGet(this.changeMap_, childKey);
        if (oldChange) ***REMOVED***
            var oldType = oldChange.type;
            if (type == Change.CHILD_ADDED && oldType == Change.CHILD_REMOVED) ***REMOVED***
                this.changeMap_[childKey] = Change.childChangedChange(childKey, change.snapshotNode, oldChange.snapshotNode);
            ***REMOVED***
            else if (type == Change.CHILD_REMOVED &&
                oldType == Change.CHILD_ADDED) ***REMOVED***
                delete this.changeMap_[childKey];
            ***REMOVED***
            else if (type == Change.CHILD_REMOVED &&
                oldType == Change.CHILD_CHANGED) ***REMOVED***
                this.changeMap_[childKey] = Change.childRemovedChange(childKey, oldChange.oldSnap);
            ***REMOVED***
            else if (type == Change.CHILD_CHANGED &&
                oldType == Change.CHILD_ADDED) ***REMOVED***
                this.changeMap_[childKey] = Change.childAddedChange(childKey, change.snapshotNode);
            ***REMOVED***
            else if (type == Change.CHILD_CHANGED &&
                oldType == Change.CHILD_CHANGED) ***REMOVED***
                this.changeMap_[childKey] = Change.childChangedChange(childKey, change.snapshotNode, oldChange.oldSnap);
            ***REMOVED***
            else ***REMOVED***
                throw assertionError('Illegal combination of changes: ' +
                    change +
                    ' occurred after ' +
                    oldChange);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            this.changeMap_[childKey] = change;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @return ***REMOVED***!Array.<!Change>***REMOVED***
     */
    ChildChangeAccumulator.prototype.getChanges = function () ***REMOVED***
        return getValues(this.changeMap_);
    ***REMOVED***;
    return ChildChangeAccumulator;
***REMOVED***());
export ***REMOVED*** ChildChangeAccumulator ***REMOVED***;

//# sourceMappingURL=ChildChangeAccumulator.js.map
