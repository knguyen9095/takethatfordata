/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** OperationType ***REMOVED*** from '../operation/Operation';
import ***REMOVED*** assert, assertionError ***REMOVED*** from '@firebase/util';
import ***REMOVED*** ChildChangeAccumulator ***REMOVED*** from './ChildChangeAccumulator';
import ***REMOVED*** Change ***REMOVED*** from './Change';
import ***REMOVED*** ChildrenNode ***REMOVED*** from '../snap/ChildrenNode';
import ***REMOVED*** KEY_INDEX ***REMOVED*** from '../snap/indexes/KeyIndex';
import ***REMOVED*** ImmutableTree ***REMOVED*** from '../util/ImmutableTree';
import ***REMOVED*** Path ***REMOVED*** from '../util/Path';
import ***REMOVED*** WriteTreeCompleteChildSource, NO_COMPLETE_CHILD_SOURCE ***REMOVED*** from './CompleteChildSource';
/**
 * @constructor
 * @struct
 */
var ProcessorResult = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** viewCache
     * @param ***REMOVED***!Array.<!Change>***REMOVED*** changes
     */
    function ProcessorResult(viewCache, changes) ***REMOVED***
        this.viewCache = viewCache;
        this.changes = changes;
    ***REMOVED***
    return ProcessorResult;
***REMOVED***());
export ***REMOVED*** ProcessorResult ***REMOVED***;
/**
 * @constructor
 */
var ViewProcessor = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***!NodeFilter***REMOVED*** filter_
     */
    function ViewProcessor(filter_) ***REMOVED***
        this.filter_ = filter_;
    ***REMOVED***
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** viewCache
     */
    ViewProcessor.prototype.assertIndexed = function (viewCache) ***REMOVED***
        assert(viewCache
            .getEventCache()
            .getNode()
            .isIndexed(this.filter_.getIndex()), 'Event snap not indexed');
        assert(viewCache
            .getServerCache()
            .getNode()
            .isIndexed(this.filter_.getIndex()), 'Server snap not indexed');
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** oldViewCache
     * @param ***REMOVED***!Operation***REMOVED*** operation
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** completeCache
     * @return ***REMOVED***!ProcessorResult***REMOVED***
     */
    ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) ***REMOVED***
        var accumulator = new ChildChangeAccumulator();
        var newViewCache, filterServerNode;
        if (operation.type === OperationType.OVERWRITE) ***REMOVED***
            var overwrite = operation;
            if (overwrite.source.fromUser) ***REMOVED***
                newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
            ***REMOVED***
            else ***REMOVED***
                assert(overwrite.source.fromServer, 'Unknown source.');
                // We filter the node if it's a tagged update or the node has been previously filtered  and the
                // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
                // again
                filterServerNode =
                    overwrite.source.tagged ||
                        (oldViewCache.getServerCache().isFiltered() &&
                            !overwrite.path.isEmpty());
                newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
            ***REMOVED***
        ***REMOVED***
        else if (operation.type === OperationType.MERGE) ***REMOVED***
            var merge = operation;
            if (merge.source.fromUser) ***REMOVED***
                newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
            ***REMOVED***
            else ***REMOVED***
                assert(merge.source.fromServer, 'Unknown source.');
                // We filter the node if it's a tagged update or the node has been previously filtered
                filterServerNode =
                    merge.source.tagged || oldViewCache.getServerCache().isFiltered();
                newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
            ***REMOVED***
        ***REMOVED***
        else if (operation.type === OperationType.ACK_USER_WRITE) ***REMOVED***
            var ackUserWrite = operation;
            if (!ackUserWrite.revert) ***REMOVED***
                newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
            ***REMOVED***
            else ***REMOVED***
                newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
            ***REMOVED***
        ***REMOVED***
        else if (operation.type === OperationType.LISTEN_COMPLETE) ***REMOVED***
            newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);
        ***REMOVED***
        else ***REMOVED***
            throw assertionError('Unknown operation type: ' + operation.type);
        ***REMOVED***
        var changes = accumulator.getChanges();
        ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);
        return new ProcessorResult(newViewCache, changes);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** oldViewCache
     * @param ***REMOVED***!ViewCache***REMOVED*** newViewCache
     * @param ***REMOVED***!Array.<!Change>***REMOVED*** accumulator
     * @private
     */
    ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) ***REMOVED***
        var eventSnap = newViewCache.getEventCache();
        if (eventSnap.isFullyInitialized()) ***REMOVED***
            var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
            var oldCompleteSnap = oldViewCache.getCompleteEventSnap();
            if (accumulator.length > 0 ||
                !oldViewCache.getEventCache().isFullyInitialized() ||
                (isLeafOrEmpty &&
                    !eventSnap
                        .getNode()
                        .equals(/** @type ***REMOVED***!Node***REMOVED*** */ (oldCompleteSnap))) ||
                !eventSnap
                    .getNode()
                    .getPriority()
                    .equals(oldCompleteSnap.getPriority())) ***REMOVED***
                accumulator.push(Change.valueChange(
                /** @type ***REMOVED***!Node***REMOVED*** */ newViewCache.getCompleteEventSnap()));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** viewCache
     * @param ***REMOVED***!Path***REMOVED*** changePath
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***!CompleteChildSource***REMOVED*** source
     * @param ***REMOVED***!ChildChangeAccumulator***REMOVED*** accumulator
     * @return ***REMOVED***!ViewCache***REMOVED***
     * @private
     */
    ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) ***REMOVED***
        var oldEventSnap = viewCache.getEventCache();
        if (writesCache.shadowingWrite(changePath) != null) ***REMOVED***
            // we have a shadowing write, ignore changes
            return viewCache;
        ***REMOVED***
        else ***REMOVED***
            var newEventCache = void 0, serverNode = void 0;
            if (changePath.isEmpty()) ***REMOVED***
                // TODO: figure out how this plays with "sliding ack windows"
                assert(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');
                if (viewCache.getServerCache().isFiltered()) ***REMOVED***
                    // We need to special case this, because we need to only apply writes to complete children, or
                    // we might end up raising events for incomplete children. If the server data is filtered deep
                    // writes cannot be guaranteed to be complete
                    var serverCache = viewCache.getCompleteServerSnap();
                    var completeChildren = serverCache instanceof ChildrenNode
                        ? serverCache
                        : ChildrenNode.EMPTY_NODE;
                    var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);
                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);
                ***REMOVED***
                else ***REMOVED***
                    var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                var childKey = changePath.getFront();
                if (childKey == '.priority') ***REMOVED***
                    assert(changePath.getLength() == 1, "Can't have a priority with additional path components");
                    var oldEventNode = oldEventSnap.getNode();
                    serverNode = viewCache.getServerCache().getNode();
                    // we might have overwrites for this priority
                    var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);
                    if (updatedPriority != null) ***REMOVED***
                        newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);
                    ***REMOVED***
                    else ***REMOVED***
                        // priority didn't change, keep old node
                        newEventCache = oldEventSnap.getNode();
                    ***REMOVED***
                ***REMOVED***
                else ***REMOVED***
                    var childChangePath = changePath.popFront();
                    // update child
                    var newEventChild = void 0;
                    if (oldEventSnap.isCompleteForChild(childKey)) ***REMOVED***
                        serverNode = viewCache.getServerCache().getNode();
                        var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);
                        if (eventChildUpdate != null) ***REMOVED***
                            newEventChild = oldEventSnap
                                .getNode()
                                .getImmediateChild(childKey)
                                .updateChild(childChangePath, eventChildUpdate);
                        ***REMOVED***
                        else ***REMOVED***
                            // Nothing changed, just keep the old child
                            newEventChild = oldEventSnap
                                .getNode()
                                .getImmediateChild(childKey);
                        ***REMOVED***
                    ***REMOVED***
                    else ***REMOVED***
                        newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
                    ***REMOVED***
                    if (newEventChild != null) ***REMOVED***
                        newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
                    ***REMOVED***
                    else ***REMOVED***
                        // no complete child available or no change
                        newEventCache = oldEventSnap.getNode();
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** oldViewCache
     * @param ***REMOVED***!Path***REMOVED*** changePath
     * @param ***REMOVED***!Node***REMOVED*** changedSnap
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** completeCache
     * @param ***REMOVED***boolean***REMOVED*** filterServerNode
     * @param ***REMOVED***!ChildChangeAccumulator***REMOVED*** accumulator
     * @return ***REMOVED***!ViewCache***REMOVED***
     * @private
     */
    ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) ***REMOVED***
        var oldServerSnap = oldViewCache.getServerCache();
        var newServerCache;
        var serverFilter = filterServerNode
            ? this.filter_
            : this.filter_.getIndexedFilter();
        if (changePath.isEmpty()) ***REMOVED***
            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
        ***REMOVED***
        else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) ***REMOVED***
            // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
            var newServerNode = oldServerSnap
                .getNode()
                .updateChild(changePath, changedSnap);
            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
        ***REMOVED***
        else ***REMOVED***
            var childKey = changePath.getFront();
            if (!oldServerSnap.isCompleteForPath(changePath) &&
                changePath.getLength() > 1) ***REMOVED***
                // We don't update incomplete nodes with updates intended for other listeners
                return oldViewCache;
            ***REMOVED***
            var childChangePath = changePath.popFront();
            var childNode = oldServerSnap.getNode().getImmediateChild(childKey);
            var newChildNode = childNode.updateChild(childChangePath, changedSnap);
            if (childKey == '.priority') ***REMOVED***
                newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
            ***REMOVED***
            else ***REMOVED***
                newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
            ***REMOVED***
        ***REMOVED***
        var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());
        var source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);
        return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** oldViewCache
     * @param ***REMOVED***!Path***REMOVED*** changePath
     * @param ***REMOVED***!Node***REMOVED*** changedSnap
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** completeCache
     * @param ***REMOVED***!ChildChangeAccumulator***REMOVED*** accumulator
     * @return ***REMOVED***!ViewCache***REMOVED***
     * @private
     */
    ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) ***REMOVED***
        var oldEventSnap = oldViewCache.getEventCache();
        var newViewCache, newEventCache;
        var source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
        if (changePath.isEmpty()) ***REMOVED***
            newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);
            newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());
        ***REMOVED***
        else ***REMOVED***
            var childKey = changePath.getFront();
            if (childKey === '.priority') ***REMOVED***
                newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);
                newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
            ***REMOVED***
            else ***REMOVED***
                var childChangePath = changePath.popFront();
                var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
                var newChild = void 0;
                if (childChangePath.isEmpty()) ***REMOVED***
                    // Child overwrite, we can replace the child
                    newChild = changedSnap;
                ***REMOVED***
                else ***REMOVED***
                    var childNode = source.getCompleteChild(childKey);
                    if (childNode != null) ***REMOVED***
                        if (childChangePath.getBack() === '.priority' &&
                            childNode.getChild(childChangePath.parent()).isEmpty()) ***REMOVED***
                            // This is a priority update on an empty node. If this node exists on the server, the
                            // server will send down the priority in the update, so ignore for now
                            newChild = childNode;
                        ***REMOVED***
                        else ***REMOVED***
                            newChild = childNode.updateChild(childChangePath, changedSnap);
                        ***REMOVED***
                    ***REMOVED***
                    else ***REMOVED***
                        // There is no complete child node available
                        newChild = ChildrenNode.EMPTY_NODE;
                    ***REMOVED***
                ***REMOVED***
                if (!oldChild.equals(newChild)) ***REMOVED***
                    var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
                    newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());
                ***REMOVED***
                else ***REMOVED***
                    newViewCache = oldViewCache;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        return newViewCache;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** viewCache
     * @param ***REMOVED***string***REMOVED*** childKey
     * @return ***REMOVED***boolean***REMOVED***
     * @private
     */
    ViewProcessor.cacheHasChild_ = function (viewCache, childKey) ***REMOVED***
        return viewCache.getEventCache().isCompleteForChild(childKey);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** viewCache
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***ImmutableTree.<!Node>***REMOVED*** changedChildren
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** serverCache
     * @param ***REMOVED***!ChildChangeAccumulator***REMOVED*** accumulator
     * @return ***REMOVED***!ViewCache***REMOVED***
     * @private
     */
    ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) ***REMOVED***
        var _this = this;
        // HACK: In the case of a limit query, there may be some changes that bump things out of the
        // window leaving room for new items.  It's important we process these changes first, so we
        // iterate the changes twice, first processing any that affect items currently in view.
        // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
        // not the other.
        var curViewCache = viewCache;
        changedChildren.foreach(function (relativePath, childNode) ***REMOVED***
            var writePath = path.child(relativePath);
            if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) ***REMOVED***
                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
            ***REMOVED***
        ***REMOVED***);
        changedChildren.foreach(function (relativePath, childNode) ***REMOVED***
            var writePath = path.child(relativePath);
            if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) ***REMOVED***
                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
            ***REMOVED***
        ***REMOVED***);
        return curViewCache;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Node***REMOVED*** node
     * @param ***REMOVED***ImmutableTree.<!Node>***REMOVED*** merge
     * @return ***REMOVED***!Node***REMOVED***
     * @private
     */
    ViewProcessor.prototype.applyMerge_ = function (node, merge) ***REMOVED***
        merge.foreach(function (relativePath, childNode) ***REMOVED***
            node = node.updateChild(relativePath, childNode);
        ***REMOVED***);
        return node;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** viewCache
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!ImmutableTree.<!Node>***REMOVED*** changedChildren
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** serverCache
     * @param ***REMOVED***boolean***REMOVED*** filterServerNode
     * @param ***REMOVED***!ChildChangeAccumulator***REMOVED*** accumulator
     * @return ***REMOVED***!ViewCache***REMOVED***
     * @private
     */
    ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) ***REMOVED***
        var _this = this;
        // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
        // wait for the complete data update coming soon.
        if (viewCache
            .getServerCache()
            .getNode()
            .isEmpty() &&
            !viewCache.getServerCache().isFullyInitialized()) ***REMOVED***
            return viewCache;
        ***REMOVED***
        // HACK: In the case of a limit query, there may be some changes that bump things out of the
        // window leaving room for new items.  It's important we process these changes first, so we
        // iterate the changes twice, first processing any that affect items currently in view.
        // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
        // not the other.
        var curViewCache = viewCache;
        var viewMergeTree;
        if (path.isEmpty()) ***REMOVED***
            viewMergeTree = changedChildren;
        ***REMOVED***
        else ***REMOVED***
            viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);
        ***REMOVED***
        var serverNode = viewCache.getServerCache().getNode();
        viewMergeTree.children.inorderTraversal(function (childKey, childTree) ***REMOVED***
            if (serverNode.hasChild(childKey)) ***REMOVED***
                var serverChild = viewCache
                    .getServerCache()
                    .getNode()
                    .getImmediateChild(childKey);
                var newChild = _this.applyMerge_(serverChild, childTree);
                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            ***REMOVED***
        ***REMOVED***);
        viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) ***REMOVED***
            var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) &&
                childMergeTree.value == null;
            if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) ***REMOVED***
                var serverChild = viewCache
                    .getServerCache()
                    .getNode()
                    .getImmediateChild(childKey);
                var newChild = _this.applyMerge_(serverChild, childMergeTree);
                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            ***REMOVED***
        ***REMOVED***);
        return curViewCache;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** viewCache
     * @param ***REMOVED***!Path***REMOVED*** ackPath
     * @param ***REMOVED***!ImmutableTree<!boolean>***REMOVED*** affectedTree
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** completeCache
     * @param ***REMOVED***!ChildChangeAccumulator***REMOVED*** accumulator
     * @return ***REMOVED***!ViewCache***REMOVED***
     * @private
     */
    ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) ***REMOVED***
        if (writesCache.shadowingWrite(ackPath) != null) ***REMOVED***
            return viewCache;
        ***REMOVED***
        // Only filter server node if it is currently filtered
        var filterServerNode = viewCache.getServerCache().isFiltered();
        // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
        // now that it won't be shadowed.
        var serverCache = viewCache.getServerCache();
        if (affectedTree.value != null) ***REMOVED***
            // This is an overwrite.
            if ((ackPath.isEmpty() && serverCache.isFullyInitialized()) ||
                serverCache.isCompleteForPath(ackPath)) ***REMOVED***
                return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
            ***REMOVED***
            else if (ackPath.isEmpty()) ***REMOVED***
                // This is a goofy edge case where we are acking data at this location but don't have full data.  We
                // should just re-apply whatever we have in our cache as a merge.
                var changedChildren_1 = ImmutableTree.Empty;
                serverCache.getNode().forEachChild(KEY_INDEX, function (name, node) ***REMOVED***
                    changedChildren_1 = changedChildren_1.set(new Path(name), node);
                ***REMOVED***);
                return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);
            ***REMOVED***
            else ***REMOVED***
                return viewCache;
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            // This is a merge.
            var changedChildren_2 = ImmutableTree.Empty;
            affectedTree.foreach(function (mergePath, value) ***REMOVED***
                var serverCachePath = ackPath.child(mergePath);
                if (serverCache.isCompleteForPath(serverCachePath)) ***REMOVED***
                    changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));
                ***REMOVED***
            ***REMOVED***);
            return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** viewCache
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***!ChildChangeAccumulator***REMOVED*** accumulator
     * @return ***REMOVED***!ViewCache***REMOVED***
     * @private
     */
    ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) ***REMOVED***
        var oldServerNode = viewCache.getServerCache();
        var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());
        return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!ViewCache***REMOVED*** viewCache
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** completeServerCache
     * @param ***REMOVED***!ChildChangeAccumulator***REMOVED*** accumulator
     * @return ***REMOVED***!ViewCache***REMOVED***
     * @private
     */
    ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) ***REMOVED***
        var complete;
        if (writesCache.shadowingWrite(path) != null) ***REMOVED***
            return viewCache;
        ***REMOVED***
        else ***REMOVED***
            var source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
            var oldEventCache = viewCache.getEventCache().getNode();
            var newEventCache = void 0;
            if (path.isEmpty() || path.getFront() === '.priority') ***REMOVED***
                var newNode = void 0;
                if (viewCache.getServerCache().isFullyInitialized()) ***REMOVED***
                    newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                ***REMOVED***
                else ***REMOVED***
                    var serverChildren = viewCache.getServerCache().getNode();
                    assert(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');
                    newNode = writesCache.calcCompleteEventChildren(serverChildren);
                ***REMOVED***
                newNode = newNode;
                newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);
            ***REMOVED***
            else ***REMOVED***
                var childKey = path.getFront();
                var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
                if (newChild == null &&
                    viewCache.getServerCache().isCompleteForChild(childKey)) ***REMOVED***
                    newChild = oldEventCache.getImmediateChild(childKey);
                ***REMOVED***
                if (newChild != null) ***REMOVED***
                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);
                ***REMOVED***
                else if (viewCache
                    .getEventCache()
                    .getNode()
                    .hasChild(childKey)) ***REMOVED***
                    // No complete child available, delete the existing one, if any
                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);
                ***REMOVED***
                else ***REMOVED***
                    newEventCache = oldEventCache;
                ***REMOVED***
                if (newEventCache.isEmpty() &&
                    viewCache.getServerCache().isFullyInitialized()) ***REMOVED***
                    // We might have reverted all child writes. Maybe the old event was a leaf node
                    complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                    if (complete.isLeafNode()) ***REMOVED***
                        newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            complete =
                viewCache.getServerCache().isFullyInitialized() ||
                    writesCache.shadowingWrite(Path.Empty) != null;
            return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());
        ***REMOVED***
    ***REMOVED***;
    return ViewProcessor;
***REMOVED***());
export ***REMOVED*** ViewProcessor ***REMOVED***;

//# sourceMappingURL=ViewProcessor.js.map
