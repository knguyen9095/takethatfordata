/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** RangedFilter ***REMOVED*** from './RangedFilter';
import ***REMOVED*** ChildrenNode ***REMOVED*** from '../../snap/ChildrenNode';
import ***REMOVED*** NamedNode ***REMOVED*** from '../../snap/Node';
import ***REMOVED*** assert ***REMOVED*** from '@firebase/util';
import ***REMOVED*** Change ***REMOVED*** from '../Change';
/**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 *
 * @constructor
 * @implements ***REMOVED***NodeFilter***REMOVED***
 */
var LimitedFilter = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***!QueryParams***REMOVED*** params
     */
    function LimitedFilter(params) ***REMOVED***
        this.rangedFilter_ = new RangedFilter(params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
    ***REMOVED***
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) ***REMOVED***
        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) ***REMOVED***
            newChild = ChildrenNode.EMPTY_NODE;
        ***REMOVED***
        if (snap.getImmediateChild(key).equals(newChild)) ***REMOVED***
            // No change
            return snap;
        ***REMOVED***
        else if (snap.numChildren() < this.limit_) ***REMOVED***
            return this.rangedFilter_
                .getIndexedFilter()
                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
        ***REMOVED***
        else ***REMOVED***
            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) ***REMOVED***
        var filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) ***REMOVED***
            // Make sure we have a children node with the correct index, not a leaf node;
            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        ***REMOVED***
        else ***REMOVED***
            if (this.limit_ * 2 < newSnap.numChildren() &&
                newSnap.isIndexed(this.index_)) ***REMOVED***
                // Easier to build up a snapshot, since what we're given has more than twice the elements we want
                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
                // anchor to the startPost, endPost, or last element as appropriate
                var iterator = void 0;
                if (this.reverse_) ***REMOVED***
                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
                ***REMOVED***
                else ***REMOVED***
                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
                ***REMOVED***
                var count = 0;
                while (iterator.hasNext() && count < this.limit_) ***REMOVED***
                    var next = iterator.getNext();
                    var inRange = void 0;
                    if (this.reverse_) ***REMOVED***
                        inRange =
                            this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;
                    ***REMOVED***
                    else ***REMOVED***
                        inRange =
                            this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;
                    ***REMOVED***
                    if (inRange) ***REMOVED***
                        filtered = filtered.updateImmediateChild(next.name, next.node);
                        count++;
                    ***REMOVED***
                    else ***REMOVED***
                        // if we have reached the end post, we cannot keep adding elemments
                        break;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
                filtered = newSnap.withIndex(this.index_);
                // Don't support priorities on queries
                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
                var startPost = void 0;
                var endPost = void 0;
                var cmp = void 0;
                var iterator = void 0;
                if (this.reverse_) ***REMOVED***
                    iterator = filtered.getReverseIterator(this.index_);
                    startPost = this.rangedFilter_.getEndPost();
                    endPost = this.rangedFilter_.getStartPost();
                    var indexCompare_1 = this.index_.getCompare();
                    cmp = function (a, b) ***REMOVED*** return indexCompare_1(b, a); ***REMOVED***;
                ***REMOVED***
                else ***REMOVED***
                    iterator = filtered.getIterator(this.index_);
                    startPost = this.rangedFilter_.getStartPost();
                    endPost = this.rangedFilter_.getEndPost();
                    cmp = this.index_.getCompare();
                ***REMOVED***
                var count = 0;
                var foundStartPost = false;
                while (iterator.hasNext()) ***REMOVED***
                    var next = iterator.getNext();
                    if (!foundStartPost && cmp(startPost, next) <= 0) ***REMOVED***
                        // start adding
                        foundStartPost = true;
                    ***REMOVED***
                    var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;
                    if (inRange) ***REMOVED***
                        count++;
                    ***REMOVED***
                    else ***REMOVED***
                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        return this.rangedFilter_
            .getIndexedFilter()
            .updateFullNode(oldSnap, filtered, optChangeAccumulator);
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) ***REMOVED***
        // Don't support priorities on queries
        return oldSnap;
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.filtersNodes = function () ***REMOVED***
        return true;
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.getIndexedFilter = function () ***REMOVED***
        return this.rangedFilter_.getIndexedFilter();
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.getIndex = function () ***REMOVED***
        return this.index_;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Node***REMOVED*** snap
     * @param ***REMOVED***string***REMOVED*** childKey
     * @param ***REMOVED***!Node***REMOVED*** childSnap
     * @param ***REMOVED***!CompleteChildSource***REMOVED*** source
     * @param ***REMOVED***?ChildChangeAccumulator***REMOVED*** changeAccumulator
     * @return ***REMOVED***!Node***REMOVED***
     * @private
     */
    LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) ***REMOVED***
        // TODO: rename all cache stuff etc to general snap terminology
        var cmp;
        if (this.reverse_) ***REMOVED***
            var indexCmp_1 = this.index_.getCompare();
            cmp = function (a, b) ***REMOVED*** return indexCmp_1(b, a); ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            cmp = this.index_.getCompare();
        ***REMOVED***
        var oldEventCache = snap;
        assert(oldEventCache.numChildren() == this.limit_, '');
        var newChildNamedNode = new NamedNode(childKey, childSnap);
        var windowBoundary = this.reverse_
            ? oldEventCache.getFirstChild(this.index_)
            : oldEventCache.getLastChild(this.index_);
        var inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) ***REMOVED***
            var oldChildSnap = oldEventCache.getImmediateChild(childKey);
            var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
            while (nextChild != null &&
                (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))) ***REMOVED***
                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
                // been applied to the limited filter yet. Ignore this next child which will be updated later in
                // the limited filter...
                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
            ***REMOVED***
            var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
            var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
            if (remainsInWindow) ***REMOVED***
                if (changeAccumulator != null) ***REMOVED***
                    changeAccumulator.trackChildChange(Change.childChangedChange(childKey, childSnap, oldChildSnap));
                ***REMOVED***
                return oldEventCache.updateImmediateChild(childKey, childSnap);
            ***REMOVED***
            else ***REMOVED***
                if (changeAccumulator != null) ***REMOVED***
                    changeAccumulator.trackChildChange(Change.childRemovedChange(childKey, oldChildSnap));
                ***REMOVED***
                var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
                var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
                if (nextChildInRange) ***REMOVED***
                    if (changeAccumulator != null) ***REMOVED***
                        changeAccumulator.trackChildChange(Change.childAddedChange(nextChild.name, nextChild.node));
                    ***REMOVED***
                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
                ***REMOVED***
                else ***REMOVED***
                    return newEventCache;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        else if (childSnap.isEmpty()) ***REMOVED***
            // we're deleting a node, but it was not in the window, so ignore it
            return snap;
        ***REMOVED***
        else if (inRange) ***REMOVED***
            if (cmp(windowBoundary, newChildNamedNode) >= 0) ***REMOVED***
                if (changeAccumulator != null) ***REMOVED***
                    changeAccumulator.trackChildChange(Change.childRemovedChange(windowBoundary.name, windowBoundary.node));
                    changeAccumulator.trackChildChange(Change.childAddedChange(childKey, childSnap));
                ***REMOVED***
                return oldEventCache
                    .updateImmediateChild(childKey, childSnap)
                    .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
            ***REMOVED***
            else ***REMOVED***
                return snap;
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            return snap;
        ***REMOVED***
    ***REMOVED***;
    return LimitedFilter;
***REMOVED***());
export ***REMOVED*** LimitedFilter ***REMOVED***;

//# sourceMappingURL=LimitedFilter.js.map
