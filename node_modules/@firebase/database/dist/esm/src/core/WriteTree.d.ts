import ***REMOVED*** Path ***REMOVED*** from './util/Path';
import ***REMOVED*** ChildrenNode ***REMOVED*** from './snap/ChildrenNode';
import ***REMOVED*** NamedNode, Node ***REMOVED*** from './snap/Node';
import ***REMOVED*** CacheNode ***REMOVED*** from './view/CacheNode';
import ***REMOVED*** Index ***REMOVED*** from './snap/indexes/Index';
/**
 * Defines a single user-initiated write operation. May be the result of a set(), transaction(), or update() call. In
 * the case of a set() or transaction, snap wil be non-null.  In the case of an update(), children will be non-null.
 */
export interface WriteRecord ***REMOVED***
    writeId: number;
    path: Path;
    snap?: Node | null;
    children?: ***REMOVED***
        [k: string]: Node;
    ***REMOVED*** | null;
    visible: boolean;
***REMOVED***
/**
 * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them
 * with underlying server data (to create "event cache" data).  Pending writes are added with addOverwrite()
 * and addMerge(), and removed with removeWrite().
 *
 * @constructor
 */
export declare class WriteTree ***REMOVED***
    /**
     * A tree tracking the result of applying all visible writes.  This does not include transactions with
     * applyLocally=false or writes that are completely shadowed by other writes.
     *
     * @type ***REMOVED***!CompoundWrite***REMOVED***
     * @private
     */
    private visibleWrites_;
    /**
     * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary
     * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also
     * used by transactions).
     *
     * @type ***REMOVED***!Array.<!WriteRecord>***REMOVED***
     * @private
     */
    private allWrites_;
    private lastWriteId_;
    /**
     * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***!WriteTreeRef***REMOVED***
     */
    childWrites(path: Path): WriteTreeRef;
    /**
     * Record a new overwrite from user code.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Node***REMOVED*** snap
     * @param ***REMOVED***!number***REMOVED*** writeId
     * @param ***REMOVED***boolean=***REMOVED*** visible This is set to false by some transactions. It should be excluded from event caches
     */
    addOverwrite(path: Path, snap: Node, writeId: number, visible?: boolean): void;
    /**
     * Record a new merge from user code.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Object.<string, !Node>***REMOVED*** changedChildren
     * @param ***REMOVED***!number***REMOVED*** writeId
     */
    addMerge(path: Path, changedChildren: ***REMOVED***
        [k: string]: Node;
    ***REMOVED***, writeId: number): void;
    /**
     * @param ***REMOVED***!number***REMOVED*** writeId
     * @return ***REMOVED***?WriteRecord***REMOVED***
     */
    getWrite(writeId: number): WriteRecord | null;
    /**
     * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
     * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
     *
     * @param ***REMOVED***!number***REMOVED*** writeId
     * @return ***REMOVED***boolean***REMOVED*** true if the write may have been visible (meaning we'll need to reevaluate / raise
     * events as a result).
     */
    removeWrite(writeId: number): boolean;
    /**
     * Return a complete snapshot for the given path if there's visible write data at that path, else null.
     * No server data is considered.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***?Node***REMOVED***
     */
    getCompleteWriteData(path: Path): Node | null;
    /**
     * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
     * writes), attempt to calculate a complete snapshot for the given path
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***?Node***REMOVED*** completeServerCache
     * @param ***REMOVED***Array.<number>=***REMOVED*** writeIdsToExclude An optional set to be excluded
     * @param ***REMOVED***boolean=***REMOVED*** includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return ***REMOVED***?Node***REMOVED***
     */
    calcCompleteEventCache(treePath: Path, completeServerCache: Node | null, writeIdsToExclude?: number[], includeHiddenWrites?: boolean): Node | null;
    /**
     * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
     * Used when creating new views, to pre-fill their complete event children snapshot.
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***?ChildrenNode***REMOVED*** completeServerChildren
     * @return ***REMOVED***!ChildrenNode***REMOVED***
     */
    calcCompleteEventChildren(treePath: Path, completeServerChildren: ChildrenNode | null): Node;
    /**
     * Given that the underlying server data has updated, determine what, if anything, needs to be
     * applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events
     *
     * Either existingEventSnap or existingServerSnap must exist
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***!Path***REMOVED*** childPath
     * @param ***REMOVED***?Node***REMOVED*** existingEventSnap
     * @param ***REMOVED***?Node***REMOVED*** existingServerSnap
     * @return ***REMOVED***?Node***REMOVED***
     */
    calcEventCacheAfterServerOverwrite(treePath: Path, childPath: Path, existingEventSnap: Node | null, existingServerSnap: Node | null): Node | null;
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***!string***REMOVED*** childKey
     * @param ***REMOVED***!CacheNode***REMOVED*** existingServerSnap
     * @return ***REMOVED***?Node***REMOVED***
     */
    calcCompleteChild(treePath: Path, childKey: string, existingServerSnap: CacheNode): Node | null;
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***?Node***REMOVED***
     */
    shadowingWrite(path: Path): Node | null;
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window.
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***?Node***REMOVED*** completeServerData
     * @param ***REMOVED***!NamedNode***REMOVED*** startPost
     * @param ***REMOVED***!number***REMOVED*** count
     * @param ***REMOVED***boolean***REMOVED*** reverse
     * @param ***REMOVED***!Index***REMOVED*** index
     * @return ***REMOVED***!Array.<!NamedNode>***REMOVED***
     */
    calcIndexedSlice(treePath: Path, completeServerData: Node | null, startPost: NamedNode, count: number, reverse: boolean, index: Index): NamedNode[];
    /**
     * @param ***REMOVED***!WriteRecord***REMOVED*** writeRecord
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***boolean***REMOVED***
     * @private
     */
    private recordContainsPath_(writeRecord, path);
    /**
     * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
     * @private
     */
    private resetTree_();
    /**
     * The default filter used when constructing the tree. Keep everything that's visible.
     *
     * @param ***REMOVED***!WriteRecord***REMOVED*** write
     * @return ***REMOVED***boolean***REMOVED***
     * @private
     */
    private static DefaultFilter_(write);
    /**
     * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
     * event data at that path.
     *
     * @param ***REMOVED***!Array.<!WriteRecord>***REMOVED*** writes
     * @param ***REMOVED***!function(!WriteRecord):boolean***REMOVED*** filter
     * @param ***REMOVED***!Path***REMOVED*** treeRoot
     * @return ***REMOVED***!CompoundWrite***REMOVED***
     * @private
     */
    private static layerTree_(writes, filter, treeRoot);
***REMOVED***
/**
 * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods
 * just proxy to the underlying WriteTree.
 *
 * @constructor
 */
export declare class WriteTreeRef ***REMOVED***
    /**
     * The path to this particular write tree ref. Used for calling methods on writeTree_ while exposing a simpler
     * interface to callers.
     *
     * @type ***REMOVED***!Path***REMOVED***
     * @private
     * @const
     */
    private readonly treePath_;
    /**
     * * A reference to the actual tree of write data. All methods are pass-through to the tree, but with the appropriate
     * path prefixed.
     *
     * This lets us make cheap references to points in the tree for sync points without having to copy and maintain all of
     * the data.
     *
     * @type ***REMOVED***!WriteTree***REMOVED***
     * @private
     * @const
     */
    private readonly writeTree_;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!WriteTree***REMOVED*** writeTree
     */
    constructor(path: Path, writeTree: WriteTree);
    /**
     * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
     * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
     * can lead to a more expensive calculation.
     *
     * @param ***REMOVED***?Node***REMOVED*** completeServerCache
     * @param ***REMOVED***Array.<number>=***REMOVED*** writeIdsToExclude Optional writes to exclude.
     * @param ***REMOVED***boolean=***REMOVED*** includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return ***REMOVED***?Node***REMOVED***
     */
    calcCompleteEventCache(completeServerCache: Node | null, writeIdsToExclude?: number[], includeHiddenWrites?: boolean): Node | null;
    /**
     * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
     * mix of the given server data and write data.
     *
     * @param ***REMOVED***?ChildrenNode***REMOVED*** completeServerChildren
     * @return ***REMOVED***!ChildrenNode***REMOVED***
     */
    calcCompleteEventChildren(completeServerChildren: ChildrenNode | null): ChildrenNode;
    /**
     * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
     * if anything, needs to be applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events should be raised
     *
     * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***?Node***REMOVED*** existingEventSnap
     * @param ***REMOVED***?Node***REMOVED*** existingServerSnap
     * @return ***REMOVED***?Node***REMOVED***
     */
    calcEventCacheAfterServerOverwrite(path: Path, existingEventSnap: Node | null, existingServerSnap: Node | null): Node | null;
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***?Node***REMOVED***
     */
    shadowingWrite(path: Path): Node | null;
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window
     *
     * @param ***REMOVED***?Node***REMOVED*** completeServerData
     * @param ***REMOVED***!NamedNode***REMOVED*** startPost
     * @param ***REMOVED***!number***REMOVED*** count
     * @param ***REMOVED***boolean***REMOVED*** reverse
     * @param ***REMOVED***!Index***REMOVED*** index
     * @return ***REMOVED***!Array.<!NamedNode>***REMOVED***
     */
    calcIndexedSlice(completeServerData: Node | null, startPost: NamedNode, count: number, reverse: boolean, index: Index): NamedNode[];
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param ***REMOVED***!string***REMOVED*** childKey
     * @param ***REMOVED***!CacheNode***REMOVED*** existingServerCache
     * @return ***REMOVED***?Node***REMOVED***
     */
    calcCompleteChild(childKey: string, existingServerCache: CacheNode): Node | null;
    /**
     * Return a WriteTreeRef for a child.
     *
     * @param ***REMOVED***string***REMOVED*** childName
     * @return ***REMOVED***!WriteTreeRef***REMOVED***
     */
    child(childName: string): WriteTreeRef;
***REMOVED***
