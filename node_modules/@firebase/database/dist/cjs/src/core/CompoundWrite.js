"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var ImmutableTree_1 = require("./util/ImmutableTree");
var Path_1 = require("./util/Path");
var util_1 = require("@firebase/util");
var Node_1 = require("./snap/Node");
var PriorityIndex_1 = require("./snap/indexes/PriorityIndex");
var util_2 = require("@firebase/util");
/**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 *
 * @constructor
 * @param ***REMOVED***!ImmutableTree.<!Node>***REMOVED*** writeTree
 */
var CompoundWrite = /** @class */ (function () ***REMOVED***
    function CompoundWrite(writeTree_) ***REMOVED***
        this.writeTree_ = writeTree_;
    ***REMOVED***
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Node***REMOVED*** node
     * @return ***REMOVED***!CompoundWrite***REMOVED***
     */
    CompoundWrite.prototype.addWrite = function (path, node) ***REMOVED***
        if (path.isEmpty()) ***REMOVED***
            return new CompoundWrite(new ImmutableTree_1.ImmutableTree(node));
        ***REMOVED***
        else ***REMOVED***
            var rootmost = this.writeTree_.findRootMostValueAndPath(path);
            if (rootmost != null) ***REMOVED***
                var rootMostPath = rootmost.path;
                var value = rootmost.value;
                var relativePath = Path_1.Path.relativePath(rootMostPath, path);
                value = value.updateChild(relativePath, node);
                return new CompoundWrite(this.writeTree_.set(rootMostPath, value));
            ***REMOVED***
            else ***REMOVED***
                var subtree = new ImmutableTree_1.ImmutableTree(node);
                var newWriteTree = this.writeTree_.setTree(path, subtree);
                return new CompoundWrite(newWriteTree);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Object.<string, !Node>***REMOVED*** updates
     * @return ***REMOVED***!CompoundWrite***REMOVED***
     */
    CompoundWrite.prototype.addWrites = function (path, updates) ***REMOVED***
        var newWrite = this;
        util_1.forEach(updates, function (childKey, node) ***REMOVED***
            newWrite = newWrite.addWrite(path.child(childKey), node);
        ***REMOVED***);
        return newWrite;
    ***REMOVED***;
    /**
     * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
     * location, which must be removed by calling this method with that path.
     *
     * @param ***REMOVED***!Path***REMOVED*** path The path at which a write and all deeper writes should be removed
     * @return ***REMOVED***!CompoundWrite***REMOVED*** The new CompoundWrite with the removed path
     */
    CompoundWrite.prototype.removeWrite = function (path) ***REMOVED***
        if (path.isEmpty()) ***REMOVED***
            return CompoundWrite.Empty;
        ***REMOVED***
        else ***REMOVED***
            var newWriteTree = this.writeTree_.setTree(path, ImmutableTree_1.ImmutableTree.Empty);
            return new CompoundWrite(newWriteTree);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
     * considered "complete".
     *
     * @param ***REMOVED***!Path***REMOVED*** path The path to check for
     * @return ***REMOVED***boolean***REMOVED*** Whether there is a complete write at that path
     */
    CompoundWrite.prototype.hasCompleteWrite = function (path) ***REMOVED***
        return this.getCompleteNode(path) != null;
    ***REMOVED***;
    /**
     * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
     * writes from deeper paths, but will return child nodes from a more shallow path.
     *
     * @param ***REMOVED***!Path***REMOVED*** path The path to get a complete write
     * @return ***REMOVED***?Node***REMOVED*** The node if complete at that path, or null otherwise.
     */
    CompoundWrite.prototype.getCompleteNode = function (path) ***REMOVED***
        var rootmost = this.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) ***REMOVED***
            return this.writeTree_
                .get(rootmost.path)
                .getChild(Path_1.Path.relativePath(rootmost.path, path));
        ***REMOVED***
        else ***REMOVED***
            return null;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns all children that are guaranteed to be a complete overwrite.
     *
     * @return ***REMOVED***!Array.<NamedNode>***REMOVED*** A list of all complete children.
     */
    CompoundWrite.prototype.getCompleteChildren = function () ***REMOVED***
        var children = [];
        var node = this.writeTree_.value;
        if (node != null) ***REMOVED***
            // If it's a leaf node, it has no children; so nothing to do.
            if (!node.isLeafNode()) ***REMOVED***
                node.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) ***REMOVED***
                    children.push(new Node_1.NamedNode(childName, childNode));
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            this.writeTree_.children.inorderTraversal(function (childName, childTree) ***REMOVED***
                if (childTree.value != null) ***REMOVED***
                    children.push(new Node_1.NamedNode(childName, childTree.value));
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
        return children;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***!CompoundWrite***REMOVED***
     */
    CompoundWrite.prototype.childCompoundWrite = function (path) ***REMOVED***
        if (path.isEmpty()) ***REMOVED***
            return this;
        ***REMOVED***
        else ***REMOVED***
            var shadowingNode = this.getCompleteNode(path);
            if (shadowingNode != null) ***REMOVED***
                return new CompoundWrite(new ImmutableTree_1.ImmutableTree(shadowingNode));
            ***REMOVED***
            else ***REMOVED***
                return new CompoundWrite(this.writeTree_.subtree(path));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
     * @return ***REMOVED***boolean***REMOVED*** Whether this CompoundWrite is empty
     */
    CompoundWrite.prototype.isEmpty = function () ***REMOVED***
        return this.writeTree_.isEmpty();
    ***REMOVED***;
    /**
     * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
     * node
     * @param ***REMOVED***!Node***REMOVED*** node The node to apply this CompoundWrite to
     * @return ***REMOVED***!Node***REMOVED*** The node with all writes applied
     */
    CompoundWrite.prototype.apply = function (node) ***REMOVED***
        return CompoundWrite.applySubtreeWrite_(Path_1.Path.Empty, this.writeTree_, node);
    ***REMOVED***;
    /**
     * @type ***REMOVED***!CompoundWrite***REMOVED***
     */
    CompoundWrite.Empty = new CompoundWrite(new ImmutableTree_1.ImmutableTree(null));
    /**
     * @param ***REMOVED***!Path***REMOVED*** relativePath
     * @param ***REMOVED***!ImmutableTree.<!Node>***REMOVED*** writeTree
     * @param ***REMOVED***!Node***REMOVED*** node
     * @return ***REMOVED***!Node***REMOVED***
     * @private
     */
    CompoundWrite.applySubtreeWrite_ = function (relativePath, writeTree, node) ***REMOVED***
        if (writeTree.value != null) ***REMOVED***
            // Since there a write is always a leaf, we're done here
            return node.updateChild(relativePath, writeTree.value);
        ***REMOVED***
        else ***REMOVED***
            var priorityWrite_1 = null;
            writeTree.children.inorderTraversal(function (childKey, childTree) ***REMOVED***
                if (childKey === '.priority') ***REMOVED***
                    // Apply priorities at the end so we don't update priorities for either empty nodes or forget
                    // to apply priorities to empty nodes that are later filled
                    util_2.assert(childTree.value !== null, 'Priority writes must always be leaf nodes');
                    priorityWrite_1 = childTree.value;
                ***REMOVED***
                else ***REMOVED***
                    node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);
                ***REMOVED***
            ***REMOVED***);
            // If there was a priority write, we only apply it if the node is not empty
            if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) ***REMOVED***
                node = node.updateChild(relativePath.child('.priority'), priorityWrite_1);
            ***REMOVED***
            return node;
        ***REMOVED***
    ***REMOVED***;
    return CompoundWrite;
***REMOVED***());
exports.CompoundWrite = CompoundWrite;

//# sourceMappingURL=CompoundWrite.js.map
