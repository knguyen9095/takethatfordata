"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var ServerValues_1 = require("./util/ServerValues");
var nodeFromJSON_1 = require("./snap/nodeFromJSON");
var Path_1 = require("./util/Path");
var SparseSnapshotTree_1 = require("./SparseSnapshotTree");
var SyncTree_1 = require("./SyncTree");
var SnapshotHolder_1 = require("./SnapshotHolder");
var util_1 = require("@firebase/util");
var util_2 = require("./util/util");
var util_3 = require("@firebase/util");
var AuthTokenProvider_1 = require("./AuthTokenProvider");
var StatsManager_1 = require("./stats/StatsManager");
var StatsReporter_1 = require("./stats/StatsReporter");
var StatsListener_1 = require("./stats/StatsListener");
var EventQueue_1 = require("./view/EventQueue");
var PersistentConnection_1 = require("./PersistentConnection");
var ReadonlyRestClient_1 = require("./ReadonlyRestClient");
var Database_1 = require("../api/Database");
var INTERRUPT_REASON = 'repo_interrupt';
/**
 * A connection to a single data repository.
 */
var Repo = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***!RepoInfo***REMOVED*** repoInfo_
     * @param ***REMOVED***boolean***REMOVED*** forceRestClient
     * @param ***REMOVED***!FirebaseApp***REMOVED*** app
     */
    function Repo(repoInfo_, forceRestClient, app) ***REMOVED***
        var _this = this;
        this.repoInfo_ = repoInfo_;
        this.app = app;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue_1.EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        // A list of data pieces and paths to be set when this client disconnects.
        this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();
        /**
         * TODO: This should be @private but it's used by test_access.js and internal.js
         * @type ***REMOVED***?PersistentConnection***REMOVED***
         */
        this.persistentConnection_ = null;
        /** @type ***REMOVED***!AuthTokenProvider***REMOVED*** */
        var authTokenProvider = new AuthTokenProvider_1.AuthTokenProvider(app);
        this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo_);
        if (forceRestClient || util_2.beingCrawled()) ***REMOVED***
            this.server_ = new ReadonlyRestClient_1.ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider);
            // Minor hack: Fire onConnect immediately, since there's no actual connection.
            setTimeout(this.onConnectStatus_.bind(this, true), 0);
        ***REMOVED***
        else ***REMOVED***
            var authOverride = app.options['databaseAuthVariableOverride'];
            // Validate authOverride
            if (typeof authOverride !== 'undefined' && authOverride !== null) ***REMOVED***
                if (typeof authOverride !== 'object') ***REMOVED***
                    throw new Error('Only objects are supported for option databaseAuthVariableOverride');
                ***REMOVED***
                try ***REMOVED***
                    util_1.stringify(authOverride);
                ***REMOVED***
                catch (e) ***REMOVED***
                    throw new Error('Invalid authOverride provided: ' + e);
                ***REMOVED***
            ***REMOVED***
            this.persistentConnection_ = new PersistentConnection_1.PersistentConnection(this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);
            this.server_ = this.persistentConnection_;
        ***REMOVED***
        authTokenProvider.addTokenChangeListener(function (token) ***REMOVED***
            _this.server_.refreshAuthToken(token);
        ***REMOVED***);
        // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
        // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
        this.statsReporter_ = StatsManager_1.StatsManager.getOrCreateReporter(repoInfo_, function () ***REMOVED*** return new StatsReporter_1.StatsReporter(_this.stats_, _this.server_); ***REMOVED***);
        this.transactions_init_();
        // Used for .info.
        this.infoData_ = new SnapshotHolder_1.SnapshotHolder();
        this.infoSyncTree_ = new SyncTree_1.SyncTree(***REMOVED***
            startListening: function (query, tag, currentHashFn, onComplete) ***REMOVED***
                var infoEvents = [];
                var node = _this.infoData_.getNode(query.path);
                // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
                // on initial data...
                if (!node.isEmpty()) ***REMOVED***
                    infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);
                    setTimeout(function () ***REMOVED***
                        onComplete('ok');
                    ***REMOVED***, 0);
                ***REMOVED***
                return infoEvents;
            ***REMOVED***,
            stopListening: function () ***REMOVED*** ***REMOVED***
        ***REMOVED***);
        this.updateInfo_('connected', false);
        this.serverSyncTree_ = new SyncTree_1.SyncTree(***REMOVED***
            startListening: function (query, tag, currentHashFn, onComplete) ***REMOVED***
                _this.server_.listen(query, currentHashFn, tag, function (status, data) ***REMOVED***
                    var events = onComplete(status, data);
                    _this.eventQueue_.raiseEventsForChangedPath(query.path, events);
                ***REMOVED***);
                // No synchronous events for network-backed sync trees
                return [];
            ***REMOVED***,
            stopListening: function (query, tag) ***REMOVED***
                _this.server_.unlisten(query, tag);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
    /**
     * @return ***REMOVED***string***REMOVED***  The URL corresponding to the root of this Firebase.
     */
    Repo.prototype.toString = function () ***REMOVED***
        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);
    ***REMOVED***;
    /**
     * @return ***REMOVED***!string***REMOVED*** The namespace represented by the repo.
     */
    Repo.prototype.name = function () ***REMOVED***
        return this.repoInfo_.namespace;
    ***REMOVED***;
    /**
     * @return ***REMOVED***!number***REMOVED*** The time in milliseconds, taking the server offset into account if we have one.
     */
    Repo.prototype.serverTime = function () ***REMOVED***
        var offsetNode = this.infoData_.getNode(new Path_1.Path('.info/serverTimeOffset'));
        var offset = offsetNode.val() || 0;
        return new Date().getTime() + offset;
    ***REMOVED***;
    /**
     * Generate ServerValues using some variables from the repo object.
     * @return ***REMOVED***!Object***REMOVED***
     */
    Repo.prototype.generateServerValues = function () ***REMOVED***
        return ServerValues_1.generateWithValues(***REMOVED***
            timestamp: this.serverTime()
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Called by realtime when we get new messages from the server.
     *
     * @private
     * @param ***REMOVED***string***REMOVED*** pathString
     * @param ***REMOVED*******REMOVED*** data
     * @param ***REMOVED***boolean***REMOVED*** isMerge
     * @param ***REMOVED***?number***REMOVED*** tag
     */
    Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) ***REMOVED***
        // For testing.
        this.dataUpdateCount++;
        var path = new Path_1.Path(pathString);
        data = this.interceptServerDataCallback_
            ? this.interceptServerDataCallback_(pathString, data)
            : data;
        var events = [];
        if (tag) ***REMOVED***
            if (isMerge) ***REMOVED***
                var taggedChildren = util_3.map(data, function (raw) ***REMOVED***
                    return nodeFromJSON_1.nodeFromJSON(raw);
                ***REMOVED***);
                events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);
            ***REMOVED***
            else ***REMOVED***
                var taggedSnap = nodeFromJSON_1.nodeFromJSON(data);
                events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);
            ***REMOVED***
        ***REMOVED***
        else if (isMerge) ***REMOVED***
            var changedChildren = util_3.map(data, function (raw) ***REMOVED***
                return nodeFromJSON_1.nodeFromJSON(raw);
            ***REMOVED***);
            events = this.serverSyncTree_.applyServerMerge(path, changedChildren);
        ***REMOVED***
        else ***REMOVED***
            var snap = nodeFromJSON_1.nodeFromJSON(data);
            events = this.serverSyncTree_.applyServerOverwrite(path, snap);
        ***REMOVED***
        var affectedPath = path;
        if (events.length > 0) ***REMOVED***
            // Since we have a listener outstanding for each transaction, receiving any events
            // is a proxy for some change having occurred.
            affectedPath = this.rerunTransactions_(path);
        ***REMOVED***
        this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);
    ***REMOVED***;
    /**
     * TODO: This should be @private but it's used by test_access.js and internal.js
     * @param ***REMOVED***?function(!string, *):****REMOVED*** callback
     * @private
     */
    Repo.prototype.interceptServerData_ = function (callback) ***REMOVED***
        this.interceptServerDataCallback_ = callback;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!boolean***REMOVED*** connectStatus
     * @private
     */
    Repo.prototype.onConnectStatus_ = function (connectStatus) ***REMOVED***
        this.updateInfo_('connected', connectStatus);
        if (connectStatus === false) ***REMOVED***
            this.runOnDisconnectEvents_();
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Object***REMOVED*** updates
     * @private
     */
    Repo.prototype.onServerInfoUpdate_ = function (updates) ***REMOVED***
        var _this = this;
        util_2.each(updates, function (value, key) ***REMOVED***
            _this.updateInfo_(key, value);
        ***REMOVED***);
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***!string***REMOVED*** pathString
     * @param ***REMOVED*******REMOVED*** value
     * @private
     */
    Repo.prototype.updateInfo_ = function (pathString, value) ***REMOVED***
        var path = new Path_1.Path('/.info/' + pathString);
        var newNode = nodeFromJSON_1.nodeFromJSON(value);
        this.infoData_.updateSnapshot(path, newNode);
        var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);
        this.eventQueue_.raiseEventsForChangedPath(path, events);
    ***REMOVED***;
    /**
     * @return ***REMOVED***!number***REMOVED***
     * @private
     */
    Repo.prototype.getNextWriteId_ = function () ***REMOVED***
        return this.nextWriteId_++;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED*******REMOVED*** newVal
     * @param ***REMOVED***number|string|null***REMOVED*** newPriority
     * @param ***REMOVED***?function(?Error, *=)***REMOVED*** onComplete
     */
    Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) ***REMOVED***
        var _this = this;
        this.log_('set', ***REMOVED***
            path: path.toString(),
            value: newVal,
            priority: newPriority
        ***REMOVED***);
        // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
        // (b) store unresolved paths on JSON parse
        var serverValues = this.generateServerValues();
        var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, newPriority);
        var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
        var writeId = this.getNextWriteId_();
        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);
        this.eventQueue_.queueEvents(events);
        this.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), function (status, errorReason) ***REMOVED***
            var success = status === 'ok';
            if (!success) ***REMOVED***
                util_2.warn('set at ' + path + ' failed: ' + status);
            ***REMOVED***
            var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);
            _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        ***REMOVED***);
        var affectedPath = this.abortTransactions_(path);
        this.rerunTransactions_(affectedPath);
        // We queued the events above, so just flush the queue here
        this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Object***REMOVED*** childrenToMerge
     * @param ***REMOVED***?function(?Error, *=)***REMOVED*** onComplete
     */
    Repo.prototype.update = function (path, childrenToMerge, onComplete) ***REMOVED***
        var _this = this;
        this.log_('update', ***REMOVED*** path: path.toString(), value: childrenToMerge ***REMOVED***);
        // Start with our existing data and merge each child into it.
        var empty = true;
        var serverValues = this.generateServerValues();
        var changedChildren = ***REMOVED******REMOVED***;
        util_3.forEach(childrenToMerge, function (changedKey, changedValue) ***REMOVED***
            empty = false;
            var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(changedValue);
            changedChildren[changedKey] = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
        ***REMOVED***);
        if (!empty) ***REMOVED***
            var writeId_1 = this.getNextWriteId_();
            var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);
            this.eventQueue_.queueEvents(events);
            this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) ***REMOVED***
                var success = status === 'ok';
                if (!success) ***REMOVED***
                    util_2.warn('update at ' + path + ' failed: ' + status);
                ***REMOVED***
                var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);
                var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;
                _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);
                _this.callOnCompleteCallback(onComplete, status, errorReason);
            ***REMOVED***);
            util_3.forEach(childrenToMerge, function (changedPath) ***REMOVED***
                var affectedPath = _this.abortTransactions_(path.child(changedPath));
                _this.rerunTransactions_(affectedPath);
            ***REMOVED***);
            // We queued the events above, so just flush the queue here
            this.eventQueue_.raiseEventsForChangedPath(path, []);
        ***REMOVED***
        else ***REMOVED***
            util_2.log("update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, 'ok');
        ***REMOVED***
    ***REMOVED***;
    /**
     * Applies all of the changes stored up in the onDisconnect_ tree.
     * @private
     */
    Repo.prototype.runOnDisconnectEvents_ = function () ***REMOVED***
        var _this = this;
        this.log_('onDisconnectEvents');
        var serverValues = this.generateServerValues();
        var resolvedOnDisconnectTree = ServerValues_1.resolveDeferredValueTree(this.onDisconnect_, serverValues);
        var events = [];
        resolvedOnDisconnectTree.forEachTree(Path_1.Path.Empty, function (path, snap) ***REMOVED***
            events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));
            var affectedPath = _this.abortTransactions_(path);
            _this.rerunTransactions_(affectedPath);
        ***REMOVED***);
        this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();
        this.eventQueue_.raiseEventsForChangedPath(Path_1.Path.Empty, events);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***?function(?Error, *=)***REMOVED*** onComplete
     */
    Repo.prototype.onDisconnectCancel = function (path, onComplete) ***REMOVED***
        var _this = this;
        this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) ***REMOVED***
            if (status === 'ok') ***REMOVED***
                _this.onDisconnect_.forget(path);
            ***REMOVED***
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED*******REMOVED*** value
     * @param ***REMOVED***?function(?Error, *=)***REMOVED*** onComplete
     */
    Repo.prototype.onDisconnectSet = function (path, value, onComplete) ***REMOVED***
        var _this = this;
        var newNode = nodeFromJSON_1.nodeFromJSON(value);
        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) ***REMOVED***
            if (status === 'ok') ***REMOVED***
                _this.onDisconnect_.remember(path, newNode);
            ***REMOVED***
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED*******REMOVED*** value
     * @param ***REMOVED*******REMOVED*** priority
     * @param ***REMOVED***?function(?Error, *=)***REMOVED*** onComplete
     */
    Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) ***REMOVED***
        var _this = this;
        var newNode = nodeFromJSON_1.nodeFromJSON(value, priority);
        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) ***REMOVED***
            if (status === 'ok') ***REMOVED***
                _this.onDisconnect_.remember(path, newNode);
            ***REMOVED***
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED*******REMOVED*** childrenToMerge
     * @param ***REMOVED***?function(?Error, *=)***REMOVED*** onComplete
     */
    Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) ***REMOVED***
        var _this = this;
        if (util_3.isEmpty(childrenToMerge)) ***REMOVED***
            util_2.log("onDisconnect().update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, 'ok');
            return;
        ***REMOVED***
        this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) ***REMOVED***
            if (status === 'ok') ***REMOVED***
                util_3.forEach(childrenToMerge, function (childName, childNode) ***REMOVED***
                    var newChildNode = nodeFromJSON_1.nodeFromJSON(childNode);
                    _this.onDisconnect_.remember(path.child(childName), newChildNode);
                ***REMOVED***);
            ***REMOVED***
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Query***REMOVED*** query
     * @param ***REMOVED***!EventRegistration***REMOVED*** eventRegistration
     */
    Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) ***REMOVED***
        var events;
        if (query.path.getFront() === '.info') ***REMOVED***
            events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);
        ***REMOVED***
        else ***REMOVED***
            events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);
        ***REMOVED***
        this.eventQueue_.raiseEventsAtPath(query.path, events);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Query***REMOVED*** query
     * @param ***REMOVED***?EventRegistration***REMOVED*** eventRegistration
     */
    Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) ***REMOVED***
        // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
        // a little bit by handling the return values anyways.
        var events;
        if (query.path.getFront() === '.info') ***REMOVED***
            events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);
        ***REMOVED***
        else ***REMOVED***
            events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);
        ***REMOVED***
        this.eventQueue_.raiseEventsAtPath(query.path, events);
    ***REMOVED***;
    Repo.prototype.interrupt = function () ***REMOVED***
        if (this.persistentConnection_) ***REMOVED***
            this.persistentConnection_.interrupt(INTERRUPT_REASON);
        ***REMOVED***
    ***REMOVED***;
    Repo.prototype.resume = function () ***REMOVED***
        if (this.persistentConnection_) ***REMOVED***
            this.persistentConnection_.resume(INTERRUPT_REASON);
        ***REMOVED***
    ***REMOVED***;
    Repo.prototype.stats = function (showDelta) ***REMOVED***
        if (showDelta === void 0) ***REMOVED*** showDelta = false; ***REMOVED***
        if (typeof console === 'undefined')
            return;
        var stats;
        if (showDelta) ***REMOVED***
            if (!this.statsListener_)
                this.statsListener_ = new StatsListener_1.StatsListener(this.stats_);
            stats = this.statsListener_.get();
        ***REMOVED***
        else ***REMOVED***
            stats = this.stats_.get();
        ***REMOVED***
        var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) ***REMOVED***
            return Math.max(currentValue.length, previousValue);
        ***REMOVED***, 0);
        util_3.forEach(stats, function (stat, value) ***REMOVED***
            // pad stat names to be the same length (plus 2 extra spaces).
            for (var i = stat.length; i < longestName + 2; i++)
                stat += ' ';
            console.log(stat + value);
        ***REMOVED***);
    ***REMOVED***;
    Repo.prototype.statsIncrementCounter = function (metric) ***REMOVED***
        this.stats_.incrementCounter(metric);
        this.statsReporter_.includeStat(metric);
    ***REMOVED***;
    /**
     * @param ***REMOVED***...****REMOVED*** var_args
     * @private
     */
    Repo.prototype.log_ = function () ***REMOVED***
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            var_args[_i] = arguments[_i];
        ***REMOVED***
        var prefix = '';
        if (this.persistentConnection_) ***REMOVED***
            prefix = this.persistentConnection_.id + ':';
        ***REMOVED***
        util_2.log.apply(void 0, [prefix].concat(var_args));
    ***REMOVED***;
    /**
     * @param ***REMOVED***?function(?Error, *=)***REMOVED*** callback
     * @param ***REMOVED***!string***REMOVED*** status
     * @param ***REMOVED***?string=***REMOVED*** errorReason
     */
    Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) ***REMOVED***
        if (callback) ***REMOVED***
            util_2.exceptionGuard(function () ***REMOVED***
                if (status == 'ok') ***REMOVED***
                    callback(null);
                ***REMOVED***
                else ***REMOVED***
                    var code = (status || 'error').toUpperCase();
                    var message = code;
                    if (errorReason)
                        message += ': ' + errorReason;
                    var error = new Error(message);
                    error.code = code;
                    callback(error);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;
    Object.defineProperty(Repo.prototype, "database", ***REMOVED***
        get: function () ***REMOVED***
            return this.__database || (this.__database = new Database_1.Database(this));
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    return Repo;
***REMOVED***());
exports.Repo = Repo;

//# sourceMappingURL=Repo.js.map
