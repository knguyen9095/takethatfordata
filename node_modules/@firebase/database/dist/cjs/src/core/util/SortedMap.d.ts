/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Implementation of an immutable SortedMap using a Left-leaning
 * Red-Black Tree, adapted from the implementation in Mugs
 * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen
 * (mads379@gmail.com).
 *
 * Original paper on Left-leaning Red-Black Trees:
 *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
 *
 * Invariant 1: No red node has a red child
 * Invariant 2: Every leaf path has the same number of black nodes
 * Invariant 3: Only the left child can be red (left leaning)
 */
export declare type Comparator<K> = (key1: K, key2: K) => number;
/**
 * An iterator over an LLRBNode.
 */
export declare class SortedMapIterator<K, V, T> ***REMOVED***
    private isReverse_;
    private resultGenerator_;
    /** @private
     * @type ***REMOVED***Array.<!LLRBNode>***REMOVED***
     */
    private nodeStack_;
    /**
     * @template K, V, T
     * @param ***REMOVED***LLRBNode|LLRBEmptyNode***REMOVED*** node Node to iterate.
     * @param ***REMOVED***?K***REMOVED*** startKey
     * @param ***REMOVED***function(K, K): number***REMOVED*** comparator
     * @param ***REMOVED***boolean***REMOVED*** isReverse_ Whether or not to iterate in reverse
     * @param ***REMOVED***(function(K, V):T)=***REMOVED*** resultGenerator_
     */
    constructor(node: LLRBNode<K, V> | LLRBEmptyNode<K, V>, startKey: K | null, comparator: Comparator<K>, isReverse_: boolean, resultGenerator_?: ((k: K, v: V) => T) | null);
    getNext(): T;
    hasNext(): boolean;
    peek(): T;
***REMOVED***
/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
export declare class LLRBNode<K, V> ***REMOVED***
    key: K;
    value: V;
    color: boolean;
    left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    /**
     * @template K, V
     * @param ***REMOVED***!K***REMOVED*** key Key associated with this node.
     * @param ***REMOVED***!V***REMOVED*** value Value associated with this node.
     * @param ***REMOVED***?boolean***REMOVED*** color Whether this node is red.
     * @param ***REMOVED***?(LLRBNode|LLRBEmptyNode)=***REMOVED*** left Left child.
     * @param ***REMOVED***?(LLRBNode|LLRBEmptyNode)=***REMOVED*** right Right child.
     */
    constructor(key: K, value: V, color: boolean | null, left?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null);
    static RED: boolean;
    static BLACK: boolean;
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param ***REMOVED***?K***REMOVED*** key New key for the node, or null.
     * @param ***REMOVED***?V***REMOVED*** value New value for the node, or null.
     * @param ***REMOVED***?boolean***REMOVED*** color New color for the node, or null.
     * @param ***REMOVED***?LLRBNode|LLRBEmptyNode***REMOVED*** left New left child for the node, or null.
     * @param ***REMOVED***?LLRBNode|LLRBEmptyNode***REMOVED*** right New right child for the node, or null.
     * @return ***REMOVED***!LLRBNode***REMOVED*** The node copy.
     */
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBNode<K, V>;
    /**
     * @return ***REMOVED***number***REMOVED*** The total number of nodes in the tree.
     */
    count(): number;
    /**
     * @return ***REMOVED***boolean***REMOVED*** True if the tree is empty.
     */
    isEmpty(): boolean;
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param ***REMOVED***function(!K, !V):****REMOVED*** action Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @return ***REMOVED*******REMOVED*** The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    inorderTraversal(action: (k: K, v: V) => any): boolean;
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param ***REMOVED***function(!Object, !Object)***REMOVED*** action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return ***REMOVED*******REMOVED*** True if traversal was aborted.
     */
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    /**
     * @return ***REMOVED***!Object***REMOVED*** The minimum node in the tree.
     * @private
     */
    private min_();
    /**
     * @return ***REMOVED***!K***REMOVED*** The maximum key in the tree.
     */
    minKey(): K;
    /**
     * @return ***REMOVED***!K***REMOVED*** The maximum key in the tree.
     */
    maxKey(): K;
    /**
     *
     * @param ***REMOVED***!Object***REMOVED*** key Key to insert.
     * @param ***REMOVED***!Object***REMOVED*** value Value to insert.
     * @param ***REMOVED***Comparator***REMOVED*** comparator Comparator.
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, with the key/value added.
     */
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    /**
     * @private
     * @return ***REMOVED***!LLRBNode|LLRBEmptyNode***REMOVED*** New tree, with the minimum key removed.
     */
    private removeMin_();
    /**
     * @param ***REMOVED***!Object***REMOVED*** key The key of the item to remove.
     * @param ***REMOVED***Comparator***REMOVED*** comparator Comparator.
     * @return ***REMOVED***!LLRBNode|LLRBEmptyNode***REMOVED*** New tree, with the specified item removed.
     */
    remove(key: K, comparator: Comparator<K>): LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    /**
     * @private
     * @return ***REMOVED***boolean***REMOVED*** Whether this is a RED node.
     */
    isRed_(): boolean;
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree after performing any needed rotations.
     */
    private fixUp_();
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after moveRedLeft.
     */
    private moveRedLeft_();
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after moveRedRight.
     */
    private moveRedRight_();
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after rotateLeft.
     */
    private rotateLeft_();
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after rotateRight.
     */
    private rotateRight_();
    /**
     * @private
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, after colorFlip.
     */
    private colorFlip_();
    /**
     * For testing.
     *
     * @private
     * @return ***REMOVED***boolean***REMOVED*** True if all is well.
     */
    private checkMaxDepth_();
    /**
     * @private
     * @return ***REMOVED***number***REMOVED*** Not sure what this returns exactly. :-).
     */
    check_(): number;
***REMOVED***
/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
export declare class LLRBEmptyNode<K, V> ***REMOVED***
    key: K;
    value: V;
    left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    color: boolean;
    /**
     * Returns a copy of the current node.
     *
     * @return ***REMOVED***!LLRBEmptyNode***REMOVED*** The node copy.
     */
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBEmptyNode<K, V>;
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param ***REMOVED***!K***REMOVED*** key Key to be added.
     * @param ***REMOVED***!V***REMOVED*** value Value to be added.
     * @param ***REMOVED***Comparator***REMOVED*** comparator Comparator.
     * @return ***REMOVED***!LLRBNode***REMOVED*** New tree, with item added.
     */
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param ***REMOVED***!K***REMOVED*** key The key to remove.
     * @param ***REMOVED***Comparator***REMOVED*** comparator Comparator.
     * @return ***REMOVED***!LLRBEmptyNode***REMOVED*** New tree, with item removed.
     */
    remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V>;
    /**
     * @return ***REMOVED***number***REMOVED*** The total number of nodes in the tree.
     */
    count(): number;
    /**
     * @return ***REMOVED***boolean***REMOVED*** True if the tree is empty.
     */
    isEmpty(): boolean;
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param ***REMOVED***function(!K, !V):****REMOVED*** action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return ***REMOVED***boolean***REMOVED*** True if traversal was aborted.
     */
    inorderTraversal(action: (k: K, v: V) => any): boolean;
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param ***REMOVED***function(!K, !V)***REMOVED*** action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return ***REMOVED***boolean***REMOVED*** True if traversal was aborted.
     */
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    /**
     * @return ***REMOVED***null***REMOVED***
     */
    minKey(): null;
    /**
     * @return ***REMOVED***null***REMOVED***
     */
    maxKey(): null;
    /**
     * @private
     * @return ***REMOVED***number***REMOVED*** Not sure what this returns exactly. :-).
     */
    check_(): number;
    /**
     * @private
     * @return ***REMOVED***boolean***REMOVED*** Whether this node is red.
     */
    isRed_(): boolean;
***REMOVED***
/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
export declare class SortedMap<K, V> ***REMOVED***
    private comparator_;
    private root_;
    /**
     * Always use the same empty node, to reduce memory.
     * @const
     */
    static EMPTY_NODE: LLRBEmptyNode<***REMOVED******REMOVED***, ***REMOVED******REMOVED***>;
    /**
     * @template K, V
     * @param ***REMOVED***function(K, K):number***REMOVED*** comparator_ Key comparator.
     * @param ***REMOVED***LLRBNode=***REMOVED*** root_ (Optional) Root node for the map.
     */
    constructor(comparator_: Comparator<K>, root_?: LLRBNode<K, V> | LLRBEmptyNode<K, V>);
    /**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param ***REMOVED***!K***REMOVED*** key Key to be added.
     * @param ***REMOVED***!V***REMOVED*** value Value to be added.
     * @return ***REMOVED***!SortedMap.<K, V>***REMOVED*** New map, with item added.
     */
    insert(key: K, value: V): SortedMap<K, V>;
    /**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param ***REMOVED***!K***REMOVED*** key The key to remove.
     * @return ***REMOVED***!SortedMap.<K, V>***REMOVED*** New map, with item removed.
     */
    remove(key: K): SortedMap<K, V>;
    /**
     * Returns the value of the node with the given key, or null.
     *
     * @param ***REMOVED***!K***REMOVED*** key The key to look up.
     * @return ***REMOVED***?V***REMOVED*** The value of the node with the given key, or null if the
     * key doesn't exist.
     */
    get(key: K): V | null;
    /**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param ***REMOVED***K***REMOVED*** key The key to find the predecessor of
     * @return ***REMOVED***?K***REMOVED*** The predecessor key.
     */
    getPredecessorKey(key: K): K | null;
    /**
     * @return ***REMOVED***boolean***REMOVED*** True if the map is empty.
     */
    isEmpty(): boolean;
    /**
     * @return ***REMOVED***number***REMOVED*** The total number of nodes in the map.
     */
    count(): number;
    /**
     * @return ***REMOVED***?K***REMOVED*** The minimum key in the map.
     */
    minKey(): K | null;
    /**
     * @return ***REMOVED***?K***REMOVED*** The maximum key in the map.
     */
    maxKey(): K | null;
    /**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param ***REMOVED***function(!K, !V):****REMOVED*** action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return ***REMOVED*******REMOVED*** The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    inorderTraversal(action: (k: K, v: V) => any): boolean;
    /**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param ***REMOVED***function(!Object, !Object)***REMOVED*** action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return ***REMOVED*******REMOVED*** True if the traversal was aborted.
     */
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    /**
     * Returns an iterator over the SortedMap.
     * @template T
     * @param ***REMOVED***(function(K, V):T)=***REMOVED*** resultGenerator
     * @return ***REMOVED***SortedMapIterator.<K, V, T>***REMOVED*** The iterator.
     */
    getIterator<T>(resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
    getIteratorFrom<T>(key: K, resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
    getReverseIteratorFrom<T>(key: K, resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
    getReverseIterator<T>(resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
***REMOVED***
