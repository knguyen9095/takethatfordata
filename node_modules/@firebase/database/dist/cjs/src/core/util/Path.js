"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("./util");
var util_2 = require("@firebase/util");
/**
 * An immutable object representing a parsed path.  It's immutable so that you
 * can pass them around to other functions without worrying about them changing
 * it.
 */
var Path = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***string|Array.<string>***REMOVED*** pathOrString Path string to parse,
     *      or another path, or the raw tokens array
     * @param ***REMOVED***number=***REMOVED*** pieceNum
     */
    function Path(pathOrString, pieceNum) ***REMOVED***
        if (pieceNum === void 0) ***REMOVED***
            this.pieces_ = pathOrString.split('/');
            // Remove empty pieces.
            var copyTo = 0;
            for (var i = 0; i < this.pieces_.length; i++) ***REMOVED***
                if (this.pieces_[i].length > 0) ***REMOVED***
                    this.pieces_[copyTo] = this.pieces_[i];
                    copyTo++;
                ***REMOVED***
            ***REMOVED***
            this.pieces_.length = copyTo;
            this.pieceNum_ = 0;
        ***REMOVED***
        else ***REMOVED***
            this.pieces_ = pathOrString;
            this.pieceNum_ = pieceNum;
        ***REMOVED***
    ***REMOVED***
    Object.defineProperty(Path, "Empty", ***REMOVED***
        /**
         * Singleton to represent an empty path
         *
         * @const
         */
        get: function () ***REMOVED***
            return new Path('');
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Path.prototype.getFront = function () ***REMOVED***
        if (this.pieceNum_ >= this.pieces_.length)
            return null;
        return this.pieces_[this.pieceNum_];
    ***REMOVED***;
    /**
     * @return ***REMOVED***number***REMOVED*** The number of segments in this path
     */
    Path.prototype.getLength = function () ***REMOVED***
        return this.pieces_.length - this.pieceNum_;
    ***REMOVED***;
    /**
     * @return ***REMOVED***!Path***REMOVED***
     */
    Path.prototype.popFront = function () ***REMOVED***
        var pieceNum = this.pieceNum_;
        if (pieceNum < this.pieces_.length) ***REMOVED***
            pieceNum++;
        ***REMOVED***
        return new Path(this.pieces_, pieceNum);
    ***REMOVED***;
    /**
     * @return ***REMOVED***?string***REMOVED***
     */
    Path.prototype.getBack = function () ***REMOVED***
        if (this.pieceNum_ < this.pieces_.length)
            return this.pieces_[this.pieces_.length - 1];
        return null;
    ***REMOVED***;
    Path.prototype.toString = function () ***REMOVED***
        var pathString = '';
        for (var i = this.pieceNum_; i < this.pieces_.length; i++) ***REMOVED***
            if (this.pieces_[i] !== '')
                pathString += '/' + this.pieces_[i];
        ***REMOVED***
        return pathString || '/';
    ***REMOVED***;
    Path.prototype.toUrlEncodedString = function () ***REMOVED***
        var pathString = '';
        for (var i = this.pieceNum_; i < this.pieces_.length; i++) ***REMOVED***
            if (this.pieces_[i] !== '')
                pathString += '/' + encodeURIComponent(String(this.pieces_[i]));
        ***REMOVED***
        return pathString || '/';
    ***REMOVED***;
    /**
     * Shallow copy of the parts of the path.
     *
     * @param ***REMOVED***number=***REMOVED*** begin
     * @return ***REMOVED***!Array<string>***REMOVED***
     */
    Path.prototype.slice = function (begin) ***REMOVED***
        if (begin === void 0) ***REMOVED*** begin = 0; ***REMOVED***
        return this.pieces_.slice(this.pieceNum_ + begin);
    ***REMOVED***;
    /**
     * @return ***REMOVED***?Path***REMOVED***
     */
    Path.prototype.parent = function () ***REMOVED***
        if (this.pieceNum_ >= this.pieces_.length)
            return null;
        var pieces = [];
        for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++)
            pieces.push(this.pieces_[i]);
        return new Path(pieces, 0);
    ***REMOVED***;
    /**
     * @param ***REMOVED***string|!Path***REMOVED*** childPathObj
     * @return ***REMOVED***!Path***REMOVED***
     */
    Path.prototype.child = function (childPathObj) ***REMOVED***
        var pieces = [];
        for (var i = this.pieceNum_; i < this.pieces_.length; i++)
            pieces.push(this.pieces_[i]);
        if (childPathObj instanceof Path) ***REMOVED***
            for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) ***REMOVED***
                pieces.push(childPathObj.pieces_[i]);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            var childPieces = childPathObj.split('/');
            for (var i = 0; i < childPieces.length; i++) ***REMOVED***
                if (childPieces[i].length > 0)
                    pieces.push(childPieces[i]);
            ***REMOVED***
        ***REMOVED***
        return new Path(pieces, 0);
    ***REMOVED***;
    /**
     * @return ***REMOVED***boolean***REMOVED*** True if there are no segments in this path
     */
    Path.prototype.isEmpty = function () ***REMOVED***
        return this.pieceNum_ >= this.pieces_.length;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** outerPath
     * @param ***REMOVED***!Path***REMOVED*** innerPath
     * @return ***REMOVED***!Path***REMOVED*** The path from outerPath to innerPath
     */
    Path.relativePath = function (outerPath, innerPath) ***REMOVED***
        var outer = outerPath.getFront(), inner = innerPath.getFront();
        if (outer === null) ***REMOVED***
            return innerPath;
        ***REMOVED***
        else if (outer === inner) ***REMOVED***
            return Path.relativePath(outerPath.popFront(), innerPath.popFront());
        ***REMOVED***
        else ***REMOVED***
            throw new Error('INTERNAL ERROR: innerPath (' +
                innerPath +
                ') is not within ' +
                'outerPath (' +
                outerPath +
                ')');
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Path***REMOVED*** left
     * @param ***REMOVED***!Path***REMOVED*** right
     * @return ***REMOVED***number***REMOVED*** -1, 0, 1 if left is less, equal, or greater than the right.
     */
    Path.comparePaths = function (left, right) ***REMOVED***
        var leftKeys = left.slice();
        var rightKeys = right.slice();
        for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) ***REMOVED***
            var cmp = util_1.nameCompare(leftKeys[i], rightKeys[i]);
            if (cmp !== 0)
                return cmp;
        ***REMOVED***
        if (leftKeys.length === rightKeys.length)
            return 0;
        return leftKeys.length < rightKeys.length ? -1 : 1;
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***Path***REMOVED*** other
     * @return ***REMOVED***boolean***REMOVED*** true if paths are the same.
     */
    Path.prototype.equals = function (other) ***REMOVED***
        if (this.getLength() !== other.getLength()) ***REMOVED***
            return false;
        ***REMOVED***
        for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, j++) ***REMOVED***
            if (this.pieces_[i] !== other.pieces_[j]) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        return true;
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***!Path***REMOVED*** other
     * @return ***REMOVED***boolean***REMOVED*** True if this path is a parent (or the same as) other
     */
    Path.prototype.contains = function (other) ***REMOVED***
        var i = this.pieceNum_;
        var j = other.pieceNum_;
        if (this.getLength() > other.getLength()) ***REMOVED***
            return false;
        ***REMOVED***
        while (i < this.pieces_.length) ***REMOVED***
            if (this.pieces_[i] !== other.pieces_[j]) ***REMOVED***
                return false;
            ***REMOVED***
            ++i;
            ++j;
        ***REMOVED***
        return true;
    ***REMOVED***;
    return Path;
***REMOVED***()); // end Path
exports.Path = Path;
/**
 * Dynamic (mutable) path used to count path lengths.
 *
 * This class is used to efficiently check paths for valid
 * length (in UTF8 bytes) and depth (used in path validation).
 *
 * Throws Error exception if path is ever invalid.
 *
 * The definition of a path always begins with '/'.
 */
var ValidationPath = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***!Path***REMOVED*** path Initial Path.
     * @param ***REMOVED***string***REMOVED*** errorPrefix_ Prefix for any error messages.
     */
    function ValidationPath(path, errorPrefix_) ***REMOVED***
        this.errorPrefix_ = errorPrefix_;
        /** @type ***REMOVED***!Array<string>***REMOVED*** */
        this.parts_ = path.slice();
        /** @type ***REMOVED***number***REMOVED*** Initialize to number of '/' chars needed in path. */
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (var i = 0; i < this.parts_.length; i++) ***REMOVED***
            this.byteLength_ += util_2.stringLength(this.parts_[i]);
        ***REMOVED***
        this.checkValid_();
    ***REMOVED***
    Object.defineProperty(ValidationPath, "MAX_PATH_DEPTH", ***REMOVED***
        /** @const ***REMOVED***number***REMOVED*** Maximum key depth. */
        get: function () ***REMOVED***
            return 32;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(ValidationPath, "MAX_PATH_LENGTH_BYTES", ***REMOVED***
        /** @const ***REMOVED***number***REMOVED*** Maximum number of (UTF8) bytes in a Firebase path. */
        get: function () ***REMOVED***
            return 768;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /** @param ***REMOVED***string***REMOVED*** child */
    ValidationPath.prototype.push = function (child) ***REMOVED***
        // Count the needed '/'
        if (this.parts_.length > 0) ***REMOVED***
            this.byteLength_ += 1;
        ***REMOVED***
        this.parts_.push(child);
        this.byteLength_ += util_2.stringLength(child);
        this.checkValid_();
    ***REMOVED***;
    ValidationPath.prototype.pop = function () ***REMOVED***
        var last = this.parts_.pop();
        this.byteLength_ -= util_2.stringLength(last);
        // Un-count the previous '/'
        if (this.parts_.length > 0) ***REMOVED***
            this.byteLength_ -= 1;
        ***REMOVED***
    ***REMOVED***;
    ValidationPath.prototype.checkValid_ = function () ***REMOVED***
        if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) ***REMOVED***
            throw new Error(this.errorPrefix_ +
                'has a key path longer than ' +
                ValidationPath.MAX_PATH_LENGTH_BYTES +
                ' bytes (' +
                this.byteLength_ +
                ').');
        ***REMOVED***
        if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) ***REMOVED***
            throw new Error(this.errorPrefix_ +
                'path specified exceeds the maximum depth that can be written (' +
                ValidationPath.MAX_PATH_DEPTH +
                ') or object contains a cycle ' +
                this.toErrorString());
        ***REMOVED***
    ***REMOVED***;
    /**
     * String for use in error messages - uses '.' notation for path.
     *
     * @return ***REMOVED***string***REMOVED***
     */
    ValidationPath.prototype.toErrorString = function () ***REMOVED***
        if (this.parts_.length == 0) ***REMOVED***
            return '';
        ***REMOVED***
        return "in property '" + this.parts_.join('.') + "'";
    ***REMOVED***;
    return ValidationPath;
***REMOVED***());
exports.ValidationPath = ValidationPath;

//# sourceMappingURL=Path.js.map
