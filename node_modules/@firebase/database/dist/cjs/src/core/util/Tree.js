"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("@firebase/util");
var Path_1 = require("./Path");
var util_2 = require("@firebase/util");
/**
 * Node in a Tree.
 */
var TreeNode = /** @class */ (function () ***REMOVED***
    function TreeNode() ***REMOVED***
        // TODO: Consider making accessors that create children and value lazily or
        // separate Internal / Leaf 'types'.
        this.children = ***REMOVED******REMOVED***;
        this.childCount = 0;
        this.value = null;
    ***REMOVED***
    return TreeNode;
***REMOVED***());
exports.TreeNode = TreeNode;
/**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */
var Tree = /** @class */ (function () ***REMOVED***
    /**
     * @template T
     * @param ***REMOVED***string=***REMOVED*** name_ Optional name of the node.
     * @param ***REMOVED***Tree=***REMOVED*** parent_ Optional parent node.
     * @param ***REMOVED***TreeNode=***REMOVED*** node_ Optional node to wrap.
     */
    function Tree(name_, parent_, node_) ***REMOVED***
        if (name_ === void 0) ***REMOVED*** name_ = ''; ***REMOVED***
        if (parent_ === void 0) ***REMOVED*** parent_ = null; ***REMOVED***
        if (node_ === void 0) ***REMOVED*** node_ = new TreeNode(); ***REMOVED***
        this.name_ = name_;
        this.parent_ = parent_;
        this.node_ = node_;
    ***REMOVED***
    /**
     * Returns a sub-Tree for the given path.
     *
     * @param ***REMOVED***!(string|Path)***REMOVED*** pathObj Path to look up.
     * @return ***REMOVED***!Tree.<T>***REMOVED*** Tree for path.
     */
    Tree.prototype.subTree = function (pathObj) ***REMOVED***
        // TODO: Require pathObj to be Path?
        var path = pathObj instanceof Path_1.Path ? pathObj : new Path_1.Path(pathObj);
        var child = this, next;
        while ((next = path.getFront()) !== null) ***REMOVED***
            var childNode = util_2.safeGet(child.node_.children, next) || new TreeNode();
            child = new Tree(next, child, childNode);
            path = path.popFront();
        ***REMOVED***
        return child;
    ***REMOVED***;
    /**
     * Returns the data associated with this tree node.
     *
     * @return ***REMOVED***?T***REMOVED*** The data or null if no data exists.
     */
    Tree.prototype.getValue = function () ***REMOVED***
        return this.node_.value;
    ***REMOVED***;
    /**
     * Sets data to this tree node.
     *
     * @param ***REMOVED***!T***REMOVED*** value Value to set.
     */
    Tree.prototype.setValue = function (value) ***REMOVED***
        util_1.assert(typeof value !== 'undefined', 'Cannot set value to undefined');
        this.node_.value = value;
        this.updateParents_();
    ***REMOVED***;
    /**
     * Clears the contents of the tree node (its value and all children).
     */
    Tree.prototype.clear = function () ***REMOVED***
        this.node_.value = null;
        this.node_.children = ***REMOVED******REMOVED***;
        this.node_.childCount = 0;
        this.updateParents_();
    ***REMOVED***;
    /**
     * @return ***REMOVED***boolean***REMOVED*** Whether the tree has any children.
     */
    Tree.prototype.hasChildren = function () ***REMOVED***
        return this.node_.childCount > 0;
    ***REMOVED***;
    /**
     * @return ***REMOVED***boolean***REMOVED*** Whether the tree is empty (no value or children).
     */
    Tree.prototype.isEmpty = function () ***REMOVED***
        return this.getValue() === null && !this.hasChildren();
    ***REMOVED***;
    /**
     * Calls action for each child of this tree node.
     *
     * @param ***REMOVED***function(!Tree.<T>)***REMOVED*** action Action to be called for each child.
     */
    Tree.prototype.forEachChild = function (action) ***REMOVED***
        var _this = this;
        util_2.forEach(this.node_.children, function (child, childTree) ***REMOVED***
            action(new Tree(child, _this, childTree));
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Does a depth-first traversal of this node's descendants, calling action for each one.
     *
     * @param ***REMOVED***function(!Tree.<T>)***REMOVED*** action Action to be called for each child.
     * @param ***REMOVED***boolean=***REMOVED*** includeSelf Whether to call action on this node as well. Defaults to
     *   false.
     * @param ***REMOVED***boolean=***REMOVED*** childrenFirst Whether to call action on children before calling it on
     *   parent.
     */
    Tree.prototype.forEachDescendant = function (action, includeSelf, childrenFirst) ***REMOVED***
        if (includeSelf && !childrenFirst)
            action(this);
        this.forEachChild(function (child) ***REMOVED***
            child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);
        ***REMOVED***);
        if (includeSelf && childrenFirst)
            action(this);
    ***REMOVED***;
    /**
     * Calls action on each ancestor node.
     *
     * @param ***REMOVED***function(!Tree.<T>)***REMOVED*** action Action to be called on each parent; return
     *   true to abort.
     * @param ***REMOVED***boolean=***REMOVED*** includeSelf Whether to call action on this node as well.
     * @return ***REMOVED***boolean***REMOVED*** true if the action callback returned true.
     */
    Tree.prototype.forEachAncestor = function (action, includeSelf) ***REMOVED***
        var node = includeSelf ? this : this.parent();
        while (node !== null) ***REMOVED***
            if (action(node)) ***REMOVED***
                return true;
            ***REMOVED***
            node = node.parent();
        ***REMOVED***
        return false;
    ***REMOVED***;
    /**
     * Does a depth-first traversal of this node's descendants.  When a descendant with a value
     * is found, action is called on it and traversal does not continue inside the node.
     * Action is *not* called on this node.
     *
     * @param ***REMOVED***function(!Tree.<T>)***REMOVED*** action Action to be called for each child.
     */
    Tree.prototype.forEachImmediateDescendantWithValue = function (action) ***REMOVED***
        this.forEachChild(function (child) ***REMOVED***
            if (child.getValue() !== null)
                action(child);
            else
                child.forEachImmediateDescendantWithValue(action);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * @return ***REMOVED***!Path***REMOVED*** The path of this tree node, as a Path.
     */
    Tree.prototype.path = function () ***REMOVED***
        return new Path_1.Path(this.parent_ === null
            ? this.name_
            : this.parent_.path() + '/' + this.name_);
    ***REMOVED***;
    /**
     * @return ***REMOVED***string***REMOVED*** The name of the tree node.
     */
    Tree.prototype.name = function () ***REMOVED***
        return this.name_;
    ***REMOVED***;
    /**
     * @return ***REMOVED***?Tree***REMOVED*** The parent tree node, or null if this is the root of the tree.
     */
    Tree.prototype.parent = function () ***REMOVED***
        return this.parent_;
    ***REMOVED***;
    /**
     * Adds or removes this child from its parent based on whether it's empty or not.
     *
     * @private
     */
    Tree.prototype.updateParents_ = function () ***REMOVED***
        if (this.parent_ !== null)
            this.parent_.updateChild_(this.name_, this);
    ***REMOVED***;
    /**
     * Adds or removes the passed child to this tree node, depending on whether it's empty.
     *
     * @param ***REMOVED***string***REMOVED*** childName The name of the child to update.
     * @param ***REMOVED***!Tree.<T>***REMOVED*** child The child to update.
     * @private
     */
    Tree.prototype.updateChild_ = function (childName, child) ***REMOVED***
        var childEmpty = child.isEmpty();
        var childExists = util_2.contains(this.node_.children, childName);
        if (childEmpty && childExists) ***REMOVED***
            delete this.node_.children[childName];
            this.node_.childCount--;
            this.updateParents_();
        ***REMOVED***
        else if (!childEmpty && !childExists) ***REMOVED***
            this.node_.children[childName] = child.node_;
            this.node_.childCount++;
            this.updateParents_();
        ***REMOVED***
    ***REMOVED***;
    return Tree;
***REMOVED***());
exports.Tree = Tree;

//# sourceMappingURL=Tree.js.map
