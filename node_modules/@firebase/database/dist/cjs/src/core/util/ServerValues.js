"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("@firebase/util");
var Path_1 = require("./Path");
var SparseSnapshotTree_1 = require("../SparseSnapshotTree");
var LeafNode_1 = require("../snap/LeafNode");
var nodeFromJSON_1 = require("../snap/nodeFromJSON");
var PriorityIndex_1 = require("../snap/indexes/PriorityIndex");
/**
 * Generate placeholders for deferred values.
 * @param ***REMOVED***?Object***REMOVED*** values
 * @return ***REMOVED***!Object***REMOVED***
 */
exports.generateWithValues = function (values) ***REMOVED***
    values = values || ***REMOVED******REMOVED***;
    values['timestamp'] = values['timestamp'] || new Date().getTime();
    return values;
***REMOVED***;
/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 * @param ***REMOVED***(Object|string|number|boolean)***REMOVED*** value
 * @param ***REMOVED***!Object***REMOVED*** serverValues
 * @return ***REMOVED***!(string|number|boolean)***REMOVED***
 */
exports.resolveDeferredValue = function (value, serverValues) ***REMOVED***
    if (!value || typeof value !== 'object') ***REMOVED***
        return value;
    ***REMOVED***
    else ***REMOVED***
        util_1.assert('.sv' in value, 'Unexpected leaf node or priority contents');
        return serverValues[value['.sv']];
    ***REMOVED***
***REMOVED***;
/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param ***REMOVED***!SparseSnapshotTree***REMOVED*** tree
 * @param ***REMOVED***!Object***REMOVED*** serverValues
 * @return ***REMOVED***!SparseSnapshotTree***REMOVED***
 */
exports.resolveDeferredValueTree = function (tree, serverValues) ***REMOVED***
    var resolvedTree = new SparseSnapshotTree_1.SparseSnapshotTree();
    tree.forEachTree(new Path_1.Path(''), function (path, node) ***REMOVED***
        resolvedTree.remember(path, exports.resolveDeferredValueSnapshot(node, serverValues));
    ***REMOVED***);
    return resolvedTree;
***REMOVED***;
/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 * @param ***REMOVED***!Node***REMOVED*** node
 * @param ***REMOVED***!Object***REMOVED*** serverValues
 * @return ***REMOVED***!Node***REMOVED***
 */
exports.resolveDeferredValueSnapshot = function (node, serverValues) ***REMOVED***
    var rawPri = node.getPriority().val();
    var priority = exports.resolveDeferredValue(rawPri, serverValues);
    var newNode;
    if (node.isLeafNode()) ***REMOVED***
        var leafNode = node;
        var value = exports.resolveDeferredValue(leafNode.getValue(), serverValues);
        if (value !== leafNode.getValue() ||
            priority !== leafNode.getPriority().val()) ***REMOVED***
            return new LeafNode_1.LeafNode(value, nodeFromJSON_1.nodeFromJSON(priority));
        ***REMOVED***
        else ***REMOVED***
            return node;
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
        var childrenNode = node;
        newNode = childrenNode;
        if (priority !== childrenNode.getPriority().val()) ***REMOVED***
            newNode = newNode.updatePriority(new LeafNode_1.LeafNode(priority));
        ***REMOVED***
        childrenNode.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) ***REMOVED***
            var newChildNode = exports.resolveDeferredValueSnapshot(childNode, serverValues);
            if (newChildNode !== childNode) ***REMOVED***
                newNode = newNode.updateImmediateChild(childName, newChildNode);
            ***REMOVED***
        ***REMOVED***);
        return newNode;
    ***REMOVED***
***REMOVED***;

//# sourceMappingURL=ServerValues.js.map
