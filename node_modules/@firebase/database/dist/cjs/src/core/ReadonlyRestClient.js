"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("@firebase/util");
var util_2 = require("./util/util");
var util_3 = require("@firebase/util");
var util_4 = require("@firebase/util");
var util_5 = require("@firebase/util");
var ServerActions_1 = require("./ServerActions");
/**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */
var ReadonlyRestClient = /** @class */ (function (_super) ***REMOVED***
    __extends(ReadonlyRestClient, _super);
    /**
     * @param ***REMOVED***!RepoInfo***REMOVED*** repoInfo_ Data about the namespace we are connecting to
     * @param ***REMOVED***function(string, *, boolean, ?number)***REMOVED*** onDataUpdate_ A callback for new data from the server
     * @param ***REMOVED***AuthTokenProvider***REMOVED*** authTokenProvider_
     * @implements ***REMOVED***ServerActions***REMOVED***
     */
    function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        /** @private ***REMOVED***function(...[*])***REMOVED*** */
        _this.log_ = util_2.logWrapper('p:rest:');
        /**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         *
         * @private ***REMOVED***!Object.<string, !Object>***REMOVED***
         */
        _this.listens_ = ***REMOVED******REMOVED***;
        return _this;
    ***REMOVED***
    ReadonlyRestClient.prototype.reportStats = function (stats) ***REMOVED***
        throw new Error('Method not implemented.');
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Query***REMOVED*** query
     * @param ***REMOVED***?number=***REMOVED*** tag
     * @return ***REMOVED***string***REMOVED***
     * @private
     */
    ReadonlyRestClient.getListenId_ = function (query, tag) ***REMOVED***
        if (tag !== undefined) ***REMOVED***
            return 'tag$' + tag;
        ***REMOVED***
        else ***REMOVED***
            util_1.assert(query.getQueryParams().isDefault(), "should have a tag if it's not a default query.");
            return query.path.toString();
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) ***REMOVED***
        var _this = this;
        var pathString = query.path.toString();
        this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier());
        // Mark this listener so we can tell if it's removed.
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        var thisListen = ***REMOVED******REMOVED***;
        this.listens_[listenId] = thisListen;
        var queryStringParamaters = query
            .getQueryParams()
            .toRestQueryStringParameters();
        this.restRequest_(pathString + '.json', queryStringParamaters, function (error, result) ***REMOVED***
            var data = result;
            if (error === 404) ***REMOVED***
                data = null;
                error = null;
            ***REMOVED***
            if (error === null) ***REMOVED***
                _this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);
            ***REMOVED***
            if (util_4.safeGet(_this.listens_, listenId) === thisListen) ***REMOVED***
                var status_1;
                if (!error) ***REMOVED***
                    status_1 = 'ok';
                ***REMOVED***
                else if (error == 401) ***REMOVED***
                    status_1 = 'permission_denied';
                ***REMOVED***
                else ***REMOVED***
                    status_1 = 'rest_error:' + error;
                ***REMOVED***
                onComplete(status_1, null);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /** @inheritDoc */
    ReadonlyRestClient.prototype.unlisten = function (query, tag) ***REMOVED***
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        delete this.listens_[listenId];
    ***REMOVED***;
    /** @inheritDoc */
    ReadonlyRestClient.prototype.refreshAuthToken = function (token) ***REMOVED***
        // no-op since we just always call getToken.
    ***REMOVED***;
    /**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     *
     * @param ***REMOVED***!string***REMOVED*** pathString
     * @param ***REMOVED***!Object.<string, *>***REMOVED*** queryStringParameters
     * @param ***REMOVED***?function(?number, *=)***REMOVED*** callback
     * @private
     */
    ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) ***REMOVED***
        var _this = this;
        if (queryStringParameters === void 0) ***REMOVED*** queryStringParameters = ***REMOVED******REMOVED***; ***REMOVED***
        queryStringParameters['format'] = 'export';
        this.authTokenProvider_
            .getToken(/*forceRefresh=*/ false)
            .then(function (authTokenData) ***REMOVED***
            var authToken = authTokenData && authTokenData.accessToken;
            if (authToken) ***REMOVED***
                queryStringParameters['auth'] = authToken;
            ***REMOVED***
            var url = (_this.repoInfo_.secure ? 'https://' : 'http://') +
                _this.repoInfo_.host +
                pathString +
                '?' +
                util_5.querystring(queryStringParameters);
            _this.log_('Sending REST request for ' + url);
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () ***REMOVED***
                if (callback && xhr.readyState === 4) ***REMOVED***
                    _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);
                    var res = null;
                    if (xhr.status >= 200 && xhr.status < 300) ***REMOVED***
                        try ***REMOVED***
                            res = util_3.jsonEval(xhr.responseText);
                        ***REMOVED***
                        catch (e) ***REMOVED***
                            util_2.warn('Failed to parse JSON response for ' +
                                url +
                                ': ' +
                                xhr.responseText);
                        ***REMOVED***
                        callback(null, res);
                    ***REMOVED***
                    else ***REMOVED***
                        // 401 and 404 are expected.
                        if (xhr.status !== 401 && xhr.status !== 404) ***REMOVED***
                            util_2.warn('Got unsuccessful REST response for ' +
                                url +
                                ' Status: ' +
                                xhr.status);
                        ***REMOVED***
                        callback(xhr.status);
                    ***REMOVED***
                    callback = null;
                ***REMOVED***
            ***REMOVED***;
            xhr.open('GET', url, /*asynchronous=*/ true);
            xhr.send();
        ***REMOVED***);
    ***REMOVED***;
    return ReadonlyRestClient;
***REMOVED***(ServerActions_1.ServerActions));
exports.ReadonlyRestClient = ReadonlyRestClient;

//# sourceMappingURL=ReadonlyRestClient.js.map
