"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var Path_1 = require("./util/Path");
var PriorityIndex_1 = require("./snap/indexes/PriorityIndex");
var CountedSet_1 = require("./util/CountedSet");
/**
 * Helper class to store a sparse set of snapshots.
 *
 * @constructor
 */
var SparseSnapshotTree = /** @class */ (function () ***REMOVED***
    function SparseSnapshotTree() ***REMOVED***
        /**
         * @private
         * @type ***REMOVED***Node***REMOVED***
         */
        this.value_ = null;
        /**
         * @private
         * @type ***REMOVED***CountedSet***REMOVED***
         */
        this.children_ = null;
    ***REMOVED***
    /**
     * Gets the node stored at the given path if one exists.
     *
     * @param ***REMOVED***!Path***REMOVED*** path Path to look up snapshot for.
     * @return ***REMOVED***?Node***REMOVED*** The retrieved node, or null.
     */
    SparseSnapshotTree.prototype.find = function (path) ***REMOVED***
        if (this.value_ != null) ***REMOVED***
            return this.value_.getChild(path);
        ***REMOVED***
        else if (!path.isEmpty() && this.children_ != null) ***REMOVED***
            var childKey = path.getFront();
            path = path.popFront();
            if (this.children_.contains(childKey)) ***REMOVED***
                var childTree = this.children_.get(childKey);
                return childTree.find(path);
            ***REMOVED***
            else ***REMOVED***
                return null;
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            return null;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Stores the given node at the specified path. If there is already a node
     * at a shallower path, it merges the new data into that snapshot node.
     *
     * @param ***REMOVED***!Path***REMOVED*** path Path to look up snapshot for.
     * @param ***REMOVED***!Node***REMOVED*** data The new data, or null.
     */
    SparseSnapshotTree.prototype.remember = function (path, data) ***REMOVED***
        if (path.isEmpty()) ***REMOVED***
            this.value_ = data;
            this.children_ = null;
        ***REMOVED***
        else if (this.value_ !== null) ***REMOVED***
            this.value_ = this.value_.updateChild(path, data);
        ***REMOVED***
        else ***REMOVED***
            if (this.children_ == null) ***REMOVED***
                this.children_ = new CountedSet_1.CountedSet();
            ***REMOVED***
            var childKey = path.getFront();
            if (!this.children_.contains(childKey)) ***REMOVED***
                this.children_.add(childKey, new SparseSnapshotTree());
            ***REMOVED***
            var child = this.children_.get(childKey);
            path = path.popFront();
            child.remember(path, data);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Purge the data at path from the cache.
     *
     * @param ***REMOVED***!Path***REMOVED*** path Path to look up snapshot for.
     * @return ***REMOVED***boolean***REMOVED*** True if this node should now be removed.
     */
    SparseSnapshotTree.prototype.forget = function (path) ***REMOVED***
        if (path.isEmpty()) ***REMOVED***
            this.value_ = null;
            this.children_ = null;
            return true;
        ***REMOVED***
        else ***REMOVED***
            if (this.value_ !== null) ***REMOVED***
                if (this.value_.isLeafNode()) ***REMOVED***
                    // We're trying to forget a node that doesn't exist
                    return false;
                ***REMOVED***
                else ***REMOVED***
                    var value = this.value_;
                    this.value_ = null;
                    var self_1 = this;
                    value.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, tree) ***REMOVED***
                        self_1.remember(new Path_1.Path(key), tree);
                    ***REMOVED***);
                    return this.forget(path);
                ***REMOVED***
            ***REMOVED***
            else if (this.children_ !== null) ***REMOVED***
                var childKey = path.getFront();
                path = path.popFront();
                if (this.children_.contains(childKey)) ***REMOVED***
                    var safeToRemove = this.children_.get(childKey).forget(path);
                    if (safeToRemove) ***REMOVED***
                        this.children_.remove(childKey);
                    ***REMOVED***
                ***REMOVED***
                if (this.children_.isEmpty()) ***REMOVED***
                    this.children_ = null;
                    return true;
                ***REMOVED***
                else ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                return true;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Recursively iterates through all of the stored tree and calls the
     * callback on each one.
     *
     * @param ***REMOVED***!Path***REMOVED*** prefixPath Path to look up node for.
     * @param ***REMOVED***!Function***REMOVED*** func The function to invoke for each tree.
     */
    SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) ***REMOVED***
        if (this.value_ !== null) ***REMOVED***
            func(prefixPath, this.value_);
        ***REMOVED***
        else ***REMOVED***
            this.forEachChild(function (key, tree) ***REMOVED***
                var path = new Path_1.Path(prefixPath.toString() + '/' + key);
                tree.forEachTree(path, func);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Iterates through each immediate child and triggers the callback.
     *
     * @param ***REMOVED***!Function***REMOVED*** func The function to invoke for each child.
     */
    SparseSnapshotTree.prototype.forEachChild = function (func) ***REMOVED***
        if (this.children_ !== null) ***REMOVED***
            this.children_.each(function (key, tree) ***REMOVED***
                func(key, tree);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;
    return SparseSnapshotTree;
***REMOVED***());
exports.SparseSnapshotTree = SparseSnapshotTree;

//# sourceMappingURL=SparseSnapshotTree.js.map
