"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("@firebase/util");
var util_2 = require("../util/util");
var snap_1 = require("./snap");
var __childrenNodeConstructor;
/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */
var LeafNode = /** @class */ (function () ***REMOVED***
    /**
     * @implements ***REMOVED***Node***REMOVED***
     * @param ***REMOVED***!(string|number|boolean|Object)***REMOVED*** value_ The value to store in this leaf node.
     *                                         The object type is possible in the event of a deferred value
     * @param ***REMOVED***!Node=***REMOVED*** priorityNode_ The priority of this node.
     */
    function LeafNode(value_, priorityNode_) ***REMOVED***
        if (priorityNode_ === void 0) ***REMOVED*** priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE; ***REMOVED***
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        util_1.assert(this.value_ !== undefined && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        snap_1.validatePriorityNode(this.priorityNode_);
    ***REMOVED***
    Object.defineProperty(LeafNode, "__childrenNodeConstructor", ***REMOVED***
        get: function () ***REMOVED***
            return __childrenNodeConstructor;
        ***REMOVED***,
        set: function (val) ***REMOVED***
            __childrenNodeConstructor = val;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /** @inheritDoc */
    LeafNode.prototype.isLeafNode = function () ***REMOVED***
        return true;
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.getPriority = function () ***REMOVED***
        return this.priorityNode_;
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.updatePriority = function (newPriorityNode) ***REMOVED***
        return new LeafNode(this.value_, newPriorityNode);
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.getImmediateChild = function (childName) ***REMOVED***
        // Hack to treat priority as a regular child
        if (childName === '.priority') ***REMOVED***
            return this.priorityNode_;
        ***REMOVED***
        else ***REMOVED***
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.getChild = function (path) ***REMOVED***
        if (path.isEmpty()) ***REMOVED***
            return this;
        ***REMOVED***
        else if (path.getFront() === '.priority') ***REMOVED***
            return this.priorityNode_;
        ***REMOVED***
        else ***REMOVED***
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LeafNode.prototype.hasChild = function () ***REMOVED***
        return false;
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.getPredecessorChildName = function (childName, childNode) ***REMOVED***
        return null;
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) ***REMOVED***
        if (childName === '.priority') ***REMOVED***
            return this.updatePriority(newChildNode);
        ***REMOVED***
        else if (newChildNode.isEmpty() && childName !== '.priority') ***REMOVED***
            return this;
        ***REMOVED***
        else ***REMOVED***
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.updateChild = function (path, newChildNode) ***REMOVED***
        var front = path.getFront();
        if (front === null) ***REMOVED***
            return newChildNode;
        ***REMOVED***
        else if (newChildNode.isEmpty() && front !== '.priority') ***REMOVED***
            return this;
        ***REMOVED***
        else ***REMOVED***
            util_1.assert(front !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');
            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.isEmpty = function () ***REMOVED***
        return false;
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.numChildren = function () ***REMOVED***
        return 0;
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.forEachChild = function (index, action) ***REMOVED***
        return false;
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LeafNode.prototype.val = function (exportFormat) ***REMOVED***
        if (exportFormat && !this.getPriority().isEmpty())
            return ***REMOVED***
                '.value': this.getValue(),
                '.priority': this.getPriority().val()
            ***REMOVED***;
        else
            return this.getValue();
    ***REMOVED***;
    /** @inheritDoc */
    LeafNode.prototype.hash = function () ***REMOVED***
        if (this.lazyHash_ === null) ***REMOVED***
            var toHash = '';
            if (!this.priorityNode_.isEmpty())
                toHash +=
                    'priority:' +
                        snap_1.priorityHashText(this.priorityNode_.val()) +
                        ':';
            var type = typeof this.value_;
            toHash += type + ':';
            if (type === 'number') ***REMOVED***
                toHash += util_2.doubleToIEEE754String(this.value_);
            ***REMOVED***
            else ***REMOVED***
                toHash += this.value_;
            ***REMOVED***
            this.lazyHash_ = util_2.sha1(toHash);
        ***REMOVED***
        return this.lazyHash_;
    ***REMOVED***;
    /**
     * Returns the value of the leaf node.
     * @return ***REMOVED***Object|string|number|boolean***REMOVED*** The value of the node.
     */
    LeafNode.prototype.getValue = function () ***REMOVED***
        return this.value_;
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LeafNode.prototype.compareTo = function (other) ***REMOVED***
        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) ***REMOVED***
            return 1;
        ***REMOVED***
        else if (other instanceof LeafNode.__childrenNodeConstructor) ***REMOVED***
            return -1;
        ***REMOVED***
        else ***REMOVED***
            util_1.assert(other.isLeafNode(), 'Unknown node type');
            return this.compareToLeafNode_(other);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Comparison specifically for two leaf nodes
     * @param ***REMOVED***!LeafNode***REMOVED*** otherLeaf
     * @return ***REMOVED***!number***REMOVED***
     * @private
     */
    LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) ***REMOVED***
        var otherLeafType = typeof otherLeaf.value_;
        var thisLeafType = typeof this.value_;
        var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        util_1.assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);
        util_1.assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);
        if (otherIndex === thisIndex) ***REMOVED***
            // Same type, compare values
            if (thisLeafType === 'object') ***REMOVED***
                // Deferred value nodes are all equal, but we should also never get to this point...
                return 0;
            ***REMOVED***
            else ***REMOVED***
                // Note that this works because true > false, all others are number or string comparisons
                if (this.value_ < otherLeaf.value_) ***REMOVED***
                    return -1;
                ***REMOVED***
                else if (this.value_ === otherLeaf.value_) ***REMOVED***
                    return 0;
                ***REMOVED***
                else ***REMOVED***
                    return 1;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            return thisIndex - otherIndex;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LeafNode.prototype.withIndex = function () ***REMOVED***
        return this;
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LeafNode.prototype.isIndexed = function () ***REMOVED***
        return true;
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    LeafNode.prototype.equals = function (other) ***REMOVED***
        /**
         * @inheritDoc
         */
        if (other === this) ***REMOVED***
            return true;
        ***REMOVED***
        else if (other.isLeafNode()) ***REMOVED***
            var otherLeaf = other;
            return (this.value_ === otherLeaf.value_ &&
                this.priorityNode_.equals(otherLeaf.priorityNode_));
        ***REMOVED***
        else ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***;
    /**
     * The sort order for comparing leaf nodes of different types. If two leaf nodes have
     * the same type, the comparison falls back to their value
     * @type ***REMOVED***Array.<!string>***REMOVED***
     * @const
     */
    LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];
    return LeafNode;
***REMOVED***());
exports.LeafNode = LeafNode;

//# sourceMappingURL=LeafNode.js.map
