"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var SortedMap_1 = require("../util/SortedMap");
var SortedMap_2 = require("../util/SortedMap");
var LOG_2 = Math.log(2);
/**
 * @constructor
 */
var Base12Num = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***number***REMOVED*** length
     */
    function Base12Num(length) ***REMOVED***
        var logBase2 = function (num) ***REMOVED***
            return parseInt((Math.log(num) / LOG_2), 10);
        ***REMOVED***;
        var bitMask = function (bits) ***REMOVED*** return parseInt(Array(bits + 1).join('1'), 2); ***REMOVED***;
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        var mask = bitMask(this.count);
        this.bits_ = (length + 1) & mask;
    ***REMOVED***
    /**
     * @return ***REMOVED***boolean***REMOVED***
     */
    Base12Num.prototype.nextBitIsOne = function () ***REMOVED***
        //noinspection JSBitwiseOperatorUsage
        var result = !(this.bits_ & (0x1 << this.current_));
        this.current_--;
        return result;
    ***REMOVED***;
    return Base12Num;
***REMOVED***());
/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @template K, V
 * @param ***REMOVED***Array.<!NamedNode>***REMOVED*** childList Unsorted list of children
 * @param ***REMOVED***function(!NamedNode, !NamedNode):number***REMOVED*** cmp The comparison method to be used
 * @param ***REMOVED***(function(NamedNode):K)=***REMOVED*** keyFn An optional function to extract K from a node wrapper, if K's
 *                                                        type is not NamedNode
 * @param ***REMOVED***(function(K, K):number)=***REMOVED*** mapSortFn An optional override for comparator used by the generated sorted map
 * @return ***REMOVED***SortedMap.<K, V>***REMOVED***
 */
exports.buildChildSet = function (childList, cmp, keyFn, mapSortFn) ***REMOVED***
    childList.sort(cmp);
    var buildBalancedTree = function (low, high) ***REMOVED***
        var length = high - low;
        var namedNode;
        var key;
        if (length == 0) ***REMOVED***
            return null;
        ***REMOVED***
        else if (length == 1) ***REMOVED***
            namedNode = childList[low];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, null, null);
        ***REMOVED***
        else ***REMOVED***
            var middle = parseInt((length / 2), 10) + low;
            var left = buildBalancedTree(low, middle);
            var right = buildBalancedTree(middle + 1, high);
            namedNode = childList[middle];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, left, right);
        ***REMOVED***
    ***REMOVED***;
    var buildFrom12Array = function (base12) ***REMOVED***
        var node = null;
        var root = null;
        var index = childList.length;
        var buildPennant = function (chunkSize, color) ***REMOVED***
            var low = index - chunkSize;
            var high = index;
            index -= chunkSize;
            var childTree = buildBalancedTree(low + 1, high);
            var namedNode = childList[low];
            var key = keyFn ? keyFn(namedNode) : namedNode;
            attachPennant(new SortedMap_1.LLRBNode(key, namedNode.node, color, null, childTree));
        ***REMOVED***;
        var attachPennant = function (pennant) ***REMOVED***
            if (node) ***REMOVED***
                node.left = pennant;
                node = pennant;
            ***REMOVED***
            else ***REMOVED***
                root = pennant;
                node = pennant;
            ***REMOVED***
        ***REMOVED***;
        for (var i = 0; i < base12.count; ++i) ***REMOVED***
            var isOne = base12.nextBitIsOne();
            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))
            var chunkSize = Math.pow(2, base12.count - (i + 1));
            if (isOne) ***REMOVED***
                buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);
            ***REMOVED***
            else ***REMOVED***
                // current == 2
                buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);
                buildPennant(chunkSize, SortedMap_1.LLRBNode.RED);
            ***REMOVED***
        ***REMOVED***
        return root;
    ***REMOVED***;
    var base12 = new Base12Num(childList.length);
    var root = buildFrom12Array(base12);
    return new SortedMap_2.SortedMap(mapSortFn || cmp, root);
***REMOVED***;

//# sourceMappingURL=childSet.js.map
