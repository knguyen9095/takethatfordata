"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("@firebase/util");
var util_2 = require("../util/util");
var SortedMap_1 = require("../util/SortedMap");
var Node_1 = require("./Node");
var snap_1 = require("./snap");
var PriorityIndex_1 = require("./indexes/PriorityIndex");
var KeyIndex_1 = require("./indexes/KeyIndex");
var IndexMap_1 = require("./IndexMap");
var LeafNode_1 = require("./LeafNode");
var comparators_1 = require("./comparators");
// TODO: For memory savings, don't store priorityNode_ if it's empty.
var EMPTY_NODE;
/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 *
 * @constructor
 * @implements ***REMOVED***Node***REMOVED***
 */
var ChildrenNode = /** @class */ (function () ***REMOVED***
    /**
     *
     * @param ***REMOVED***!SortedMap.<string, !Node>***REMOVED*** children_ List of children
     * of this node..
     * @param ***REMOVED***?Node***REMOVED*** priorityNode_ The priority of this node (as a snapshot node).
     * @param ***REMOVED***!IndexMap***REMOVED*** indexMap_
     */
    function ChildrenNode(children_, priorityNode_, indexMap_) ***REMOVED***
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        /**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */
        if (this.priorityNode_) ***REMOVED***
            snap_1.validatePriorityNode(this.priorityNode_);
        ***REMOVED***
        if (this.children_.isEmpty()) ***REMOVED***
            util_1.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');
        ***REMOVED***
    ***REMOVED***
    Object.defineProperty(ChildrenNode, "EMPTY_NODE", ***REMOVED***
        get: function () ***REMOVED***
            return (EMPTY_NODE ||
                (EMPTY_NODE = new ChildrenNode(new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), null, IndexMap_1.IndexMap.Default)));
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /** @inheritDoc */
    ChildrenNode.prototype.isLeafNode = function () ***REMOVED***
        return false;
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.getPriority = function () ***REMOVED***
        return this.priorityNode_ || EMPTY_NODE;
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.updatePriority = function (newPriorityNode) ***REMOVED***
        if (this.children_.isEmpty()) ***REMOVED***
            // Don't allow priorities on empty nodes
            return this;
        ***REMOVED***
        else ***REMOVED***
            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.getImmediateChild = function (childName) ***REMOVED***
        // Hack to treat priority as a regular child
        if (childName === '.priority') ***REMOVED***
            return this.getPriority();
        ***REMOVED***
        else ***REMOVED***
            var child = this.children_.get(childName);
            return child === null ? EMPTY_NODE : child;
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.getChild = function (path) ***REMOVED***
        var front = path.getFront();
        if (front === null)
            return this;
        return this.getImmediateChild(front).getChild(path.popFront());
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.hasChild = function (childName) ***REMOVED***
        return this.children_.get(childName) !== null;
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) ***REMOVED***
        util_1.assert(newChildNode, 'We should always be passing snapshot nodes');
        if (childName === '.priority') ***REMOVED***
            return this.updatePriority(newChildNode);
        ***REMOVED***
        else ***REMOVED***
            var namedNode = new Node_1.NamedNode(childName, newChildNode);
            var newChildren = void 0, newIndexMap = void 0, newPriority = void 0;
            if (newChildNode.isEmpty()) ***REMOVED***
                newChildren = this.children_.remove(childName);
                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
            ***REMOVED***
            else ***REMOVED***
                newChildren = this.children_.insert(childName, newChildNode);
                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
            ***REMOVED***
            newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
            return new ChildrenNode(newChildren, newPriority, newIndexMap);
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.updateChild = function (path, newChildNode) ***REMOVED***
        var front = path.getFront();
        if (front === null) ***REMOVED***
            return newChildNode;
        ***REMOVED***
        else ***REMOVED***
            util_1.assert(path.getFront() !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');
            var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);
            return this.updateImmediateChild(front, newImmediateChild);
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.isEmpty = function () ***REMOVED***
        return this.children_.isEmpty();
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.numChildren = function () ***REMOVED***
        return this.children_.count();
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.val = function (exportFormat) ***REMOVED***
        if (this.isEmpty())
            return null;
        var obj = ***REMOVED******REMOVED***;
        var numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) ***REMOVED***
            obj[key] = childNode.val(exportFormat);
            numKeys++;
            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) ***REMOVED***
                maxKey = Math.max(maxKey, Number(key));
            ***REMOVED***
            else ***REMOVED***
                allIntegerKeys = false;
            ***REMOVED***
        ***REMOVED***);
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) ***REMOVED***
            // convert to array.
            var array = [];
            for (var key in obj)
                array[key] = obj[key];
            return array;
        ***REMOVED***
        else ***REMOVED***
            if (exportFormat && !this.getPriority().isEmpty()) ***REMOVED***
                obj['.priority'] = this.getPriority().val();
            ***REMOVED***
            return obj;
        ***REMOVED***
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.hash = function () ***REMOVED***
        if (this.lazyHash_ === null) ***REMOVED***
            var toHash_1 = '';
            if (!this.getPriority().isEmpty())
                toHash_1 +=
                    'priority:' +
                        snap_1.priorityHashText(this.getPriority().val()) +
                        ':';
            this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) ***REMOVED***
                var childHash = childNode.hash();
                if (childHash !== '')
                    toHash_1 += ':' + key + ':' + childHash;
            ***REMOVED***);
            this.lazyHash_ = toHash_1 === '' ? '' : util_2.sha1(toHash_1);
        ***REMOVED***
        return this.lazyHash_;
    ***REMOVED***;
    /** @inheritDoc */
    ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) ***REMOVED***
        var idx = this.resolveIndex_(index);
        if (idx) ***REMOVED***
            var predecessor = idx.getPredecessorKey(new Node_1.NamedNode(childName, childNode));
            return predecessor ? predecessor.name : null;
        ***REMOVED***
        else ***REMOVED***
            return this.children_.getPredecessorKey(childName);
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***?string***REMOVED***
     */
    ChildrenNode.prototype.getFirstChildName = function (indexDefinition) ***REMOVED***
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) ***REMOVED***
            var minKey = idx.minKey();
            return minKey && minKey.name;
        ***REMOVED***
        else ***REMOVED***
            return this.children_.minKey();
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***?NamedNode***REMOVED***
     */
    ChildrenNode.prototype.getFirstChild = function (indexDefinition) ***REMOVED***
        var minKey = this.getFirstChildName(indexDefinition);
        if (minKey) ***REMOVED***
            return new Node_1.NamedNode(minKey, this.children_.get(minKey));
        ***REMOVED***
        else ***REMOVED***
            return null;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Given an index, return the key name of the largest value we have, according to that index
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***?string***REMOVED***
     */
    ChildrenNode.prototype.getLastChildName = function (indexDefinition) ***REMOVED***
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) ***REMOVED***
            var maxKey = idx.maxKey();
            return maxKey && maxKey.name;
        ***REMOVED***
        else ***REMOVED***
            return this.children_.maxKey();
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***?NamedNode***REMOVED***
     */
    ChildrenNode.prototype.getLastChild = function (indexDefinition) ***REMOVED***
        var maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) ***REMOVED***
            return new Node_1.NamedNode(maxKey, this.children_.get(maxKey));
        ***REMOVED***
        else ***REMOVED***
            return null;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.forEachChild = function (index, action) ***REMOVED***
        var idx = this.resolveIndex_(index);
        if (idx) ***REMOVED***
            return idx.inorderTraversal(function (wrappedNode) ***REMOVED***
                return action(wrappedNode.name, wrappedNode.node);
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            return this.children_.inorderTraversal(action);
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***SortedMapIterator***REMOVED***
     */
    ChildrenNode.prototype.getIterator = function (indexDefinition) ***REMOVED***
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***!NamedNode***REMOVED*** startPost
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***!SortedMapIterator***REMOVED***
     */
    ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) ***REMOVED***
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) ***REMOVED***
            return idx.getIteratorFrom(startPost, function (key) ***REMOVED*** return key; ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            var iterator = this.children_.getIteratorFrom(startPost.name, Node_1.NamedNode.Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, startPost) < 0) ***REMOVED***
                iterator.getNext();
                next = iterator.peek();
            ***REMOVED***
            return iterator;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***!SortedMapIterator***REMOVED***
     */
    ChildrenNode.prototype.getReverseIterator = function (indexDefinition) ***REMOVED***
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
    ***REMOVED***;
    /**
     * @param ***REMOVED***!NamedNode***REMOVED*** endPost
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***!SortedMapIterator***REMOVED***
     */
    ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) ***REMOVED***
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) ***REMOVED***
            return idx.getReverseIteratorFrom(endPost, function (key) ***REMOVED***
                return key;
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            var iterator = this.children_.getReverseIteratorFrom(endPost.name, Node_1.NamedNode.Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, endPost) > 0) ***REMOVED***
                iterator.getNext();
                next = iterator.peek();
            ***REMOVED***
            return iterator;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.compareTo = function (other) ***REMOVED***
        if (this.isEmpty()) ***REMOVED***
            if (other.isEmpty()) ***REMOVED***
                return 0;
            ***REMOVED***
            else ***REMOVED***
                return -1;
            ***REMOVED***
        ***REMOVED***
        else if (other.isLeafNode() || other.isEmpty()) ***REMOVED***
            return 1;
        ***REMOVED***
        else if (other === exports.MAX_NODE) ***REMOVED***
            return -1;
        ***REMOVED***
        else ***REMOVED***
            // Must be another node with children.
            return 0;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.withIndex = function (indexDefinition) ***REMOVED***
        if (indexDefinition === KeyIndex_1.KEY_INDEX ||
            this.indexMap_.hasIndex(indexDefinition)) ***REMOVED***
            return this;
        ***REMOVED***
        else ***REMOVED***
            var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.isIndexed = function (index) ***REMOVED***
        return index === KeyIndex_1.KEY_INDEX || this.indexMap_.hasIndex(index);
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.equals = function (other) ***REMOVED***
        if (other === this) ***REMOVED***
            return true;
        ***REMOVED***
        else if (other.isLeafNode()) ***REMOVED***
            return false;
        ***REMOVED***
        else ***REMOVED***
            var otherChildrenNode = other;
            if (!this.getPriority().equals(otherChildrenNode.getPriority())) ***REMOVED***
                return false;
            ***REMOVED***
            else if (this.children_.count() === otherChildrenNode.children_.count()) ***REMOVED***
                var thisIter = this.getIterator(PriorityIndex_1.PRIORITY_INDEX);
                var otherIter = otherChildrenNode.getIterator(PriorityIndex_1.PRIORITY_INDEX);
                var thisCurrent = thisIter.getNext();
                var otherCurrent = otherIter.getNext();
                while (thisCurrent && otherCurrent) ***REMOVED***
                    if (thisCurrent.name !== otherCurrent.name ||
                        !thisCurrent.node.equals(otherCurrent.node)) ***REMOVED***
                        return false;
                    ***REMOVED***
                    thisCurrent = thisIter.getNext();
                    otherCurrent = otherIter.getNext();
                ***REMOVED***
                return thisCurrent === null && otherCurrent === null;
            ***REMOVED***
            else ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     * @private
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***?SortedMap.<NamedNode, Node>***REMOVED***
     */
    ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) ***REMOVED***
        if (indexDefinition === KeyIndex_1.KEY_INDEX) ***REMOVED***
            return null;
        ***REMOVED***
        else ***REMOVED***
            return this.indexMap_.get(indexDefinition.toString());
        ***REMOVED***
    ***REMOVED***;
    /**
     * @private
     * @type ***REMOVED***RegExp***REMOVED***
     */
    ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
    return ChildrenNode;
***REMOVED***());
exports.ChildrenNode = ChildrenNode;
/**
 * @constructor
 * @extends ***REMOVED***ChildrenNode***REMOVED***
 * @private
 */
var MaxNode = /** @class */ (function (_super) ***REMOVED***
    __extends(MaxNode, _super);
    function MaxNode() ***REMOVED***
        return _super.call(this, new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap_1.IndexMap.Default) || this;
    ***REMOVED***
    MaxNode.prototype.compareTo = function (other) ***REMOVED***
        if (other === this) ***REMOVED***
            return 0;
        ***REMOVED***
        else ***REMOVED***
            return 1;
        ***REMOVED***
    ***REMOVED***;
    MaxNode.prototype.equals = function (other) ***REMOVED***
        // Not that we every compare it, but MAX_NODE is only ever equal to itself
        return other === this;
    ***REMOVED***;
    MaxNode.prototype.getPriority = function () ***REMOVED***
        return this;
    ***REMOVED***;
    MaxNode.prototype.getImmediateChild = function (childName) ***REMOVED***
        return ChildrenNode.EMPTY_NODE;
    ***REMOVED***;
    MaxNode.prototype.isEmpty = function () ***REMOVED***
        return false;
    ***REMOVED***;
    return MaxNode;
***REMOVED***(ChildrenNode));
exports.MaxNode = MaxNode;
/**
 * Marker that will sort higher than any other snapshot.
 * @type ***REMOVED***!MAX_NODE***REMOVED***
 * @const
 */
exports.MAX_NODE = new MaxNode();
Object.defineProperties(Node_1.NamedNode, ***REMOVED***
    MIN: ***REMOVED***
        value: new Node_1.NamedNode(util_2.MIN_NAME, ChildrenNode.EMPTY_NODE)
    ***REMOVED***,
    MAX: ***REMOVED***
        value: new Node_1.NamedNode(util_2.MAX_NAME, exports.MAX_NODE)
    ***REMOVED***
***REMOVED***);
/**
 * Reference Extensions
 */
KeyIndex_1.KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode_1.LeafNode.__childrenNodeConstructor = ChildrenNode;
snap_1.setMaxNode(exports.MAX_NODE);
PriorityIndex_1.setMaxNode(exports.MAX_NODE);

//# sourceMappingURL=ChildrenNode.js.map
