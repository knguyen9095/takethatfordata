"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("@firebase/util");
var childSet_1 = require("./childSet");
var util_2 = require("@firebase/util");
var Node_1 = require("./Node");
var PriorityIndex_1 = require("./indexes/PriorityIndex");
var KeyIndex_1 = require("./indexes/KeyIndex");
var _defaultIndexMap;
var fallbackObject = ***REMOVED******REMOVED***;
/**
 *
 * @param ***REMOVED***Object.<string, FallbackType|SortedMap.<NamedNode, Node>>***REMOVED*** indexes
 * @param ***REMOVED***Object.<string, Index>***REMOVED*** indexSet
 * @constructor
 */
var IndexMap = /** @class */ (function () ***REMOVED***
    function IndexMap(indexes_, indexSet_) ***REMOVED***
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
    ***REMOVED***
    Object.defineProperty(IndexMap, "Default", ***REMOVED***
        /**
         * The default IndexMap for nodes without a priority
         * @type ***REMOVED***!IndexMap***REMOVED***
         * @const
         */
        get: function () ***REMOVED***
            util_1.assert(fallbackObject && PriorityIndex_1.PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');
            _defaultIndexMap =
                _defaultIndexMap ||
                    new IndexMap(***REMOVED*** '.priority': fallbackObject ***REMOVED***, ***REMOVED*** '.priority': PriorityIndex_1.PRIORITY_INDEX ***REMOVED***);
            return _defaultIndexMap;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /**
     *
     * @param ***REMOVED***!string***REMOVED*** indexKey
     * @return ***REMOVED***?SortedMap.<NamedNode, Node>***REMOVED***
     */
    IndexMap.prototype.get = function (indexKey) ***REMOVED***
        var sortedMap = util_2.safeGet(this.indexes_, indexKey);
        if (!sortedMap)
            throw new Error('No index defined for ' + indexKey);
        if (sortedMap === fallbackObject) ***REMOVED***
            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
            // regular child map
            return null;
        ***REMOVED***
        else ***REMOVED***
            return sortedMap;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @return ***REMOVED***boolean***REMOVED***
     */
    IndexMap.prototype.hasIndex = function (indexDefinition) ***REMOVED***
        return util_2.contains(this.indexSet_, indexDefinition.toString());
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Index***REMOVED*** indexDefinition
     * @param ***REMOVED***!SortedMap.<string, !Node>***REMOVED*** existingChildren
     * @return ***REMOVED***!IndexMap***REMOVED***
     */
    IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) ***REMOVED***
        util_1.assert(indexDefinition !== KeyIndex_1.KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        var childList = [];
        var sawIndexedValue = false;
        var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);
        var next = iter.getNext();
        while (next) ***REMOVED***
            sawIndexedValue =
                sawIndexedValue || indexDefinition.isDefinedOn(next.node);
            childList.push(next);
            next = iter.getNext();
        ***REMOVED***
        var newIndex;
        if (sawIndexedValue) ***REMOVED***
            newIndex = childSet_1.buildChildSet(childList, indexDefinition.getCompare());
        ***REMOVED***
        else ***REMOVED***
            newIndex = fallbackObject;
        ***REMOVED***
        var indexName = indexDefinition.toString();
        var newIndexSet = util_2.clone(this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        var newIndexes = util_2.clone(this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap(newIndexes, newIndexSet);
    ***REMOVED***;
    /**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     * @param ***REMOVED***!NamedNode***REMOVED*** namedNode
     * @param ***REMOVED***!SortedMap.<string, !Node>***REMOVED*** existingChildren
     * @return ***REMOVED***!IndexMap***REMOVED***
     */
    IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) ***REMOVED***
        var _this = this;
        var newIndexes = util_2.map(this.indexes_, function (indexedChildren, indexName) ***REMOVED***
            var index = util_2.safeGet(_this.indexSet_, indexName);
            util_1.assert(index, 'Missing index implementation for ' + indexName);
            if (indexedChildren === fallbackObject) ***REMOVED***
                // Check to see if we need to index everything
                if (index.isDefinedOn(namedNode.node)) ***REMOVED***
                    // We need to build this index
                    var childList = [];
                    var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);
                    var next = iter.getNext();
                    while (next) ***REMOVED***
                        if (next.name != namedNode.name) ***REMOVED***
                            childList.push(next);
                        ***REMOVED***
                        next = iter.getNext();
                    ***REMOVED***
                    childList.push(namedNode);
                    return childSet_1.buildChildSet(childList, index.getCompare());
                ***REMOVED***
                else ***REMOVED***
                    // No change, this remains a fallback
                    return fallbackObject;
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                var existingSnap = existingChildren.get(namedNode.name);
                var newChildren = indexedChildren;
                if (existingSnap) ***REMOVED***
                    newChildren = newChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));
                ***REMOVED***
                return newChildren.insert(namedNode, namedNode.node);
            ***REMOVED***
        ***REMOVED***);
        return new IndexMap(newIndexes, this.indexSet_);
    ***REMOVED***;
    /**
     * Create a new IndexMap instance with the given value removed
     * @param ***REMOVED***!NamedNode***REMOVED*** namedNode
     * @param ***REMOVED***!SortedMap.<string, !Node>***REMOVED*** existingChildren
     * @return ***REMOVED***!IndexMap***REMOVED***
     */
    IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) ***REMOVED***
        var newIndexes = util_2.map(this.indexes_, function (indexedChildren) ***REMOVED***
            if (indexedChildren === fallbackObject) ***REMOVED***
                // This is the fallback. Just return it, nothing to do in this case
                return indexedChildren;
            ***REMOVED***
            else ***REMOVED***
                var existingSnap = existingChildren.get(namedNode.name);
                if (existingSnap) ***REMOVED***
                    return indexedChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));
                ***REMOVED***
                else ***REMOVED***
                    // No record of this child
                    return indexedChildren;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
        return new IndexMap(newIndexes, this.indexSet_);
    ***REMOVED***;
    return IndexMap;
***REMOVED***());
exports.IndexMap = IndexMap;

//# sourceMappingURL=IndexMap.js.map
