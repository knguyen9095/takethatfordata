"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
var Path_1 = require("./util/Path");
var CompoundWrite_1 = require("./CompoundWrite");
var PriorityIndex_1 = require("./snap/indexes/PriorityIndex");
var ChildrenNode_1 = require("./snap/ChildrenNode");
/**
 * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them
 * with underlying server data (to create "event cache" data).  Pending writes are added with addOverwrite()
 * and addMerge(), and removed with removeWrite().
 *
 * @constructor
 */
var WriteTree = /** @class */ (function () ***REMOVED***
    function WriteTree() ***REMOVED***
        /**
         * A tree tracking the result of applying all visible writes.  This does not include transactions with
         * applyLocally=false or writes that are completely shadowed by other writes.
         *
         * @type ***REMOVED***!CompoundWrite***REMOVED***
         * @private
         */
        this.visibleWrites_ = CompoundWrite_1.CompoundWrite.Empty;
        /**
         * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary
         * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also
         * used by transactions).
         *
         * @type ***REMOVED***!Array.<!WriteRecord>***REMOVED***
         * @private
         */
        this.allWrites_ = [];
        this.lastWriteId_ = -1;
    ***REMOVED***
    /**
     * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***!WriteTreeRef***REMOVED***
     */
    WriteTree.prototype.childWrites = function (path) ***REMOVED***
        return new WriteTreeRef(path, this);
    ***REMOVED***;
    /**
     * Record a new overwrite from user code.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Node***REMOVED*** snap
     * @param ***REMOVED***!number***REMOVED*** writeId
     * @param ***REMOVED***boolean=***REMOVED*** visible This is set to false by some transactions. It should be excluded from event caches
     */
    WriteTree.prototype.addOverwrite = function (path, snap, writeId, visible) ***REMOVED***
        util_2.assert(writeId > this.lastWriteId_, 'Stacking an older write on top of newer ones');
        if (visible === undefined) ***REMOVED***
            visible = true;
        ***REMOVED***
        this.allWrites_.push(***REMOVED***
            path: path,
            snap: snap,
            writeId: writeId,
            visible: visible
        ***REMOVED***);
        if (visible) ***REMOVED***
            this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);
        ***REMOVED***
        this.lastWriteId_ = writeId;
    ***REMOVED***;
    /**
     * Record a new merge from user code.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!Object.<string, !Node>***REMOVED*** changedChildren
     * @param ***REMOVED***!number***REMOVED*** writeId
     */
    WriteTree.prototype.addMerge = function (path, changedChildren, writeId) ***REMOVED***
        util_2.assert(writeId > this.lastWriteId_, 'Stacking an older merge on top of newer ones');
        this.allWrites_.push(***REMOVED***
            path: path,
            children: changedChildren,
            writeId: writeId,
            visible: true
        ***REMOVED***);
        this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);
        this.lastWriteId_ = writeId;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!number***REMOVED*** writeId
     * @return ***REMOVED***?WriteRecord***REMOVED***
     */
    WriteTree.prototype.getWrite = function (writeId) ***REMOVED***
        for (var i = 0; i < this.allWrites_.length; i++) ***REMOVED***
            var record = this.allWrites_[i];
            if (record.writeId === writeId) ***REMOVED***
                return record;
            ***REMOVED***
        ***REMOVED***
        return null;
    ***REMOVED***;
    /**
     * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
     * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
     *
     * @param ***REMOVED***!number***REMOVED*** writeId
     * @return ***REMOVED***boolean***REMOVED*** true if the write may have been visible (meaning we'll need to reevaluate / raise
     * events as a result).
     */
    WriteTree.prototype.removeWrite = function (writeId) ***REMOVED***
        // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
        // out of order.
        //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
        //assert(validClear, "Either we don't have this write, or it's the first one in the queue");
        var _this = this;
        var idx = this.allWrites_.findIndex(function (s) ***REMOVED***
            return s.writeId === writeId;
        ***REMOVED***);
        util_2.assert(idx >= 0, 'removeWrite called with nonexistent writeId.');
        var writeToRemove = this.allWrites_[idx];
        this.allWrites_.splice(idx, 1);
        var removedWriteWasVisible = writeToRemove.visible;
        var removedWriteOverlapsWithOtherWrites = false;
        var i = this.allWrites_.length - 1;
        while (removedWriteWasVisible && i >= 0) ***REMOVED***
            var currentWrite = this.allWrites_[i];
            if (currentWrite.visible) ***REMOVED***
                if (i >= idx &&
                    this.recordContainsPath_(currentWrite, writeToRemove.path)) ***REMOVED***
                    // The removed write was completely shadowed by a subsequent write.
                    removedWriteWasVisible = false;
                ***REMOVED***
                else if (writeToRemove.path.contains(currentWrite.path)) ***REMOVED***
                    // Either we're covering some writes or they're covering part of us (depending on which came first).
                    removedWriteOverlapsWithOtherWrites = true;
                ***REMOVED***
            ***REMOVED***
            i--;
        ***REMOVED***
        if (!removedWriteWasVisible) ***REMOVED***
            return false;
        ***REMOVED***
        else if (removedWriteOverlapsWithOtherWrites) ***REMOVED***
            // There's some shadowing going on. Just rebuild the visible writes from scratch.
            this.resetTree_();
            return true;
        ***REMOVED***
        else ***REMOVED***
            // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
            if (writeToRemove.snap) ***REMOVED***
                this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path);
            ***REMOVED***
            else ***REMOVED***
                var children = writeToRemove.children;
                util_1.forEach(children, function (childName) ***REMOVED***
                    _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));
                ***REMOVED***);
            ***REMOVED***
            return true;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Return a complete snapshot for the given path if there's visible write data at that path, else null.
     * No server data is considered.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***?Node***REMOVED***
     */
    WriteTree.prototype.getCompleteWriteData = function (path) ***REMOVED***
        return this.visibleWrites_.getCompleteNode(path);
    ***REMOVED***;
    /**
     * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
     * writes), attempt to calculate a complete snapshot for the given path
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***?Node***REMOVED*** completeServerCache
     * @param ***REMOVED***Array.<number>=***REMOVED*** writeIdsToExclude An optional set to be excluded
     * @param ***REMOVED***boolean=***REMOVED*** includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return ***REMOVED***?Node***REMOVED***
     */
    WriteTree.prototype.calcCompleteEventCache = function (treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) ***REMOVED***
        if (!writeIdsToExclude && !includeHiddenWrites) ***REMOVED***
            var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);
            if (shadowingNode != null) ***REMOVED***
                return shadowingNode;
            ***REMOVED***
            else ***REMOVED***
                var subMerge = this.visibleWrites_.childCompoundWrite(treePath);
                if (subMerge.isEmpty()) ***REMOVED***
                    return completeServerCache;
                ***REMOVED***
                else if (completeServerCache == null &&
                    !subMerge.hasCompleteWrite(Path_1.Path.Empty)) ***REMOVED***
                    // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
                    return null;
                ***REMOVED***
                else ***REMOVED***
                    var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    return subMerge.apply(layeredCache);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            var merge = this.visibleWrites_.childCompoundWrite(treePath);
            if (!includeHiddenWrites && merge.isEmpty()) ***REMOVED***
                return completeServerCache;
            ***REMOVED***
            else ***REMOVED***
                // If the server cache is null, and we don't have a complete cache, we need to return null
                if (!includeHiddenWrites &&
                    completeServerCache == null &&
                    !merge.hasCompleteWrite(Path_1.Path.Empty)) ***REMOVED***
                    return null;
                ***REMOVED***
                else ***REMOVED***
                    var filter = function (write) ***REMOVED***
                        return ((write.visible || includeHiddenWrites) &&
                            (!writeIdsToExclude ||
                                !~writeIdsToExclude.indexOf(write.writeId)) &&
                            (write.path.contains(treePath) || treePath.contains(write.path)));
                    ***REMOVED***;
                    var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);
                    var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    return mergeAtPath.apply(layeredCache);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
     * Used when creating new views, to pre-fill their complete event children snapshot.
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***?ChildrenNode***REMOVED*** completeServerChildren
     * @return ***REMOVED***!ChildrenNode***REMOVED***
     */
    WriteTree.prototype.calcCompleteEventChildren = function (treePath, completeServerChildren) ***REMOVED***
        var completeChildren = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);
        if (topLevelSet) ***REMOVED***
            if (!topLevelSet.isLeafNode()) ***REMOVED***
                // we're shadowing everything. Return the children.
                topLevelSet.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childSnap) ***REMOVED***
                    completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
                ***REMOVED***);
            ***REMOVED***
            return completeChildren;
        ***REMOVED***
        else if (completeServerChildren) ***REMOVED***
            // Layer any children we have on top of this
            // We know we don't have a top-level set, so just enumerate existing children
            var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);
            completeServerChildren.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) ***REMOVED***
                var node = merge_1
                    .childCompoundWrite(new Path_1.Path(childName))
                    .apply(childNode);
                completeChildren = completeChildren.updateImmediateChild(childName, node);
            ***REMOVED***);
            // Add any complete children we have from the set
            merge_1.getCompleteChildren().forEach(function (namedNode) ***REMOVED***
                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
            ***REMOVED***);
            return completeChildren;
        ***REMOVED***
        else ***REMOVED***
            // We don't have anything to layer on top of. Layer on any children we have
            // Note that we can return an empty snap if we have a defined delete
            var merge = this.visibleWrites_.childCompoundWrite(treePath);
            merge.getCompleteChildren().forEach(function (namedNode) ***REMOVED***
                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
            ***REMOVED***);
            return completeChildren;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Given that the underlying server data has updated, determine what, if anything, needs to be
     * applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events
     *
     * Either existingEventSnap or existingServerSnap must exist
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***!Path***REMOVED*** childPath
     * @param ***REMOVED***?Node***REMOVED*** existingEventSnap
     * @param ***REMOVED***?Node***REMOVED*** existingServerSnap
     * @return ***REMOVED***?Node***REMOVED***
     */
    WriteTree.prototype.calcEventCacheAfterServerOverwrite = function (treePath, childPath, existingEventSnap, existingServerSnap) ***REMOVED***
        util_2.assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');
        var path = treePath.child(childPath);
        if (this.visibleWrites_.hasCompleteWrite(path)) ***REMOVED***
            // At this point we can probably guarantee that we're in case 2, meaning no events
            // May need to check visibility while doing the findRootMostValueAndPath call
            return null;
        ***REMOVED***
        else ***REMOVED***
            // No complete shadowing. We're either partially shadowing or not shadowing at all.
            var childMerge = this.visibleWrites_.childCompoundWrite(path);
            if (childMerge.isEmpty()) ***REMOVED***
                // We're not shadowing at all. Case 1
                return existingServerSnap.getChild(childPath);
            ***REMOVED***
            else ***REMOVED***
                // This could be more efficient if the serverNode + updates doesn't change the eventSnap
                // However this is tricky to find out, since user updates don't necessary change the server
                // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
                // adds nodes, but doesn't change any existing writes. It is therefore not enough to
                // only check if the updates change the serverNode.
                // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
                return childMerge.apply(existingServerSnap.getChild(childPath));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***!string***REMOVED*** childKey
     * @param ***REMOVED***!CacheNode***REMOVED*** existingServerSnap
     * @return ***REMOVED***?Node***REMOVED***
     */
    WriteTree.prototype.calcCompleteChild = function (treePath, childKey, existingServerSnap) ***REMOVED***
        var path = treePath.child(childKey);
        var shadowingNode = this.visibleWrites_.getCompleteNode(path);
        if (shadowingNode != null) ***REMOVED***
            return shadowingNode;
        ***REMOVED***
        else ***REMOVED***
            if (existingServerSnap.isCompleteForChild(childKey)) ***REMOVED***
                var childMerge = this.visibleWrites_.childCompoundWrite(path);
                return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));
            ***REMOVED***
            else ***REMOVED***
                return null;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***?Node***REMOVED***
     */
    WriteTree.prototype.shadowingWrite = function (path) ***REMOVED***
        return this.visibleWrites_.getCompleteNode(path);
    ***REMOVED***;
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window.
     *
     * @param ***REMOVED***!Path***REMOVED*** treePath
     * @param ***REMOVED***?Node***REMOVED*** completeServerData
     * @param ***REMOVED***!NamedNode***REMOVED*** startPost
     * @param ***REMOVED***!number***REMOVED*** count
     * @param ***REMOVED***boolean***REMOVED*** reverse
     * @param ***REMOVED***!Index***REMOVED*** index
     * @return ***REMOVED***!Array.<!NamedNode>***REMOVED***
     */
    WriteTree.prototype.calcIndexedSlice = function (treePath, completeServerData, startPost, count, reverse, index) ***REMOVED***
        var toIterate;
        var merge = this.visibleWrites_.childCompoundWrite(treePath);
        var shadowingNode = merge.getCompleteNode(Path_1.Path.Empty);
        if (shadowingNode != null) ***REMOVED***
            toIterate = shadowingNode;
        ***REMOVED***
        else if (completeServerData != null) ***REMOVED***
            toIterate = merge.apply(completeServerData);
        ***REMOVED***
        else ***REMOVED***
            // no children to iterate on
            return [];
        ***REMOVED***
        toIterate = toIterate.withIndex(index);
        if (!toIterate.isEmpty() && !toIterate.isLeafNode()) ***REMOVED***
            var nodes = [];
            var cmp = index.getCompare();
            var iter = reverse
                ? toIterate.getReverseIteratorFrom(startPost, index)
                : toIterate.getIteratorFrom(startPost, index);
            var next = iter.getNext();
            while (next && nodes.length < count) ***REMOVED***
                if (cmp(next, startPost) !== 0) ***REMOVED***
                    nodes.push(next);
                ***REMOVED***
                next = iter.getNext();
            ***REMOVED***
            return nodes;
        ***REMOVED***
        else ***REMOVED***
            return [];
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!WriteRecord***REMOVED*** writeRecord
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***boolean***REMOVED***
     * @private
     */
    WriteTree.prototype.recordContainsPath_ = function (writeRecord, path) ***REMOVED***
        if (writeRecord.snap) ***REMOVED***
            return writeRecord.path.contains(path);
        ***REMOVED***
        else ***REMOVED***
            // findKey can return undefined, so use !! to coerce to boolean
            return !!util_1.findKey(writeRecord.children, function (childSnap, childName) ***REMOVED***
                return writeRecord.path.child(childName).contains(path);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
     * @private
     */
    WriteTree.prototype.resetTree_ = function () ***REMOVED***
        this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, Path_1.Path.Empty);
        if (this.allWrites_.length > 0) ***REMOVED***
            this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;
        ***REMOVED***
        else ***REMOVED***
            this.lastWriteId_ = -1;
        ***REMOVED***
    ***REMOVED***;
    /**
     * The default filter used when constructing the tree. Keep everything that's visible.
     *
     * @param ***REMOVED***!WriteRecord***REMOVED*** write
     * @return ***REMOVED***boolean***REMOVED***
     * @private
     */
    WriteTree.DefaultFilter_ = function (write) ***REMOVED***
        return write.visible;
    ***REMOVED***;
    /**
     * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
     * event data at that path.
     *
     * @param ***REMOVED***!Array.<!WriteRecord>***REMOVED*** writes
     * @param ***REMOVED***!function(!WriteRecord):boolean***REMOVED*** filter
     * @param ***REMOVED***!Path***REMOVED*** treeRoot
     * @return ***REMOVED***!CompoundWrite***REMOVED***
     * @private
     */
    WriteTree.layerTree_ = function (writes, filter, treeRoot) ***REMOVED***
        var compoundWrite = CompoundWrite_1.CompoundWrite.Empty;
        for (var i = 0; i < writes.length; ++i) ***REMOVED***
            var write = writes[i];
            // Theory, a later set will either:
            // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
            // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
            if (filter(write)) ***REMOVED***
                var writePath = write.path;
                var relativePath = void 0;
                if (write.snap) ***REMOVED***
                    if (treeRoot.contains(writePath)) ***REMOVED***
                        relativePath = Path_1.Path.relativePath(treeRoot, writePath);
                        compoundWrite = compoundWrite.addWrite(relativePath, write.snap);
                    ***REMOVED***
                    else if (writePath.contains(treeRoot)) ***REMOVED***
                        relativePath = Path_1.Path.relativePath(writePath, treeRoot);
                        compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, write.snap.getChild(relativePath));
                    ***REMOVED***
                    else ***REMOVED***
                        // There is no overlap between root path and write path, ignore write
                    ***REMOVED***
                ***REMOVED***
                else if (write.children) ***REMOVED***
                    if (treeRoot.contains(writePath)) ***REMOVED***
                        relativePath = Path_1.Path.relativePath(treeRoot, writePath);
                        compoundWrite = compoundWrite.addWrites(relativePath, write.children);
                    ***REMOVED***
                    else if (writePath.contains(treeRoot)) ***REMOVED***
                        relativePath = Path_1.Path.relativePath(writePath, treeRoot);
                        if (relativePath.isEmpty()) ***REMOVED***
                            compoundWrite = compoundWrite.addWrites(Path_1.Path.Empty, write.children);
                        ***REMOVED***
                        else ***REMOVED***
                            var child = util_1.safeGet(write.children, relativePath.getFront());
                            if (child) ***REMOVED***
                                // There exists a child in this node that matches the root path
                                var deepNode = child.getChild(relativePath.popFront());
                                compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, deepNode);
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                    else ***REMOVED***
                        // There is no overlap between root path and write path, ignore write
                    ***REMOVED***
                ***REMOVED***
                else ***REMOVED***
                    throw util_2.assertionError('WriteRecord should have .snap or .children');
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        return compoundWrite;
    ***REMOVED***;
    return WriteTree;
***REMOVED***());
exports.WriteTree = WriteTree;
/**
 * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods
 * just proxy to the underlying WriteTree.
 *
 * @constructor
 */
var WriteTreeRef = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***!WriteTree***REMOVED*** writeTree
     */
    function WriteTreeRef(path, writeTree) ***REMOVED***
        this.treePath_ = path;
        this.writeTree_ = writeTree;
    ***REMOVED***
    /**
     * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
     * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
     * can lead to a more expensive calculation.
     *
     * @param ***REMOVED***?Node***REMOVED*** completeServerCache
     * @param ***REMOVED***Array.<number>=***REMOVED*** writeIdsToExclude Optional writes to exclude.
     * @param ***REMOVED***boolean=***REMOVED*** includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return ***REMOVED***?Node***REMOVED***
     */
    WriteTreeRef.prototype.calcCompleteEventCache = function (completeServerCache, writeIdsToExclude, includeHiddenWrites) ***REMOVED***
        return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);
    ***REMOVED***;
    /**
     * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
     * mix of the given server data and write data.
     *
     * @param ***REMOVED***?ChildrenNode***REMOVED*** completeServerChildren
     * @return ***REMOVED***!ChildrenNode***REMOVED***
     */
    WriteTreeRef.prototype.calcCompleteEventChildren = function (completeServerChildren) ***REMOVED***
        return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);
    ***REMOVED***;
    /**
     * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
     * if anything, needs to be applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events should be raised
     *
     * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @param ***REMOVED***?Node***REMOVED*** existingEventSnap
     * @param ***REMOVED***?Node***REMOVED*** existingServerSnap
     * @return ***REMOVED***?Node***REMOVED***
     */
    WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function (path, existingEventSnap, existingServerSnap) ***REMOVED***
        return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);
    ***REMOVED***;
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param ***REMOVED***!Path***REMOVED*** path
     * @return ***REMOVED***?Node***REMOVED***
     */
    WriteTreeRef.prototype.shadowingWrite = function (path) ***REMOVED***
        return this.writeTree_.shadowingWrite(this.treePath_.child(path));
    ***REMOVED***;
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window
     *
     * @param ***REMOVED***?Node***REMOVED*** completeServerData
     * @param ***REMOVED***!NamedNode***REMOVED*** startPost
     * @param ***REMOVED***!number***REMOVED*** count
     * @param ***REMOVED***boolean***REMOVED*** reverse
     * @param ***REMOVED***!Index***REMOVED*** index
     * @return ***REMOVED***!Array.<!NamedNode>***REMOVED***
     */
    WriteTreeRef.prototype.calcIndexedSlice = function (completeServerData, startPost, count, reverse, index) ***REMOVED***
        return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);
    ***REMOVED***;
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param ***REMOVED***!string***REMOVED*** childKey
     * @param ***REMOVED***!CacheNode***REMOVED*** existingServerCache
     * @return ***REMOVED***?Node***REMOVED***
     */
    WriteTreeRef.prototype.calcCompleteChild = function (childKey, existingServerCache) ***REMOVED***
        return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);
    ***REMOVED***;
    /**
     * Return a WriteTreeRef for a child.
     *
     * @param ***REMOVED***string***REMOVED*** childName
     * @return ***REMOVED***!WriteTreeRef***REMOVED***
     */
    WriteTreeRef.prototype.child = function (childName) ***REMOVED***
        return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);
    ***REMOVED***;
    return WriteTreeRef;
***REMOVED***());
exports.WriteTreeRef = WriteTreeRef;

//# sourceMappingURL=WriteTree.js.map
