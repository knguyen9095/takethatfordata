"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var CacheNode_1 = require("./view/CacheNode");
var ChildrenNode_1 = require("./snap/ChildrenNode");
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
var ViewCache_1 = require("./view/ViewCache");
var View_1 = require("./view/View");
var __referenceConstructor;
/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */
var SyncPoint = /** @class */ (function () ***REMOVED***
    function SyncPoint() ***REMOVED***
        /**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         *
         * @type ***REMOVED***!Object.<!string, !View>***REMOVED***
         * @private
         */
        this.views_ = ***REMOVED******REMOVED***;
    ***REMOVED***
    Object.defineProperty(SyncPoint, "__referenceConstructor", ***REMOVED***
        get: function () ***REMOVED***
            util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');
            return __referenceConstructor;
        ***REMOVED***,
        set: function (val) ***REMOVED***
            util_1.assert(!__referenceConstructor, '__referenceConstructor has already been defined');
            __referenceConstructor = val;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /**
     * @return ***REMOVED***boolean***REMOVED***
     */
    SyncPoint.prototype.isEmpty = function () ***REMOVED***
        return util_2.isEmpty(this.views_);
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***!Operation***REMOVED*** operation
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** optCompleteServerCache
     * @return ***REMOVED***!Array.<!Event>***REMOVED***
     */
    SyncPoint.prototype.applyOperation = function (operation, writesCache, optCompleteServerCache) ***REMOVED***
        var queryId = operation.source.queryId;
        if (queryId !== null) ***REMOVED***
            var view = util_2.safeGet(this.views_, queryId);
            util_1.assert(view != null, 'SyncTree gave us an op for an invalid query.');
            return view.applyOperation(operation, writesCache, optCompleteServerCache);
        ***REMOVED***
        else ***REMOVED***
            var events_1 = [];
            util_2.forEach(this.views_, function (key, view) ***REMOVED***
                events_1 = events_1.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));
            ***REMOVED***);
            return events_1;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Add an event callback for the specified query.
     *
     * @param ***REMOVED***!Query***REMOVED*** query
     * @param ***REMOVED***!EventRegistration***REMOVED*** eventRegistration
     * @param ***REMOVED***!WriteTreeRef***REMOVED*** writesCache
     * @param ***REMOVED***?Node***REMOVED*** serverCache Complete server cache, if we have it.
     * @param ***REMOVED***boolean***REMOVED*** serverCacheComplete
     * @return ***REMOVED***!Array.<!Event>***REMOVED*** Events to raise.
     */
    SyncPoint.prototype.addEventRegistration = function (query, eventRegistration, writesCache, serverCache, serverCacheComplete) ***REMOVED***
        var queryId = query.queryIdentifier();
        var view = util_2.safeGet(this.views_, queryId);
        if (!view) ***REMOVED***
            // TODO: make writesCache take flag for complete server node
            var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);
            var eventCacheComplete = false;
            if (eventCache) ***REMOVED***
                eventCacheComplete = true;
            ***REMOVED***
            else if (serverCache instanceof ChildrenNode_1.ChildrenNode) ***REMOVED***
                eventCache = writesCache.calcCompleteEventChildren(serverCache);
                eventCacheComplete = false;
            ***REMOVED***
            else ***REMOVED***
                eventCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                eventCacheComplete = false;
            ***REMOVED***
            var viewCache = new ViewCache_1.ViewCache(new CacheNode_1.CacheNode(
            /** @type ***REMOVED***!Node***REMOVED*** */ (eventCache), eventCacheComplete, false), new CacheNode_1.CacheNode(
            /** @type ***REMOVED***!Node***REMOVED*** */ (serverCache), serverCacheComplete, false));
            view = new View_1.View(query, viewCache);
            this.views_[queryId] = view;
        ***REMOVED***
        // This is guaranteed to exist now, we just created anything that was missing
        view.addEventRegistration(eventRegistration);
        return view.getInitialEvents(eventRegistration);
    ***REMOVED***;
    /**
     * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
     *
     * If query is the default query, we'll check all views for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
     *
     * @param ***REMOVED***!Query***REMOVED*** query
     * @param ***REMOVED***?EventRegistration***REMOVED*** eventRegistration If null, remove all callbacks.
     * @param ***REMOVED***Error=***REMOVED*** cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return ***REMOVED******REMOVED***removed:!Array.<!Query>, events:!Array.<!Event>***REMOVED******REMOVED*** removed queries and any cancel events
     */
    SyncPoint.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) ***REMOVED***
        var queryId = query.queryIdentifier();
        var removed = [];
        var cancelEvents = [];
        var hadCompleteView = this.hasCompleteView();
        if (queryId === 'default') ***REMOVED***
            // When you do ref.off(...), we search all views for the registration to remove.
            var self_1 = this;
            util_2.forEach(this.views_, function (viewQueryId, view) ***REMOVED***
                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
                if (view.isEmpty()) ***REMOVED***
                    delete self_1.views_[viewQueryId];
                    // We'll deal with complete views later.
                    if (!view
                        .getQuery()
                        .getQueryParams()
                        .loadsAllData()) ***REMOVED***
                        removed.push(view.getQuery());
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            // remove the callback from the specific view.
            var view = util_2.safeGet(this.views_, queryId);
            if (view) ***REMOVED***
                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
                if (view.isEmpty()) ***REMOVED***
                    delete this.views_[queryId];
                    // We'll deal with complete views later.
                    if (!view
                        .getQuery()
                        .getQueryParams()
                        .loadsAllData()) ***REMOVED***
                        removed.push(view.getQuery());
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        if (hadCompleteView && !this.hasCompleteView()) ***REMOVED***
            // We removed our last complete view.
            removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));
        ***REMOVED***
        return ***REMOVED*** removed: removed, events: cancelEvents ***REMOVED***;
    ***REMOVED***;
    /**
     * @return ***REMOVED***!Array.<!View>***REMOVED***
     */
    SyncPoint.prototype.getQueryViews = function () ***REMOVED***
        var _this = this;
        var values = Object.keys(this.views_).map(function (key) ***REMOVED*** return _this.views_[key]; ***REMOVED***);
        return values.filter(function (view) ***REMOVED***
            return !view
                .getQuery()
                .getQueryParams()
                .loadsAllData();
        ***REMOVED***);
    ***REMOVED***;
    /**
     *
     * @param ***REMOVED***!Path***REMOVED*** path The path to the desired complete snapshot
     * @return ***REMOVED***?Node***REMOVED*** A complete cache, if it exists
     */
    SyncPoint.prototype.getCompleteServerCache = function (path) ***REMOVED***
        var serverCache = null;
        util_2.forEach(this.views_, function (key, view) ***REMOVED***
            serverCache = serverCache || view.getCompleteServerCache(path);
        ***REMOVED***);
        return serverCache;
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Query***REMOVED*** query
     * @return ***REMOVED***?View***REMOVED***
     */
    SyncPoint.prototype.viewForQuery = function (query) ***REMOVED***
        var params = query.getQueryParams();
        if (params.loadsAllData()) ***REMOVED***
            return this.getCompleteView();
        ***REMOVED***
        else ***REMOVED***
            var queryId = query.queryIdentifier();
            return util_2.safeGet(this.views_, queryId);
        ***REMOVED***
    ***REMOVED***;
    /**
     * @param ***REMOVED***!Query***REMOVED*** query
     * @return ***REMOVED***boolean***REMOVED***
     */
    SyncPoint.prototype.viewExistsForQuery = function (query) ***REMOVED***
        return this.viewForQuery(query) != null;
    ***REMOVED***;
    /**
     * @return ***REMOVED***boolean***REMOVED***
     */
    SyncPoint.prototype.hasCompleteView = function () ***REMOVED***
        return this.getCompleteView() != null;
    ***REMOVED***;
    /**
     * @return ***REMOVED***?View***REMOVED***
     */
    SyncPoint.prototype.getCompleteView = function () ***REMOVED***
        var completeView = util_2.findValue(this.views_, function (view) ***REMOVED***
            return view
                .getQuery()
                .getQueryParams()
                .loadsAllData();
        ***REMOVED***);
        return completeView || null;
    ***REMOVED***;
    return SyncPoint;
***REMOVED***());
exports.SyncPoint = SyncPoint;

//# sourceMappingURL=SyncPoint.js.map
