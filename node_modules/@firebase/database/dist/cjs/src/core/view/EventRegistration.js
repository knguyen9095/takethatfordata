"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var DataSnapshot_1 = require("../../api/DataSnapshot");
var Event_1 = require("./Event");
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
/**
 * Represents registration for 'value' events.
 */
var ValueEventRegistration = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***?function(!DataSnapshot)***REMOVED*** callback_
     * @param ***REMOVED***?function(Error)***REMOVED*** cancelCallback_
     * @param ***REMOVED***?Object***REMOVED*** context_
     */
    function ValueEventRegistration(callback_, cancelCallback_, context_) ***REMOVED***
        this.callback_ = callback_;
        this.cancelCallback_ = cancelCallback_;
        this.context_ = context_;
    ***REMOVED***
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.respondsTo = function (eventType) ***REMOVED***
        return eventType === 'value';
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.createEvent = function (change, query) ***REMOVED***
        var index = query.getQueryParams().getIndex();
        return new Event_1.DataEvent('value', this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, query.getRef(), index));
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.getEventRunner = function (eventData) ***REMOVED***
        var ctx = this.context_;
        if (eventData.getEventType() === 'cancel') ***REMOVED***
            util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');
            var cancelCB_1 = this.cancelCallback_;
            return function () ***REMOVED***
                // We know that error exists, we checked above that this is a cancel event
                cancelCB_1.call(ctx, eventData.error);
            ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            var cb_1 = this.callback_;
            return function () ***REMOVED***
                cb_1.call(ctx, eventData.snapshot);
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.createCancelEvent = function (error, path) ***REMOVED***
        if (this.cancelCallback_) ***REMOVED***
            return new Event_1.CancelEvent(this, error, path);
        ***REMOVED***
        else ***REMOVED***
            return null;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.matches = function (other) ***REMOVED***
        if (!(other instanceof ValueEventRegistration)) ***REMOVED***
            return false;
        ***REMOVED***
        else if (!other.callback_ || !this.callback_) ***REMOVED***
            // If no callback specified, we consider it to match any callback.
            return true;
        ***REMOVED***
        else ***REMOVED***
            return (other.callback_ === this.callback_ && other.context_ === this.context_);
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.hasAnyCallback = function () ***REMOVED***
        return this.callback_ !== null;
    ***REMOVED***;
    return ValueEventRegistration;
***REMOVED***());
exports.ValueEventRegistration = ValueEventRegistration;
/**
 * Represents the registration of 1 or more child_xxx events.
 *
 * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you
 * register a group of callbacks together in the future.
 *
 * @constructor
 * @implements ***REMOVED***EventRegistration***REMOVED***
 */
var ChildEventRegistration = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***?Object.<string, function(!DataSnapshot, ?string=)>***REMOVED*** callbacks_
     * @param ***REMOVED***?function(Error)***REMOVED*** cancelCallback_
     * @param ***REMOVED***Object=***REMOVED*** context_
     */
    function ChildEventRegistration(callbacks_, cancelCallback_, context_) ***REMOVED***
        this.callbacks_ = callbacks_;
        this.cancelCallback_ = cancelCallback_;
        this.context_ = context_;
    ***REMOVED***
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.respondsTo = function (eventType) ***REMOVED***
        var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;
        eventToCheck =
            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;
        return util_1.contains(this.callbacks_, eventToCheck);
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.createCancelEvent = function (error, path) ***REMOVED***
        if (this.cancelCallback_) ***REMOVED***
            return new Event_1.CancelEvent(this, error, path);
        ***REMOVED***
        else ***REMOVED***
            return null;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.createEvent = function (change, query) ***REMOVED***
        util_2.assert(change.childName != null, 'Child events should have a childName.');
        var ref = query.getRef().child(/** @type ***REMOVED***!string***REMOVED*** */ (change.childName));
        var index = query.getQueryParams().getIndex();
        return new Event_1.DataEvent(change.type, this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, ref, index), change.prevName);
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.getEventRunner = function (eventData) ***REMOVED***
        var ctx = this.context_;
        if (eventData.getEventType() === 'cancel') ***REMOVED***
            util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');
            var cancelCB_2 = this.cancelCallback_;
            return function () ***REMOVED***
                // We know that error exists, we checked above that this is a cancel event
                cancelCB_2.call(ctx, eventData.error);
            ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            var cb_2 = this.callbacks_[eventData.eventType];
            return function () ***REMOVED***
                cb_2.call(ctx, eventData.snapshot, eventData.prevName);
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.matches = function (other) ***REMOVED***
        if (other instanceof ChildEventRegistration) ***REMOVED***
            if (!this.callbacks_ || !other.callbacks_) ***REMOVED***
                return true;
            ***REMOVED***
            else if (this.context_ === other.context_) ***REMOVED***
                var otherCount = util_1.getCount(other.callbacks_);
                var thisCount = util_1.getCount(this.callbacks_);
                if (otherCount === thisCount) ***REMOVED***
                    // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.
                    //  If event types don't match, not a match
                    // If count is not 1, exact match across all
                    if (otherCount === 1) ***REMOVED***
                        var otherKey /** @type ***REMOVED***!string***REMOVED*** */ = util_1.getAnyKey(other.callbacks_);
                        var thisKey /** @type ***REMOVED***!string***REMOVED*** */ = util_1.getAnyKey(this.callbacks_);
                        return (thisKey === otherKey &&
                            (!other.callbacks_[otherKey] ||
                                !this.callbacks_[thisKey] ||
                                other.callbacks_[otherKey] === this.callbacks_[thisKey]));
                    ***REMOVED***
                    else ***REMOVED***
                        // Exact match on each key.
                        return util_1.every(this.callbacks_, function (eventType, cb) ***REMOVED*** return other.callbacks_[eventType] === cb; ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        return false;
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.hasAnyCallback = function () ***REMOVED***
        return this.callbacks_ !== null;
    ***REMOVED***;
    return ChildEventRegistration;
***REMOVED***());
exports.ChildEventRegistration = ChildEventRegistration;

//# sourceMappingURL=EventRegistration.js.map
