"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("@firebase/util");
var Change_1 = require("../Change");
var ChildrenNode_1 = require("../../snap/ChildrenNode");
var PriorityIndex_1 = require("../../snap/indexes/PriorityIndex");
/**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 *
 * @constructor
 * @implements ***REMOVED***NodeFilter***REMOVED***
 * @param ***REMOVED***!Index***REMOVED*** index
 */
var IndexedFilter = /** @class */ (function () ***REMOVED***
    function IndexedFilter(index_) ***REMOVED***
        this.index_ = index_;
    ***REMOVED***
    IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) ***REMOVED***
        util_1.assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');
        var oldChild = snap.getImmediateChild(key);
        // Check if anything actually changed.
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) ***REMOVED***
            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.
            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need
            // to avoid treating these cases as "nothing changed."
            if (oldChild.isEmpty() == newChild.isEmpty()) ***REMOVED***
                // Nothing changed.
                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
                return snap;
            ***REMOVED***
        ***REMOVED***
        if (optChangeAccumulator != null) ***REMOVED***
            if (newChild.isEmpty()) ***REMOVED***
                if (snap.hasChild(key)) ***REMOVED***
                    optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, oldChild));
                ***REMOVED***
                else ***REMOVED***
                    util_1.assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');
                ***REMOVED***
            ***REMOVED***
            else if (oldChild.isEmpty()) ***REMOVED***
                optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, newChild));
            ***REMOVED***
            else ***REMOVED***
                optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, newChild, oldChild));
            ***REMOVED***
        ***REMOVED***
        if (snap.isLeafNode() && newChild.isEmpty()) ***REMOVED***
            return snap;
        ***REMOVED***
        else ***REMOVED***
            // Make sure the node is indexed
            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) ***REMOVED***
        if (optChangeAccumulator != null) ***REMOVED***
            if (!oldSnap.isLeafNode()) ***REMOVED***
                oldSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) ***REMOVED***
                    if (!newSnap.hasChild(key)) ***REMOVED***
                        optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, childNode));
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
            if (!newSnap.isLeafNode()) ***REMOVED***
                newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) ***REMOVED***
                    if (oldSnap.hasChild(key)) ***REMOVED***
                        var oldChild = oldSnap.getImmediateChild(key);
                        if (!oldChild.equals(childNode)) ***REMOVED***
                            optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, childNode, oldChild));
                        ***REMOVED***
                    ***REMOVED***
                    else ***REMOVED***
                        optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, childNode));
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***
        return newSnap.withIndex(this.index_);
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) ***REMOVED***
        if (oldSnap.isEmpty()) ***REMOVED***
            return ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        ***REMOVED***
        else ***REMOVED***
            return oldSnap.updatePriority(newPriority);
        ***REMOVED***
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.filtersNodes = function () ***REMOVED***
        return false;
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.getIndexedFilter = function () ***REMOVED***
        return this;
    ***REMOVED***;
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.getIndex = function () ***REMOVED***
        return this.index_;
    ***REMOVED***;
    return IndexedFilter;
***REMOVED***());
exports.IndexedFilter = IndexedFilter;

//# sourceMappingURL=IndexedFilter.js.map
