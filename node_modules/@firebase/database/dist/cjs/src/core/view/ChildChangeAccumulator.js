"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var util_1 = require("@firebase/util");
var Change_1 = require("./Change");
var util_2 = require("@firebase/util");
/**
 * @constructor
 */
var ChildChangeAccumulator = /** @class */ (function () ***REMOVED***
    function ChildChangeAccumulator() ***REMOVED***
        this.changeMap_ = ***REMOVED******REMOVED***;
    ***REMOVED***
    /**
     * @param ***REMOVED***!Change***REMOVED*** change
     */
    ChildChangeAccumulator.prototype.trackChildChange = function (change) ***REMOVED***
        var type = change.type;
        var childKey /** @type ***REMOVED***!string***REMOVED*** */ = change.childName;
        util_2.assert(type == Change_1.Change.CHILD_ADDED ||
            type == Change_1.Change.CHILD_CHANGED ||
            type == Change_1.Change.CHILD_REMOVED, 'Only child changes supported for tracking');
        util_2.assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');
        var oldChange = util_1.safeGet(this.changeMap_, childKey);
        if (oldChange) ***REMOVED***
            var oldType = oldChange.type;
            if (type == Change_1.Change.CHILD_ADDED && oldType == Change_1.Change.CHILD_REMOVED) ***REMOVED***
                this.changeMap_[childKey] = Change_1.Change.childChangedChange(childKey, change.snapshotNode, oldChange.snapshotNode);
            ***REMOVED***
            else if (type == Change_1.Change.CHILD_REMOVED &&
                oldType == Change_1.Change.CHILD_ADDED) ***REMOVED***
                delete this.changeMap_[childKey];
            ***REMOVED***
            else if (type == Change_1.Change.CHILD_REMOVED &&
                oldType == Change_1.Change.CHILD_CHANGED) ***REMOVED***
                this.changeMap_[childKey] = Change_1.Change.childRemovedChange(childKey, oldChange.oldSnap);
            ***REMOVED***
            else if (type == Change_1.Change.CHILD_CHANGED &&
                oldType == Change_1.Change.CHILD_ADDED) ***REMOVED***
                this.changeMap_[childKey] = Change_1.Change.childAddedChange(childKey, change.snapshotNode);
            ***REMOVED***
            else if (type == Change_1.Change.CHILD_CHANGED &&
                oldType == Change_1.Change.CHILD_CHANGED) ***REMOVED***
                this.changeMap_[childKey] = Change_1.Change.childChangedChange(childKey, change.snapshotNode, oldChange.oldSnap);
            ***REMOVED***
            else ***REMOVED***
                throw util_2.assertionError('Illegal combination of changes: ' +
                    change +
                    ' occurred after ' +
                    oldChange);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            this.changeMap_[childKey] = change;
        ***REMOVED***
    ***REMOVED***;
    /**
     * @return ***REMOVED***!Array.<!Change>***REMOVED***
     */
    ChildChangeAccumulator.prototype.getChanges = function () ***REMOVED***
        return util_1.getValues(this.changeMap_);
    ***REMOVED***;
    return ChildChangeAccumulator;
***REMOVED***());
exports.ChildChangeAccumulator = ChildChangeAccumulator;

//# sourceMappingURL=ChildChangeAccumulator.js.map
