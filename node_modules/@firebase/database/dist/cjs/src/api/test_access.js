"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var RepoInfo_1 = require("../core/RepoInfo");
var PersistentConnection_1 = require("../core/PersistentConnection");
var RepoManager_1 = require("../core/RepoManager");
var Connection_1 = require("../realtime/Connection");
exports.DataConnection = PersistentConnection_1.PersistentConnection;
/**
 * @param ***REMOVED***!string***REMOVED*** pathString
 * @param ***REMOVED***function(*)***REMOVED*** onComplete
 */
PersistentConnection_1.PersistentConnection.prototype.simpleListen = function (pathString, onComplete) ***REMOVED***
    this.sendRequest('q', ***REMOVED*** p: pathString ***REMOVED***, onComplete);
***REMOVED***;
/**
 * @param ***REMOVED*******REMOVED*** data
 * @param ***REMOVED***function(*)***REMOVED*** onEcho
 */
PersistentConnection_1.PersistentConnection.prototype.echo = function (data, onEcho) ***REMOVED***
    this.sendRequest('echo', ***REMOVED*** d: data ***REMOVED***, onEcho);
***REMOVED***;
// RealTimeConnection properties that we use in tests.
exports.RealTimeConnection = Connection_1.Connection;
/**
 * @param ***REMOVED***function(): string***REMOVED*** newHash
 * @return ***REMOVED***function()***REMOVED***
 */
exports.hijackHash = function (newHash) ***REMOVED***
    var oldPut = PersistentConnection_1.PersistentConnection.prototype.put;
    PersistentConnection_1.PersistentConnection.prototype.put = function (pathString, data, opt_onComplete, opt_hash) ***REMOVED***
        if (opt_hash !== undefined) ***REMOVED***
            opt_hash = newHash();
        ***REMOVED***
        oldPut.call(this, pathString, data, opt_onComplete, opt_hash);
    ***REMOVED***;
    return function () ***REMOVED***
        PersistentConnection_1.PersistentConnection.prototype.put = oldPut;
    ***REMOVED***;
***REMOVED***;
/**
 * @type ***REMOVED***function(new:RepoInfo, !string, boolean, !string, boolean): undefined***REMOVED***
 */
exports.ConnectionTarget = RepoInfo_1.RepoInfo;
/**
 * @param ***REMOVED***!Query***REMOVED*** query
 * @return ***REMOVED***!string***REMOVED***
 */
exports.queryIdentifier = function (query) ***REMOVED***
    return query.queryIdentifier();
***REMOVED***;
/**
 * @param ***REMOVED***!Query***REMOVED*** firebaseRef
 * @return ***REMOVED***!Object***REMOVED***
 */
exports.listens = function (firebaseRef) ***REMOVED***
    return firebaseRef.repo.persistentConnection_.listens_;
***REMOVED***;
/**
 * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.
 *
 * @param ***REMOVED***boolean***REMOVED*** forceRestClient
 */
exports.forceRestClient = function (forceRestClient) ***REMOVED***
    RepoManager_1.RepoManager.getInstance().forceRestClient(forceRestClient);
***REMOVED***;

//# sourceMappingURL=test_access.js.map
