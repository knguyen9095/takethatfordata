"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var WebSocketConnection_1 = require("./realtime/WebSocketConnection");
var BrowserPollConnection_1 = require("./realtime/BrowserPollConnection");
var faye_websocket_1 = require("faye-websocket");
WebSocketConnection_1.setWebSocketImpl(faye_websocket_1.Client);
/**
 * @suppress ***REMOVED***es5Strict***REMOVED***
 */
(function () ***REMOVED***
    var version = process['version'];
    if (version !== 'v0.10.22' &&
        version !== 'v0.10.23' &&
        version !== 'v0.10.24')
        return;
    /**
     * The following duplicates much of `/lib/_stream_writable.js` at
     * b922b5e90d2c14dd332b95827c2533e083df7e55, applying the fix for
     * https://github.com/joyent/node/issues/6506. Note that this fix also
     * needs to be applied to `Duplex.prototype.write()` (in
     * `/lib/_stream_duplex.js`) as well.
     */
    var Writable = require('_stream_writable');
    Writable['prototype']['write'] = function (chunk, encoding, cb) ***REMOVED***
        var state = this['_writableState'];
        var ret = false;
        if (typeof encoding === 'function') ***REMOVED***
            cb = encoding;
            encoding = null;
        ***REMOVED***
        if (Buffer['isBuffer'](chunk))
            encoding = 'buffer';
        else if (!encoding)
            encoding = state['defaultEncoding'];
        if (typeof cb !== 'function')
            cb = function () ***REMOVED*** ***REMOVED***;
        if (state['ended'])
            writeAfterEnd(this, state, cb);
        else if (validChunk(this, state, chunk, cb))
            ret = writeOrBuffer(this, state, chunk, encoding, cb);
        return ret;
    ***REMOVED***;
    function writeAfterEnd(stream, state, cb) ***REMOVED***
        var er = new Error('write after end');
        // TODO: defer error events consistently everywhere, not just the cb
        stream['emit']('error', er);
        process['nextTick'](function () ***REMOVED***
            cb(er);
        ***REMOVED***);
    ***REMOVED***
    function validChunk(stream, state, chunk, cb) ***REMOVED***
        var valid = true;
        if (!Buffer['isBuffer'](chunk) &&
            'string' !== typeof chunk &&
            chunk !== null &&
            chunk !== undefined &&
            !state['objectMode']) ***REMOVED***
            var er = new TypeError('Invalid non-string/buffer chunk');
            stream['emit']('error', er);
            process['nextTick'](function () ***REMOVED***
                cb(er);
            ***REMOVED***);
            valid = false;
        ***REMOVED***
        return valid;
    ***REMOVED***
    function writeOrBuffer(stream, state, chunk, encoding, cb) ***REMOVED***
        chunk = decodeChunk(state, chunk, encoding);
        if (Buffer['isBuffer'](chunk))
            encoding = 'buffer';
        var len = state['objectMode'] ? 1 : chunk['length'];
        state['length'] += len;
        var ret = state['length'] < state['highWaterMark'];
        // we must ensure that previous needDrain will not be reset to false.
        if (!ret)
            state['needDrain'] = true;
        if (state['writing'])
            state['buffer']['push'](new WriteReq(chunk, encoding, cb));
        else
            doWrite(stream, state, len, chunk, encoding, cb);
        return ret;
    ***REMOVED***
    function decodeChunk(state, chunk, encoding) ***REMOVED***
        if (!state['objectMode'] &&
            state['decodeStrings'] !== false &&
            typeof chunk === 'string') ***REMOVED***
            chunk = new Buffer(chunk, encoding);
        ***REMOVED***
        return chunk;
    ***REMOVED***
    /**
     * @constructor
     */
    function WriteReq(chunk, encoding, cb) ***REMOVED***
        this['chunk'] = chunk;
        this['encoding'] = encoding;
        this['callback'] = cb;
    ***REMOVED***
    function doWrite(stream, state, len, chunk, encoding, cb) ***REMOVED***
        state['writelen'] = len;
        state['writecb'] = cb;
        state['writing'] = true;
        state['sync'] = true;
        stream['_write'](chunk, encoding, state['onwrite']);
        state['sync'] = false;
    ***REMOVED***
    var Duplex = require('_stream_duplex');
    Duplex['prototype']['write'] = Writable['prototype']['write'];
***REMOVED***)();
/**
 * @type ***REMOVED***?function(***REMOVED***url: string, forever: boolean***REMOVED***, function(Error, number, string))***REMOVED***
 */
BrowserPollConnection_1.FirebaseIFrameScriptHolder.request = null;
/**
 * @param ***REMOVED******REMOVED***url: string, forever: boolean***REMOVED******REMOVED*** req
 * @param ***REMOVED***function(string)=***REMOVED*** onComplete
 */
BrowserPollConnection_1.FirebaseIFrameScriptHolder.nodeRestRequest = function (req, onComplete) ***REMOVED***
    if (!BrowserPollConnection_1.FirebaseIFrameScriptHolder.request)
        BrowserPollConnection_1.FirebaseIFrameScriptHolder.request = /** @type ***REMOVED***function(***REMOVED***url: string, forever: boolean***REMOVED***, function(Error, number, string))***REMOVED*** */ require('request');
    BrowserPollConnection_1.FirebaseIFrameScriptHolder.request(req, function (error, response, body) ***REMOVED***
        if (error)
            throw 'Rest request for ' + req.url + ' failed.';
        if (onComplete)
            onComplete(body);
    ***REMOVED***);
***REMOVED***;
/**
 * @param ***REMOVED***!string***REMOVED*** url
 * @param ***REMOVED***function()***REMOVED*** loadCB
 */
BrowserPollConnection_1.FirebaseIFrameScriptHolder.prototype.doNodeLongPoll = function (url, loadCB) ***REMOVED***
    var self = this;
    BrowserPollConnection_1.FirebaseIFrameScriptHolder.nodeRestRequest(***REMOVED*** url: url, forever: true ***REMOVED***, function (body) ***REMOVED***
        self.evalBody(body);
        loadCB();
    ***REMOVED***);
***REMOVED***;
/**
 * Evaluates the string contents of a jsonp response.
 * @param ***REMOVED***!string***REMOVED*** body
 */
BrowserPollConnection_1.FirebaseIFrameScriptHolder.prototype.evalBody = function (body) ***REMOVED***
    var jsonpCB;
    //jsonpCB is externed in firebase-extern.js
    eval('jsonpCB = function(' +
        BrowserPollConnection_1.FIREBASE_LONGPOLL_COMMAND_CB_NAME +
        ', ' +
        BrowserPollConnection_1.FIREBASE_LONGPOLL_DATA_CB_NAME +
        ') ***REMOVED***' +
        body +
        '***REMOVED***');
    jsonpCB(this.commandCB, this.onMessageCB);
***REMOVED***;

//# sourceMappingURL=nodePatches.js.map
