/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** createSubscribe, deepCopy, deepExtend, ErrorFactory, patchProperty ***REMOVED*** from '@firebase/util';
var contains = function (obj, key) ***REMOVED***
    return Object.prototype.hasOwnProperty.call(obj, key);
***REMOVED***;
var DEFAULT_ENTRY_NAME = '[DEFAULT]';
// An array to capture listeners before the true auth functions
// exist
var tokenListeners = [];
/**
 * Global context object for a collection of services using
 * a shared authentication state.
 */
var FirebaseAppImpl = /** @class */ (function () ***REMOVED***
    function FirebaseAppImpl(options, name, firebase_) ***REMOVED***
        this.firebase_ = firebase_;
        this.isDeleted_ = false;
        this.services_ = ***REMOVED******REMOVED***;
        this.name_ = name;
        this.options_ = deepCopy(options);
        this.INTERNAL = ***REMOVED***
            getUid: function () ***REMOVED*** return null; ***REMOVED***,
            getToken: function () ***REMOVED*** return Promise.resolve(null); ***REMOVED***,
            addAuthTokenListener: function (callback) ***REMOVED***
                tokenListeners.push(callback);
                // Make sure callback is called, asynchronously, in the absence of the auth module
                setTimeout(function () ***REMOVED*** return callback(null); ***REMOVED***, 0);
            ***REMOVED***,
            removeAuthTokenListener: function (callback) ***REMOVED***
                tokenListeners = tokenListeners.filter(function (listener) ***REMOVED*** return listener !== callback; ***REMOVED***);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
    Object.defineProperty(FirebaseAppImpl.prototype, "name", ***REMOVED***
        get: function () ***REMOVED***
            this.checkDestroyed_();
            return this.name_;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(FirebaseAppImpl.prototype, "options", ***REMOVED***
        get: function () ***REMOVED***
            this.checkDestroyed_();
            return this.options_;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    FirebaseAppImpl.prototype.delete = function () ***REMOVED***
        var _this = this;
        return new Promise(function (resolve) ***REMOVED***
            _this.checkDestroyed_();
            resolve();
        ***REMOVED***)
            .then(function () ***REMOVED***
            _this.firebase_.INTERNAL.removeApp(_this.name_);
            var services = [];
            Object.keys(_this.services_).forEach(function (serviceKey) ***REMOVED***
                Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) ***REMOVED***
                    services.push(_this.services_[serviceKey][instanceKey]);
                ***REMOVED***);
            ***REMOVED***);
            return Promise.all(services.map(function (service) ***REMOVED***
                return service.INTERNAL.delete();
            ***REMOVED***));
        ***REMOVED***)
            .then(function () ***REMOVED***
            _this.isDeleted_ = true;
            _this.services_ = ***REMOVED******REMOVED***;
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Return a service instance associated with this app (creating it
     * on demand), identified by the passed instanceIdentifier.
     *
     * NOTE: Currently storage is the only one that is leveraging this
     * functionality. They invoke it by calling:
     *
     * ```javascript
     * firebase.app().storage('STORAGE BUCKET ID')
     * ```
     *
     * The service name is passed to this already
     * @internal
     */
    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) ***REMOVED***
        if (instanceIdentifier === void 0) ***REMOVED*** instanceIdentifier = DEFAULT_ENTRY_NAME; ***REMOVED***
        this.checkDestroyed_();
        if (!this.services_[name]) ***REMOVED***
            this.services_[name] = ***REMOVED******REMOVED***;
        ***REMOVED***
        if (!this.services_[name][instanceIdentifier]) ***REMOVED***
            /**
             * If a custom instance has been defined (i.e. not '[DEFAULT]')
             * then we will pass that instance on, otherwise we pass `null`
             */
            var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME
                ? instanceIdentifier
                : undefined;
            var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);
            this.services_[name][instanceIdentifier] = service;
        ***REMOVED***
        return this.services_[name][instanceIdentifier];
    ***REMOVED***;
    /**
     * Callback function used to extend an App instance at the time
     * of service instance creation.
     */
    FirebaseAppImpl.prototype.extendApp = function (props) ***REMOVED***
        var _this = this;
        // Copy the object onto the FirebaseAppImpl prototype
        deepExtend(this, props);
        /**
         * If the app has overwritten the addAuthTokenListener stub, forward
         * the active token listeners on to the true fxn.
         *
         * TODO: This function is required due to our current module
         * structure. Once we are able to rely strictly upon a single module
         * implementation, this code should be refactored and Auth should
         * provide these stubs and the upgrade logic
         */
        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) ***REMOVED***
            tokenListeners.forEach(function (listener) ***REMOVED***
                _this.INTERNAL.addAuthTokenListener(listener);
            ***REMOVED***);
            tokenListeners = [];
        ***REMOVED***
    ***REMOVED***;
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    FirebaseAppImpl.prototype.checkDestroyed_ = function () ***REMOVED***
        if (this.isDeleted_) ***REMOVED***
            error('app-deleted', ***REMOVED*** name: this.name_ ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;
    return FirebaseAppImpl;
***REMOVED***());
// Prevent dead-code elimination of these methods w/o invalid property
// copying.
(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||
    FirebaseAppImpl.prototype.delete ||
    console.log('dc');
/**
 * Return a firebase namespace object.
 *
 * In production, this will be called exactly once and the result
 * assigned to the 'firebase' global.  It may be called multiple times
 * in unit tests.
 */
export function createFirebaseNamespace() ***REMOVED***
    var apps_ = ***REMOVED******REMOVED***;
    var factories = ***REMOVED******REMOVED***;
    var appHooks = ***REMOVED******REMOVED***;
    // A namespace is a plain JavaScript Object.
    var namespace = ***REMOVED***
        // Hack to prevent Babel from modifying the object returned
        // as the firebase namespace.
        __esModule: true,
        initializeApp: initializeApp,
        app: app,
        apps: null,
        Promise: Promise,
        SDK_VERSION: '4.9.1',
        INTERNAL: ***REMOVED***
            registerService: registerService,
            createFirebaseNamespace: createFirebaseNamespace,
            extendNamespace: extendNamespace,
            createSubscribe: createSubscribe,
            ErrorFactory: ErrorFactory,
            removeApp: removeApp,
            factories: factories,
            useAsService: useAsService,
            Promise: Promise,
            deepExtend: deepExtend
        ***REMOVED***
    ***REMOVED***;
    // Inject a circular default export to allow Babel users who were previously
    // using:
    //
    //   import firebase from 'firebase';
    //   which becomes: var firebase = require('firebase').default;
    //
    // instead of
    //
    //   import * as firebase from 'firebase';
    //   which becomes: var firebase = require('firebase');
    patchProperty(namespace, 'default', namespace);
    // firebase.apps is a read-only getter.
    Object.defineProperty(namespace, 'apps', ***REMOVED***
        get: getApps
    ***REMOVED***);
    /**
     * Called by App.delete() - but before any services associated with the App
     * are deleted.
     */
    function removeApp(name) ***REMOVED***
        var app = apps_[name];
        callAppHooks(app, 'delete');
        delete apps_[name];
    ***REMOVED***
    /**
     * Get the App object for a given name (or DEFAULT).
     */
    function app(name) ***REMOVED***
        name = name || DEFAULT_ENTRY_NAME;
        if (!contains(apps_, name)) ***REMOVED***
            error('no-app', ***REMOVED*** name: name ***REMOVED***);
        ***REMOVED***
        return apps_[name];
    ***REMOVED***
    patchProperty(app, 'App', FirebaseAppImpl);
    /**
     * Create a new App instance (name must be unique).
     */
    function initializeApp(options, name) ***REMOVED***
        if (name === undefined) ***REMOVED***
            name = DEFAULT_ENTRY_NAME;
        ***REMOVED***
        else ***REMOVED***
            if (typeof name !== 'string' || name === '') ***REMOVED***
                error('bad-app-name', ***REMOVED*** name: name + '' ***REMOVED***);
            ***REMOVED***
        ***REMOVED***
        if (contains(apps_, name)) ***REMOVED***
            error('duplicate-app', ***REMOVED*** name: name ***REMOVED***);
        ***REMOVED***
        var app = new FirebaseAppImpl(options, name, namespace);
        apps_[name] = app;
        callAppHooks(app, 'create');
        return app;
    ***REMOVED***
    /*
     * Return an array of all the non-deleted FirebaseApps.
     */
    function getApps() ***REMOVED***
        // Make a copy so caller cannot mutate the apps list.
        return Object.keys(apps_).map(function (name) ***REMOVED*** return apps_[name]; ***REMOVED***);
    ***REMOVED***
    /*
     * Register a Firebase Service.
     *
     * firebase.INTERNAL.registerService()
     *
     * TODO: Implement serviceProperties.
     */
    function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) ***REMOVED***
        // Cannot re-register a service that already exists
        if (factories[name]) ***REMOVED***
            error('duplicate-service', ***REMOVED*** name: name ***REMOVED***);
        ***REMOVED***
        // Capture the service factory for later service instantiation
        factories[name] = createService;
        // Capture the appHook, if passed
        if (appHook) ***REMOVED***
            appHooks[name] = appHook;
            // Run the **new** app hook on all existing apps
            getApps().forEach(function (app) ***REMOVED***
                appHook('create', app);
            ***REMOVED***);
        ***REMOVED***
        // The Service namespace is an accessor function ...
        var serviceNamespace = function (appArg) ***REMOVED***
            if (appArg === void 0) ***REMOVED*** appArg = app(); ***REMOVED***
            if (typeof appArg[name] !== 'function') ***REMOVED***
                // Invalid argument.
                // This happens in the following case: firebase.storage('gs:/')
                error('invalid-app-argument', ***REMOVED*** name: name ***REMOVED***);
            ***REMOVED***
            // Forward service instance lookup to the FirebaseApp.
            return appArg[name]();
        ***REMOVED***;
        // ... and a container for service-level properties.
        if (serviceProperties !== undefined) ***REMOVED***
            deepExtend(serviceNamespace, serviceProperties);
        ***REMOVED***
        // Monkey-patch the serviceNamespace onto the firebase namespace
        namespace[name] = serviceNamespace;
        // Patch the FirebaseAppImpl prototype
        FirebaseAppImpl.prototype[name] = function () ***REMOVED***
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
                args[_i] = arguments[_i];
            ***REMOVED***
            var serviceFxn = this._getService.bind(this, name);
            return serviceFxn.apply(this, allowMultipleInstances ? args : []);
        ***REMOVED***;
        return serviceNamespace;
    ***REMOVED***
    /**
     * Patch the top-level firebase namespace with additional properties.
     *
     * firebase.INTERNAL.extendNamespace()
     */
    function extendNamespace(props) ***REMOVED***
        deepExtend(namespace, props);
    ***REMOVED***
    function callAppHooks(app, eventName) ***REMOVED***
        Object.keys(factories).forEach(function (serviceName) ***REMOVED***
            // Ignore virtual services
            var factoryName = useAsService(app, serviceName);
            if (factoryName === null) ***REMOVED***
                return;
            ***REMOVED***
            if (appHooks[factoryName]) ***REMOVED***
                appHooks[factoryName](eventName, app);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
    // Map the requested service to a registered service name
    // (used to map auth to serverAuth service when needed).
    function useAsService(app, name) ***REMOVED***
        if (name === 'serverAuth') ***REMOVED***
            return null;
        ***REMOVED***
        var useService = name;
        var options = app.options;
        return useService;
    ***REMOVED***
    return namespace;
***REMOVED***
function error(code, args) ***REMOVED***
    throw appErrors.create(code, args);
***REMOVED***
// TypeScript does not support non-string indexes!
// let errors: ***REMOVED***[code: AppError: string***REMOVED*** = ***REMOVED***
var errors = ***REMOVED***
    'no-app': "No Firebase App '***REMOVED***$name***REMOVED***' has been created - " +
        'call Firebase App.initializeApp()',
    'bad-app-name': "Illegal App name: '***REMOVED***$name***REMOVED***",
    'duplicate-app': "Firebase App named '***REMOVED***$name***REMOVED***' already exists",
    'app-deleted': "Firebase App named '***REMOVED***$name***REMOVED***' already deleted",
    'duplicate-service': "Firebase service named '***REMOVED***$name***REMOVED***' already registered",
    'sa-not-supported': 'Initializing the Firebase SDK with a service ' +
        'account is only allowed in a Node.js environment. On client ' +
        'devices, you should instead initialize the SDK with an api key and ' +
        'auth domain',
    'invalid-app-argument': 'firebase.***REMOVED***$name***REMOVED***() takes either no argument or a ' +
        'Firebase App instance.'
***REMOVED***;
var appErrors = new ErrorFactory('app', 'Firebase', errors);


//# sourceMappingURL=firebaseApp.js.map
