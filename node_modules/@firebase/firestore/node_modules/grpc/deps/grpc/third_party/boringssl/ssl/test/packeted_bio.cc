/* Copyright (c) 2014, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

#include "packeted_bio.h"

#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

#include <openssl/mem.h>

#include "../../crypto/internal.h"


namespace ***REMOVED***

extern const BIO_METHOD g_packeted_bio_method;

const uint8_t kOpcodePacket = 'P';
const uint8_t kOpcodeTimeout = 'T';
const uint8_t kOpcodeTimeoutAck = 't';

struct PacketedBio ***REMOVED***
  PacketedBio(timeval *clock_arg, bool advance_clock_arg)
      : clock(clock_arg), advance_clock(advance_clock_arg) ***REMOVED***
    OPENSSL_memset(&timeout, 0, sizeof(timeout));
    OPENSSL_memset(&read_deadline, 0, sizeof(read_deadline));
  ***REMOVED***

  bool HasTimeout() const ***REMOVED***
    return timeout.tv_sec != 0 || timeout.tv_usec != 0;
  ***REMOVED***

  bool CanRead() const ***REMOVED***
    if (read_deadline.tv_sec == 0 && read_deadline.tv_usec == 0) ***REMOVED***
      return true;
    ***REMOVED***

    if (clock->tv_sec == read_deadline.tv_sec) ***REMOVED***
      return clock->tv_usec < read_deadline.tv_usec;
    ***REMOVED***
    return clock->tv_sec < read_deadline.tv_sec;
  ***REMOVED***

  timeval timeout;
  timeval *clock;
  timeval read_deadline;
  bool advance_clock;
***REMOVED***;

PacketedBio *GetData(BIO *bio) ***REMOVED***
  if (bio->method != &g_packeted_bio_method) ***REMOVED***
    return NULL;
  ***REMOVED***
  return (PacketedBio *)bio->ptr;
***REMOVED***

// ReadAll reads |len| bytes from |bio| into |out|. It returns 1 on success and
// 0 or -1 on error.
static int ReadAll(BIO *bio, uint8_t *out, size_t len) ***REMOVED***
  while (len > 0) ***REMOVED***
    int chunk_len = INT_MAX;
    if (len <= INT_MAX) ***REMOVED***
      chunk_len = (int)len;
    ***REMOVED***
    int ret = BIO_read(bio, out, chunk_len);
    if (ret <= 0) ***REMOVED***
      return ret;
    ***REMOVED***
    out += ret;
    len -= ret;
  ***REMOVED***
  return 1;
***REMOVED***

static int PacketedWrite(BIO *bio, const char *in, int inl) ***REMOVED***
  if (bio->next_bio == NULL) ***REMOVED***
    return 0;
  ***REMOVED***

  BIO_clear_retry_flags(bio);

  // Write the header.
  uint8_t header[5];
  header[0] = kOpcodePacket;
  header[1] = (inl >> 24) & 0xff;
  header[2] = (inl >> 16) & 0xff;
  header[3] = (inl >> 8) & 0xff;
  header[4] = inl & 0xff;
  int ret = BIO_write(bio->next_bio, header, sizeof(header));
  if (ret <= 0) ***REMOVED***
    BIO_copy_next_retry(bio);
    return ret;
  ***REMOVED***

  // Write the buffer.
  ret = BIO_write(bio->next_bio, in, inl);
  if (ret < 0 || (inl > 0 && ret == 0)) ***REMOVED***
    BIO_copy_next_retry(bio);
    return ret;
  ***REMOVED***
  assert(ret == inl);
  return ret;
***REMOVED***

static int PacketedRead(BIO *bio, char *out, int outl) ***REMOVED***
  PacketedBio *data = GetData(bio);
  if (bio->next_bio == NULL) ***REMOVED***
    return 0;
  ***REMOVED***

  BIO_clear_retry_flags(bio);

  for (;;) ***REMOVED***
    // Check if the read deadline has passed.
    if (!data->CanRead()) ***REMOVED***
      BIO_set_retry_read(bio);
      return -1;
    ***REMOVED***

    // Read the opcode.
    uint8_t opcode;
    int ret = ReadAll(bio->next_bio, &opcode, sizeof(opcode));
    if (ret <= 0) ***REMOVED***
      BIO_copy_next_retry(bio);
      return ret;
    ***REMOVED***

    if (opcode == kOpcodeTimeout) ***REMOVED***
      // The caller is required to advance any pending timeouts before
      // continuing.
      if (data->HasTimeout()) ***REMOVED***
        fprintf(stderr, "Unprocessed timeout!\n");
        return -1;
      ***REMOVED***

      // Process the timeout.
      uint8_t buf[8];
      ret = ReadAll(bio->next_bio, buf, sizeof(buf));
      if (ret <= 0) ***REMOVED***
        BIO_copy_next_retry(bio);
        return ret;
      ***REMOVED***
      uint64_t timeout = (static_cast<uint64_t>(buf[0]) << 56) |
          (static_cast<uint64_t>(buf[1]) << 48) |
          (static_cast<uint64_t>(buf[2]) << 40) |
          (static_cast<uint64_t>(buf[3]) << 32) |
          (static_cast<uint64_t>(buf[4]) << 24) |
          (static_cast<uint64_t>(buf[5]) << 16) |
          (static_cast<uint64_t>(buf[6]) << 8) |
          static_cast<uint64_t>(buf[7]);
      timeout /= 1000;  // Convert nanoseconds to microseconds.

      data->timeout.tv_usec = timeout % 1000000;
      data->timeout.tv_sec = timeout / 1000000;

      // Send an ACK to the peer.
      ret = BIO_write(bio->next_bio, &kOpcodeTimeoutAck, 1);
      if (ret <= 0) ***REMOVED***
        return ret;
      ***REMOVED***
      assert(ret == 1);

      if (!data->advance_clock) ***REMOVED***
        // Signal to the caller to retry the read, after advancing the clock.
        BIO_set_retry_read(bio);
        return -1;
      ***REMOVED***

      PacketedBioAdvanceClock(bio);
      continue;
    ***REMOVED***

    if (opcode != kOpcodePacket) ***REMOVED***
      fprintf(stderr, "Unknown opcode, %u\n", opcode);
      return -1;
    ***REMOVED***

    // Read the length prefix.
    uint8_t len_bytes[4];
    ret = ReadAll(bio->next_bio, len_bytes, sizeof(len_bytes));
    if (ret <= 0) ***REMOVED***
      BIO_copy_next_retry(bio);
      return ret;
    ***REMOVED***

    uint32_t len = (len_bytes[0] << 24) | (len_bytes[1] << 16) |
        (len_bytes[2] << 8) | len_bytes[3];
    uint8_t *buf = (uint8_t *)OPENSSL_malloc(len);
    if (buf == NULL) ***REMOVED***
      return -1;
    ***REMOVED***
    ret = ReadAll(bio->next_bio, buf, len);
    if (ret <= 0) ***REMOVED***
      fprintf(stderr, "Packeted BIO was truncated\n");
      return -1;
    ***REMOVED***

    if (outl > (int)len) ***REMOVED***
      outl = len;
    ***REMOVED***
    OPENSSL_memcpy(out, buf, outl);
    OPENSSL_free(buf);
    return outl;
  ***REMOVED***
***REMOVED***

static long PacketedCtrl(BIO *bio, int cmd, long num, void *ptr) ***REMOVED***
  if (cmd == BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT) ***REMOVED***
    OPENSSL_memcpy(&GetData(bio)->read_deadline, ptr, sizeof(timeval));
    return 1;
  ***REMOVED***

  if (bio->next_bio == NULL) ***REMOVED***
    return 0;
  ***REMOVED***
  BIO_clear_retry_flags(bio);
  int ret = BIO_ctrl(bio->next_bio, cmd, num, ptr);
  BIO_copy_next_retry(bio);
  return ret;
***REMOVED***

static int PacketedNew(BIO *bio) ***REMOVED***
  bio->init = 1;
  return 1;
***REMOVED***

static int PacketedFree(BIO *bio) ***REMOVED***
  if (bio == NULL) ***REMOVED***
    return 0;
  ***REMOVED***

  delete GetData(bio);
  bio->init = 0;
  return 1;
***REMOVED***

static long PacketedCallbackCtrl(BIO *bio, int cmd, bio_info_cb fp) ***REMOVED***
  if (bio->next_bio == NULL) ***REMOVED***
    return 0;
  ***REMOVED***
  return BIO_callback_ctrl(bio->next_bio, cmd, fp);
***REMOVED***

const BIO_METHOD g_packeted_bio_method = ***REMOVED***
  BIO_TYPE_FILTER,
  "packeted bio",
  PacketedWrite,
  PacketedRead,
  NULL /* puts */,
  NULL /* gets */,
  PacketedCtrl,
  PacketedNew,
  PacketedFree,
  PacketedCallbackCtrl,
***REMOVED***;

***REMOVED***  // namespace

bssl::UniquePtr<BIO> PacketedBioCreate(timeval *clock, bool advance_clock) ***REMOVED***
  bssl::UniquePtr<BIO> bio(BIO_new(&g_packeted_bio_method));
  if (!bio) ***REMOVED***
    return nullptr;
  ***REMOVED***
  bio->ptr = new PacketedBio(clock, advance_clock);
  return bio;
***REMOVED***

bool PacketedBioAdvanceClock(BIO *bio) ***REMOVED***
  PacketedBio *data = GetData(bio);
  if (data == nullptr) ***REMOVED***
    return false;
  ***REMOVED***

  if (!data->HasTimeout()) ***REMOVED***
    return false;
  ***REMOVED***

  data->clock->tv_usec += data->timeout.tv_usec;
  data->clock->tv_sec += data->clock->tv_usec / 1000000;
  data->clock->tv_usec %= 1000000;
  data->clock->tv_sec += data->timeout.tv_sec;
  OPENSSL_memset(&data->timeout, 0, sizeof(data->timeout));
  return true;
***REMOVED***
