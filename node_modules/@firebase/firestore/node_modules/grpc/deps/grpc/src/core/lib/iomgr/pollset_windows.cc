/*
 *
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include "src/core/lib/iomgr/port.h"

#ifdef GRPC_WINSOCK_SOCKET

#include <grpc/support/log.h>
#include <grpc/support/thd.h>

#include "src/core/lib/iomgr/iocp_windows.h"
#include "src/core/lib/iomgr/iomgr_internal.h"
#include "src/core/lib/iomgr/pollset.h"
#include "src/core/lib/iomgr/pollset_windows.h"

#define GRPC_POLLSET_KICK_BROADCAST ((grpc_pollset_worker*)1)

grpc_core::DebugOnlyTraceFlag grpc_trace_fd_refcount(false, "fd_refcount");

gpr_mu grpc_polling_mu;
static grpc_pollset_worker* g_active_poller;
static grpc_pollset_worker g_global_root_worker;

void grpc_pollset_global_init(void) ***REMOVED***
  gpr_mu_init(&grpc_polling_mu);
  g_active_poller = NULL;
  g_global_root_worker.links[GRPC_POLLSET_WORKER_LINK_GLOBAL].next =
      g_global_root_worker.links[GRPC_POLLSET_WORKER_LINK_GLOBAL].prev =
          &g_global_root_worker;
***REMOVED***

void grpc_pollset_global_shutdown(void) ***REMOVED*** gpr_mu_destroy(&grpc_polling_mu); ***REMOVED***

static void remove_worker(grpc_pollset_worker* worker,
                          grpc_pollset_worker_link_type type) ***REMOVED***
  worker->links[type].prev->links[type].next = worker->links[type].next;
  worker->links[type].next->links[type].prev = worker->links[type].prev;
  worker->links[type].next = worker->links[type].prev = worker;
***REMOVED***

static int has_workers(grpc_pollset_worker* root,
                       grpc_pollset_worker_link_type type) ***REMOVED***
  return root->links[type].next != root;
***REMOVED***

static grpc_pollset_worker* pop_front_worker(
    grpc_pollset_worker* root, grpc_pollset_worker_link_type type) ***REMOVED***
  if (has_workers(root, type)) ***REMOVED***
    grpc_pollset_worker* w = root->links[type].next;
    remove_worker(w, type);
    return w;
  ***REMOVED*** else ***REMOVED***
    return NULL;
  ***REMOVED***
***REMOVED***

static void push_front_worker(grpc_pollset_worker* root,
                              grpc_pollset_worker_link_type type,
                              grpc_pollset_worker* worker) ***REMOVED***
  worker->links[type].prev = root;
  worker->links[type].next = worker->links[type].prev->links[type].next;
  worker->links[type].prev->links[type].next =
      worker->links[type].next->links[type].prev = worker;
***REMOVED***

size_t grpc_pollset_size(void) ***REMOVED*** return sizeof(grpc_pollset); ***REMOVED***

/* There isn't really any such thing as a pollset under Windows, due to the
   nature of the IO completion ports. We're still going to provide a minimal
   set of features for the sake of the rest of grpc. But grpc_pollset_work
   won't actually do any polling, and return as quickly as possible. */

void grpc_pollset_init(grpc_pollset* pollset, gpr_mu** mu) ***REMOVED***
  *mu = &grpc_polling_mu;
  pollset->root_worker.links[GRPC_POLLSET_WORKER_LINK_POLLSET].next =
      pollset->root_worker.links[GRPC_POLLSET_WORKER_LINK_POLLSET].prev =
          &pollset->root_worker;
***REMOVED***

void grpc_pollset_shutdown(grpc_exec_ctx* exec_ctx, grpc_pollset* pollset,
                           grpc_closure* closure) ***REMOVED***
  pollset->shutting_down = 1;
  grpc_pollset_kick(exec_ctx, pollset, GRPC_POLLSET_KICK_BROADCAST);
  if (!pollset->is_iocp_worker) ***REMOVED***
    GRPC_CLOSURE_SCHED(exec_ctx, closure, GRPC_ERROR_NONE);
  ***REMOVED*** else ***REMOVED***
    pollset->on_shutdown = closure;
  ***REMOVED***
***REMOVED***

void grpc_pollset_destroy(grpc_exec_ctx* exec_ctx, grpc_pollset* pollset) ***REMOVED******REMOVED***

grpc_error* grpc_pollset_work(grpc_exec_ctx* exec_ctx, grpc_pollset* pollset,
                              grpc_pollset_worker** worker_hdl,
                              grpc_millis deadline) ***REMOVED***
  grpc_pollset_worker worker;
  if (worker_hdl) *worker_hdl = &worker;

  int added_worker = 0;
  worker.links[GRPC_POLLSET_WORKER_LINK_POLLSET].next =
      worker.links[GRPC_POLLSET_WORKER_LINK_POLLSET].prev =
          worker.links[GRPC_POLLSET_WORKER_LINK_GLOBAL].next =
              worker.links[GRPC_POLLSET_WORKER_LINK_GLOBAL].prev = NULL;
  worker.kicked = 0;
  worker.pollset = pollset;
  gpr_cv_init(&worker.cv);
  if (!pollset->kicked_without_pollers && !pollset->shutting_down) ***REMOVED***
    if (g_active_poller == NULL) ***REMOVED***
      grpc_pollset_worker* next_worker;
      /* become poller */
      pollset->is_iocp_worker = 1;
      g_active_poller = &worker;
      gpr_mu_unlock(&grpc_polling_mu);
      grpc_iocp_work(exec_ctx, deadline);
      grpc_exec_ctx_flush(exec_ctx);
      gpr_mu_lock(&grpc_polling_mu);
      pollset->is_iocp_worker = 0;
      g_active_poller = NULL;
      /* try to get a worker from this pollsets worker list */
      next_worker = pop_front_worker(&pollset->root_worker,
                                     GRPC_POLLSET_WORKER_LINK_POLLSET);
      if (next_worker == NULL) ***REMOVED***
        /* try to get a worker from the global list */
        next_worker = pop_front_worker(&g_global_root_worker,
                                       GRPC_POLLSET_WORKER_LINK_GLOBAL);
      ***REMOVED***
      if (next_worker != NULL) ***REMOVED***
        next_worker->kicked = 1;
        gpr_cv_signal(&next_worker->cv);
      ***REMOVED***

      if (pollset->shutting_down && pollset->on_shutdown != NULL) ***REMOVED***
        GRPC_CLOSURE_SCHED(exec_ctx, pollset->on_shutdown, GRPC_ERROR_NONE);
        pollset->on_shutdown = NULL;
      ***REMOVED***
      goto done;
    ***REMOVED***
    push_front_worker(&g_global_root_worker, GRPC_POLLSET_WORKER_LINK_GLOBAL,
                      &worker);
    push_front_worker(&pollset->root_worker, GRPC_POLLSET_WORKER_LINK_POLLSET,
                      &worker);
    added_worker = 1;
    while (!worker.kicked) ***REMOVED***
      if (gpr_cv_wait(&worker.cv, &grpc_polling_mu,
                      grpc_millis_to_timespec(deadline, GPR_CLOCK_REALTIME))) ***REMOVED***
        grpc_exec_ctx_invalidate_now(exec_ctx);
        break;
      ***REMOVED***
      grpc_exec_ctx_invalidate_now(exec_ctx);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    pollset->kicked_without_pollers = 0;
  ***REMOVED***
done:
  if (!grpc_closure_list_empty(exec_ctx->closure_list)) ***REMOVED***
    gpr_mu_unlock(&grpc_polling_mu);
    grpc_exec_ctx_flush(exec_ctx);
    gpr_mu_lock(&grpc_polling_mu);
  ***REMOVED***
  if (added_worker) ***REMOVED***
    remove_worker(&worker, GRPC_POLLSET_WORKER_LINK_GLOBAL);
    remove_worker(&worker, GRPC_POLLSET_WORKER_LINK_POLLSET);
  ***REMOVED***
  gpr_cv_destroy(&worker.cv);
  if (worker_hdl) *worker_hdl = NULL;
  return GRPC_ERROR_NONE;
***REMOVED***

grpc_error* grpc_pollset_kick(grpc_exec_ctx* exec_ctx, grpc_pollset* p,
                              grpc_pollset_worker* specific_worker) ***REMOVED***
  if (specific_worker != NULL) ***REMOVED***
    if (specific_worker == GRPC_POLLSET_KICK_BROADCAST) ***REMOVED***
      for (specific_worker =
               p->root_worker.links[GRPC_POLLSET_WORKER_LINK_POLLSET].next;
           specific_worker != &p->root_worker;
           specific_worker =
               specific_worker->links[GRPC_POLLSET_WORKER_LINK_POLLSET].next) ***REMOVED***
        specific_worker->kicked = 1;
        gpr_cv_signal(&specific_worker->cv);
      ***REMOVED***
      p->kicked_without_pollers = 1;
      if (p->is_iocp_worker) ***REMOVED***
        grpc_iocp_kick();
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (p->is_iocp_worker && g_active_poller == specific_worker) ***REMOVED***
        grpc_iocp_kick();
      ***REMOVED*** else ***REMOVED***
        specific_worker->kicked = 1;
        gpr_cv_signal(&specific_worker->cv);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    specific_worker =
        pop_front_worker(&p->root_worker, GRPC_POLLSET_WORKER_LINK_POLLSET);
    if (specific_worker != NULL) ***REMOVED***
      grpc_pollset_kick(exec_ctx, p, specific_worker);
    ***REMOVED*** else if (p->is_iocp_worker) ***REMOVED***
      grpc_iocp_kick();
    ***REMOVED*** else ***REMOVED***
      p->kicked_without_pollers = 1;
    ***REMOVED***
  ***REMOVED***
  return GRPC_ERROR_NONE;
***REMOVED***

#endif /* GRPC_WINSOCK_SOCKET */
