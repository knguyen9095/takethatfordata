/*
 *
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include "src/core/lib/transport/timeout_encoding.h"

#include <stdio.h>
#include <string.h>

#include <grpc/support/port_platform.h>
#include "src/core/lib/support/string.h"

static int64_t round_up(int64_t x, int64_t divisor) ***REMOVED***
  return (x / divisor + (x % divisor != 0)) * divisor;
***REMOVED***

/* round an integer up to the next value with three significant figures */
static int64_t round_up_to_three_sig_figs(int64_t x) ***REMOVED***
  if (x < 1000) return x;
  if (x < 10000) return round_up(x, 10);
  if (x < 100000) return round_up(x, 100);
  if (x < 1000000) return round_up(x, 1000);
  if (x < 10000000) return round_up(x, 10000);
  if (x < 100000000) return round_up(x, 100000);
  if (x < 1000000000) return round_up(x, 1000000);
  return round_up(x, 10000000);
***REMOVED***

/* encode our minimum viable timeout value */
static void enc_tiny(char* buffer) ***REMOVED*** memcpy(buffer, "1n", 3); ***REMOVED***

static void enc_ext(char* buffer, int64_t value, char ext) ***REMOVED***
  int n = int64_ttoa(value, buffer);
  buffer[n] = ext;
  buffer[n + 1] = 0;
***REMOVED***

static void enc_seconds(char* buffer, int64_t sec) ***REMOVED***
  if (sec % 3600 == 0) ***REMOVED***
    enc_ext(buffer, sec / 3600, 'H');
  ***REMOVED*** else if (sec % 60 == 0) ***REMOVED***
    enc_ext(buffer, sec / 60, 'M');
  ***REMOVED*** else ***REMOVED***
    enc_ext(buffer, sec, 'S');
  ***REMOVED***
***REMOVED***

static void enc_millis(char* buffer, int64_t x) ***REMOVED***
  x = round_up_to_three_sig_figs(x);
  if (x < GPR_MS_PER_SEC) ***REMOVED***
    enc_ext(buffer, x, 'm');
  ***REMOVED*** else ***REMOVED***
    if (x % GPR_MS_PER_SEC == 0) ***REMOVED***
      enc_seconds(buffer, x / GPR_MS_PER_SEC);
    ***REMOVED*** else ***REMOVED***
      enc_ext(buffer, x, 'm');
    ***REMOVED***
  ***REMOVED***
***REMOVED***

void grpc_http2_encode_timeout(grpc_millis timeout, char* buffer) ***REMOVED***
  if (timeout <= 0) ***REMOVED***
    enc_tiny(buffer);
  ***REMOVED*** else if (timeout < 1000 * GPR_MS_PER_SEC) ***REMOVED***
    enc_millis(buffer, timeout);
  ***REMOVED*** else ***REMOVED***
    enc_seconds(buffer,
                timeout / GPR_MS_PER_SEC + (timeout % GPR_MS_PER_SEC != 0));
  ***REMOVED***
***REMOVED***

static int is_all_whitespace(const char* p, const char* end) ***REMOVED***
  while (p != end && *p == ' ') p++;
  return p == end;
***REMOVED***

int grpc_http2_decode_timeout(grpc_slice text, grpc_millis* timeout) ***REMOVED***
  grpc_millis x = 0;
  const uint8_t* p = GRPC_SLICE_START_PTR(text);
  const uint8_t* end = GRPC_SLICE_END_PTR(text);
  int have_digit = 0;
  /* skip whitespace */
  for (; p != end && *p == ' '; p++)
    ;
  /* decode numeric part */
  for (; p != end && *p >= '0' && *p <= '9'; p++) ***REMOVED***
    int32_t digit = (int32_t)(*p - (uint8_t)'0');
    have_digit = 1;
    /* spec allows max. 8 digits, but we allow values up to 1,000,000,000 */
    if (x >= (100 * 1000 * 1000)) ***REMOVED***
      if (x != (100 * 1000 * 1000) || digit != 0) ***REMOVED***
        *timeout = GRPC_MILLIS_INF_FUTURE;
        return 1;
      ***REMOVED***
    ***REMOVED***
    x = x * 10 + digit;
  ***REMOVED***
  if (!have_digit) return 0;
  /* skip whitespace */
  for (; p != end && *p == ' '; p++)
    ;
  if (p == end) return 0;
  /* decode unit specifier */
  switch (*p) ***REMOVED***
    case 'n':
      *timeout = x / GPR_NS_PER_MS + (x % GPR_NS_PER_MS != 0);
      break;
    case 'u':
      *timeout = x / GPR_US_PER_MS + (x % GPR_US_PER_MS != 0);
      break;
    case 'm':
      *timeout = x;
      break;
    case 'S':
      *timeout = x * GPR_MS_PER_SEC;
      break;
    case 'M':
      *timeout = x * 60 * GPR_MS_PER_SEC;
      break;
    case 'H':
      *timeout = x * 60 * 60 * GPR_MS_PER_SEC;
      break;
    default:
      return 0;
  ***REMOVED***
  p++;
  return is_all_whitespace((const char*)p, (const char*)end);
***REMOVED***
