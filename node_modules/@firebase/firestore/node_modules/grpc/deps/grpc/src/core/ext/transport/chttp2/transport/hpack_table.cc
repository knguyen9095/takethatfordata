/*
 *
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include "src/core/ext/transport/chttp2/transport/hpack_table.h"

#include <assert.h>
#include <string.h>

#include <grpc/support/alloc.h>
#include <grpc/support/log.h>
#include <grpc/support/string_util.h>

#include "src/core/lib/debug/trace.h"
#include "src/core/lib/support/murmur_hash.h"

extern grpc_core::TraceFlag grpc_http_trace;

static struct ***REMOVED***
  const char* key;
  const char* value;
***REMOVED*** static_table[] = ***REMOVED***
    /* 0: */
    ***REMOVED***nullptr, nullptr***REMOVED***,
    /* 1: */
    ***REMOVED***":authority", ""***REMOVED***,
    /* 2: */
    ***REMOVED***":method", "GET"***REMOVED***,
    /* 3: */
    ***REMOVED***":method", "POST"***REMOVED***,
    /* 4: */
    ***REMOVED***":path", "/"***REMOVED***,
    /* 5: */
    ***REMOVED***":path", "/index.html"***REMOVED***,
    /* 6: */
    ***REMOVED***":scheme", "http"***REMOVED***,
    /* 7: */
    ***REMOVED***":scheme", "https"***REMOVED***,
    /* 8: */
    ***REMOVED***":status", "200"***REMOVED***,
    /* 9: */
    ***REMOVED***":status", "204"***REMOVED***,
    /* 10: */
    ***REMOVED***":status", "206"***REMOVED***,
    /* 11: */
    ***REMOVED***":status", "304"***REMOVED***,
    /* 12: */
    ***REMOVED***":status", "400"***REMOVED***,
    /* 13: */
    ***REMOVED***":status", "404"***REMOVED***,
    /* 14: */
    ***REMOVED***":status", "500"***REMOVED***,
    /* 15: */
    ***REMOVED***"accept-charset", ""***REMOVED***,
    /* 16: */
    ***REMOVED***"accept-encoding", "gzip, deflate"***REMOVED***,
    /* 17: */
    ***REMOVED***"accept-language", ""***REMOVED***,
    /* 18: */
    ***REMOVED***"accept-ranges", ""***REMOVED***,
    /* 19: */
    ***REMOVED***"accept", ""***REMOVED***,
    /* 20: */
    ***REMOVED***"access-control-allow-origin", ""***REMOVED***,
    /* 21: */
    ***REMOVED***"age", ""***REMOVED***,
    /* 22: */
    ***REMOVED***"allow", ""***REMOVED***,
    /* 23: */
    ***REMOVED***"authorization", ""***REMOVED***,
    /* 24: */
    ***REMOVED***"cache-control", ""***REMOVED***,
    /* 25: */
    ***REMOVED***"content-disposition", ""***REMOVED***,
    /* 26: */
    ***REMOVED***"content-encoding", ""***REMOVED***,
    /* 27: */
    ***REMOVED***"content-language", ""***REMOVED***,
    /* 28: */
    ***REMOVED***"content-length", ""***REMOVED***,
    /* 29: */
    ***REMOVED***"content-location", ""***REMOVED***,
    /* 30: */
    ***REMOVED***"content-range", ""***REMOVED***,
    /* 31: */
    ***REMOVED***"content-type", ""***REMOVED***,
    /* 32: */
    ***REMOVED***"cookie", ""***REMOVED***,
    /* 33: */
    ***REMOVED***"date", ""***REMOVED***,
    /* 34: */
    ***REMOVED***"etag", ""***REMOVED***,
    /* 35: */
    ***REMOVED***"expect", ""***REMOVED***,
    /* 36: */
    ***REMOVED***"expires", ""***REMOVED***,
    /* 37: */
    ***REMOVED***"from", ""***REMOVED***,
    /* 38: */
    ***REMOVED***"host", ""***REMOVED***,
    /* 39: */
    ***REMOVED***"if-match", ""***REMOVED***,
    /* 40: */
    ***REMOVED***"if-modified-since", ""***REMOVED***,
    /* 41: */
    ***REMOVED***"if-none-match", ""***REMOVED***,
    /* 42: */
    ***REMOVED***"if-range", ""***REMOVED***,
    /* 43: */
    ***REMOVED***"if-unmodified-since", ""***REMOVED***,
    /* 44: */
    ***REMOVED***"last-modified", ""***REMOVED***,
    /* 45: */
    ***REMOVED***"link", ""***REMOVED***,
    /* 46: */
    ***REMOVED***"location", ""***REMOVED***,
    /* 47: */
    ***REMOVED***"max-forwards", ""***REMOVED***,
    /* 48: */
    ***REMOVED***"proxy-authenticate", ""***REMOVED***,
    /* 49: */
    ***REMOVED***"proxy-authorization", ""***REMOVED***,
    /* 50: */
    ***REMOVED***"range", ""***REMOVED***,
    /* 51: */
    ***REMOVED***"referer", ""***REMOVED***,
    /* 52: */
    ***REMOVED***"refresh", ""***REMOVED***,
    /* 53: */
    ***REMOVED***"retry-after", ""***REMOVED***,
    /* 54: */
    ***REMOVED***"server", ""***REMOVED***,
    /* 55: */
    ***REMOVED***"set-cookie", ""***REMOVED***,
    /* 56: */
    ***REMOVED***"strict-transport-security", ""***REMOVED***,
    /* 57: */
    ***REMOVED***"transfer-encoding", ""***REMOVED***,
    /* 58: */
    ***REMOVED***"user-agent", ""***REMOVED***,
    /* 59: */
    ***REMOVED***"vary", ""***REMOVED***,
    /* 60: */
    ***REMOVED***"via", ""***REMOVED***,
    /* 61: */
    ***REMOVED***"www-authenticate", ""***REMOVED***,
***REMOVED***;

static uint32_t entries_for_bytes(uint32_t bytes) ***REMOVED***
  return (bytes + GRPC_CHTTP2_HPACK_ENTRY_OVERHEAD - 1) /
         GRPC_CHTTP2_HPACK_ENTRY_OVERHEAD;
***REMOVED***

void grpc_chttp2_hptbl_init(grpc_exec_ctx* exec_ctx, grpc_chttp2_hptbl* tbl) ***REMOVED***
  size_t i;

  memset(tbl, 0, sizeof(*tbl));
  tbl->current_table_bytes = tbl->max_bytes =
      GRPC_CHTTP2_INITIAL_HPACK_TABLE_SIZE;
  tbl->max_entries = tbl->cap_entries =
      entries_for_bytes(tbl->current_table_bytes);
  tbl->ents = (grpc_mdelem*)gpr_malloc(sizeof(*tbl->ents) * tbl->cap_entries);
  memset(tbl->ents, 0, sizeof(*tbl->ents) * tbl->cap_entries);
  for (i = 1; i <= GRPC_CHTTP2_LAST_STATIC_ENTRY; i++) ***REMOVED***
    tbl->static_ents[i - 1] = grpc_mdelem_from_slices(
        exec_ctx,
        grpc_slice_intern(grpc_slice_from_static_string(static_table[i].key)),
        grpc_slice_intern(
            grpc_slice_from_static_string(static_table[i].value)));
  ***REMOVED***
***REMOVED***

void grpc_chttp2_hptbl_destroy(grpc_exec_ctx* exec_ctx,
                               grpc_chttp2_hptbl* tbl) ***REMOVED***
  size_t i;
  for (i = 0; i < GRPC_CHTTP2_LAST_STATIC_ENTRY; i++) ***REMOVED***
    GRPC_MDELEM_UNREF(exec_ctx, tbl->static_ents[i]);
  ***REMOVED***
  for (i = 0; i < tbl->num_ents; i++) ***REMOVED***
    GRPC_MDELEM_UNREF(exec_ctx,
                      tbl->ents[(tbl->first_ent + i) % tbl->cap_entries]);
  ***REMOVED***
  gpr_free(tbl->ents);
***REMOVED***

grpc_mdelem grpc_chttp2_hptbl_lookup(const grpc_chttp2_hptbl* tbl,
                                     uint32_t tbl_index) ***REMOVED***
  /* Static table comes first, just return an entry from it */
  if (tbl_index <= GRPC_CHTTP2_LAST_STATIC_ENTRY) ***REMOVED***
    return tbl->static_ents[tbl_index - 1];
  ***REMOVED***
  /* Otherwise, find the value in the list of valid entries */
  tbl_index -= (GRPC_CHTTP2_LAST_STATIC_ENTRY + 1);
  if (tbl_index < tbl->num_ents) ***REMOVED***
    uint32_t offset =
        (tbl->num_ents - 1u - tbl_index + tbl->first_ent) % tbl->cap_entries;
    return tbl->ents[offset];
  ***REMOVED***
  /* Invalid entry: return error */
  return GRPC_MDNULL;
***REMOVED***

/* Evict one element from the table */
static void evict1(grpc_exec_ctx* exec_ctx, grpc_chttp2_hptbl* tbl) ***REMOVED***
  grpc_mdelem first_ent = tbl->ents[tbl->first_ent];
  size_t elem_bytes = GRPC_SLICE_LENGTH(GRPC_MDKEY(first_ent)) +
                      GRPC_SLICE_LENGTH(GRPC_MDVALUE(first_ent)) +
                      GRPC_CHTTP2_HPACK_ENTRY_OVERHEAD;
  GPR_ASSERT(elem_bytes <= tbl->mem_used);
  tbl->mem_used -= (uint32_t)elem_bytes;
  tbl->first_ent = ((tbl->first_ent + 1) % tbl->cap_entries);
  tbl->num_ents--;
  GRPC_MDELEM_UNREF(exec_ctx, first_ent);
***REMOVED***

static void rebuild_ents(grpc_chttp2_hptbl* tbl, uint32_t new_cap) ***REMOVED***
  grpc_mdelem* ents = (grpc_mdelem*)gpr_malloc(sizeof(*ents) * new_cap);
  uint32_t i;

  for (i = 0; i < tbl->num_ents; i++) ***REMOVED***
    ents[i] = tbl->ents[(tbl->first_ent + i) % tbl->cap_entries];
  ***REMOVED***
  gpr_free(tbl->ents);
  tbl->ents = ents;
  tbl->cap_entries = new_cap;
  tbl->first_ent = 0;
***REMOVED***

void grpc_chttp2_hptbl_set_max_bytes(grpc_exec_ctx* exec_ctx,
                                     grpc_chttp2_hptbl* tbl,
                                     uint32_t max_bytes) ***REMOVED***
  if (tbl->max_bytes == max_bytes) ***REMOVED***
    return;
  ***REMOVED***
  if (grpc_http_trace.enabled()) ***REMOVED***
    gpr_log(GPR_DEBUG, "Update hpack parser max size to %d", max_bytes);
  ***REMOVED***
  while (tbl->mem_used > max_bytes) ***REMOVED***
    evict1(exec_ctx, tbl);
  ***REMOVED***
  tbl->max_bytes = max_bytes;
***REMOVED***

grpc_error* grpc_chttp2_hptbl_set_current_table_size(grpc_exec_ctx* exec_ctx,
                                                     grpc_chttp2_hptbl* tbl,
                                                     uint32_t bytes) ***REMOVED***
  if (tbl->current_table_bytes == bytes) ***REMOVED***
    return GRPC_ERROR_NONE;
  ***REMOVED***
  if (bytes > tbl->max_bytes) ***REMOVED***
    char* msg;
    gpr_asprintf(&msg,
                 "Attempt to make hpack table %d bytes when max is %d bytes",
                 bytes, tbl->max_bytes);
    grpc_error* err = GRPC_ERROR_CREATE_FROM_COPIED_STRING(msg);
    gpr_free(msg);
    return err;
  ***REMOVED***
  if (grpc_http_trace.enabled()) ***REMOVED***
    gpr_log(GPR_DEBUG, "Update hpack parser table size to %d", bytes);
  ***REMOVED***
  while (tbl->mem_used > bytes) ***REMOVED***
    evict1(exec_ctx, tbl);
  ***REMOVED***
  tbl->current_table_bytes = bytes;
  tbl->max_entries = entries_for_bytes(bytes);
  if (tbl->max_entries > tbl->cap_entries) ***REMOVED***
    rebuild_ents(tbl, GPR_MAX(tbl->max_entries, 2 * tbl->cap_entries));
  ***REMOVED*** else if (tbl->max_entries < tbl->cap_entries / 3) ***REMOVED***
    uint32_t new_cap = GPR_MAX(tbl->max_entries, 16u);
    if (new_cap != tbl->cap_entries) ***REMOVED***
      rebuild_ents(tbl, new_cap);
    ***REMOVED***
  ***REMOVED***
  return GRPC_ERROR_NONE;
***REMOVED***

grpc_error* grpc_chttp2_hptbl_add(grpc_exec_ctx* exec_ctx,
                                  grpc_chttp2_hptbl* tbl, grpc_mdelem md) ***REMOVED***
  /* determine how many bytes of buffer this entry represents */
  size_t elem_bytes = GRPC_SLICE_LENGTH(GRPC_MDKEY(md)) +
                      GRPC_SLICE_LENGTH(GRPC_MDVALUE(md)) +
                      GRPC_CHTTP2_HPACK_ENTRY_OVERHEAD;

  if (tbl->current_table_bytes > tbl->max_bytes) ***REMOVED***
    char* msg;
    gpr_asprintf(
        &msg,
        "HPACK max table size reduced to %d but not reflected by hpack "
        "stream (still at %d)",
        tbl->max_bytes, tbl->current_table_bytes);
    grpc_error* err = GRPC_ERROR_CREATE_FROM_COPIED_STRING(msg);
    gpr_free(msg);
    return err;
  ***REMOVED***

  /* we can't add elements bigger than the max table size */
  if (elem_bytes > tbl->current_table_bytes) ***REMOVED***
    /* HPACK draft 10 section 4.4 states:
     * If the size of the new entry is less than or equal to the maximum
     * size, that entry is added to the table.  It is not an error to
     * attempt to add an entry that is larger than the maximum size; an
     * attempt to add an entry larger than the entire table causes
     * the table
     * to be emptied of all existing entries, and results in an
     * empty table.
     */
    while (tbl->num_ents) ***REMOVED***
      evict1(exec_ctx, tbl);
    ***REMOVED***
    return GRPC_ERROR_NONE;
  ***REMOVED***

  /* evict entries to ensure no overflow */
  while (elem_bytes > (size_t)tbl->current_table_bytes - tbl->mem_used) ***REMOVED***
    evict1(exec_ctx, tbl);
  ***REMOVED***

  /* copy the finalized entry in */
  tbl->ents[(tbl->first_ent + tbl->num_ents) % tbl->cap_entries] =
      GRPC_MDELEM_REF(md);

  /* update accounting values */
  tbl->num_ents++;
  tbl->mem_used += (uint32_t)elem_bytes;
  return GRPC_ERROR_NONE;
***REMOVED***

grpc_chttp2_hptbl_find_result grpc_chttp2_hptbl_find(
    const grpc_chttp2_hptbl* tbl, grpc_mdelem md) ***REMOVED***
  grpc_chttp2_hptbl_find_result r = ***REMOVED***0, 0***REMOVED***;
  uint32_t i;

  /* See if the string is in the static table */
  for (i = 0; i < GRPC_CHTTP2_LAST_STATIC_ENTRY; i++) ***REMOVED***
    grpc_mdelem ent = tbl->static_ents[i];
    if (!grpc_slice_eq(GRPC_MDKEY(md), GRPC_MDKEY(ent))) continue;
    r.index = i + 1u;
    r.has_value = grpc_slice_eq(GRPC_MDVALUE(md), GRPC_MDVALUE(ent));
    if (r.has_value) return r;
  ***REMOVED***

  /* Scan the dynamic table */
  for (i = 0; i < tbl->num_ents; i++) ***REMOVED***
    uint32_t idx =
        (uint32_t)(tbl->num_ents - i + GRPC_CHTTP2_LAST_STATIC_ENTRY);
    grpc_mdelem ent = tbl->ents[(tbl->first_ent + i) % tbl->cap_entries];
    if (!grpc_slice_eq(GRPC_MDKEY(md), GRPC_MDKEY(ent))) continue;
    r.index = idx;
    r.has_value = grpc_slice_eq(GRPC_MDVALUE(md), GRPC_MDVALUE(ent));
    if (r.has_value) return r;
  ***REMOVED***

  return r;
***REMOVED***
