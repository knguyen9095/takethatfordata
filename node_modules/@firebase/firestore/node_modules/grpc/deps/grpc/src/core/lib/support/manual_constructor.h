/*
 *
 * Copyright 2016 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#ifndef GRPC_CORE_LIB_SUPPORT_MANUAL_CONSTRUCTOR_H
#define GRPC_CORE_LIB_SUPPORT_MANUAL_CONSTRUCTOR_H

// manually construct a region of memory with some type

#include <stddef.h>
#include <stdlib.h>
#include <new>
#include <type_traits>
#include <utility>

#include <grpc/support/log.h>

namespace grpc_core ***REMOVED***

// this contains templated helpers needed to implement the ManualConstructors
// in this file.
namespace manual_ctor_impl ***REMOVED***

// is_one_of returns true it a class, Member, is present in a variadic list of
// classes, List.
template <class Member, class... List>
class is_one_of;

template <class Member, class... List>
class is_one_of<Member, Member, List...> ***REMOVED***
 public:
  static constexpr const bool value = true;
***REMOVED***;

template <class Member, class A, class... List>
class is_one_of<Member, A, List...> ***REMOVED***
 public:
  static constexpr const bool value = is_one_of<Member, List...>::value;
***REMOVED***;

template <class Member>
class is_one_of<Member> ***REMOVED***
 public:
  static constexpr const bool value = false;
***REMOVED***;

// max_size_of returns sizeof(Type) for the largest type in the variadic list
// of classes, Types.
template <class... Types>
class max_size_of;

template <class A>
class max_size_of<A> ***REMOVED***
 public:
  static constexpr const size_t value = sizeof(A);
***REMOVED***;

template <class A, class... B>
class max_size_of<A, B...> ***REMOVED***
 public:
  static constexpr const size_t value = sizeof(A) > max_size_of<B...>::value
                                            ? sizeof(A)
                                            : max_size_of<B...>::value;
***REMOVED***;

// max_size_of returns alignof(Type) for the largest type in the variadic list
// of classes, Types.
template <class... Types>
class max_align_of;

template <class A>
class max_align_of<A> ***REMOVED***
 public:
  static constexpr const size_t value = alignof(A);
***REMOVED***;

template <class A, class... B>
class max_align_of<A, B...> ***REMOVED***
 public:
  static constexpr const size_t value = alignof(A) > max_align_of<B...>::value
                                            ? alignof(A)
                                            : max_align_of<B...>::value;
***REMOVED***;

***REMOVED***  // namespace manual_ctor_impl

template <class BaseType, class... DerivedTypes>
class PolymorphicManualConstructor ***REMOVED***
 public:
  // No constructor or destructor because one of the most useful uses of
  // this class is as part of a union, and members of a union could not have
  // constructors or destructors till C++11.  And, anyway, the whole point of
  // this class is to bypass constructor and destructor.

  BaseType* get() ***REMOVED*** return reinterpret_cast<BaseType*>(&space_); ***REMOVED***
  const BaseType* get() const ***REMOVED***
    return reinterpret_cast<const BaseType*>(&space_);
  ***REMOVED***

  BaseType* operator->() ***REMOVED*** return get(); ***REMOVED***
  const BaseType* operator->() const ***REMOVED*** return get(); ***REMOVED***

  BaseType& operator*() ***REMOVED*** return *get(); ***REMOVED***
  const BaseType& operator*() const ***REMOVED*** return *get(); ***REMOVED***

  template <class DerivedType>
  void Init() ***REMOVED***
    FinishInit(new (&space_) DerivedType);
  ***REMOVED***

  // Init() constructs the Type instance using the given arguments
  // (which are forwarded to Type's constructor).
  //
  // Note that Init() with no arguments performs default-initialization,
  // not zero-initialization (i.e it behaves the same as "new Type;", not
  // "new Type();"), so it will leave non-class types uninitialized.
  template <class DerivedType, typename... Ts>
  void Init(Ts&&... args) ***REMOVED***
    FinishInit(new (&space_) DerivedType(std::forward<Ts>(args)...));
  ***REMOVED***

  // Init() that is equivalent to copy and move construction.
  // Enables usage like this:
  //   ManualConstructor<std::vector<int>> v;
  //   v.Init(***REMOVED***1, 2, 3***REMOVED***);
  template <class DerivedType>
  void Init(const DerivedType& x) ***REMOVED***
    FinishInit(new (&space_) DerivedType(x));
  ***REMOVED***
  template <class DerivedType>
  void Init(DerivedType&& x) ***REMOVED***
    FinishInit(new (&space_) DerivedType(std::move(x)));
  ***REMOVED***

  void Destroy() ***REMOVED*** get()->~BaseType(); ***REMOVED***

 private:
  template <class DerivedType>
  void FinishInit(DerivedType* p) ***REMOVED***
    static_assert(
        manual_ctor_impl::is_one_of<DerivedType, DerivedTypes...>::value,
        "DerivedType must be one of the predeclared DerivedTypes");
    GPR_ASSERT(reinterpret_cast<BaseType*>(static_cast<DerivedType*>(p)) == p);
  ***REMOVED***

  typename std::aligned_storage<
      grpc_core::manual_ctor_impl::max_size_of<DerivedTypes...>::value,
      grpc_core::manual_ctor_impl::max_align_of<DerivedTypes...>::value>::type
      space_;
***REMOVED***;

template <typename Type>
class ManualConstructor ***REMOVED***
 public:
  // No constructor or destructor because one of the most useful uses of
  // this class is as part of a union, and members of a union could not have
  // constructors or destructors till C++11.  And, anyway, the whole point of
  // this class is to bypass constructor and destructor.

  Type* get() ***REMOVED*** return reinterpret_cast<Type*>(&space_); ***REMOVED***
  const Type* get() const ***REMOVED*** return reinterpret_cast<const Type*>(&space_); ***REMOVED***

  Type* operator->() ***REMOVED*** return get(); ***REMOVED***
  const Type* operator->() const ***REMOVED*** return get(); ***REMOVED***

  Type& operator*() ***REMOVED*** return *get(); ***REMOVED***
  const Type& operator*() const ***REMOVED*** return *get(); ***REMOVED***

  void Init() ***REMOVED*** new (&space_) Type; ***REMOVED***

  // Init() constructs the Type instance using the given arguments
  // (which are forwarded to Type's constructor).
  //
  // Note that Init() with no arguments performs default-initialization,
  // not zero-initialization (i.e it behaves the same as "new Type;", not
  // "new Type();"), so it will leave non-class types uninitialized.
  template <typename... Ts>
  void Init(Ts&&... args) ***REMOVED***
    new (&space_) Type(std::forward<Ts>(args)...);
  ***REMOVED***

  // Init() that is equivalent to copy and move construction.
  // Enables usage like this:
  //   ManualConstructor<std::vector<int>> v;
  //   v.Init(***REMOVED***1, 2, 3***REMOVED***);
  void Init(const Type& x) ***REMOVED*** new (&space_) Type(x); ***REMOVED***
  void Init(Type&& x) ***REMOVED*** new (&space_) Type(std::move(x)); ***REMOVED***

  void Destroy() ***REMOVED*** get()->~Type(); ***REMOVED***

 private:
  typename std::aligned_storage<sizeof(Type), alignof(Type)>::type space_;
***REMOVED***;

***REMOVED***  // namespace grpc_core

#endif
