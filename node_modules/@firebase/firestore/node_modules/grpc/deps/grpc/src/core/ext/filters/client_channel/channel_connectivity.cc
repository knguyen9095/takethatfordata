/*
 *
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include "src/core/lib/surface/channel.h"

#include <inttypes.h>

#include <grpc/support/alloc.h>
#include <grpc/support/log.h>

#include "src/core/ext/filters/client_channel/client_channel.h"
#include "src/core/lib/iomgr/timer.h"
#include "src/core/lib/surface/api_trace.h"
#include "src/core/lib/surface/completion_queue.h"

grpc_connectivity_state grpc_channel_check_connectivity_state(
    grpc_channel* channel, int try_to_connect) ***REMOVED***
  /* forward through to the underlying client channel */
  grpc_channel_element* client_channel_elem =
      grpc_channel_stack_last_element(grpc_channel_get_channel_stack(channel));
  grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;
  grpc_connectivity_state state;
  GRPC_API_TRACE(
      "grpc_channel_check_connectivity_state(channel=%p, try_to_connect=%d)", 2,
      (channel, try_to_connect));
  if (client_channel_elem->filter == &grpc_client_channel_filter) ***REMOVED***
    state = grpc_client_channel_check_connectivity_state(
        &exec_ctx, client_channel_elem, try_to_connect);
    grpc_exec_ctx_finish(&exec_ctx);
    return state;
  ***REMOVED***
  gpr_log(GPR_ERROR,
          "grpc_channel_check_connectivity_state called on something that is "
          "not a client channel, but '%s'",
          client_channel_elem->filter->name);
  grpc_exec_ctx_finish(&exec_ctx);
  return GRPC_CHANNEL_SHUTDOWN;
***REMOVED***

typedef enum ***REMOVED***
  WAITING,
  READY_TO_CALL_BACK,
  CALLING_BACK_AND_FINISHED,
***REMOVED*** callback_phase;

typedef struct ***REMOVED***
  gpr_mu mu;
  callback_phase phase;
  grpc_closure on_complete;
  grpc_closure on_timeout;
  grpc_closure watcher_timer_init;
  grpc_timer alarm;
  grpc_connectivity_state state;
  grpc_completion_queue* cq;
  grpc_cq_completion completion_storage;
  grpc_channel* channel;
  grpc_error* error;
  void* tag;
***REMOVED*** state_watcher;

static void delete_state_watcher(grpc_exec_ctx* exec_ctx, state_watcher* w) ***REMOVED***
  grpc_channel_element* client_channel_elem = grpc_channel_stack_last_element(
      grpc_channel_get_channel_stack(w->channel));
  if (client_channel_elem->filter == &grpc_client_channel_filter) ***REMOVED***
    GRPC_CHANNEL_INTERNAL_UNREF(exec_ctx, w->channel,
                                "watch_channel_connectivity");
  ***REMOVED*** else ***REMOVED***
    abort();
  ***REMOVED***
  gpr_mu_destroy(&w->mu);
  gpr_free(w);
***REMOVED***

static void finished_completion(grpc_exec_ctx* exec_ctx, void* pw,
                                grpc_cq_completion* ignored) ***REMOVED***
  bool should_delete = false;
  state_watcher* w = (state_watcher*)pw;
  gpr_mu_lock(&w->mu);
  switch (w->phase) ***REMOVED***
    case WAITING:
    case READY_TO_CALL_BACK:
      GPR_UNREACHABLE_CODE(return );
    case CALLING_BACK_AND_FINISHED:
      should_delete = true;
      break;
  ***REMOVED***
  gpr_mu_unlock(&w->mu);

  if (should_delete) ***REMOVED***
    delete_state_watcher(exec_ctx, w);
  ***REMOVED***
***REMOVED***

static void partly_done(grpc_exec_ctx* exec_ctx, state_watcher* w,
                        bool due_to_completion, grpc_error* error) ***REMOVED***
  if (due_to_completion) ***REMOVED***
    grpc_timer_cancel(exec_ctx, &w->alarm);
  ***REMOVED*** else ***REMOVED***
    grpc_channel_element* client_channel_elem = grpc_channel_stack_last_element(
        grpc_channel_get_channel_stack(w->channel));
    grpc_client_channel_watch_connectivity_state(
        exec_ctx, client_channel_elem,
        grpc_polling_entity_create_from_pollset(grpc_cq_pollset(w->cq)),
        nullptr, &w->on_complete, nullptr);
  ***REMOVED***

  gpr_mu_lock(&w->mu);

  if (due_to_completion) ***REMOVED***
    if (grpc_trace_operation_failures.enabled()) ***REMOVED***
      GRPC_LOG_IF_ERROR("watch_completion_error", GRPC_ERROR_REF(error));
    ***REMOVED***
    GRPC_ERROR_UNREF(error);
    error = GRPC_ERROR_NONE;
  ***REMOVED*** else ***REMOVED***
    if (error == GRPC_ERROR_NONE) ***REMOVED***
      error = GRPC_ERROR_CREATE_FROM_STATIC_STRING(
          "Timed out waiting for connection state change");
    ***REMOVED*** else if (error == GRPC_ERROR_CANCELLED) ***REMOVED***
      error = GRPC_ERROR_NONE;
    ***REMOVED***
  ***REMOVED***
  switch (w->phase) ***REMOVED***
    case WAITING:
      GRPC_ERROR_REF(error);
      w->error = error;
      w->phase = READY_TO_CALL_BACK;
      break;
    case READY_TO_CALL_BACK:
      if (error != GRPC_ERROR_NONE) ***REMOVED***
        GPR_ASSERT(!due_to_completion);
        GRPC_ERROR_UNREF(w->error);
        GRPC_ERROR_REF(error);
        w->error = error;
      ***REMOVED***
      w->phase = CALLING_BACK_AND_FINISHED;
      grpc_cq_end_op(exec_ctx, w->cq, w->tag, w->error, finished_completion, w,
                     &w->completion_storage);
      break;
    case CALLING_BACK_AND_FINISHED:
      GPR_UNREACHABLE_CODE(return );
      break;
  ***REMOVED***
  gpr_mu_unlock(&w->mu);

  GRPC_ERROR_UNREF(error);
***REMOVED***

static void watch_complete(grpc_exec_ctx* exec_ctx, void* pw,
                           grpc_error* error) ***REMOVED***
  partly_done(exec_ctx, (state_watcher*)pw, true, GRPC_ERROR_REF(error));
***REMOVED***

static void timeout_complete(grpc_exec_ctx* exec_ctx, void* pw,
                             grpc_error* error) ***REMOVED***
  partly_done(exec_ctx, (state_watcher*)pw, false, GRPC_ERROR_REF(error));
***REMOVED***

int grpc_channel_num_external_connectivity_watchers(grpc_channel* channel) ***REMOVED***
  grpc_channel_element* client_channel_elem =
      grpc_channel_stack_last_element(grpc_channel_get_channel_stack(channel));
  return grpc_client_channel_num_external_connectivity_watchers(
      client_channel_elem);
***REMOVED***

typedef struct watcher_timer_init_arg ***REMOVED***
  state_watcher* w;
  gpr_timespec deadline;
***REMOVED*** watcher_timer_init_arg;

static void watcher_timer_init(grpc_exec_ctx* exec_ctx, void* arg,
                               grpc_error* error_ignored) ***REMOVED***
  watcher_timer_init_arg* wa = (watcher_timer_init_arg*)arg;

  grpc_timer_init(exec_ctx, &wa->w->alarm,
                  grpc_timespec_to_millis_round_up(wa->deadline),
                  &wa->w->on_timeout);
  gpr_free(wa);
***REMOVED***

int grpc_channel_support_connectivity_watcher(grpc_channel* channel) ***REMOVED***
  grpc_channel_element* client_channel_elem =
      grpc_channel_stack_last_element(grpc_channel_get_channel_stack(channel));
  return client_channel_elem->filter != &grpc_client_channel_filter ? 0 : 1;
***REMOVED***

void grpc_channel_watch_connectivity_state(
    grpc_channel* channel, grpc_connectivity_state last_observed_state,
    gpr_timespec deadline, grpc_completion_queue* cq, void* tag) ***REMOVED***
  grpc_channel_element* client_channel_elem =
      grpc_channel_stack_last_element(grpc_channel_get_channel_stack(channel));
  grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;
  state_watcher* w = (state_watcher*)gpr_malloc(sizeof(*w));

  GRPC_API_TRACE(
      "grpc_channel_watch_connectivity_state("
      "channel=%p, last_observed_state=%d, "
      "deadline=gpr_timespec ***REMOVED*** tv_sec: %" PRId64
      ", tv_nsec: %d, clock_type: %d ***REMOVED***, "
      "cq=%p, tag=%p)",
      7,
      (channel, (int)last_observed_state, deadline.tv_sec, deadline.tv_nsec,
       (int)deadline.clock_type, cq, tag));

  GPR_ASSERT(grpc_cq_begin_op(cq, tag));

  gpr_mu_init(&w->mu);
  GRPC_CLOSURE_INIT(&w->on_complete, watch_complete, w,
                    grpc_schedule_on_exec_ctx);
  GRPC_CLOSURE_INIT(&w->on_timeout, timeout_complete, w,
                    grpc_schedule_on_exec_ctx);
  w->phase = WAITING;
  w->state = last_observed_state;
  w->cq = cq;
  w->tag = tag;
  w->channel = channel;
  w->error = nullptr;

  watcher_timer_init_arg* wa =
      (watcher_timer_init_arg*)gpr_malloc(sizeof(watcher_timer_init_arg));
  wa->w = w;
  wa->deadline = deadline;
  GRPC_CLOSURE_INIT(&w->watcher_timer_init, watcher_timer_init, wa,
                    grpc_schedule_on_exec_ctx);

  if (client_channel_elem->filter == &grpc_client_channel_filter) ***REMOVED***
    GRPC_CHANNEL_INTERNAL_REF(channel, "watch_channel_connectivity");
    grpc_client_channel_watch_connectivity_state(
        &exec_ctx, client_channel_elem,
        grpc_polling_entity_create_from_pollset(grpc_cq_pollset(cq)), &w->state,
        &w->on_complete, &w->watcher_timer_init);
  ***REMOVED*** else ***REMOVED***
    abort();
  ***REMOVED***

  grpc_exec_ctx_finish(&exec_ctx);
***REMOVED***
