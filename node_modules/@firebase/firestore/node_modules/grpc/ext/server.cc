/*
 *
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <memory>

#include "server.h"

#include <nan.h>
#include <node.h>

#include <vector>
#include "call.h"
#include "completion_queue.h"
#include "grpc/grpc.h"
#include "grpc/grpc_security.h"
#include "grpc/support/log.h"
#include "server_credentials.h"
#include "slice.h"
#include "timeval.h"

namespace grpc ***REMOVED***
namespace node ***REMOVED***

using Nan::Callback;
using Nan::EscapableHandleScope;
using Nan::HandleScope;
using Nan::Maybe;
using Nan::MaybeLocal;
using Nan::ObjectWrap;
using Nan::Persistent;
using Nan::Utf8String;

using std::unique_ptr;
using v8::Array;
using v8::Boolean;
using v8::Date;
using v8::Exception;
using v8::External;
using v8::Function;
using v8::FunctionTemplate;
using v8::Local;
using v8::Number;
using v8::Object;
using v8::String;
using v8::Value;

Nan::Callback *Server::constructor;
Persistent<FunctionTemplate> Server::fun_tpl;

static Callback *shutdown_callback = NULL;

class ServerShutdownOp : public Op ***REMOVED***
 public:
  ServerShutdownOp(grpc_server *server) : server(server) ***REMOVED******REMOVED***

  ~ServerShutdownOp() ***REMOVED******REMOVED***

  Local<Value> GetNodeValue() const ***REMOVED*** return Nan::Null(); ***REMOVED***

  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED*** return true; ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return false; ***REMOVED***
  void OnComplete(bool success) ***REMOVED***
    /* Because cancel_all_calls was called, we assume that shutdown_and_notify
       completes successfully */
    grpc_server_destroy(server);
  ***REMOVED***

  grpc_server *server;

 protected:
  std::string GetTypeString() const ***REMOVED*** return "shutdown"; ***REMOVED***
***REMOVED***;

class NewCallOp : public Op ***REMOVED***
 public:
  NewCallOp() ***REMOVED***
    call = NULL;
    grpc_call_details_init(&details);
    grpc_metadata_array_init(&request_metadata);
  ***REMOVED***

  ~NewCallOp() ***REMOVED***
    grpc_call_details_destroy(&details);
    grpc_metadata_array_destroy(&request_metadata);
  ***REMOVED***

  Local<Value> GetNodeValue() const ***REMOVED***
    Nan::EscapableHandleScope scope;
    if (call == NULL) ***REMOVED***
      return scope.Escape(Nan::Null());
    ***REMOVED***
    Local<Object> obj = Nan::New<Object>();
    Nan::Set(obj, Nan::New("call").ToLocalChecked(), Call::WrapStruct(call));
    // TODO(murgatroid99): Use zero-copy string construction instead
    Nan::Set(obj, Nan::New("method").ToLocalChecked(),
             CopyStringFromSlice(details.method));
    Nan::Set(obj, Nan::New("host").ToLocalChecked(),
             CopyStringFromSlice(details.host));
    Nan::Set(obj, Nan::New("deadline").ToLocalChecked(),
             Nan::New<Date>(TimespecToMilliseconds(details.deadline))
                 .ToLocalChecked());
    Nan::Set(obj, Nan::New("metadata").ToLocalChecked(),
             ParseMetadata(&request_metadata));
    return scope.Escape(obj);
  ***REMOVED***

  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED*** return true; ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return false; ***REMOVED***
  void OnComplete(bool success) ***REMOVED******REMOVED***

  grpc_call *call;
  grpc_call_details details;
  grpc_metadata_array request_metadata;

 protected:
  std::string GetTypeString() const ***REMOVED*** return "new_call"; ***REMOVED***
***REMOVED***;

class TryShutdownOp : public Op ***REMOVED***
 public:
  TryShutdownOp(Server *server, Local<Value> server_value) : server(server) ***REMOVED***
    server_persist.Reset(server_value);
  ***REMOVED***
  Local<Value> GetNodeValue() const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(Nan::New(server_persist));
  ***REMOVED***
  bool ParseOp(Local<Value> value, grpc_op *out) ***REMOVED*** return true; ***REMOVED***
  bool IsFinalOp() ***REMOVED*** return false; ***REMOVED***
  void OnComplete(bool success) ***REMOVED***
    if (success) ***REMOVED***
      server->DestroyWrappedServer();
    ***REMOVED***
  ***REMOVED***

 protected:
  std::string GetTypeString() const ***REMOVED*** return "try_shutdown"; ***REMOVED***

 private:
  Server *server;
  Nan::Persistent<v8::Value, Nan::CopyablePersistentTraits<v8::Value>>
      server_persist;
***REMOVED***;

Server::Server(grpc_server *server) : wrapped_server(server) ***REMOVED******REMOVED***

Server::~Server() ***REMOVED*** this->ShutdownServer(); ***REMOVED***

void Server::Init(Local<Object> exports) ***REMOVED***
  HandleScope scope;
  Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(New);
  tpl->SetClassName(Nan::New("Server").ToLocalChecked());
  tpl->InstanceTemplate()->SetInternalFieldCount(1);
  Nan::SetPrototypeMethod(tpl, "requestCall", RequestCall);
  Nan::SetPrototypeMethod(tpl, "addHttp2Port", AddHttp2Port);
  Nan::SetPrototypeMethod(tpl, "start", Start);
  Nan::SetPrototypeMethod(tpl, "tryShutdown", TryShutdown);
  Nan::SetPrototypeMethod(tpl, "forceShutdown", ForceShutdown);
  fun_tpl.Reset(tpl);
  Local<Function> ctr = Nan::GetFunction(tpl).ToLocalChecked();
  Nan::Set(exports, Nan::New("Server").ToLocalChecked(), ctr);
  constructor = new Callback(ctr);
***REMOVED***

bool Server::HasInstance(Local<Value> val) ***REMOVED***
  HandleScope scope;
  return Nan::New(fun_tpl)->HasInstance(val);
***REMOVED***

void Server::DestroyWrappedServer() ***REMOVED***
  if (this->wrapped_server != NULL) ***REMOVED***
    grpc_server_destroy(this->wrapped_server);
    this->wrapped_server = NULL;
  ***REMOVED***
***REMOVED***

NAN_METHOD(ServerShutdownCallback) ***REMOVED***
  if (!info[0]->IsNull()) ***REMOVED***
    return Nan::ThrowError("forceShutdown failed somehow");
  ***REMOVED***
***REMOVED***

void Server::ShutdownServer() ***REMOVED***
  Nan::HandleScope scope;
  if (this->wrapped_server != NULL) ***REMOVED***
    if (shutdown_callback == NULL) ***REMOVED***
      Local<FunctionTemplate> callback_tpl =
          Nan::New<FunctionTemplate>(ServerShutdownCallback);
      shutdown_callback =
          new Callback(Nan::GetFunction(callback_tpl).ToLocalChecked());
    ***REMOVED***

    ServerShutdownOp *op = new ServerShutdownOp(this->wrapped_server);
    unique_ptr<OpVec> ops(new OpVec());
    ops->push_back(unique_ptr<Op>(op));

    grpc_server_shutdown_and_notify(
        this->wrapped_server, GetCompletionQueue(),
        new struct tag(new Callback(**shutdown_callback), ops.release(), NULL,
                       Nan::Null()));
    grpc_server_cancel_all_calls(this->wrapped_server);
    CompletionQueueNext();
    this->wrapped_server = NULL;
  ***REMOVED***
***REMOVED***

NAN_METHOD(Server::New) ***REMOVED***
  /* If this is not a constructor call, make a constructor call and return
     the result */
  if (!info.IsConstructCall()) ***REMOVED***
    const int argc = 1;
    Local<Value> argv[argc] = ***REMOVED***info[0]***REMOVED***;
    MaybeLocal<Object> maybe_instance =
        Nan::NewInstance(constructor->GetFunction(), argc, argv);
    if (maybe_instance.IsEmpty()) ***REMOVED***
      // There's probably a pending exception
      return;
    ***REMOVED*** else ***REMOVED***
      info.GetReturnValue().Set(maybe_instance.ToLocalChecked());
      return;
    ***REMOVED***
  ***REMOVED***
  grpc_server *wrapped_server;
  grpc_completion_queue *queue = GetCompletionQueue();
  grpc_channel_args *channel_args;
  if (!ParseChannelArgs(info[0], &channel_args)) ***REMOVED***
    DeallocateChannelArgs(channel_args);
    return Nan::ThrowTypeError(
        "Server options must be an object with "
        "string keys and integer or string values");
  ***REMOVED***
  wrapped_server = grpc_server_create(channel_args, NULL);
  DeallocateChannelArgs(channel_args);
  grpc_server_register_completion_queue(wrapped_server, queue, NULL);
  Server *server = new Server(wrapped_server);
  server->Wrap(info.This());
  info.GetReturnValue().Set(info.This());
***REMOVED***

NAN_METHOD(Server::RequestCall) ***REMOVED***
  if (!HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError("requestCall can only be called on a Server");
  ***REMOVED***
  Server *server = ObjectWrap::Unwrap<Server>(info.This());
  NewCallOp *op = new NewCallOp();
  unique_ptr<OpVec> ops(new OpVec());
  ops->push_back(unique_ptr<Op>(op));
  grpc_call_error error = grpc_server_request_call(
      server->wrapped_server, &op->call, &op->details, &op->request_metadata,
      GetCompletionQueue(), GetCompletionQueue(),
      new struct tag(new Callback(info[0].As<Function>()), ops.release(), NULL,
                     Nan::Null()));
  if (error != GRPC_CALL_OK) ***REMOVED***
    return Nan::ThrowError(nanErrorWithCode("requestCall failed", error));
  ***REMOVED***
  CompletionQueueNext();
***REMOVED***

NAN_METHOD(Server::AddHttp2Port) ***REMOVED***
  if (!HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError("addHttp2Port can only be called on a Server");
  ***REMOVED***
  if (!info[0]->IsString()) ***REMOVED***
    return Nan::ThrowTypeError(
        "addHttp2Port's first argument must be a String");
  ***REMOVED***
  if (!ServerCredentials::HasInstance(info[1])) ***REMOVED***
    return Nan::ThrowTypeError(
        "addHttp2Port's second argument must be ServerCredentials");
  ***REMOVED***
  Server *server = ObjectWrap::Unwrap<Server>(info.This());
  ServerCredentials *creds_object = ObjectWrap::Unwrap<ServerCredentials>(
      Nan::To<Object>(info[1]).ToLocalChecked());
  grpc_server_credentials *creds = creds_object->GetWrappedServerCredentials();
  int port;
  if (creds == NULL) ***REMOVED***
    port = grpc_server_add_insecure_http2_port(server->wrapped_server,
                                               *Utf8String(info[0]));
  ***REMOVED*** else ***REMOVED***
    port = grpc_server_add_secure_http2_port(server->wrapped_server,
                                             *Utf8String(info[0]), creds);
  ***REMOVED***
  info.GetReturnValue().Set(Nan::New<Number>(port));
***REMOVED***

NAN_METHOD(Server::Start) ***REMOVED***
  Nan::HandleScope scope;
  if (!HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError("start can only be called on a Server");
  ***REMOVED***
  Server *server = ObjectWrap::Unwrap<Server>(info.This());
  grpc_server_start(server->wrapped_server);
***REMOVED***

NAN_METHOD(Server::TryShutdown) ***REMOVED***
  Nan::HandleScope scope;
  if (!HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError("tryShutdown can only be called on a Server");
  ***REMOVED***
  if (!info[0]->IsFunction()) ***REMOVED***
    return Nan::ThrowError("tryShutdown's argument must be a callback");
  ***REMOVED***
  Server *server = ObjectWrap::Unwrap<Server>(info.This());
  if (server->wrapped_server == NULL) ***REMOVED***
    // Server is already shut down. Call callback immediately.
    Nan::Callback callback(info[0].As<Function>());
    callback.Call(0, ***REMOVED******REMOVED***);
    return;
  ***REMOVED***
  TryShutdownOp *op = new TryShutdownOp(server, info.This());
  unique_ptr<OpVec> ops(new OpVec());
  ops->push_back(unique_ptr<Op>(op));
  grpc_server_shutdown_and_notify(
      server->wrapped_server, GetCompletionQueue(),
      new struct tag(new Nan::Callback(info[0].As<Function>()), ops.release(),
                     NULL, Nan::Null()));
  CompletionQueueNext();
***REMOVED***

NAN_METHOD(Server::ForceShutdown) ***REMOVED***
  Nan::HandleScope scope;
  if (!HasInstance(info.This())) ***REMOVED***
    return Nan::ThrowTypeError("forceShutdown can only be called on a Server");
  ***REMOVED***
  Server *server = ObjectWrap::Unwrap<Server>(info.This());
  server->ShutdownServer();
***REMOVED***

***REMOVED***  // namespace node
***REMOVED***  // namespace grpc
