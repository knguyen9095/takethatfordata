/**
 * @license
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/**
 * Client module
 *
 * This module contains the factory method for creating Client classes, and the
 * method calling code for all types of methods.
 *
 * @example <caption>Create a client and call a method on it</caption>
 *
 * var proto_obj = grpc.load(proto_file_path);
 * var Client = proto_obj.package.subpackage.ServiceName;
 * var client = new Client(server_address, client_credentials);
 * var call = client.unaryMethod(arguments, callback);
 */

'use strict';

var _ = require('lodash');
var arguejs = require('arguejs');

var grpc = require('./grpc_extension');

var common = require('./common');

var Metadata = require('./metadata');

var constants = require('./constants');

var EventEmitter = require('events').EventEmitter;

var stream = require('stream');

var Readable = stream.Readable;
var Writable = stream.Writable;
var Duplex = stream.Duplex;
var util = require('util');
var version = require('../package.json').version;

/**
 * Create an Error object from a status object
 * @private
 * @param ***REMOVED***grpc~StatusObject***REMOVED*** status The status object
 * @return ***REMOVED***Error***REMOVED*** The resulting Error
 */
function createStatusError(status) ***REMOVED***
  let statusName = _.invert(constants.status)[status.code];
  let message = `$***REMOVED***status.code***REMOVED*** $***REMOVED***statusName***REMOVED***: $***REMOVED***status.details***REMOVED***`;
  let error = new Error(message);
  error.code = status.code;
  error.metadata = status.metadata;
  error.details = status.details;
  return error;
***REMOVED***

/**
 * Initial response metadata sent by the server when it starts processing the
 * call
 * @event grpc~ClientUnaryCall#metadata
 * @type ***REMOVED***grpc.Metadata***REMOVED***
 */

/**
 * Status of the call when it has completed.
 * @event grpc~ClientUnaryCall#status
 * @type grpc~StatusObject
 */

util.inherits(ClientUnaryCall, EventEmitter);

/**
 * An EventEmitter. Used for unary calls.
 * @constructor grpc~ClientUnaryCall
 * @extends external:EventEmitter
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call object associated with the request
 */
function ClientUnaryCall(call) ***REMOVED***
  EventEmitter.call(this);
  this.call = call;
***REMOVED***

util.inherits(ClientWritableStream, Writable);

/**
 * A stream that the client can write to. Used for calls that are streaming from
 * the client side.
 * @constructor grpc~ClientWritableStream
 * @extends external:Writable
 * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientWritableStream#cancel
 * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientWritableStream#getPeer
 * @borrows grpc~ClientUnaryCall#event:metadata as
 *     grpc~ClientWritableStream#metadata
 * @borrows grpc~ClientUnaryCall#event:status as
 *     grpc~ClientWritableStream#status
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call object to send data with
 * @param ***REMOVED***grpc~serialize=***REMOVED*** [serialize=identity] Serialization
 *     function for writes.
 */
function ClientWritableStream(call, serialize) ***REMOVED***
  Writable.call(this, ***REMOVED***objectMode: true***REMOVED***);
  this.call = call;
  this.serialize = common.wrapIgnoreNull(serialize);
  this.on('finish', function() ***REMOVED***
    var batch = ***REMOVED******REMOVED***;
    batch[grpc.opType.SEND_CLOSE_FROM_CLIENT] = true;
    call.startBatch(batch, function() ***REMOVED******REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Write a message to the request stream. If serializing the argument fails,
 * the call will be cancelled and the stream will end with an error.
 * @name grpc~ClientWritableStream#write
 * @kind function
 * @override
 * @param ***REMOVED*******REMOVED*** message The message to write. Must be a valid argument to the
 *     serialize function of the corresponding method
 * @param ***REMOVED***grpc.writeFlags***REMOVED*** flags Flags to modify how the message is written
 * @param ***REMOVED***Function***REMOVED*** callback Callback for when this chunk of data is flushed
 * @return ***REMOVED***boolean***REMOVED*** As defined for [Writable]***REMOVED***@link external:Writable***REMOVED***
 */

/**
 * Attempt to write the given chunk. Calls the callback when done. This is an
 * implementation of a method needed for implementing stream.Writable.
 * @private
 * @param ***REMOVED*******REMOVED*** chunk The chunk to write
 * @param ***REMOVED***grpc.writeFlags***REMOVED*** encoding Used to pass write flags
 * @param ***REMOVED***function(Error=)***REMOVED*** callback Called when the write is complete
 */
function _write(chunk, encoding, callback) ***REMOVED***
  /* jshint validthis: true */
  var batch = ***REMOVED******REMOVED***;
  var message;
  var self = this;
  if (this.writeFailed) ***REMOVED***
    /* Once a write fails, just call the callback immediately to let the caller
       flush any pending writes. */
    setImmediate(callback);
    return;
  ***REMOVED***
  try ***REMOVED***
    message = this.serialize(chunk);
  ***REMOVED*** catch (e) ***REMOVED***
    /* Sending this error to the server and emitting it immediately on the
       client may put the call in a slightly weird state on the client side,
       but passing an object that causes a serialization failure is a misuse
       of the API anyway, so that's OK. The primary purpose here is to give the
       programmer a useful error and to stop the stream properly */
    this.call.cancelWithStatus(constants.status.INTERNAL,
                               'Serialization failure');
    callback(e);
    return;
  ***REMOVED***
  if (_.isFinite(encoding)) ***REMOVED***
    /* Attach the encoding if it is a finite number. This is the closest we
     * can get to checking that it is valid flags */
    message.grpcWriteFlags = encoding;
  ***REMOVED***
  batch[grpc.opType.SEND_MESSAGE] = message;
  this.call.startBatch(batch, function(err, event) ***REMOVED***
    if (err) ***REMOVED***
      /* Assume that the call is complete and that writing failed because a
         status was received. In that case, set a flag to discard all future
         writes */
      self.writeFailed = true;
    ***REMOVED***
    callback();
  ***REMOVED***);
***REMOVED***

ClientWritableStream.prototype._write = _write;

util.inherits(ClientReadableStream, Readable);

/**
 * A stream that the client can read from. Used for calls that are streaming
 * from the server side.
 * @constructor grpc~ClientReadableStream
 * @extends external:Readable
 * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientReadableStream#cancel
 * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientReadableStream#getPeer
 * @borrows grpc~ClientUnaryCall#event:metadata as
 *     grpc~ClientReadableStream#metadata
 * @borrows grpc~ClientUnaryCall#event:status as
 *     grpc~ClientReadableStream#status
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call object to read data with
 * @param ***REMOVED***grpc~deserialize=***REMOVED*** [deserialize=identity]
 *     Deserialization function for reads
 */
function ClientReadableStream(call, deserialize) ***REMOVED***
  Readable.call(this, ***REMOVED***objectMode: true***REMOVED***);
  this.call = call;
  this.finished = false;
  this.reading = false;
  this.deserialize = common.wrapIgnoreNull(deserialize);
  /* Status generated from reading messages from the server. Overrides the
   * status from the server if not OK */
  this.read_status = null;
  /* Status received from the server. */
  this.received_status = null;
***REMOVED***

/**
 * Called when all messages from the server have been processed. The status
 * parameter indicates that the call should end with that status. status
 * defaults to OK if not provided.
 * @param ***REMOVED***Object!***REMOVED*** status The status that the call should end with
 * @private
 */
function _readsDone(status) ***REMOVED***
  /* jshint validthis: true */
  if (!status) ***REMOVED***
    status = ***REMOVED***code: constants.status.OK, details: 'OK'***REMOVED***;
  ***REMOVED***
  if (status.code !== constants.status.OK) ***REMOVED***
    this.call.cancelWithStatus(status.code, status.details);
  ***REMOVED***
  this.finished = true;
  this.read_status = status;
  this._emitStatusIfDone();
***REMOVED***

ClientReadableStream.prototype._readsDone = _readsDone;

/**
 * Called to indicate that we have received a status from the server.
 * @private
 */
function _receiveStatus(status) ***REMOVED***
  /* jshint validthis: true */
  this.received_status = status;
  this._emitStatusIfDone();
***REMOVED***

ClientReadableStream.prototype._receiveStatus = _receiveStatus;

/**
 * If we have both processed all incoming messages and received the status from
 * the server, emit the status. Otherwise, do nothing.
 * @private
 */
function _emitStatusIfDone() ***REMOVED***
  /* jshint validthis: true */
  var status;
  if (this.read_status && this.received_status) ***REMOVED***
    if (this.read_status.code !== constants.status.OK) ***REMOVED***
      status = this.read_status;
    ***REMOVED*** else ***REMOVED***
      status = this.received_status;
    ***REMOVED***
    if (status.code === constants.status.OK) ***REMOVED***
      this.push(null);
    ***REMOVED*** else ***REMOVED***
      var error = createStatusError(status);
      this.emit('error', error);
    ***REMOVED***
    this.emit('status', status);
  ***REMOVED***
***REMOVED***

ClientReadableStream.prototype._emitStatusIfDone = _emitStatusIfDone;

/**
 * Read the next object from the stream.
 * @private
 * @param ***REMOVED*******REMOVED*** size Ignored because we use objectMode=true
 */
function _read(size) ***REMOVED***
  /* jshint validthis: true */
  var self = this;
  /**
   * Callback to be called when a READ event is received. Pushes the data onto
   * the read queue and starts reading again if applicable
   * @param ***REMOVED***grpc.Event***REMOVED*** event READ event object
   */
  function readCallback(err, event) ***REMOVED***
    if (err) ***REMOVED***
      // Something has gone wrong. Stop reading and wait for status
      self.finished = true;
      self._readsDone();
      return;
    ***REMOVED***
    var data = event.read;
    var deserialized;
    try ***REMOVED***
      deserialized = self.deserialize(data);
    ***REMOVED*** catch (e) ***REMOVED***
      self._readsDone(***REMOVED***code: constants.status.INTERNAL,
                       details: 'Failed to parse server response'***REMOVED***);
      return;
    ***REMOVED***
    if (data === null) ***REMOVED***
      self._readsDone();
      return;
    ***REMOVED***
    if (self.push(deserialized) && data !== null) ***REMOVED***
      var read_batch = ***REMOVED******REMOVED***;
      read_batch[grpc.opType.RECV_MESSAGE] = true;
      self.call.startBatch(read_batch, readCallback);
    ***REMOVED*** else ***REMOVED***
      self.reading = false;
    ***REMOVED***
  ***REMOVED***
  if (self.finished) ***REMOVED***
    self.push(null);
  ***REMOVED*** else ***REMOVED***
    if (!self.reading) ***REMOVED***
      self.reading = true;
      var read_batch = ***REMOVED******REMOVED***;
      read_batch[grpc.opType.RECV_MESSAGE] = true;
      self.call.startBatch(read_batch, readCallback);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

ClientReadableStream.prototype._read = _read;

util.inherits(ClientDuplexStream, Duplex);

/**
 * A stream that the client can read from or write to. Used for calls with
 * duplex streaming.
 * @constructor grpc~ClientDuplexStream
 * @extends external:Duplex
 * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientDuplexStream#cancel
 * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientDuplexStream#getPeer
 * @borrows grpc~ClientWritableStream#write as grpc~ClientDuplexStream#write
 * @borrows grpc~ClientUnaryCall#event:metadata as
 *     grpc~ClientDuplexStream#metadata
 * @borrows grpc~ClientUnaryCall#event:status as
 *     grpc~ClientDuplexStream#status
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call Call object to proxy
 * @param ***REMOVED***grpc~serialize=***REMOVED*** [serialize=identity] Serialization
 *     function for requests
 * @param ***REMOVED***grpc~deserialize=***REMOVED*** [deserialize=identity]
 *     Deserialization function for responses
 */
function ClientDuplexStream(call, serialize, deserialize) ***REMOVED***
  Duplex.call(this, ***REMOVED***objectMode: true***REMOVED***);
  this.serialize = common.wrapIgnoreNull(serialize);
  this.deserialize = common.wrapIgnoreNull(deserialize);
  this.call = call;
  /* Status generated from reading messages from the server. Overrides the
   * status from the server if not OK */
  this.read_status = null;
  /* Status received from the server. */
  this.received_status = null;
  this.on('finish', function() ***REMOVED***
    var batch = ***REMOVED******REMOVED***;
    batch[grpc.opType.SEND_CLOSE_FROM_CLIENT] = true;
    call.startBatch(batch, function() ***REMOVED******REMOVED***);
  ***REMOVED***);
***REMOVED***

ClientDuplexStream.prototype._readsDone = _readsDone;
ClientDuplexStream.prototype._receiveStatus = _receiveStatus;
ClientDuplexStream.prototype._emitStatusIfDone = _emitStatusIfDone;
ClientDuplexStream.prototype._read = _read;
ClientDuplexStream.prototype._write = _write;

/**
 * Cancel the ongoing call. Results in the call ending with a CANCELLED status,
 * unless it has already ended with some other status.
 * @alias grpc~ClientUnaryCall#cancel
 */
function cancel() ***REMOVED***
  /* jshint validthis: true */
  this.call.cancel();
***REMOVED***

ClientUnaryCall.prototype.cancel = cancel;
ClientReadableStream.prototype.cancel = cancel;
ClientWritableStream.prototype.cancel = cancel;
ClientDuplexStream.prototype.cancel = cancel;

/**
 * Get the endpoint this call/stream is connected to.
 * @return ***REMOVED***string***REMOVED*** The URI of the endpoint
 * @alias grpc~ClientUnaryCall#getPeer
 */
function getPeer() ***REMOVED***
  /* jshint validthis: true */
  return this.call.getPeer();
***REMOVED***

ClientUnaryCall.prototype.getPeer = getPeer;
ClientReadableStream.prototype.getPeer = getPeer;
ClientWritableStream.prototype.getPeer = getPeer;
ClientDuplexStream.prototype.getPeer = getPeer;

/**
 * Any client call type
 * @typedef ***REMOVED***(grpc~ClientUnaryCall|grpc~ClientReadableStream|
 *            grpc~ClientWritableStream|grpc~ClientDuplexStream)***REMOVED***
 *     grpc.Client~Call
 */

/**
 * Options that can be set on a call.
 * @typedef ***REMOVED***Object***REMOVED*** grpc.Client~CallOptions
 * @property ***REMOVED***grpc~Deadline***REMOVED*** deadline The deadline for the entire call to
 *     complete.
 * @property ***REMOVED***string***REMOVED*** host Server hostname to set on the call. Only meaningful
 *     if different from the server address used to construct the client.
 * @property ***REMOVED***grpc.Client~Call***REMOVED*** parent Parent call. Used in servers when
 *     making a call as part of the process of handling a call. Used to
 *     propagate some information automatically, as specified by
 *     propagate_flags.
 * @property ***REMOVED***number***REMOVED*** propagate_flags Indicates which properties of a parent
 *     call should propagate to this call. Bitwise combination of flags in
 *     ***REMOVED***@link grpc.propagate***REMOVED***.
 * @property ***REMOVED***grpc.credentials~CallCredentials***REMOVED*** credentials The credentials that
 *     should be used to make this particular call.
 */

/**
 * Get a call object built with the provided options.
 * @access private
 * @param ***REMOVED***grpc.Client~CallOptions=***REMOVED*** options Options object.
 */
function getCall(channel, method, options) ***REMOVED***
  var deadline;
  var host;
  var parent;
  var propagate_flags;
  var credentials;
  if (options) ***REMOVED***
    deadline = options.deadline;
    host = options.host;
    parent = _.get(options, 'parent.call');
    propagate_flags = options.propagate_flags;
    credentials = options.credentials;
  ***REMOVED***
  if (deadline === undefined) ***REMOVED***
    deadline = Infinity;
  ***REMOVED***
  var call = new grpc.Call(channel, method, deadline, host,
                           parent, propagate_flags);
  if (credentials) ***REMOVED***
    call.setCredentials(credentials);
  ***REMOVED***
  return call;
***REMOVED***

/**
 * A generic gRPC client. Primarily useful as a base class for generated clients
 * @memberof grpc
 * @constructor
 * @param ***REMOVED***string***REMOVED*** address Server address to connect to
 * @param ***REMOVED***grpc.credentials~ChannelCredentials***REMOVED*** credentials Credentials to use to connect to
 *     the server
 * @param ***REMOVED***Object***REMOVED*** options Options to apply to channel creation
 */
function Client(address, credentials, options) ***REMOVED***
  if (!options) ***REMOVED***
    options = ***REMOVED******REMOVED***;
  ***REMOVED***
  /* Append the grpc-node user agent string after the application user agent
   * string, and put the combination at the beginning of the user agent string
   */
  if (options['grpc.primary_user_agent']) ***REMOVED***
    options['grpc.primary_user_agent'] += ' ';
  ***REMOVED*** else ***REMOVED***
    options['grpc.primary_user_agent'] = '';
  ***REMOVED***
  options['grpc.primary_user_agent'] += 'grpc-node/' + version;
  /* Private fields use $ as a prefix instead of _ because it is an invalid
   * prefix of a method name */
  this.$channel = new grpc.Channel(address, credentials, options);
***REMOVED***

exports.Client = Client;

/**
 * @callback grpc.Client~requestCallback
 * @param ***REMOVED***?grpc~ServiceError***REMOVED*** error The error, if the call
 *     failed
 * @param ***REMOVED*******REMOVED*** value The response value, if the call succeeded
 */

/**
 * Make a unary request to the given method, using the given serialize
 * and deserialize functions, with the given argument.
 * @param ***REMOVED***string***REMOVED*** method The name of the method to request
 * @param ***REMOVED***grpc~serialize***REMOVED*** serialize The serialization function for
 *     inputs
 * @param ***REMOVED***grpc~deserialize***REMOVED*** deserialize The deserialization
 *     function for outputs
 * @param ***REMOVED*******REMOVED*** argument The argument to the call. Should be serializable with
 *     serialize
 * @param ***REMOVED***grpc.Metadata=***REMOVED*** metadata Metadata to add to the call
 * @param ***REMOVED***grpc.Client~CallOptions=***REMOVED*** options Options map
 * @param ***REMOVED***grpc.Client~requestCallback***REMOVED*** callback The callback to
 *     for when the response is received
 * @return ***REMOVED***grpc~ClientUnaryCall***REMOVED*** An event emitter for stream related events
 */
Client.prototype.makeUnaryRequest = function(method, serialize, deserialize,
                                             argument, metadata, options,
                                             callback) ***REMOVED***
  /* While the arguments are listed in the function signature, those variables
   * are not used directly. Instead, ArgueJS processes the arguments
   * object. This allows for simple handling of optional arguments in the
   * middle of the argument list, and also provides type checking. */
  var args = arguejs(***REMOVED***method: String, serialize: Function,
                      deserialize: Function,
                      argument: null, metadata: [Metadata, new Metadata()],
                      options: [Object], callback: Function***REMOVED***, arguments);
  var call = getCall(this.$channel, method, args.options);
  var emitter = new ClientUnaryCall(call);
  metadata = args.metadata.clone();
  var client_batch = ***REMOVED******REMOVED***;
  var message = serialize(args.argument);
  if (args.options) ***REMOVED***
    message.grpcWriteFlags = args.options.flags;
  ***REMOVED***

  client_batch[grpc.opType.SEND_INITIAL_METADATA] =
      metadata._getCoreRepresentation();
  client_batch[grpc.opType.SEND_MESSAGE] = message;
  client_batch[grpc.opType.SEND_CLOSE_FROM_CLIENT] = true;
  client_batch[grpc.opType.RECV_INITIAL_METADATA] = true;
  client_batch[grpc.opType.RECV_MESSAGE] = true;
  client_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;
  call.startBatch(client_batch, function(err, response) ***REMOVED***
    response.status.metadata = Metadata._fromCoreRepresentation(
        response.status.metadata);
    var status = response.status;
    var error;
    var deserialized;
    emitter.emit('metadata', Metadata._fromCoreRepresentation(
        response.metadata));
    if (status.code === constants.status.OK) ***REMOVED***
      if (err) ***REMOVED***
        // Got a batch error, but OK status. Something went wrong
        args.callback(err);
        return;
      ***REMOVED*** else ***REMOVED***
        try ***REMOVED***
          deserialized = deserialize(response.read);
        ***REMOVED*** catch (e) ***REMOVED***
          /* Change status to indicate bad server response. This will result
           * in passing an error to the callback */
          status = ***REMOVED***
            code: constants.status.INTERNAL,
            details: 'Failed to parse server response'
          ***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    if (status.code !== constants.status.OK) ***REMOVED***
      error = new createStatusError(status);
      args.callback(error);
    ***REMOVED*** else ***REMOVED***
      args.callback(null, deserialized);
    ***REMOVED***
    emitter.emit('status', status);
  ***REMOVED***);
  return emitter;
***REMOVED***;

/**
 * Make a client stream request to the given method, using the given serialize
 * and deserialize functions, with the given argument.
 * @param ***REMOVED***string***REMOVED*** method The name of the method to request
 * @param ***REMOVED***grpc~serialize***REMOVED*** serialize The serialization function for
 *     inputs
 * @param ***REMOVED***grpc~deserialize***REMOVED*** deserialize The deserialization
 *     function for outputs
 * @param ***REMOVED***grpc.Metadata=***REMOVED*** metadata Array of metadata key/value pairs to add to
 *     the call
 * @param ***REMOVED***grpc.Client~CallOptions=***REMOVED*** options Options map
 * @param ***REMOVED***grpc.Client~requestCallback***REMOVED*** callback The callback to for when the
 *     response is received
 * @return ***REMOVED***grpc~ClientWritableStream***REMOVED*** An event emitter for stream related
 *     events
 */
Client.prototype.makeClientStreamRequest = function(method, serialize,
                                                      deserialize, metadata,
                                                      options, callback) ***REMOVED***
  /* While the arguments are listed in the function signature, those variables
   * are not used directly. Instead, ArgueJS processes the arguments
   * object. This allows for simple handling of optional arguments in the
   * middle of the argument list, and also provides type checking. */
  var args = arguejs(***REMOVED***method:String, serialize: Function,
                      deserialize: Function,
                      metadata: [Metadata, new Metadata()],
                      options: [Object], callback: Function***REMOVED***, arguments);
  var call = getCall(this.$channel, method, args.options);
  metadata = args.metadata.clone();
  var stream = new ClientWritableStream(call, serialize);
  var metadata_batch = ***REMOVED******REMOVED***;
  metadata_batch[grpc.opType.SEND_INITIAL_METADATA] =
      metadata._getCoreRepresentation();
  metadata_batch[grpc.opType.RECV_INITIAL_METADATA] = true;
  call.startBatch(metadata_batch, function(err, response) ***REMOVED***
    if (err) ***REMOVED***
      // The call has stopped for some reason. A non-OK status will arrive
      // in the other batch.
      return;
    ***REMOVED***
    stream.emit('metadata', Metadata._fromCoreRepresentation(
        response.metadata));
  ***REMOVED***);
  var client_batch = ***REMOVED******REMOVED***;
  client_batch[grpc.opType.RECV_MESSAGE] = true;
  client_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;
  call.startBatch(client_batch, function(err, response) ***REMOVED***
    response.status.metadata = Metadata._fromCoreRepresentation(
        response.status.metadata);
    var status = response.status;
    var error;
    var deserialized;
    if (status.code === constants.status.OK) ***REMOVED***
      if (err) ***REMOVED***
        // Got a batch error, but OK status. Something went wrong
        args.callback(err);
        return;
      ***REMOVED*** else ***REMOVED***
        try ***REMOVED***
          deserialized = deserialize(response.read);
        ***REMOVED*** catch (e) ***REMOVED***
          /* Change status to indicate bad server response. This will result
           * in passing an error to the callback */
          status = ***REMOVED***
            code: constants.status.INTERNAL,
            details: 'Failed to parse server response'
          ***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    if (status.code !== constants.status.OK) ***REMOVED***
      error = createStatusError(status);
      args.callback(error);
    ***REMOVED*** else ***REMOVED***
      args.callback(null, deserialized);
    ***REMOVED***
    stream.emit('status', status);
  ***REMOVED***);
  return stream;
***REMOVED***;

/**
 * Make a server stream request to the given method, with the given serialize
 * and deserialize function, using the given argument
 * @param ***REMOVED***string***REMOVED*** method The name of the method to request
 * @param ***REMOVED***grpc~serialize***REMOVED*** serialize The serialization function for inputs
 * @param ***REMOVED***grpc~deserialize***REMOVED*** deserialize The deserialization
 *     function for outputs
 * @param ***REMOVED*******REMOVED*** argument The argument to the call. Should be serializable with
 *     serialize
 * @param ***REMOVED***grpc.Metadata=***REMOVED*** metadata Array of metadata key/value pairs to add to
 *     the call
 * @param ***REMOVED***grpc.Client~CallOptions=***REMOVED*** options Options map
 * @return ***REMOVED***grpc~ClientReadableStream***REMOVED*** An event emitter for stream related
 *     events
 */
Client.prototype.makeServerStreamRequest = function(method, serialize,
                                                    deserialize, argument,
                                                    metadata, options) ***REMOVED***
  /* While the arguments are listed in the function signature, those variables
   * are not used directly. Instead, ArgueJS processes the arguments
   * object. */
  var args = arguejs(***REMOVED***method:String, serialize: Function,
                      deserialize: Function,
                      argument: null, metadata: [Metadata, new Metadata()],
                      options: [Object]***REMOVED***, arguments);
  var call = getCall(this.$channel, method, args.options);
  metadata = args.metadata.clone();
  var stream = new ClientReadableStream(call, deserialize);
  var start_batch = ***REMOVED******REMOVED***;
  var message = serialize(args.argument);
  if (args.options) ***REMOVED***
    message.grpcWriteFlags = args.options.flags;
  ***REMOVED***
  start_batch[grpc.opType.SEND_INITIAL_METADATA] =
      metadata._getCoreRepresentation();
  start_batch[grpc.opType.RECV_INITIAL_METADATA] = true;
  start_batch[grpc.opType.SEND_MESSAGE] = message;
  start_batch[grpc.opType.SEND_CLOSE_FROM_CLIENT] = true;
  call.startBatch(start_batch, function(err, response) ***REMOVED***
    if (err) ***REMOVED***
      // The call has stopped for some reason. A non-OK status will arrive
      // in the other batch.
      return;
    ***REMOVED***
    stream.emit('metadata', Metadata._fromCoreRepresentation(
        response.metadata));
  ***REMOVED***);
  var status_batch = ***REMOVED******REMOVED***;
  status_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;
  call.startBatch(status_batch, function(err, response) ***REMOVED***
    if (err) ***REMOVED***
      stream.emit('error', err);
      return;
    ***REMOVED***
    response.status.metadata = Metadata._fromCoreRepresentation(
        response.status.metadata);
    stream._receiveStatus(response.status);
  ***REMOVED***);
  return stream;
***REMOVED***;


/**
 * Make a bidirectional stream request with this method on the given channel.
 * @param ***REMOVED***string***REMOVED*** method The name of the method to request
 * @param ***REMOVED***grpc~serialize***REMOVED*** serialize The serialization function for inputs
 * @param ***REMOVED***grpc~deserialize***REMOVED*** deserialize The deserialization
 *     function for outputs
 * @param ***REMOVED***grpc.Metadata=***REMOVED*** metadata Array of metadata key/value
 *     pairs to add to the call
 * @param ***REMOVED***grpc.Client~CallOptions=***REMOVED*** options Options map
 * @return ***REMOVED***grpc~ClientDuplexStream***REMOVED*** An event emitter for stream related events
 */
Client.prototype.makeBidiStreamRequest = function(method, serialize,
                                                  deserialize, metadata,
                                                  options) ***REMOVED***
  /* While the arguments are listed in the function signature, those variables
   * are not used directly. Instead, ArgueJS processes the arguments
   * object. */
  var args = arguejs(***REMOVED***method:String, serialize: Function,
                      deserialize: Function,
                      metadata: [Metadata, new Metadata()],
                      options: [Object]***REMOVED***, arguments);
  var call = getCall(this.$channel, method, args.options);
  metadata = args.metadata.clone();
  var stream = new ClientDuplexStream(call, serialize, deserialize);
  var start_batch = ***REMOVED******REMOVED***;
  start_batch[grpc.opType.SEND_INITIAL_METADATA] =
      metadata._getCoreRepresentation();
  start_batch[grpc.opType.RECV_INITIAL_METADATA] = true;
  call.startBatch(start_batch, function(err, response) ***REMOVED***
    if (err) ***REMOVED***
      // The call has stopped for some reason. A non-OK status will arrive
      // in the other batch.
      return;
    ***REMOVED***
    stream.emit('metadata', Metadata._fromCoreRepresentation(
        response.metadata));
  ***REMOVED***);
  var status_batch = ***REMOVED******REMOVED***;
  status_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;
  call.startBatch(status_batch, function(err, response) ***REMOVED***
    if (err) ***REMOVED***
      stream.emit('error', err);
      return;
    ***REMOVED***
    response.status.metadata = Metadata._fromCoreRepresentation(
        response.status.metadata);
    stream._receiveStatus(response.status);
  ***REMOVED***);
  return stream;
***REMOVED***;

/**
 * Close this client.
 */
Client.prototype.close = function() ***REMOVED***
  this.$channel.close();
***REMOVED***;

/**
 * Return the underlying channel object for the specified client
 * @return ***REMOVED***Channel***REMOVED*** The channel
 */
Client.prototype.getChannel = function() ***REMOVED***
  return this.$channel;
***REMOVED***;

/**
 * Wait for the client to be ready. The callback will be called when the
 * client has successfully connected to the server, and it will be called
 * with an error if the attempt to connect to the server has unrecoverablly
 * failed or if the deadline expires. This function will make the channel
 * start connecting if it has not already done so.
 * @param ***REMOVED***grpc~Deadline***REMOVED*** deadline When to stop waiting for a connection.
 * @param ***REMOVED***function(Error)***REMOVED*** callback The callback to call when done attempting
 *     to connect.
 */
Client.prototype.waitForReady = function(deadline, callback) ***REMOVED***
  var self = this;
  var checkState = function(err) ***REMOVED***
    if (err) ***REMOVED***
      callback(new Error('Failed to connect before the deadline'));
      return;
    ***REMOVED***
    var new_state = self.$channel.getConnectivityState(true);
    if (new_state === grpc.connectivityState.READY) ***REMOVED***
      callback();
    ***REMOVED*** else if (new_state === grpc.connectivityState.FATAL_FAILURE) ***REMOVED***
      callback(new Error('Failed to connect to server'));
    ***REMOVED*** else ***REMOVED***
      self.$channel.watchConnectivityState(new_state, deadline, checkState);
    ***REMOVED***
  ***REMOVED***;
  /* Force a single round of polling to ensure that the channel state is up
   * to date */
  grpc.forcePoll();
  setImmediate(checkState);
***REMOVED***;

/**
 * Map with short names for each of the requester maker functions. Used in
 * makeClientConstructor
 * @private
 */
var requester_funcs = ***REMOVED***
  unary: Client.prototype.makeUnaryRequest,
  server_stream: Client.prototype.makeServerStreamRequest,
  client_stream: Client.prototype.makeClientStreamRequest,
  bidi: Client.prototype.makeBidiStreamRequest
***REMOVED***;

function getDefaultValues(metadata, options) ***REMOVED***
  var res = ***REMOVED******REMOVED***;
  res.metadata = metadata || new Metadata();
  res.options = options || ***REMOVED******REMOVED***;
  return res;
***REMOVED***

/**
 * Map with wrappers for each type of requester function to make it use the old
 * argument order with optional arguments after the callback.
 * @access private
 */
var deprecated_request_wrap = ***REMOVED***
  unary: function(makeUnaryRequest) ***REMOVED***
    return function makeWrappedUnaryRequest(argument, callback,
                                            metadata, options) ***REMOVED***
      /* jshint validthis: true */
      var opt_args = getDefaultValues(metadata, metadata);
      return makeUnaryRequest.call(this, argument, opt_args.metadata,
                                   opt_args.options, callback);
    ***REMOVED***;
  ***REMOVED***,
  client_stream: function(makeServerStreamRequest) ***REMOVED***
    return function makeWrappedClientStreamRequest(callback, metadata,
                                                   options) ***REMOVED***
      /* jshint validthis: true */
      var opt_args = getDefaultValues(metadata, options);
      return makeServerStreamRequest.call(this, opt_args.metadata,
                                          opt_args.options, callback);
    ***REMOVED***;
  ***REMOVED***,
  server_stream: _.identity,
  bidi: _.identity
***REMOVED***;

/**
 * Creates a constructor for a client with the given methods, as specified in
 * the methods argument. The resulting class will have an instance method for
 * each method in the service, which is a partial application of one of the
 * [Client]***REMOVED***@link grpc.Client***REMOVED*** request methods, depending on `requestSerialize`
 * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`
 * arguments predefined.
 * @memberof grpc
 * @alias grpc~makeGenericClientConstructor
 * @param ***REMOVED***grpc~ServiceDefinition***REMOVED*** methods An object mapping method names to
 *     method attributes
 * @param ***REMOVED***string***REMOVED*** serviceName The fully qualified name of the service
 * @param ***REMOVED***Object***REMOVED*** class_options An options object.
 * @param ***REMOVED***boolean=***REMOVED*** [class_options.deprecatedArgumentOrder=false] Indicates
 *     that the old argument order should be used for methods, with optional
 *     arguments at the end instead of the callback at the end. This option
 *     is only a temporary stopgap measure to smooth an API breakage.
 *     It is deprecated, and new code should not use it.
 * @return ***REMOVED***function***REMOVED*** New client constructor, which is a subclass of
 *     ***REMOVED***@link grpc.Client***REMOVED***, and has the same arguments as that constructor.
 */
exports.makeClientConstructor = function(methods, serviceName,
                                         class_options) ***REMOVED***
  if (!class_options) ***REMOVED***
    class_options = ***REMOVED******REMOVED***;
  ***REMOVED***

  function ServiceClient(address, credentials, options) ***REMOVED***
    Client.call(this, address, credentials, options);
  ***REMOVED***

  util.inherits(ServiceClient, Client);

  _.each(methods, function(attrs, name) ***REMOVED***
    var method_type;
    if (_.startsWith(name, '$')) ***REMOVED***
      throw new Error('Method names cannot start with $');
    ***REMOVED***
    if (attrs.requestStream) ***REMOVED***
      if (attrs.responseStream) ***REMOVED***
        method_type = 'bidi';
      ***REMOVED*** else ***REMOVED***
        method_type = 'client_stream';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (attrs.responseStream) ***REMOVED***
        method_type = 'server_stream';
      ***REMOVED*** else ***REMOVED***
        method_type = 'unary';
      ***REMOVED***
    ***REMOVED***
    var serialize = attrs.requestSerialize;
    var deserialize = attrs.responseDeserialize;
    var method_func = _.partial(requester_funcs[method_type], attrs.path,
                                serialize, deserialize);
    if (class_options.deprecatedArgumentOrder) ***REMOVED***
      ServiceClient.prototype[name] = deprecated_request_wrap(method_func);
    ***REMOVED*** else ***REMOVED***
      ServiceClient.prototype[name] = method_func;
    ***REMOVED***
    // Associate all provided attributes with the method
    _.assign(ServiceClient.prototype[name], attrs);
    if (attrs.originalName) ***REMOVED***
      ServiceClient.prototype[attrs.originalName] = ServiceClient.prototype[name];
    ***REMOVED***
  ***REMOVED***);

  ServiceClient.service = methods;

  return ServiceClient;
***REMOVED***;

/**
 * Return the underlying channel object for the specified client
 * @memberof grpc
 * @alias grpc~getClientChannel
 * @param ***REMOVED***grpc.Client***REMOVED*** client The client
 * @return ***REMOVED***Channel***REMOVED*** The channel
 * @see grpc.Client#getChannel
 */
exports.getClientChannel = function(client) ***REMOVED***
  return Client.prototype.getChannel.call(client);
***REMOVED***;

/**
 * Wait for the client to be ready. The callback will be called when the
 * client has successfully connected to the server, and it will be called
 * with an error if the attempt to connect to the server has unrecoverablly
 * failed or if the deadline expires. This function will make the channel
 * start connecting if it has not already done so.
 * @memberof grpc
 * @alias grpc~waitForClientReady
 * @param ***REMOVED***grpc.Client***REMOVED*** client The client to wait on
 * @param ***REMOVED***grpc~Deadline***REMOVED*** deadline When to stop waiting for a connection. Pass
 *     Infinity to wait forever.
 * @param ***REMOVED***function(Error)***REMOVED*** callback The callback to call when done attempting
 *     to connect.
 * @see grpc.Client#waitForReady
 */
exports.waitForClientReady = function(client, deadline, callback) ***REMOVED***
  Client.prototype.waitForReady.call(client, deadline, callback);
***REMOVED***;
