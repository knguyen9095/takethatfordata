module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = ***REMOVED*** sep: '/' ***REMOVED***
try ***REMOVED***
  path = require('path')
***REMOVED*** catch (er) ***REMOVED******REMOVED***

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = ***REMOVED******REMOVED***
var expand = require('brace-expansion')

var plTypes = ***REMOVED***
  '!': ***REMOVED*** open: '(?:(?!(?:', close: '))[^/]*?)'***REMOVED***,
  '?': ***REMOVED*** open: '(?:', close: ')?' ***REMOVED***,
  '+': ***REMOVED*** open: '(?:', close: ')+' ***REMOVED***,
  '*': ***REMOVED*** open: '(?:', close: ')*' ***REMOVED***,
  '@': ***REMOVED*** open: '(?:', close: ')' ***REMOVED***
***REMOVED***

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.***REMOVED***1,2***REMOVED***)($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().****REMOVED******REMOVED***+?[]^$\\!')

// "abc" -> ***REMOVED*** a:true, b:true, c:true ***REMOVED***
function charSet (s) ***REMOVED***
  return s.split('').reduce(function (set, c) ***REMOVED***
    set[c] = true
    return set
  ***REMOVED***, ***REMOVED******REMOVED***)
***REMOVED***

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***
  return function (p, i, list) ***REMOVED***
    return minimatch(p, pattern, options)
  ***REMOVED***
***REMOVED***

function ext (a, b) ***REMOVED***
  a = a || ***REMOVED******REMOVED***
  b = b || ***REMOVED******REMOVED***
  var t = ***REMOVED******REMOVED***
  Object.keys(b).forEach(function (k) ***REMOVED***
    t[k] = b[k]
  ***REMOVED***)
  Object.keys(a).forEach(function (k) ***REMOVED***
    t[k] = a[k]
  ***REMOVED***)
  return t
***REMOVED***

minimatch.defaults = function (def) ***REMOVED***
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) ***REMOVED***
    return orig.minimatch(p, pattern, ext(def, options))
  ***REMOVED***

  m.Minimatch = function Minimatch (pattern, options) ***REMOVED***
    return new orig.Minimatch(pattern, ext(def, options))
  ***REMOVED***

  return m
***REMOVED***

Minimatch.defaults = function (def) ***REMOVED***
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
***REMOVED***

function minimatch (p, pattern, options) ***REMOVED***
  if (typeof pattern !== 'string') ***REMOVED***
    throw new TypeError('glob pattern string required')
  ***REMOVED***

  if (!options) options = ***REMOVED******REMOVED***

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') ***REMOVED***
    return false
  ***REMOVED***

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
***REMOVED***

function Minimatch (pattern, options) ***REMOVED***
  if (!(this instanceof Minimatch)) ***REMOVED***
    return new Minimatch(pattern, options)
  ***REMOVED***

  if (typeof pattern !== 'string') ***REMOVED***
    throw new TypeError('glob pattern string required')
  ***REMOVED***

  if (!options) options = ***REMOVED******REMOVED***
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') ***REMOVED***
    pattern = pattern.split(path.sep).join('/')
  ***REMOVED***

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
***REMOVED***

Minimatch.prototype.debug = function () ***REMOVED******REMOVED***

Minimatch.prototype.make = make
function make () ***REMOVED***
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') ***REMOVED***
    this.comment = true
    return
  ***REMOVED***
  if (!pattern) ***REMOVED***
    this.empty = true
    return
  ***REMOVED***

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) ***REMOVED***
    return s.split(slashSplit)
  ***REMOVED***)

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) ***REMOVED***
    return s.map(this.parse, this)
  ***REMOVED***, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) ***REMOVED***
    return s.indexOf(false) === -1
  ***REMOVED***)

  this.debug(this.pattern, set)

  this.set = set
***REMOVED***

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () ***REMOVED***
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) ***REMOVED***
    negate = !negate
    negateOffset++
  ***REMOVED***

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
***REMOVED***

// Brace expansion:
// a***REMOVED***b,c***REMOVED***d -> abd acd
// a***REMOVED***b,***REMOVED***c -> abc ac
// a***REMOVED***0..3***REMOVED***d -> a0d a1d a2d a3d
// a***REMOVED***b,c***REMOVED***d,e***REMOVED***f***REMOVED***g -> abg acdfg acefg
// a***REMOVED***b,c***REMOVED***d***REMOVED***e,f***REMOVED***g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a***REMOVED***2..***REMOVED***b -> a***REMOVED***2..***REMOVED***b
// a***REMOVED***b***REMOVED***c -> a***REMOVED***b***REMOVED***c
minimatch.braceExpand = function (pattern, options) ***REMOVED***
  return braceExpand(pattern, options)
***REMOVED***

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) ***REMOVED***
  if (!options) ***REMOVED***
    if (this instanceof Minimatch) ***REMOVED***
      options = this.options
    ***REMOVED*** else ***REMOVED***
      options = ***REMOVED******REMOVED***
    ***REMOVED***
  ***REMOVED***

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') ***REMOVED***
    throw new TypeError('undefined pattern')
  ***REMOVED***

  if (options.nobrace ||
    !pattern.match(/\***REMOVED***.*\***REMOVED***/)) ***REMOVED***
    // shortcut. no need to expand.
    return [pattern]
  ***REMOVED***

  return expand(pattern)
***REMOVED***

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = ***REMOVED******REMOVED***
function parse (pattern, isSub) ***REMOVED***
  if (pattern.length > 1024 * 64) ***REMOVED***
    throw new TypeError('pattern is too long')
  ***REMOVED***

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.***REMOVED***1,2***REMOVED***(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () ***REMOVED***
    if (stateChar) ***REMOVED***
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) ***REMOVED***
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      ***REMOVED***
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    ***REMOVED***
  ***REMOVED***

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) ***REMOVED***
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) ***REMOVED***
      re += '\\' + c
      escaping = false
      continue
    ***REMOVED***

    switch (c) ***REMOVED***
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) ***REMOVED***
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        ***REMOVED***

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) ***REMOVED***
          re += '('
          continue
        ***REMOVED***

        if (!stateChar) ***REMOVED***
          re += '\\('
          continue
        ***REMOVED***

        patternListStack.push(***REMOVED***
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        ***REMOVED***)
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) ***REMOVED***
          re += '\\)'
          continue
        ***REMOVED***

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') ***REMOVED***
          negativeLists.push(pl)
        ***REMOVED***
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) ***REMOVED***
          re += '\\|'
          escaping = false
          continue
        ***REMOVED***

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) ***REMOVED***
          re += '\\' + c
          continue
        ***REMOVED***

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) ***REMOVED***
          re += '\\' + c
          escaping = false
          continue
        ***REMOVED***

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) ***REMOVED***
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try ***REMOVED***
            RegExp('[' + cs + ']')
          ***REMOVED*** catch (er) ***REMOVED***
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          ***REMOVED***
        ***REMOVED***

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) ***REMOVED***
          // no need
          escaping = false
        ***REMOVED*** else if (reSpecials[c]
          && !(c === '^' && inClass)) ***REMOVED***
          re += '\\'
        ***REMOVED***

        re += c

    ***REMOVED*** // switch
  ***REMOVED*** // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) ***REMOVED***
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  ***REMOVED***

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) ***REMOVED***
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\***REMOVED***2***REMOVED***)***REMOVED***0,64***REMOVED***)(\\?)\|/g, function (_, $1, $2) ***REMOVED***
      if (!$2) ***REMOVED***
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      ***REMOVED***

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    ***REMOVED***)

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  ***REMOVED***

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) ***REMOVED***
    // trailing \\
    re += '\\\\'
  ***REMOVED***

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) ***REMOVED***
    case '.':
    case '[':
    case '(': addPatternStart = true
  ***REMOVED***

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) ***REMOVED***
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) ***REMOVED***
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    ***REMOVED***
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) ***REMOVED***
      dollar = '$'
    ***REMOVED***
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  ***REMOVED***

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) ***REMOVED***
    re = '(?=.)' + re
  ***REMOVED***

  if (addPatternStart) ***REMOVED***
    re = patternStart + re
  ***REMOVED***

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) ***REMOVED***
    return [re, hasMagic]
  ***REMOVED***

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) ***REMOVED***
    return globUnescape(pattern)
  ***REMOVED***

  var flags = options.nocase ? 'i' : ''
  try ***REMOVED***
    var regExp = new RegExp('^' + re + '$', flags)
  ***REMOVED*** catch (er) ***REMOVED***
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  ***REMOVED***

  regExp._glob = pattern
  regExp._src = re

  return regExp
***REMOVED***

minimatch.makeRe = function (pattern, options) ***REMOVED***
  return new Minimatch(pattern, options || ***REMOVED******REMOVED***).makeRe()
***REMOVED***

Minimatch.prototype.makeRe = makeRe
function makeRe () ***REMOVED***
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) ***REMOVED***
    this.regexp = false
    return this.regexp
  ***REMOVED***
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) ***REMOVED***
    return pattern.map(function (p) ***REMOVED***
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    ***REMOVED***).join('\\\/')
  ***REMOVED***).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try ***REMOVED***
    this.regexp = new RegExp(re, flags)
  ***REMOVED*** catch (ex) ***REMOVED***
    this.regexp = false
  ***REMOVED***
  return this.regexp
***REMOVED***

minimatch.match = function (list, pattern, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) ***REMOVED***
    return mm.match(f)
  ***REMOVED***)
  if (mm.options.nonull && !list.length) ***REMOVED***
    list.push(pattern)
  ***REMOVED***
  return list
***REMOVED***

Minimatch.prototype.match = match
function match (f, partial) ***REMOVED***
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') ***REMOVED***
    f = f.split(path.sep).join('/')
  ***REMOVED***

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) ***REMOVED***
    filename = f[i]
    if (filename) break
  ***REMOVED***

  for (i = 0; i < set.length; i++) ***REMOVED***
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) ***REMOVED***
      file = [filename]
    ***REMOVED***
    var hit = this.matchOne(file, pattern, partial)
    if (hit) ***REMOVED***
      if (options.flipNegate) return true
      return !this.negate
    ***REMOVED***
  ***REMOVED***

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
***REMOVED***

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) ***REMOVED***
  var options = this.options

  this.debug('matchOne',
    ***REMOVED*** 'this': this, file: file, pattern: pattern ***REMOVED***)

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) ***REMOVED***
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) ***REMOVED***
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) ***REMOVED***
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) ***REMOVED***
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        ***REMOVED***
        return true
      ***REMOVED***

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) ***REMOVED***
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) ***REMOVED***
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        ***REMOVED*** else ***REMOVED***
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) ***REMOVED***
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          ***REMOVED***

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        ***REMOVED***
      ***REMOVED***

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) ***REMOVED***
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      ***REMOVED***
      return false
    ***REMOVED***

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') ***REMOVED***
      if (options.nocase) ***REMOVED***
        hit = f.toLowerCase() === p.toLowerCase()
      ***REMOVED*** else ***REMOVED***
        hit = f === p
      ***REMOVED***
      this.debug('string match', p, f, hit)
    ***REMOVED*** else ***REMOVED***
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    ***REMOVED***

    if (!hit) return false
  ***REMOVED***

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) ***REMOVED***
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  ***REMOVED*** else if (fi === fl) ***REMOVED***
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  ***REMOVED*** else if (pi === pl) ***REMOVED***
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  ***REMOVED***

  // should be unreachable.
  throw new Error('wtf?')
***REMOVED***

// replace stuff like \* with *
function globUnescape (s) ***REMOVED***
  return s.replace(/\\(.)/g, '$1')
***REMOVED***

function regExpEscape (s) ***REMOVED***
  return s.replace(/[-[\]***REMOVED******REMOVED***()*+?.,\\^$|#\s]/g, '\\$&')
***REMOVED***
