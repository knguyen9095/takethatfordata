var fs = require('./fs.js')
var constants = require('constants')

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() ***REMOVED***
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
***REMOVED***
try ***REMOVED***
  process.cwd()
***REMOVED*** catch (er) ***REMOVED******REMOVED***

var chdir = process.chdir
process.chdir = function(d) ***REMOVED***
  cwd = null
  chdir.call(process, d)
***REMOVED***

module.exports = patch

function patch (fs) ***REMOVED***
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) ***REMOVED***
    patchLchmod(fs)
  ***REMOVED***

  // lutimes implementation, or no-op
  if (!fs.lutimes) ***REMOVED***
    patchLutimes(fs)
  ***REMOVED***

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) ***REMOVED***
    fs.lchmod = function (path, mode, cb) ***REMOVED***
      if (cb) process.nextTick(cb)
    ***REMOVED***
    fs.lchmodSync = function () ***REMOVED******REMOVED***
  ***REMOVED***
  if (!fs.lchown) ***REMOVED***
    fs.lchown = function (path, uid, gid, cb) ***REMOVED***
      if (cb) process.nextTick(cb)
    ***REMOVED***
    fs.lchownSync = function () ***REMOVED******REMOVED***
  ***REMOVED***

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") ***REMOVED***
    fs.rename = (function (fs$rename) ***REMOVED*** return function (from, to, cb) ***REMOVED***
      var start = Date.now()
      var backoff = 0;
      fs$rename(from, to, function CB (er) ***REMOVED***
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) ***REMOVED***
          setTimeout(function() ***REMOVED***
            fs.stat(to, function (stater, st) ***REMOVED***
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er)
            ***REMOVED***)
          ***REMOVED***, backoff)
          if (backoff < 100)
            backoff += 10;
          return;
        ***REMOVED***
        if (cb) cb(er)
      ***REMOVED***)
    ***REMOVED******REMOVED***)(fs.rename)
  ***REMOVED***

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) ***REMOVED*** return function (fd, buffer, offset, length, position, callback_) ***REMOVED***
    var callback
    if (callback_ && typeof callback_ === 'function') ***REMOVED***
      var eagCounter = 0
      callback = function (er, _, __) ***REMOVED***
        if (er && er.code === 'EAGAIN' && eagCounter < 10) ***REMOVED***
          eagCounter ++
          return fs$read.call(fs, fd, buffer, offset, length, position, callback)
        ***REMOVED***
        callback_.apply(this, arguments)
      ***REMOVED***
    ***REMOVED***
    return fs$read.call(fs, fd, buffer, offset, length, position, callback)
  ***REMOVED******REMOVED***)(fs.read)

  fs.readSync = (function (fs$readSync) ***REMOVED*** return function (fd, buffer, offset, length, position) ***REMOVED***
    var eagCounter = 0
    while (true) ***REMOVED***
      try ***REMOVED***
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      ***REMOVED*** catch (er) ***REMOVED***
        if (er.code === 'EAGAIN' && eagCounter < 10) ***REMOVED***
          eagCounter ++
          continue
        ***REMOVED***
        throw er
      ***REMOVED***
    ***REMOVED***
  ***REMOVED******REMOVED***)(fs.readSync)
***REMOVED***

function patchLchmod (fs) ***REMOVED***
  fs.lchmod = function (path, mode, callback) ***REMOVED***
    fs.open( path
           , constants.O_WRONLY | constants.O_SYMLINK
           , mode
           , function (err, fd) ***REMOVED***
      if (err) ***REMOVED***
        if (callback) callback(err)
        return
      ***REMOVED***
      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      fs.fchmod(fd, mode, function (err) ***REMOVED***
        fs.close(fd, function(err2) ***REMOVED***
          if (callback) callback(err || err2)
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***

  fs.lchmodSync = function (path, mode) ***REMOVED***
    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

    // prefer to return the chmod error, if one occurs,
    // but still try to close, and report closing errors if they occur.
    var threw = true
    var ret
    try ***REMOVED***
      ret = fs.fchmodSync(fd, mode)
      threw = false
    ***REMOVED*** finally ***REMOVED***
      if (threw) ***REMOVED***
        try ***REMOVED***
          fs.closeSync(fd)
        ***REMOVED*** catch (er) ***REMOVED******REMOVED***
      ***REMOVED*** else ***REMOVED***
        fs.closeSync(fd)
      ***REMOVED***
    ***REMOVED***
    return ret
  ***REMOVED***
***REMOVED***

function patchLutimes (fs) ***REMOVED***
  if (constants.hasOwnProperty("O_SYMLINK")) ***REMOVED***
    fs.lutimes = function (path, at, mt, cb) ***REMOVED***
      fs.open(path, constants.O_SYMLINK, function (er, fd) ***REMOVED***
        if (er) ***REMOVED***
          if (cb) cb(er)
          return
        ***REMOVED***
        fs.futimes(fd, at, mt, function (er) ***REMOVED***
          fs.close(fd, function (er2) ***REMOVED***
            if (cb) cb(er || er2)
          ***REMOVED***)
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***

    fs.lutimesSync = function (path, at, mt) ***REMOVED***
      var fd = fs.openSync(path, constants.O_SYMLINK)
      var ret
      var threw = true
      try ***REMOVED***
        ret = fs.futimesSync(fd, at, mt)
        threw = false
      ***REMOVED*** finally ***REMOVED***
        if (threw) ***REMOVED***
          try ***REMOVED***
            fs.closeSync(fd)
          ***REMOVED*** catch (er) ***REMOVED******REMOVED***
        ***REMOVED*** else ***REMOVED***
          fs.closeSync(fd)
        ***REMOVED***
      ***REMOVED***
      return ret
    ***REMOVED***

  ***REMOVED*** else ***REMOVED***
    fs.lutimes = function (_a, _b, _c, cb) ***REMOVED*** if (cb) process.nextTick(cb) ***REMOVED***
    fs.lutimesSync = function () ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED***

function chmodFix (orig) ***REMOVED***
  if (!orig) return orig
  return function (target, mode, cb) ***REMOVED***
    return orig.call(fs, target, mode, function (er) ***REMOVED***
      if (chownErOk(er)) er = null
      if (cb) cb.apply(this, arguments)
    ***REMOVED***)
  ***REMOVED***
***REMOVED***

function chmodFixSync (orig) ***REMOVED***
  if (!orig) return orig
  return function (target, mode) ***REMOVED***
    try ***REMOVED***
      return orig.call(fs, target, mode)
    ***REMOVED*** catch (er) ***REMOVED***
      if (!chownErOk(er)) throw er
    ***REMOVED***
  ***REMOVED***
***REMOVED***


function chownFix (orig) ***REMOVED***
  if (!orig) return orig
  return function (target, uid, gid, cb) ***REMOVED***
    return orig.call(fs, target, uid, gid, function (er) ***REMOVED***
      if (chownErOk(er)) er = null
      if (cb) cb.apply(this, arguments)
    ***REMOVED***)
  ***REMOVED***
***REMOVED***

function chownFixSync (orig) ***REMOVED***
  if (!orig) return orig
  return function (target, uid, gid) ***REMOVED***
    try ***REMOVED***
      return orig.call(fs, target, uid, gid)
    ***REMOVED*** catch (er) ***REMOVED***
      if (!chownErOk(er)) throw er
    ***REMOVED***
  ***REMOVED***
***REMOVED***


function statFix (orig) ***REMOVED***
  if (!orig) return orig
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target, cb) ***REMOVED***
    return orig.call(fs, target, function (er, stats) ***REMOVED***
      if (!stats) return cb.apply(this, arguments)
      if (stats.uid < 0) stats.uid += 0x100000000
      if (stats.gid < 0) stats.gid += 0x100000000
      if (cb) cb.apply(this, arguments)
    ***REMOVED***)
  ***REMOVED***
***REMOVED***

function statFixSync (orig) ***REMOVED***
  if (!orig) return orig
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target) ***REMOVED***
    var stats = orig.call(fs, target)
    if (stats.uid < 0) stats.uid += 0x100000000
    if (stats.gid < 0) stats.gid += 0x100000000
    return stats;
  ***REMOVED***
***REMOVED***

// ENOSYS means that the fs doesn't support the op. Just ignore
// that, because it doesn't matter.
//
// if there's no getuid, or if getuid() is something other
// than 0, and the error is EINVAL or EPERM, then just ignore
// it.
//
// This specific case is a silent failure in cp, install, tar,
// and most other unix tools that manage permissions.
//
// When running as root, or if other types of errors are
// encountered, then it's strict.
function chownErOk (er) ***REMOVED***
  if (!er)
    return true

  if (er.code === "ENOSYS")
    return true

  var nonroot = !process.getuid || process.getuid() !== 0
  if (nonroot) ***REMOVED***
    if (er.code === "EINVAL" || er.code === "EPERM")
      return true
  ***REMOVED***

  return false
***REMOVED***
