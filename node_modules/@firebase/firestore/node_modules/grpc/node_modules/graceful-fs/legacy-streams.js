var Stream = require('stream').Stream

module.exports = legacy

function legacy (fs) ***REMOVED***
  return ***REMOVED***
    ReadStream: ReadStream,
    WriteStream: WriteStream
  ***REMOVED***

  function ReadStream (path, options) ***REMOVED***
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || ***REMOVED******REMOVED***;

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) ***REMOVED***
      var key = keys[index];
      this[key] = options[key];
    ***REMOVED***

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) ***REMOVED***
      if ('number' !== typeof this.start) ***REMOVED***
        throw TypeError('start must be a Number');
      ***REMOVED***
      if (this.end === undefined) ***REMOVED***
        this.end = Infinity;
      ***REMOVED*** else if ('number' !== typeof this.end) ***REMOVED***
        throw TypeError('end must be a Number');
      ***REMOVED***

      if (this.start > this.end) ***REMOVED***
        throw new Error('start must be <= end');
      ***REMOVED***

      this.pos = this.start;
    ***REMOVED***

    if (this.fd !== null) ***REMOVED***
      process.nextTick(function() ***REMOVED***
        self._read();
      ***REMOVED***);
      return;
    ***REMOVED***

    fs.open(this.path, this.flags, this.mode, function (err, fd) ***REMOVED***
      if (err) ***REMOVED***
        self.emit('error', err);
        self.readable = false;
        return;
      ***REMOVED***

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    ***REMOVED***)
  ***REMOVED***

  function WriteStream (path, options) ***REMOVED***
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || ***REMOVED******REMOVED***;

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) ***REMOVED***
      var key = keys[index];
      this[key] = options[key];
    ***REMOVED***

    if (this.start !== undefined) ***REMOVED***
      if ('number' !== typeof this.start) ***REMOVED***
        throw TypeError('start must be a Number');
      ***REMOVED***
      if (this.start < 0) ***REMOVED***
        throw new Error('start must be >= zero');
      ***REMOVED***

      this.pos = this.start;
    ***REMOVED***

    this.busy = false;
    this._queue = [];

    if (this.fd === null) ***REMOVED***
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    ***REMOVED***
  ***REMOVED***
***REMOVED***
