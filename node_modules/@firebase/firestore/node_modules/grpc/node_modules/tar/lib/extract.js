// give it a tarball and a path, and it'll dump the contents

module.exports = Extract

var tar = require("../tar.js")
  , fstream = require("fstream")
  , inherits = require("inherits")
  , path = require("path")

function Extract (opts) ***REMOVED***
  if (!(this instanceof Extract)) return new Extract(opts)
  tar.Parse.apply(this)

  if (typeof opts !== "object") ***REMOVED***
    opts = ***REMOVED*** path: opts ***REMOVED***
  ***REMOVED***

  // better to drop in cwd? seems more standard.
  opts.path = opts.path || path.resolve("node-tar-extract")
  opts.type = "Directory"
  opts.Directory = true

  // similar to --strip or --strip-components
  opts.strip = +opts.strip
  if (!opts.strip || opts.strip <= 0) opts.strip = 0

  this._fst = fstream.Writer(opts)

  this.pause()
  var me = this

  // Hardlinks in tarballs are relative to the root
  // of the tarball.  So, they need to be resolved against
  // the target directory in order to be created properly.
  me.on("entry", function (entry) ***REMOVED***
    // if there's a "strip" argument, then strip off that many
    // path components.
    if (opts.strip) ***REMOVED***
      var p = entry.path.split("/").slice(opts.strip).join("/")
      entry.path = entry.props.path = p
      if (entry.linkpath) ***REMOVED***
        var lp = entry.linkpath.split("/").slice(opts.strip).join("/")
        entry.linkpath = entry.props.linkpath = lp
      ***REMOVED***
    ***REMOVED***
    if (entry.type === "Link") ***REMOVED***
      entry.linkpath = entry.props.linkpath =
        path.join(opts.path, path.join("/", entry.props.linkpath))
    ***REMOVED***

    if (entry.type === "SymbolicLink") ***REMOVED***
      var dn = path.dirname(entry.path) || ""
      var linkpath = entry.props.linkpath
      var target = path.resolve(opts.path, dn, linkpath)
      if (target.indexOf(opts.path) !== 0) ***REMOVED***
        linkpath = path.join(opts.path, path.join("/", linkpath))
      ***REMOVED***
      entry.linkpath = entry.props.linkpath = linkpath
    ***REMOVED***
  ***REMOVED***)

  this._fst.on("ready", function () ***REMOVED***
    me.pipe(me._fst, ***REMOVED*** end: false ***REMOVED***)
    me.resume()
  ***REMOVED***)

  this._fst.on('error', function(err) ***REMOVED***
    me.emit('error', err)
  ***REMOVED***)

  this._fst.on('drain', function() ***REMOVED***
    me.emit('drain')
  ***REMOVED***)

  // this._fst.on("end", function () ***REMOVED***
  //   console.error("\nEEEE Extract End", me._fst.path)
  // ***REMOVED***)

  this._fst.on("close", function () ***REMOVED***
    // console.error("\nEEEE Extract End", me._fst.path)
    me.emit("finish")
    me.emit("end")
    me.emit("close")
  ***REMOVED***)
***REMOVED***

inherits(Extract, tar.Parse)

Extract.prototype._streamEnd = function () ***REMOVED***
  var me = this
  if (!me._ended || me._entry) me.error("unexpected eof")
  me._fst.end()
  // my .end() is coming later.
***REMOVED***
