'use strict';

var url = require('url')
  , equal = require('./equal')
  , util = require('./util')
  , SchemaObject = require('./schema_obj');

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  ***REMOVED***Function***REMOVED*** compile reference to schema compilation funciton (localCompile)
 * @param  ***REMOVED***Object***REMOVED*** root object with information about the root schema for the current schema
 * @param  ***REMOVED***String***REMOVED*** ref reference to resolve
 * @return ***REMOVED***Object|Function***REMOVED*** schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) ***REMOVED***
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') ***REMOVED***
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  ***REMOVED***

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) ***REMOVED***
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  ***REMOVED***

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) ***REMOVED***
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  ***REMOVED***

  if (schema instanceof SchemaObject) ***REMOVED***
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  ***REMOVED*** else if (schema) ***REMOVED***
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  ***REMOVED***

  return v;
***REMOVED***


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  ***REMOVED***Object***REMOVED*** root root object with properties schema, refVal, refs
 * @param  ***REMOVED***String***REMOVED*** ref  reference to resolve
 * @return ***REMOVED***Object***REMOVED*** object with properties schema, root, baseId
 */
function resolveSchema(root, ref) ***REMOVED***
  /* jshint validthis: true */
  var p = url.parse(ref, false, true)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(root.schema.id);
  if (refPath !== baseId) ***REMOVED***
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') ***REMOVED***
      return resolveRecursive.call(this, root, refVal, p);
    ***REMOVED*** else if (refVal instanceof SchemaObject) ***REMOVED***
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    ***REMOVED*** else ***REMOVED***
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) ***REMOVED***
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return ***REMOVED*** schema: refVal, root: root, baseId: baseId ***REMOVED***;
        root = refVal;
      ***REMOVED*** else ***REMOVED***
        return;
      ***REMOVED***
    ***REMOVED***
    if (!root.schema) return;
    baseId = getFullPath(root.schema.id);
  ***REMOVED***
  return getJsonPointer.call(this, p, baseId, root.schema, root);
***REMOVED***


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) ***REMOVED***
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) ***REMOVED***
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    if (schema.id) baseId = resolveUrl(baseId, schema.id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  ***REMOVED***
***REMOVED***


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) ***REMOVED***
  /* jshint validthis: true */
  parsedRef.hash = parsedRef.hash || '';
  if (parsedRef.hash.slice(0,2) != '#/') return;
  var parts = parsedRef.hash.split('/');

  for (var i = 1; i < parts.length; i++) ***REMOVED***
    var part = parts[i];
    if (part) ***REMOVED***
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (!schema) break;
      if (schema.id && !PREVENT_SCOPE_CHANGE[part]) baseId = resolveUrl(baseId, schema.id);
      if (schema.$ref) ***REMOVED***
        var $ref = resolveUrl(baseId, schema.$ref);
        var res = resolveSchema.call(this, root, $ref);
        if (res) ***REMOVED***
          schema = res.schema;
          root = res.root;
          baseId = res.baseId;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if (schema && schema != root.schema)
    return ***REMOVED*** schema: schema, root: root, baseId: baseId ***REMOVED***;
***REMOVED***


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) ***REMOVED***
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
***REMOVED***


function checkNoRef(schema) ***REMOVED***
  var item;
  if (Array.isArray(schema)) ***REMOVED***
    for (var i=0; i<schema.length; i++) ***REMOVED***
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    for (var key in schema) ***REMOVED***
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    ***REMOVED***
  ***REMOVED***
  return true;
***REMOVED***


function countKeys(schema) ***REMOVED***
  var count = 0, item;
  if (Array.isArray(schema)) ***REMOVED***
    for (var i=0; i<schema.length; i++) ***REMOVED***
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    for (var key in schema) ***REMOVED***
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) ***REMOVED***
        count++;
      ***REMOVED*** else ***REMOVED***
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return count;
***REMOVED***


function getFullPath(id, normalize) ***REMOVED***
  if (normalize !== false) id = normalizeId(id);
  var p = url.parse(id, false, true);
  return _getFullPath(p);
***REMOVED***


function _getFullPath(p) ***REMOVED***
  var protocolSeparator = p.protocol || p.href.slice(0,2) == '//' ? '//' : '';
  return (p.protocol||'') + protocolSeparator + (p.host||'') + (p.path||'')  + '#';
***REMOVED***


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) ***REMOVED***
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
***REMOVED***


function resolveUrl(baseId, id) ***REMOVED***
  id = normalizeId(id);
  return url.resolve(baseId, id);
***REMOVED***


/* @this Ajv */
function resolveIds(schema) ***REMOVED***
  /* eslint no-shadow: 0 */
  /* jshint validthis: true */
  var id = normalizeId(schema.id);
  var localRefs = ***REMOVED******REMOVED***;
  _resolveIds.call(this, schema, getFullPath(id, false), id);
  return localRefs;

  /* @this Ajv */
  function _resolveIds(schema, fullPath, baseId) ***REMOVED***
    /* jshint validthis: true */
    if (Array.isArray(schema)) ***REMOVED***
      for (var i=0; i<schema.length; i++)
        _resolveIds.call(this, schema[i], fullPath+'/'+i, baseId);
    ***REMOVED*** else if (schema && typeof schema == 'object') ***REMOVED***
      if (typeof schema.id == 'string') ***REMOVED***
        var id = baseId = baseId
                          ? url.resolve(baseId, schema.id)
                          : schema.id;
        id = normalizeId(id);

        var refVal = this._refs[id];
        if (typeof refVal == 'string') refVal = this._refs[refVal];
        if (refVal && refVal.schema) ***REMOVED***
          if (!equal(schema, refVal.schema))
            throw new Error('id "' + id + '" resolves to more than one schema');
        ***REMOVED*** else if (id != normalizeId(fullPath)) ***REMOVED***
          if (id[0] == '#') ***REMOVED***
            if (localRefs[id] && !equal(schema, localRefs[id]))
              throw new Error('id "' + id + '" resolves to more than one schema');
            localRefs[id] = schema;
          ***REMOVED*** else ***REMOVED***
            this._refs[id] = fullPath;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      for (var key in schema)
        _resolveIds.call(this, schema[key], fullPath+'/'+util.escapeFragment(key), baseId);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
