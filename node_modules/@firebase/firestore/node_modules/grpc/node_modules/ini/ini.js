exports.parse = exports.decode = decode

exports.stringify = exports.encode = encode

exports.safe = safe
exports.unsafe = unsafe

var eol = typeof process !== 'undefined' &&
  process.platform === 'win32' ? '\r\n' : '\n'

function encode (obj, opt) ***REMOVED***
  var children = []
  var out = ''

  if (typeof opt === 'string') ***REMOVED***
    opt = ***REMOVED***
      section: opt,
      whitespace: false
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    opt = opt || ***REMOVED******REMOVED***
    opt.whitespace = opt.whitespace === true
  ***REMOVED***

  var separator = opt.whitespace ? ' = ' : '='

  Object.keys(obj).forEach(function (k, _, __) ***REMOVED***
    var val = obj[k]
    if (val && Array.isArray(val)) ***REMOVED***
      val.forEach(function (item) ***REMOVED***
        out += safe(k + '[]') + separator + safe(item) + '\n'
      ***REMOVED***)
    ***REMOVED*** else if (val && typeof val === 'object') ***REMOVED***
      children.push(k)
    ***REMOVED*** else ***REMOVED***
      out += safe(k) + separator + safe(val) + eol
    ***REMOVED***
  ***REMOVED***)

  if (opt.section && out.length) ***REMOVED***
    out = '[' + safe(opt.section) + ']' + eol + out
  ***REMOVED***

  children.forEach(function (k, _, __) ***REMOVED***
    var nk = dotSplit(k).join('\\.')
    var section = (opt.section ? opt.section + '.' : '') + nk
    var child = encode(obj[k], ***REMOVED***
      section: section,
      whitespace: opt.whitespace
    ***REMOVED***)
    if (out.length && child.length) ***REMOVED***
      out += eol
    ***REMOVED***
    out += child
  ***REMOVED***)

  return out
***REMOVED***

function dotSplit (str) ***REMOVED***
  return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002')
    .replace(/\\\./g, '\u0001')
    .split(/\./).map(function (part) ***REMOVED***
      return part.replace(/\1/g, '\\.')
      .replace(/\2LITERAL\\1LITERAL\2/g, '\u0001')
    ***REMOVED***)
***REMOVED***

function decode (str) ***REMOVED***
  var out = ***REMOVED******REMOVED***
  var p = out
  var section = null
  //          section     |key      = value
  var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i
  var lines = str.split(/[\r\n]+/g)

  lines.forEach(function (line, _, __) ***REMOVED***
    if (!line || line.match(/^\s*[;#]/)) return
    var match = line.match(re)
    if (!match) return
    if (match[1] !== undefined) ***REMOVED***
      section = unsafe(match[1])
      p = out[section] = out[section] || ***REMOVED******REMOVED***
      return
    ***REMOVED***
    var key = unsafe(match[2])
    var value = match[3] ? unsafe(match[4]) : true
    switch (value) ***REMOVED***
      case 'true':
      case 'false':
      case 'null': value = JSON.parse(value)
    ***REMOVED***

    // Convert keys with '[]' suffix to an array
    if (key.length > 2 && key.slice(-2) === '[]') ***REMOVED***
      key = key.substring(0, key.length - 2)
      if (!p[key]) ***REMOVED***
        p[key] = []
      ***REMOVED*** else if (!Array.isArray(p[key])) ***REMOVED***
        p[key] = [p[key]]
      ***REMOVED***
    ***REMOVED***

    // safeguard against resetting a previously defined
    // array by accidentally forgetting the brackets
    if (Array.isArray(p[key])) ***REMOVED***
      p[key].push(value)
    ***REMOVED*** else ***REMOVED***
      p[key] = value
    ***REMOVED***
  ***REMOVED***)

  // ***REMOVED***a:***REMOVED***y:1***REMOVED***,"a.b":***REMOVED***x:2***REMOVED******REMOVED*** --> ***REMOVED***a:***REMOVED***y:1,b:***REMOVED***x:2***REMOVED******REMOVED******REMOVED***
  // use a filter to return the keys that have to be deleted.
  Object.keys(out).filter(function (k, _, __) ***REMOVED***
    if (!out[k] ||
      typeof out[k] !== 'object' ||
      Array.isArray(out[k])) ***REMOVED***
      return false
    ***REMOVED***
    // see if the parent section is also an object.
    // if so, add it to that, and mark this one for deletion
    var parts = dotSplit(k)
    var p = out
    var l = parts.pop()
    var nl = l.replace(/\\\./g, '.')
    parts.forEach(function (part, _, __) ***REMOVED***
      if (!p[part] || typeof p[part] !== 'object') p[part] = ***REMOVED******REMOVED***
      p = p[part]
    ***REMOVED***)
    if (p === out && nl === l) ***REMOVED***
      return false
    ***REMOVED***
    p[nl] = out[k]
    return true
  ***REMOVED***).forEach(function (del, _, __) ***REMOVED***
    delete out[del]
  ***REMOVED***)

  return out
***REMOVED***

function isQuoted (val) ***REMOVED***
  return (val.charAt(0) === '"' && val.slice(-1) === '"') ||
    (val.charAt(0) === "'" && val.slice(-1) === "'")
***REMOVED***

function safe (val) ***REMOVED***
  return (typeof val !== 'string' ||
    val.match(/[=\r\n]/) ||
    val.match(/^\[/) ||
    (val.length > 1 &&
     isQuoted(val)) ||
    val !== val.trim())
      ? JSON.stringify(val)
      : val.replace(/;/g, '\\;').replace(/#/g, '\\#')
***REMOVED***

function unsafe (val, doUnesc) ***REMOVED***
  val = (val || '').trim()
  if (isQuoted(val)) ***REMOVED***
    // remove the single quotes before calling JSON.parse
    if (val.charAt(0) === "'") ***REMOVED***
      val = val.substr(1, val.length - 2)
    ***REMOVED***
    try ***REMOVED*** val = JSON.parse(val) ***REMOVED*** catch (_) ***REMOVED******REMOVED***
  ***REMOVED*** else ***REMOVED***
    // walk the val to find the first not-escaped ; character
    var esc = false
    var unesc = ''
    for (var i = 0, l = val.length; i < l; i++) ***REMOVED***
      var c = val.charAt(i)
      if (esc) ***REMOVED***
        if ('\\;#'.indexOf(c) !== -1) ***REMOVED***
          unesc += c
        ***REMOVED*** else ***REMOVED***
          unesc += '\\' + c
        ***REMOVED***
        esc = false
      ***REMOVED*** else if (';#'.indexOf(c) !== -1) ***REMOVED***
        break
      ***REMOVED*** else if (c === '\\') ***REMOVED***
        esc = true
      ***REMOVED*** else ***REMOVED***
        unesc += c
      ***REMOVED***
    ***REMOVED***
    if (esc) ***REMOVED***
      unesc += '\\'
    ***REMOVED***
    return unesc.trim()
  ***REMOVED***
  return val
***REMOVED***
