/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** SnapshotVersion ***REMOVED*** from '../core/snapshot_version';
import ***REMOVED*** Timestamp ***REMOVED*** from '../core/timestamp';
import ***REMOVED*** documentKeySet ***REMOVED*** from '../model/collections';
import ***REMOVED*** DocumentKey ***REMOVED*** from '../model/document_key';
import ***REMOVED*** assert, fail ***REMOVED*** from '../util/assert';
import ***REMOVED*** immediateSuccessor ***REMOVED*** from '../util/misc';
import * as EncodedResourcePath from './encoded_resource_path';
import ***REMOVED*** DbTarget, DbTargetDocument, DbTargetGlobal ***REMOVED*** from './indexeddb_schema';
import ***REMOVED*** PersistencePromise ***REMOVED*** from './persistence_promise';
import ***REMOVED*** SimpleDbTransaction ***REMOVED*** from './simple_db';
var IndexedDbQueryCache = /** @class */ (function () ***REMOVED***
    function IndexedDbQueryCache(serializer) ***REMOVED***
        this.serializer = serializer;
        /**
         * The last received snapshot version. We store this seperately from the
         * metadata to avoid the extra conversion to/from DbTimestamp.
         */
        this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;
        /**
         * A cached copy of the metadata for the query cache.
         */
        this.metadata = new DbTargetGlobal(
        /*highestTargetId=*/ 0, 
        /*lastListenSequenceNumber=*/ 0, SnapshotVersion.MIN.toTimestamp());
        /** The garbage collector to notify about potential garbage keys. */
        this.garbageCollector = null;
    ***REMOVED***
    IndexedDbQueryCache.prototype.start = function (transaction) ***REMOVED***
        var _this = this;
        return globalTargetStore(transaction)
            .get(DbTargetGlobal.key)
            .next(function (metadata) ***REMOVED***
            if (metadata !== null) ***REMOVED***
                _this.metadata = metadata;
                var lastSavedVersion = metadata.lastRemoteSnapshotVersion;
                _this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos));
            ***REMOVED***
            return PersistencePromise.resolve();
        ***REMOVED***);
    ***REMOVED***;
    IndexedDbQueryCache.prototype.getHighestTargetId = function () ***REMOVED***
        return this.metadata.highestTargetId;
    ***REMOVED***;
    IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function () ***REMOVED***
        return this.lastRemoteSnapshotVersion;
    ***REMOVED***;
    IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) ***REMOVED***
        this.lastRemoteSnapshotVersion = snapshotVersion;
        this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();
        return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);
    ***REMOVED***;
    IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) ***REMOVED***
        var _this = this;
        var targetId = queryData.targetId;
        var addedQueryPromise = targetsStore(transaction).put(this.serializer.toDbTarget(queryData));
        if (targetId > this.metadata.highestTargetId) ***REMOVED***
            this.metadata.highestTargetId = targetId;
            return addedQueryPromise.next(function () ***REMOVED***
                return globalTargetStore(transaction).put(DbTargetGlobal.key, _this.metadata);
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            return addedQueryPromise;
        ***REMOVED***
    ***REMOVED***;
    IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) ***REMOVED***
        return this.removeMatchingKeysForTargetId(transaction, queryData.targetId).next(function () ***REMOVED***
            targetsStore(transaction).delete(queryData.targetId);
        ***REMOVED***);
    ***REMOVED***;
    IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) ***REMOVED***
        var _this = this;
        // Iterating by the canonicalId may yield more than one result because
        // canonicalId values are not required to be unique per target. This query
        // depends on the queryTargets index to be efficent.
        var canonicalId = query.canonicalId();
        var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);
        var result = null;
        return targetsStore(transaction)
            .iterate(***REMOVED*** range: range, index: DbTarget.queryTargetsIndexName ***REMOVED***, function (key, value, control) ***REMOVED***
            var found = _this.serializer.fromDbTarget(value);
            // After finding a potential match, check that the query is
            // actually equal to the requested query.
            if (query.isEqual(found.query)) ***REMOVED***
                result = found;
                control.done();
            ***REMOVED***
        ***REMOVED***)
            .next(function () ***REMOVED*** return result; ***REMOVED***);
    ***REMOVED***;
    IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) ***REMOVED***
        // PORTING NOTE: The reverse index (documentsTargets) is maintained by
        // Indexeddb.
        var promises = [];
        var store = documentTargetStore(txn);
        keys.forEach(function (key) ***REMOVED***
            var path = EncodedResourcePath.encode(key.path);
            promises.push(store.put(new DbTargetDocument(targetId, path)));
        ***REMOVED***);
        return PersistencePromise.waitFor(promises);
    ***REMOVED***;
    IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) ***REMOVED***
        var _this = this;
        // PORTING NOTE: The reverse index (documentsTargets) is maintained by
        // IndexedDb.
        var promises = [];
        var store = documentTargetStore(txn);
        keys.forEach(function (key) ***REMOVED***
            var path = EncodedResourcePath.encode(key.path);
            promises.push(store.delete([targetId, path]));
            if (_this.garbageCollector !== null) ***REMOVED***
                _this.garbageCollector.addPotentialGarbageKey(key);
            ***REMOVED***
        ***REMOVED***);
        return PersistencePromise.waitFor(promises);
    ***REMOVED***;
    IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) ***REMOVED***
        var store = documentTargetStore(txn);
        var range = IDBKeyRange.bound([targetId], [targetId + 1], 
        /*lowerOpen=*/ false, 
        /*upperOpen=*/ true);
        return this.notifyGCForRemovedKeys(txn, range).next(function () ***REMOVED***
            return store.delete(range);
        ***REMOVED***);
    ***REMOVED***;
    IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function (txn, range) ***REMOVED***
        var _this = this;
        var store = documentTargetStore(txn);
        if (this.garbageCollector !== null && this.garbageCollector.isEager) ***REMOVED***
            // In order to generate garbage events properly, we need to read these
            // keys before deleting.
            return store.iterate(***REMOVED*** range: range, keysOnly: true ***REMOVED***, function (key, _, control) ***REMOVED***
                var path = EncodedResourcePath.decode(key[1]);
                var docKey = new DocumentKey(path);
                // Paranoid assertion in case the the collector is set to null
                // during the iteration.
                assert(_this.garbageCollector !== null, 'GarbageCollector for query cache set to null during key removal.');
                _this.garbageCollector.addPotentialGarbageKey(docKey);
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            return PersistencePromise.resolve();
        ***REMOVED***
    ***REMOVED***;
    IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) ***REMOVED***
        var promises = [];
        var range = IDBKeyRange.bound([targetId], [targetId + 1], 
        /*lowerOpen=*/ false, 
        /*upperOpen=*/ true);
        var store = documentTargetStore(txn);
        var result = documentKeySet();
        return store
            .iterate(***REMOVED*** range: range, keysOnly: true ***REMOVED***, function (key, _, control) ***REMOVED***
            var path = EncodedResourcePath.decode(key[1]);
            var docKey = new DocumentKey(path);
            result = result.add(docKey);
        ***REMOVED***)
            .next(function () ***REMOVED*** return result; ***REMOVED***);
    ***REMOVED***;
    IndexedDbQueryCache.prototype.setGarbageCollector = function (gc) ***REMOVED***
        this.garbageCollector = gc;
    ***REMOVED***;
    IndexedDbQueryCache.prototype.containsKey = function (txn, key) ***REMOVED***
        assert(txn !== null, 'Persistence Transaction cannot be null for query cache containsKey');
        var path = EncodedResourcePath.encode(key.path);
        var range = IDBKeyRange.bound([path], [immediateSuccessor(path)], 
        /*lowerOpen=*/ false, 
        /*upperOpen=*/ true);
        var count = 0;
        return documentTargetStore(txn)
            .iterate(***REMOVED***
            index: DbTargetDocument.documentTargetsIndex,
            keysOnly: true,
            range: range
        ***REMOVED***, function (key, _, control) ***REMOVED***
            count++;
            control.done();
        ***REMOVED***)
            .next(function () ***REMOVED*** return count > 0; ***REMOVED***);
    ***REMOVED***;
    return IndexedDbQueryCache;
***REMOVED***());
export ***REMOVED*** IndexedDbQueryCache ***REMOVED***;
/**
 * Helper to get a typed SimpleDbStore for the queries object store.
 */
function targetsStore(txn) ***REMOVED***
    return getStore(txn, DbTarget.store);
***REMOVED***
/**
 * Helper to get a typed SimpleDbStore for the target globals object store.
 */
function globalTargetStore(txn) ***REMOVED***
    return getStore(txn, DbTargetGlobal.store);
***REMOVED***
/**
 * Helper to get a typed SimpleDbStore for the document target object store.
 */
function documentTargetStore(txn) ***REMOVED***
    return getStore(txn, DbTargetDocument.store);
***REMOVED***
/**
 * Helper to get a typed SimpleDbStore from a transaction.
 */
function getStore(txn, store) ***REMOVED***
    if (txn instanceof SimpleDbTransaction) ***REMOVED***
        return txn.store(store);
    ***REMOVED***
    else ***REMOVED***
        return fail('Invalid transaction object provided!');
    ***REMOVED***
***REMOVED***

//# sourceMappingURL=indexeddb_query_cache.js.map
