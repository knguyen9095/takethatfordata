/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** Timestamp ***REMOVED*** from '../core/timestamp';
import ***REMOVED*** ObjectValue ***REMOVED*** from '../model/field_value';
import ***REMOVED*** ArrayValue, BlobValue, BooleanValue, DoubleValue, GeoPointValue, IntegerValue, NullValue, RefValue, StringValue, TimestampValue ***REMOVED*** from '../model/field_value';
import ***REMOVED*** FieldMask, FieldTransform, PatchMutation, ServerTimestampTransform, SetMutation, TransformMutation ***REMOVED*** from '../model/mutation';
import ***REMOVED*** FieldPath ***REMOVED*** from '../model/path';
import ***REMOVED*** assert, fail ***REMOVED*** from '../util/assert';
import ***REMOVED*** Code, FirestoreError ***REMOVED*** from '../util/error';
import ***REMOVED*** isPlainObject, valueDescription ***REMOVED*** from '../util/input_validation';
import ***REMOVED*** primitiveComparator ***REMOVED*** from '../util/misc';
import * as objUtils from '../util/obj';
import ***REMOVED*** SortedMap ***REMOVED*** from '../util/sorted_map';
import * as typeUtils from '../util/types';
import ***REMOVED*** Blob ***REMOVED*** from './blob';
import ***REMOVED*** FieldPath as ExternalFieldPath, fromDotSeparatedString ***REMOVED*** from './field_path';
import ***REMOVED*** DeleteFieldValueImpl, FieldValueImpl, ServerTimestampFieldValueImpl ***REMOVED*** from './field_value';
import ***REMOVED*** GeoPoint ***REMOVED*** from './geo_point';
var RESERVED_FIELD_REGEX = /^__.*__$/;
/** The result of parsing document data (e.g. for a setData call). */
var ParsedSetData = /** @class */ (function () ***REMOVED***
    function ParsedSetData(data, fieldMask, fieldTransforms) ***REMOVED***
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
    ***REMOVED***
    ParsedSetData.prototype.toMutations = function (key, precondition) ***REMOVED***
        var mutations = [];
        if (this.fieldMask !== null) ***REMOVED***
            mutations.push(new PatchMutation(key, this.data, this.fieldMask, precondition));
        ***REMOVED***
        else ***REMOVED***
            mutations.push(new SetMutation(key, this.data, precondition));
        ***REMOVED***
        if (this.fieldTransforms.length > 0) ***REMOVED***
            mutations.push(new TransformMutation(key, this.fieldTransforms));
        ***REMOVED***
        return mutations;
    ***REMOVED***;
    return ParsedSetData;
***REMOVED***());
export ***REMOVED*** ParsedSetData ***REMOVED***;
/** The result of parsing "update" data (i.e. for an updateData call). */
var ParsedUpdateData = /** @class */ (function () ***REMOVED***
    function ParsedUpdateData(data, fieldMask, fieldTransforms) ***REMOVED***
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
    ***REMOVED***
    ParsedUpdateData.prototype.toMutations = function (key, precondition) ***REMOVED***
        var mutations = [
            new PatchMutation(key, this.data, this.fieldMask, precondition)
        ];
        if (this.fieldTransforms.length > 0) ***REMOVED***
            mutations.push(new TransformMutation(key, this.fieldTransforms));
        ***REMOVED***
        return mutations;
    ***REMOVED***;
    return ParsedUpdateData;
***REMOVED***());
export ***REMOVED*** ParsedUpdateData ***REMOVED***;
/*
 * Represents what type of API method provided the data being parsed; useful
 * for determining which error conditions apply during parsing and providing
 * better error messages.
 */
var UserDataSource;
(function (UserDataSource) ***REMOVED***
    UserDataSource[UserDataSource["Set"] = 0] = "Set";
    UserDataSource[UserDataSource["Update"] = 1] = "Update";
    UserDataSource[UserDataSource["MergeSet"] = 2] = "MergeSet";
    UserDataSource[UserDataSource["QueryValue"] = 3] = "QueryValue"; // from a where clause or cursor bound
***REMOVED***)(UserDataSource || (UserDataSource = ***REMOVED******REMOVED***));
function isWrite(dataSource) ***REMOVED***
    switch (dataSource) ***REMOVED***
        case UserDataSource.Set: // fall through
        case UserDataSource.MergeSet: // fall through
        case UserDataSource.Update:
            return true;
        case UserDataSource.QueryValue:
            return false;
        default:
            throw fail("Unexpected case for UserDataSource: " + dataSource);
    ***REMOVED***
***REMOVED***
/** A "context" object passed around while parsing user data. */
var ParseContext = /** @class */ (function () ***REMOVED***
    /**
     * Initializes a ParseContext with the given source and path.
     *
     * @param dataSource Indicates what kind of API method this data came from.
     * @param methodName The name of the method the user called to create this
     *     ParseContext.
     * @param path A path within the object being parsed. This could be an empty
     *     path (in which case the context represents the root of the data being
     *     parsed), or a nonempty path (indicating the context represents a nested
     *     location within the data).
     * @param arrayElement Whether or not this context corresponds to an element
     *     of an array.
     * @param fieldTransforms A mutable list of field transforms encountered while
     *     parsing the data.
     * @param fieldMask A mutable list of field paths encountered while parsing
     *     the data.
     *
     * TODO(b/34871131): We don't support array paths right now, so path can be
     * null to indicate the context represents any location within an array (in
     * which case certain features will not work and errors will be somewhat
     * compromised).
     */
    function ParseContext(dataSource, methodName, path, arrayElement, fieldTransforms, fieldMask) ***REMOVED***
        this.dataSource = dataSource;
        this.methodName = methodName;
        this.path = path;
        this.arrayElement = arrayElement;
        // Minor hack: If fieldTransforms is undefined, we assume this is an
        // external call and we need to validate the entire path.
        if (fieldTransforms === undefined) ***REMOVED***
            this.validatePath();
        ***REMOVED***
        this.arrayElement = arrayElement !== undefined ? arrayElement : false;
        this.fieldTransforms = fieldTransforms || [];
        this.fieldMask = fieldMask || [];
    ***REMOVED***
    ParseContext.prototype.childContextForField = function (field) ***REMOVED***
        var childPath = this.path == null ? null : this.path.child(field);
        var context = new ParseContext(this.dataSource, this.methodName, childPath, 
        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);
        context.validatePathSegment(field);
        return context;
    ***REMOVED***;
    ParseContext.prototype.childContextForFieldPath = function (field) ***REMOVED***
        var childPath = this.path == null ? null : this.path.child(field);
        var context = new ParseContext(this.dataSource, this.methodName, childPath, 
        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);
        context.validatePath();
        return context;
    ***REMOVED***;
    ParseContext.prototype.childContextForArray = function (index) ***REMOVED***
        // TODO(b/34871131): We don't support array paths right now; so make path
        // null.
        return new ParseContext(this.dataSource, this.methodName, 
        /*path=*/ null, 
        /*arrayElement=*/ true, this.fieldTransforms, this.fieldMask);
    ***REMOVED***;
    ParseContext.prototype.createError = function (reason) ***REMOVED***
        var fieldDescription = this.path === null || this.path.isEmpty()
            ? ''
            : " (found in field " + this.path.toString() + ")";
        return new FirestoreError(Code.INVALID_ARGUMENT, "Function " + this.methodName + "() called with invalid data. " +
            reason +
            fieldDescription);
    ***REMOVED***;
    ParseContext.prototype.validatePath = function () ***REMOVED***
        // TODO(b/34871131): Remove null check once we have proper paths for fields
        // within arrays.
        if (this.path === null) ***REMOVED***
            return;
        ***REMOVED***
        for (var i = 0; i < this.path.length; i++) ***REMOVED***
            this.validatePathSegment(this.path.get(i));
        ***REMOVED***
    ***REMOVED***;
    ParseContext.prototype.validatePathSegment = function (segment) ***REMOVED***
        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) ***REMOVED***
            throw this.createError('Document fields cannot begin and end with __');
        ***REMOVED***
    ***REMOVED***;
    ParseContext.prototype.isWrite = function () ***REMOVED***
        return (this.dataSource === UserDataSource.Set ||
            this.dataSource === UserDataSource.Update);
    ***REMOVED***;
    return ParseContext;
***REMOVED***());
/**
 * A placeholder object for DocumentReferences in this file, in order to
 * avoid a circular dependency. See the comments for `DataPreConverter` for
 * the full context.
 */
var DocumentKeyReference = /** @class */ (function () ***REMOVED***
    function DocumentKeyReference(databaseId, key) ***REMOVED***
        this.databaseId = databaseId;
        this.key = key;
    ***REMOVED***
    return DocumentKeyReference;
***REMOVED***());
export ***REMOVED*** DocumentKeyReference ***REMOVED***;
/**
 * Helper for parsing raw user input (provided via the API) into internal model
 * classes.
 */
var UserDataConverter = /** @class */ (function () ***REMOVED***
    function UserDataConverter(preConverter) ***REMOVED***
        this.preConverter = preConverter;
    ***REMOVED***
    /** Parse document data from a non-merge set() call. */
    UserDataConverter.prototype.parseSetData = function (methodName, input) ***REMOVED***
        var context = new ParseContext(UserDataSource.Set, methodName, FieldPath.EMPTY_PATH);
        validatePlainObject('Data must be an object, but it was:', context, input);
        var updateData = this.parseData(input, context);
        return new ParsedSetData(updateData, 
        /* fieldMask= */ null, context.fieldTransforms);
    ***REMOVED***;
    /** Parse document data from a set() call with '***REMOVED***merge:true***REMOVED***'. */
    UserDataConverter.prototype.parseMergeData = function (methodName, input) ***REMOVED***
        var context = new ParseContext(UserDataSource.MergeSet, methodName, FieldPath.EMPTY_PATH);
        validatePlainObject('Data must be an object, but it was:', context, input);
        var updateData = this.parseData(input, context);
        var fieldMask = new FieldMask(context.fieldMask);
        return new ParsedSetData(updateData, fieldMask, context.fieldTransforms);
    ***REMOVED***;
    /** Parse update data from an update() call. */
    UserDataConverter.prototype.parseUpdateData = function (methodName, input) ***REMOVED***
        var _this = this;
        var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);
        validatePlainObject('Data must be an object, but it was:', context, input);
        var fieldMaskPaths = [];
        var updateData = ObjectValue.EMPTY;
        objUtils.forEach(input, function (key, value) ***REMOVED***
            var path = fieldPathFromDotSeparatedString(methodName, key);
            var childContext = context.childContextForFieldPath(path);
            value = _this.runPreConverter(value, childContext);
            if (value instanceof DeleteFieldValueImpl) ***REMOVED***
                // Add it to the field mask, but don't add anything to updateData.
                fieldMaskPaths.push(path);
            ***REMOVED***
            else ***REMOVED***
                var parsedValue = _this.parseData(value, childContext);
                if (parsedValue != null) ***REMOVED***
                    fieldMaskPaths.push(path);
                    updateData = updateData.set(path, parsedValue);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
        var mask = new FieldMask(fieldMaskPaths);
        return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
    ***REMOVED***;
    /** Parse update data from a list of field/value arguments. */
    UserDataConverter.prototype.parseUpdateVarargs = function (methodName, field, value, moreFieldsAndValues) ***REMOVED***
        var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);
        var keys = [fieldPathFromArgument(methodName, field)];
        var values = [value];
        if (moreFieldsAndValues.length % 2 !== 0) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() needs to be called with an even number " +
                'of arguments that alternate between field names and values.');
        ***REMOVED***
        for (var i = 0; i < moreFieldsAndValues.length; i += 2) ***REMOVED***
            keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));
            values.push(moreFieldsAndValues[i + 1]);
        ***REMOVED***
        var fieldMaskPaths = [];
        var updateData = ObjectValue.EMPTY;
        for (var i = 0; i < keys.length; ++i) ***REMOVED***
            var path = keys[i];
            var childContext = context.childContextForFieldPath(path);
            var value_1 = this.runPreConverter(values[i], childContext);
            if (value_1 instanceof DeleteFieldValueImpl) ***REMOVED***
                // Add it to the field mask, but don't add anything to updateData.
                fieldMaskPaths.push(path);
            ***REMOVED***
            else ***REMOVED***
                var parsedValue = this.parseData(value_1, childContext);
                if (parsedValue != null) ***REMOVED***
                    fieldMaskPaths.push(path);
                    updateData = updateData.set(path, parsedValue);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        var mask = new FieldMask(fieldMaskPaths);
        return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
    ***REMOVED***;
    /**
     * Parse a "query value" (e.g. value in a where filter or a value in a cursor
     * bound).
     */
    UserDataConverter.prototype.parseQueryValue = function (methodName, input) ***REMOVED***
        var context = new ParseContext(UserDataSource.QueryValue, methodName, FieldPath.EMPTY_PATH);
        var parsed = this.parseData(input, context);
        assert(parsed != null, 'Parsed data should not be null.');
        assert(context.fieldTransforms.length === 0, 'Field transforms should have been disallowed.');
        return parsed;
    ***REMOVED***;
    /** Sends data through this.preConverter, handling any thrown errors. */
    UserDataConverter.prototype.runPreConverter = function (input, context) ***REMOVED***
        try ***REMOVED***
            return this.preConverter(input);
        ***REMOVED***
        catch (e) ***REMOVED***
            var message = errorMessage(e);
            throw context.createError(message);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Internal helper for parsing user data.
     *
     * @param input Data to be parsed.
     * @param context A context object representing the current path being parsed,
     * the source of the data being parsed, etc.
     * @return The parsed value, or null if the value was a FieldValue sentinel
     * that should not be included in the resulting parsed data.
     */
    UserDataConverter.prototype.parseData = function (input, context) ***REMOVED***
        input = this.runPreConverter(input, context);
        if (input instanceof Array) ***REMOVED***
            // TODO(b/34871131): Include the path containing the array in the error
            // message.
            if (context.arrayElement) ***REMOVED***
                throw context.createError('Nested arrays are not supported');
            ***REMOVED***
            // If context.path is null we are already inside an array and we don't
            // support field mask paths more granular than the top-level array.
            if (context.path) ***REMOVED***
                context.fieldMask.push(context.path);
            ***REMOVED***
            return this.parseArray(input, context);
        ***REMOVED***
        else if (looksLikeJsonObject(input)) ***REMOVED***
            validatePlainObject('Unsupported field value:', context, input);
            return this.parseObject(input, context);
        ***REMOVED***
        else ***REMOVED***
            // If context.path is null, we are inside an array and we should have
            // already added the root of the array to the field mask.
            if (context.path) ***REMOVED***
                context.fieldMask.push(context.path);
            ***REMOVED***
            return this.parseScalarValue(input, context);
        ***REMOVED***
    ***REMOVED***;
    UserDataConverter.prototype.parseArray = function (array, context) ***REMOVED***
        var result = [];
        var entryIndex = 0;
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) ***REMOVED***
            var entry = array_1[_i];
            var parsedEntry = this.parseData(entry, context.childContextForArray(entryIndex));
            if (parsedEntry == null) ***REMOVED***
                // Just include nulls in the array for fields being replaced with a
                // sentinel.
                parsedEntry = NullValue.INSTANCE;
            ***REMOVED***
            result.push(parsedEntry);
            entryIndex++;
        ***REMOVED***
        return new ArrayValue(result);
    ***REMOVED***;
    UserDataConverter.prototype.parseObject = function (obj, context) ***REMOVED***
        var _this = this;
        var result = new SortedMap(primitiveComparator);
        objUtils.forEach(obj, function (key, val) ***REMOVED***
            var parsedValue = _this.parseData(val, context.childContextForField(key));
            if (parsedValue != null) ***REMOVED***
                result = result.insert(key, parsedValue);
            ***REMOVED***
        ***REMOVED***);
        return new ObjectValue(result);
    ***REMOVED***;
    /**
     * Helper to parse a scalar value (i.e. not an Object or Array)
     *
     * @return The parsed value, or null if the value was a FieldValue sentinel
     * that should not be included in the resulting parsed data.
     */
    UserDataConverter.prototype.parseScalarValue = function (value, context) ***REMOVED***
        if (value === null) ***REMOVED***
            return NullValue.INSTANCE;
        ***REMOVED***
        else if (typeof value === 'number') ***REMOVED***
            if (typeUtils.isSafeInteger(value)) ***REMOVED***
                return new IntegerValue(value);
            ***REMOVED***
            else ***REMOVED***
                return new DoubleValue(value);
            ***REMOVED***
        ***REMOVED***
        else if (typeof value === 'boolean') ***REMOVED***
            return BooleanValue.of(value);
        ***REMOVED***
        else if (typeof value === 'string') ***REMOVED***
            return new StringValue(value);
        ***REMOVED***
        else if (value instanceof Date) ***REMOVED***
            return new TimestampValue(Timestamp.fromDate(value));
        ***REMOVED***
        else if (value instanceof GeoPoint) ***REMOVED***
            return new GeoPointValue(value);
        ***REMOVED***
        else if (value instanceof Blob) ***REMOVED***
            return new BlobValue(value);
        ***REMOVED***
        else if (value instanceof DocumentKeyReference) ***REMOVED***
            return new RefValue(value.databaseId, value.key);
        ***REMOVED***
        else if (value instanceof FieldValueImpl) ***REMOVED***
            if (value instanceof DeleteFieldValueImpl) ***REMOVED***
                if (context.dataSource === UserDataSource.MergeSet) ***REMOVED***
                    return null;
                ***REMOVED***
                else if (context.dataSource === UserDataSource.Update) ***REMOVED***
                    assert(context.path == null || context.path.length > 0, 'FieldValue.delete() at the top level should have already' +
                        ' been handled.');
                    throw context.createError('FieldValue.delete() can only appear at the top level ' +
                        'of your update data');
                ***REMOVED***
                else ***REMOVED***
                    // We shouldn't encounter delete sentinels for queries or non-merge set() calls.
                    throw context.createError('FieldValue.delete() can only be used with update() and set() with ***REMOVED***merge:true***REMOVED***');
                ***REMOVED***
            ***REMOVED***
            else if (value instanceof ServerTimestampFieldValueImpl) ***REMOVED***
                if (!isWrite(context.dataSource)) ***REMOVED***
                    throw context.createError('FieldValue.serverTimestamp() can only be used with set()' +
                        ' and update()');
                ***REMOVED***
                if (context.path === null) ***REMOVED***
                    throw context.createError('FieldValue.serverTimestamp() is not currently' +
                        ' supported inside arrays');
                ***REMOVED***
                context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance));
                // Return null so this value is omitted from the parsed result.
                return null;
            ***REMOVED***
            else ***REMOVED***
                return fail('Unknown FieldValue type: ' + value);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            throw context.createError("Unsupported field value: " + valueDescription(value));
        ***REMOVED***
    ***REMOVED***;
    return UserDataConverter;
***REMOVED***());
export ***REMOVED*** UserDataConverter ***REMOVED***;
/**
 * Checks whether an object looks like a JSON object that should be converted
 * into a struct. Normal class/prototype instances are considered to look like
 * JSON objects since they should be converted to a struct value. Arrays, Dates,
 * GeoPoints, etc. are not considered to look like JSON objects since they map
 * to specific FieldValue types other than ObjectValue.
 */
function looksLikeJsonObject(input) ***REMOVED***
    return (typeof input === 'object' &&
        input !== null &&
        !(input instanceof Array) &&
        !(input instanceof Date) &&
        !(input instanceof GeoPoint) &&
        !(input instanceof Blob) &&
        !(input instanceof DocumentKeyReference) &&
        !(input instanceof FieldValueImpl));
***REMOVED***
function validatePlainObject(message, context, input) ***REMOVED***
    if (!looksLikeJsonObject(input) || !isPlainObject(input)) ***REMOVED***
        var description = valueDescription(input);
        if (description === 'an object') ***REMOVED***
            // Massage the error if it was an object.
            throw context.createError(message + ' a custom object');
        ***REMOVED***
        else ***REMOVED***
            throw context.createError(message + ' ' + description);
        ***REMOVED***
    ***REMOVED***
***REMOVED***
/**
 * Helper that calls fromDotSeparatedString() but wraps any error thrown.
 */
export function fieldPathFromArgument(methodName, path) ***REMOVED***
    if (path instanceof ExternalFieldPath) ***REMOVED***
        return path._internalPath;
    ***REMOVED***
    else if (typeof path === 'string') ***REMOVED***
        return fieldPathFromDotSeparatedString(methodName, path);
    ***REMOVED***
    else ***REMOVED***
        var message = 'Field path arguments must be of type string or FieldPath.';
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() called with invalid data. " + message);
    ***REMOVED***
***REMOVED***
/**
 * Wraps fromDotSeparatedString with an error message about the method that
 * was thrown.
 * @param methodName The publicly visible method name
 * @param path The dot-separated string form of a field path which will be split
 * on dots.
 */
function fieldPathFromDotSeparatedString(methodName, path) ***REMOVED***
    try ***REMOVED***
        return fromDotSeparatedString(path)._internalPath;
    ***REMOVED***
    catch (e) ***REMOVED***
        var message = errorMessage(e);
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() called with invalid data. " + message);
    ***REMOVED***
***REMOVED***
/**
 * Extracts the message from a caught exception, which should be an Error object
 * though JS doesn't guarantee that.
 */
function errorMessage(error) ***REMOVED***
    return error instanceof Error ? error.message : error.toString();
***REMOVED***

//# sourceMappingURL=user_data_converter.js.map
