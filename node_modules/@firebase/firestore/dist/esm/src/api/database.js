/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
import ***REMOVED*** FieldPath as ExternalFieldPath ***REMOVED*** from './field_path';
import ***REMOVED*** DatabaseId, DatabaseInfo ***REMOVED*** from '../core/database_info';
import ***REMOVED*** FirestoreClient ***REMOVED*** from '../core/firestore_client';
import ***REMOVED*** Bound, Direction, fieldFilter, OrderBy, Query as InternalQuery, RelationFilter, RelationOp ***REMOVED*** from '../core/query';
import ***REMOVED*** ChangeType ***REMOVED*** from '../core/view_snapshot';
import ***REMOVED*** NoDocument ***REMOVED*** from '../model/document';
import ***REMOVED*** DocumentKey ***REMOVED*** from '../model/document_key';
import ***REMOVED*** ArrayValue, FieldValueOptions, ObjectValue, RefValue ***REMOVED*** from '../model/field_value';
import ***REMOVED*** DeleteMutation, Precondition ***REMOVED*** from '../model/mutation';
import ***REMOVED*** ResourcePath ***REMOVED*** from '../model/path';
import ***REMOVED*** PlatformSupport ***REMOVED*** from '../platform/platform';
import ***REMOVED*** makeConstructorPrivate ***REMOVED*** from '../util/api';
import ***REMOVED*** assert, fail ***REMOVED*** from '../util/assert';
import ***REMOVED*** AsyncObserver ***REMOVED*** from '../util/async_observer';
import ***REMOVED*** AsyncQueue ***REMOVED*** from '../util/async_queue';
import ***REMOVED*** Code, FirestoreError ***REMOVED*** from '../util/error';
import ***REMOVED*** invalidClassError, validateArgType, validateAtLeastNumberOfArgs, validateBetweenNumberOfArgs, validateDefined, validateExactNumberOfArgs, validateNamedOptionalType, validateNamedOptionalPropertyEquals, validateNamedType, validateOptionalArgType, validateOptionNames, valueDescription ***REMOVED*** from '../util/input_validation';
import * as log from '../util/log';
import ***REMOVED*** LogLevel ***REMOVED*** from '../util/log';
import ***REMOVED*** AutoId ***REMOVED*** from '../util/misc';
import * as objUtils from '../util/obj';
import ***REMOVED*** EmptyCredentialsProvider, FirebaseCredentialsProvider, makeCredentialsProvider ***REMOVED*** from './credentials';
import ***REMOVED*** isPartialObserver ***REMOVED*** from './observer';
import ***REMOVED*** DocumentKeyReference, fieldPathFromArgument, UserDataConverter ***REMOVED*** from './user_data_converter';
// The objects that are a part of this API are exposed to third-parties as
// compiled javascript so we want to flag our private members with a leading
// underscore to discourage their use.
// tslint:disable:strip-private-property-underscore
var DEFAULT_HOST = 'firestore.googleapis.com';
var DEFAULT_SSL = true;
/**
 * A concrete type describing all the values that can be applied via a
 * user-supplied firestore.Settings object. This is a separate type so that
 * defaults can be supplied and the value can be checked for equality.
 */
var FirestoreSettings = /** @class */ (function () ***REMOVED***
    function FirestoreSettings(settings) ***REMOVED***
        if (settings.host === undefined) ***REMOVED***
            if (settings.ssl !== undefined) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
            ***REMOVED***
            this.host = DEFAULT_HOST;
            this.ssl = DEFAULT_SSL;
        ***REMOVED***
        else ***REMOVED***
            validateNamedType('settings', 'string', 'host', settings.host);
            this.host = settings.host;
            validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);
            this.ssl = objUtils.defaulted(settings.ssl, DEFAULT_SSL);
        ***REMOVED***
        validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);
        validateNamedOptionalType('settings', 'object', 'credentials', settings.credentials);
        this.credentials = settings.credentials;
    ***REMOVED***
    FirestoreSettings.prototype.isEqual = function (other) ***REMOVED***
        return (this.host === other.host &&
            this.ssl === other.ssl &&
            this.credentials === other.credentials);
    ***REMOVED***;
    return FirestoreSettings;
***REMOVED***());
var FirestoreConfig = /** @class */ (function () ***REMOVED***
    function FirestoreConfig() ***REMOVED***
    ***REMOVED***
    return FirestoreConfig;
***REMOVED***());
/**
 * The root reference to the database.
 */
var Firestore = /** @class */ (function () ***REMOVED***
    function Firestore(databaseIdOrApp) ***REMOVED***
        var _this = this;
        // Public for use in tests.
        // TODO(mikelehen): Use modularized initialization instead.
        this._queue = new AsyncQueue();
        this.INTERNAL = ***REMOVED***
            delete: function () ***REMOVED***
                if (_this._firestoreClient) ***REMOVED***
                    return _this._firestoreClient.shutdown();
                ***REMOVED***
                else ***REMOVED***
                    return Promise.resolve();
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
        var config = new FirestoreConfig();
        if (typeof databaseIdOrApp.options === 'object') ***REMOVED***
            // This is very likely a Firebase app object
            // TODO(b/34177605): Can we somehow use instanceof?
            var app = databaseIdOrApp;
            config.firebaseApp = app;
            config.databaseId = Firestore.databaseIdFromApp(app);
            config.persistenceKey = config.firebaseApp.name;
            config.credentials = new FirebaseCredentialsProvider(app);
        ***REMOVED***
        else ***REMOVED***
            var external_1 = databaseIdOrApp;
            if (!external_1.projectId) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide projectId');
            ***REMOVED***
            config.databaseId = new DatabaseId(external_1.projectId, external_1.database);
            // Use a default persistenceKey that lines up with FirebaseApp.
            config.persistenceKey = '[DEFAULT]';
            config.credentials = new EmptyCredentialsProvider();
        ***REMOVED***
        config.settings = new FirestoreSettings(***REMOVED******REMOVED***);
        this._config = config;
        this._databaseId = config.databaseId;
    ***REMOVED***
    Firestore.prototype.settings = function (settingsLiteral) ***REMOVED***
        validateExactNumberOfArgs('Firestore.settings', arguments, 1);
        validateArgType('Firestore.settings', 'object', 1, settingsLiteral);
        if (objUtils.contains(settingsLiteral, 'persistence')) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, '"persistence" is now specified with a separate call to ' +
                'firestore.enablePersistence().');
        ***REMOVED***
        var newSettings = new FirestoreSettings(settingsLiteral);
        if (this._firestoreClient && !this._config.settings.isEqual(newSettings)) ***REMOVED***
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +
                'be changed. You can only call settings() before calling any other ' +
                'methods on a Firestore object.');
        ***REMOVED***
        this._config.settings = newSettings;
        if (newSettings.credentials !== undefined) ***REMOVED***
            this._config.credentials = makeCredentialsProvider(newSettings.credentials);
        ***REMOVED***
    ***REMOVED***;
    Firestore.prototype.enableNetwork = function () ***REMOVED***
        this.ensureClientConfigured();
        return this._firestoreClient.enableNetwork();
    ***REMOVED***;
    Firestore.prototype.disableNetwork = function () ***REMOVED***
        this.ensureClientConfigured();
        return this._firestoreClient.disableNetwork();
    ***REMOVED***;
    Firestore.prototype.enablePersistence = function () ***REMOVED***
        if (this._firestoreClient) ***REMOVED***
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer ' +
                'be enabled. You can only call enablePersistence() before calling ' +
                'any other methods on a Firestore object.');
        ***REMOVED***
        return this.configureClient(/* persistence= */ true);
    ***REMOVED***;
    Firestore.prototype.ensureClientConfigured = function () ***REMOVED***
        if (!this._firestoreClient) ***REMOVED***
            this.configureClient(/* persistence= */ false);
        ***REMOVED***
        return this._firestoreClient;
    ***REMOVED***;
    Firestore.prototype.configureClient = function (persistence) ***REMOVED***
        var _this = this;
        assert(!!this._config.settings.host, 'FirestoreSettings.host cannot be falsey');
        assert(!this._firestoreClient, 'configureClient() called multiple times');
        var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);
        var preConverter = function (value) ***REMOVED***
            if (value instanceof DocumentReference) ***REMOVED***
                var thisDb = _this._config.databaseId;
                var otherDb = value.firestore._config.databaseId;
                if (!otherDb.isEqual(thisDb)) ***REMOVED***
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document reference is for database ' +
                        (otherDb.projectId + "/" + otherDb.database + " but should be ") +
                        ("for database " + thisDb.projectId + "/" + thisDb.database));
                ***REMOVED***
                return new DocumentKeyReference(_this._config.databaseId, value._key);
            ***REMOVED***
            else ***REMOVED***
                return value;
            ***REMOVED***
        ***REMOVED***;
        this._dataConverter = new UserDataConverter(preConverter);
        this._firestoreClient = new FirestoreClient(PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, this._queue);
        return this._firestoreClient.start(persistence);
    ***REMOVED***;
    Firestore.databaseIdFromApp = function (app) ***REMOVED***
        var options = app.options;
        if (!objUtils.contains(options, 'projectId')) ***REMOVED***
            // TODO(b/62673263): We can safely remove the special handling of
            // 'firestoreId' once alpha testers have upgraded.
            if (objUtils.contains(options, 'firestoreId')) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, '"firestoreId" is now specified as "projectId" in ' +
                    'firebase.initializeApp.');
            ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
        ***REMOVED***
        if (objUtils.contains(options, 'firestoreOptions')) ***REMOVED***
            // TODO(b/62673263): We can safely remove the special handling of
            // 'firestoreOptions' once alpha testers have upgraded.
            throw new FirestoreError(Code.INVALID_ARGUMENT, '"firestoreOptions" values are now specified with ' +
                'Firestore.settings()');
        ***REMOVED***
        var projectId = options['projectId'];
        if (!projectId || typeof projectId !== 'string') ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'projectId must be a string in FirebaseApp.options');
        ***REMOVED***
        return new DatabaseId(projectId);
    ***REMOVED***;
    Object.defineProperty(Firestore.prototype, "app", ***REMOVED***
        get: function () ***REMOVED***
            if (!this._config.firebaseApp) ***REMOVED***
                throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is " +
                    'not available');
            ***REMOVED***
            return this._config.firebaseApp;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Firestore.prototype.collection = function (pathString) ***REMOVED***
        validateExactNumberOfArgs('Firestore.collection', arguments, 1);
        validateArgType('Firestore.collection', 'string', 1, pathString);
        if (!pathString) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection path to collection()');
        ***REMOVED***
        this.ensureClientConfigured();
        return new CollectionReference(ResourcePath.fromString(pathString), this);
    ***REMOVED***;
    Firestore.prototype.doc = function (pathString) ***REMOVED***
        validateExactNumberOfArgs('Firestore.doc', arguments, 1);
        validateArgType('Firestore.doc', 'string', 1, pathString);
        if (!pathString) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty document path to doc()');
        ***REMOVED***
        this.ensureClientConfigured();
        return DocumentReference.forPath(ResourcePath.fromString(pathString), this);
    ***REMOVED***;
    Firestore.prototype.runTransaction = function (updateFunction) ***REMOVED***
        var _this = this;
        validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);
        validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);
        return this.ensureClientConfigured().transaction(function (transaction) ***REMOVED***
            return updateFunction(new Transaction(_this, transaction));
        ***REMOVED***);
    ***REMOVED***;
    Firestore.prototype.batch = function () ***REMOVED***
        this.ensureClientConfigured();
        return new WriteBatch(this);
    ***REMOVED***;
    Object.defineProperty(Firestore, "logLevel", ***REMOVED***
        get: function () ***REMOVED***
            switch (log.getLogLevel()) ***REMOVED***
                case LogLevel.DEBUG:
                    return 'debug';
                case LogLevel.ERROR:
                    return 'error';
                case LogLevel.SILENT:
                    return 'silent';
                default:
                    return fail('Unknown log level: ' + log.getLogLevel());
            ***REMOVED***
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Firestore.setLogLevel = function (level) ***REMOVED***
        validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);
        validateArgType('Firestore.setLogLevel', 'string', 1, level);
        switch (level) ***REMOVED***
            case 'debug':
                log.setLogLevel(log.LogLevel.DEBUG);
                break;
            case 'error':
                log.setLogLevel(log.LogLevel.ERROR);
                break;
            case 'silent':
                log.setLogLevel(log.LogLevel.SILENT);
                break;
            default:
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid log level: ' + level);
        ***REMOVED***
    ***REMOVED***;
    return Firestore;
***REMOVED***());
export ***REMOVED*** Firestore ***REMOVED***;
/**
 * A reference to a transaction.
 */
var Transaction = /** @class */ (function () ***REMOVED***
    function Transaction(_firestore, _transaction) ***REMOVED***
        this._firestore = _firestore;
        this._transaction = _transaction;
    ***REMOVED***
    Transaction.prototype.get = function (documentRef) ***REMOVED***
        var _this = this;
        validateExactNumberOfArgs('Transaction.get', arguments, 1);
        var ref = validateReference('Transaction.get', documentRef, this._firestore);
        return this._transaction
            .lookup([ref._key])
            .then(function (docs) ***REMOVED***
            if (!docs || docs.length !== 1) ***REMOVED***
                return fail('Mismatch in docs returned from document lookup.');
            ***REMOVED***
            var doc = docs[0];
            if (doc instanceof NoDocument) ***REMOVED***
                return new DocumentSnapshot(_this._firestore, ref._key, null, false);
            ***REMOVED***
            return new DocumentSnapshot(_this._firestore, ref._key, doc, false);
        ***REMOVED***);
    ***REMOVED***;
    Transaction.prototype.set = function (documentRef, value, options) ***REMOVED***
        validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);
        var ref = validateReference('Transaction.set', documentRef, this._firestore);
        options = validateSetOptions('Transaction.set', options);
        var parsed = options.merge
            ? this._firestore._dataConverter.parseMergeData('Transaction.set', value)
            : this._firestore._dataConverter.parseSetData('Transaction.set', value);
        this._transaction.set(ref._key, parsed);
        return this;
    ***REMOVED***;
    Transaction.prototype.update = function (documentRef, fieldOrUpdateData, value) ***REMOVED***
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) ***REMOVED***
            moreFieldsAndValues[_i - 3] = arguments[_i];
        ***REMOVED***
        var ref;
        var parsed;
        if (typeof fieldOrUpdateData === 'string' ||
            fieldOrUpdateData instanceof ExternalFieldPath) ***REMOVED***
            validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);
            ref = validateReference('Transaction.update', documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateVarargs('Transaction.update', fieldOrUpdateData, value, moreFieldsAndValues);
        ***REMOVED***
        else ***REMOVED***
            validateExactNumberOfArgs('Transaction.update', arguments, 2);
            ref = validateReference('Transaction.update', documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateData('Transaction.update', fieldOrUpdateData);
        ***REMOVED***
        this._transaction.update(ref._key, parsed);
        return this;
    ***REMOVED***;
    Transaction.prototype.delete = function (documentRef) ***REMOVED***
        validateExactNumberOfArgs('Transaction.delete', arguments, 1);
        var ref = validateReference('Transaction.delete', documentRef, this._firestore);
        this._transaction.delete(ref._key);
        return this;
    ***REMOVED***;
    return Transaction;
***REMOVED***());
export ***REMOVED*** Transaction ***REMOVED***;
var WriteBatch = /** @class */ (function () ***REMOVED***
    function WriteBatch(_firestore) ***REMOVED***
        this._firestore = _firestore;
        this._mutations = [];
        this._committed = false;
    ***REMOVED***
    WriteBatch.prototype.set = function (documentRef, value, options) ***REMOVED***
        validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);
        this.verifyNotCommitted();
        var ref = validateReference('WriteBatch.set', documentRef, this._firestore);
        options = validateSetOptions('WriteBatch.set', options);
        var parsed = options.merge
            ? this._firestore._dataConverter.parseMergeData('WriteBatch.set', value)
            : this._firestore._dataConverter.parseSetData('WriteBatch.set', value);
        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.NONE));
        return this;
    ***REMOVED***;
    WriteBatch.prototype.update = function (documentRef, fieldOrUpdateData, value) ***REMOVED***
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) ***REMOVED***
            moreFieldsAndValues[_i - 3] = arguments[_i];
        ***REMOVED***
        this.verifyNotCommitted();
        var ref;
        var parsed;
        if (typeof fieldOrUpdateData === 'string' ||
            fieldOrUpdateData instanceof ExternalFieldPath) ***REMOVED***
            validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);
            ref = validateReference('WriteBatch.update', documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update', fieldOrUpdateData, value, moreFieldsAndValues);
        ***REMOVED***
        else ***REMOVED***
            validateExactNumberOfArgs('WriteBatch.update', arguments, 2);
            ref = validateReference('WriteBatch.update', documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateData('WriteBatch.update', fieldOrUpdateData);
        ***REMOVED***
        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.exists(true)));
        return this;
    ***REMOVED***;
    WriteBatch.prototype.delete = function (documentRef) ***REMOVED***
        validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);
        this.verifyNotCommitted();
        var ref = validateReference('WriteBatch.delete', documentRef, this._firestore);
        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.NONE));
        return this;
    ***REMOVED***;
    WriteBatch.prototype.commit = function () ***REMOVED***
        this.verifyNotCommitted();
        this._committed = true;
        if (this._mutations.length > 0) ***REMOVED***
            return this._firestore.ensureClientConfigured().write(this._mutations);
        ***REMOVED***
        else ***REMOVED***
            return Promise.resolve();
        ***REMOVED***
    ***REMOVED***;
    WriteBatch.prototype.verifyNotCommitted = function () ***REMOVED***
        if (this._committed) ***REMOVED***
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +
                'has been called.');
        ***REMOVED***
    ***REMOVED***;
    return WriteBatch;
***REMOVED***());
export ***REMOVED*** WriteBatch ***REMOVED***;
/**
 * A reference to a particular document in a collection in the database.
 */
var DocumentReference = /** @class */ (function () ***REMOVED***
    function DocumentReference(_key, firestore) ***REMOVED***
        this._key = _key;
        this.firestore = firestore;
        this._firestoreClient = this.firestore.ensureClientConfigured();
    ***REMOVED***
    DocumentReference.forPath = function (path, firestore) ***REMOVED***
        if (path.length % 2 !== 0) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid document reference. Document ' +
                'references must have an even number of segments, but ' +
                (path.canonicalString() + " has " + path.length));
        ***REMOVED***
        return new DocumentReference(new DocumentKey(path), firestore);
    ***REMOVED***;
    Object.defineProperty(DocumentReference.prototype, "id", ***REMOVED***
        get: function () ***REMOVED***
            return this._key.path.lastSegment();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(DocumentReference.prototype, "parent", ***REMOVED***
        get: function () ***REMOVED***
            return new CollectionReference(this._key.path.popLast(), this.firestore);
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(DocumentReference.prototype, "path", ***REMOVED***
        get: function () ***REMOVED***
            return this._key.path.canonicalString();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    DocumentReference.prototype.collection = function (pathString) ***REMOVED***
        validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);
        validateArgType('DocumentReference.collection', 'string', 1, pathString);
        if (!pathString) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection name to collection()');
        ***REMOVED***
        var path = ResourcePath.fromString(pathString);
        return new CollectionReference(this._key.path.child(path), this.firestore);
    ***REMOVED***;
    DocumentReference.prototype.isEqual = function (other) ***REMOVED***
        if (!(other instanceof DocumentReference)) ***REMOVED***
            throw invalidClassError('isEqual', 'DocumentReference', 1, other);
        ***REMOVED***
        return this.firestore === other.firestore && this._key.isEqual(other._key);
    ***REMOVED***;
    DocumentReference.prototype.set = function (value, options) ***REMOVED***
        validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);
        options = validateSetOptions('DocumentReference.set', options);
        var parsed = options.merge
            ? this.firestore._dataConverter.parseMergeData('DocumentReference.set', value)
            : this.firestore._dataConverter.parseSetData('DocumentReference.set', value);
        return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.NONE));
    ***REMOVED***;
    DocumentReference.prototype.update = function (fieldOrUpdateData, value) ***REMOVED***
        var moreFieldsAndValues = [];
        for (var _i = 2; _i < arguments.length; _i++) ***REMOVED***
            moreFieldsAndValues[_i - 2] = arguments[_i];
        ***REMOVED***
        var parsed;
        if (typeof fieldOrUpdateData === 'string' ||
            fieldOrUpdateData instanceof ExternalFieldPath) ***REMOVED***
            validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);
            parsed = this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update', fieldOrUpdateData, value, moreFieldsAndValues);
        ***REMOVED***
        else ***REMOVED***
            validateExactNumberOfArgs('DocumentReference.update', arguments, 1);
            parsed = this.firestore._dataConverter.parseUpdateData('DocumentReference.update', fieldOrUpdateData);
        ***REMOVED***
        return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.exists(true)));
    ***REMOVED***;
    DocumentReference.prototype.delete = function () ***REMOVED***
        validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);
        return this._firestoreClient.write([
            new DeleteMutation(this._key, Precondition.NONE)
        ]);
    ***REMOVED***;
    DocumentReference.prototype.onSnapshot = function () ***REMOVED***
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            args[_i] = arguments[_i];
        ***REMOVED***
        validateBetweenNumberOfArgs('DocumentReference.onSnapshot', arguments, 1, 4);
        var options = ***REMOVED***
            includeMetadataChanges: false
        ***REMOVED***;
        var observer;
        var currArg = 0;
        if (typeof args[currArg] === 'object' &&
            !isPartialObserver(args[currArg])) ***REMOVED***
            options = args[currArg];
            validateOptionNames('DocumentReference.onSnapshot', options, [
                'includeMetadataChanges'
            ]);
            validateNamedOptionalType('DocumentReference.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);
            currArg++;
        ***REMOVED***
        var internalOptions = ***REMOVED***
            includeDocumentMetadataChanges: options.includeMetadataChanges,
            includeQueryMetadataChanges: options.includeMetadataChanges
        ***REMOVED***;
        if (isPartialObserver(args[currArg])) ***REMOVED***
            observer = args[currArg];
        ***REMOVED***
        else ***REMOVED***
            validateArgType('DocumentReference.onSnapshot', 'function', currArg, args[currArg]);
            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 1, args[currArg + 1]);
            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 2, args[currArg + 2]);
            observer = ***REMOVED***
                next: args[currArg],
                error: args[currArg + 1],
                complete: args[currArg + 2]
            ***REMOVED***;
        ***REMOVED***
        return this.onSnapshotInternal(internalOptions, observer);
    ***REMOVED***;
    DocumentReference.prototype.onSnapshotInternal = function (options, observer) ***REMOVED***
        var _this = this;
        var errHandler = function (err) ***REMOVED***
            console.error('Uncaught Error in onSnapshot:', err);
        ***REMOVED***;
        if (observer.error) ***REMOVED***
            errHandler = observer.error.bind(observer);
        ***REMOVED***
        var asyncObserver = new AsyncObserver(***REMOVED***
            next: function (snapshot) ***REMOVED***
                if (observer.next) ***REMOVED***
                    assert(snapshot.docs.size <= 1, 'Too many documents returned on a document query');
                    var doc = snapshot.docs.get(_this._key);
                    observer.next(new DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache));
                ***REMOVED***
            ***REMOVED***,
            error: errHandler
        ***REMOVED***);
        var internalListener = this._firestoreClient.listen(InternalQuery.atPath(this._key.path), asyncObserver, options);
        return function () ***REMOVED***
            asyncObserver.mute();
            _this._firestoreClient.unlisten(internalListener);
        ***REMOVED***;
    ***REMOVED***;
    DocumentReference.prototype.get = function () ***REMOVED***
        var _this = this;
        validateExactNumberOfArgs('DocumentReference.get', arguments, 0);
        return new Promise(function (resolve, reject) ***REMOVED***
            var unlisten = _this.onSnapshotInternal(***REMOVED***
                includeQueryMetadataChanges: true,
                includeDocumentMetadataChanges: true,
                waitForSyncWhenOnline: true
            ***REMOVED***, ***REMOVED***
                next: function (snap) ***REMOVED***
                    // Remove query first before passing event to user to avoid
                    // user actions affecting the now stale query.
                    unlisten();
                    if (!snap.exists && snap.metadata.fromCache) ***REMOVED***
                        // TODO(dimond): If we're online and the document doesn't
                        // exist then we resolve with a doc.exists set to false. If
                        // we're offline however, we reject the Promise in this
                        // case. Two options: 1) Cache the negative response from
                        // the server so we can deliver that even when you're
                        // offline 2) Actually reject the Promise in the online case
                        // if the document doesn't exist.
                        reject(new FirestoreError(Code.ABORTED, 'Failed to get document because the client is ' + 'offline.'));
                    ***REMOVED***
                    else ***REMOVED***
                        resolve(snap);
                    ***REMOVED***
                ***REMOVED***,
                error: reject
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    return DocumentReference;
***REMOVED***());
export ***REMOVED*** DocumentReference ***REMOVED***;
var SnapshotMetadata = /** @class */ (function () ***REMOVED***
    function SnapshotMetadata(hasPendingWrites, fromCache) ***REMOVED***
        this.hasPendingWrites = hasPendingWrites;
        this.fromCache = fromCache;
    ***REMOVED***
    SnapshotMetadata.prototype.isEqual = function (other) ***REMOVED***
        return (this.hasPendingWrites === other.hasPendingWrites &&
            this.fromCache === other.fromCache);
    ***REMOVED***;
    return SnapshotMetadata;
***REMOVED***());
var DocumentSnapshot = /** @class */ (function () ***REMOVED***
    function DocumentSnapshot(_firestore, _key, _document, _fromCache) ***REMOVED***
        this._firestore = _firestore;
        this._key = _key;
        this._document = _document;
        this._fromCache = _fromCache;
    ***REMOVED***
    DocumentSnapshot.prototype.data = function (options) ***REMOVED***
        validateBetweenNumberOfArgs('DocumentSnapshot.data', arguments, 0, 1);
        options = validateSnapshotOptions('DocumentSnapshot.data', options);
        return !this._document
            ? undefined
            : this.convertObject(this._document.data, FieldValueOptions.fromSnapshotOptions(options));
    ***REMOVED***;
    DocumentSnapshot.prototype.get = function (fieldPath, options) ***REMOVED***
        validateBetweenNumberOfArgs('DocumentSnapshot.get', arguments, 1, 2);
        options = validateSnapshotOptions('DocumentSnapshot.get', options);
        if (this._document) ***REMOVED***
            var value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));
            if (value !== undefined) ***REMOVED***
                return this.convertValue(value, FieldValueOptions.fromSnapshotOptions(options));
            ***REMOVED***
        ***REMOVED***
        return undefined;
    ***REMOVED***;
    Object.defineProperty(DocumentSnapshot.prototype, "id", ***REMOVED***
        get: function () ***REMOVED***
            return this._key.path.lastSegment();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(DocumentSnapshot.prototype, "ref", ***REMOVED***
        get: function () ***REMOVED***
            return new DocumentReference(this._key, this._firestore);
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(DocumentSnapshot.prototype, "exists", ***REMOVED***
        get: function () ***REMOVED***
            return this._document !== null;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(DocumentSnapshot.prototype, "metadata", ***REMOVED***
        get: function () ***REMOVED***
            return new SnapshotMetadata(this._document !== null && this._document.hasLocalMutations, this._fromCache);
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    DocumentSnapshot.prototype.isEqual = function (other) ***REMOVED***
        if (!(other instanceof DocumentSnapshot)) ***REMOVED***
            throw invalidClassError('isEqual', 'DocumentSnapshot', 1, other);
        ***REMOVED***
        return (this._firestore === other._firestore &&
            this._fromCache === other._fromCache &&
            this._key.isEqual(other._key) &&
            (this._document === null
                ? other._document === null
                : this._document.isEqual(other._document)));
    ***REMOVED***;
    DocumentSnapshot.prototype.convertObject = function (data, options) ***REMOVED***
        var _this = this;
        var result = ***REMOVED******REMOVED***;
        data.forEach(function (key, value) ***REMOVED***
            result[key] = _this.convertValue(value, options);
        ***REMOVED***);
        return result;
    ***REMOVED***;
    DocumentSnapshot.prototype.convertValue = function (value, options) ***REMOVED***
        if (value instanceof ObjectValue) ***REMOVED***
            return this.convertObject(value, options);
        ***REMOVED***
        else if (value instanceof ArrayValue) ***REMOVED***
            return this.convertArray(value, options);
        ***REMOVED***
        else if (value instanceof RefValue) ***REMOVED***
            var key = value.value(options);
            var database = this._firestore.ensureClientConfigured().databaseId();
            if (!value.databaseId.isEqual(database)) ***REMOVED***
                // TODO(b/64130202): Somehow support foreign references.
                log.error("Document " + this._key.path + " contains a document " +
                    "reference within a different database (" +
                    (value.databaseId.projectId + "/" + value.databaseId.database + ") which is not ") +
                    "supported. It will be treated as a reference in the current " +
                    ("database (" + database.projectId + "/" + database.database + ") ") +
                    "instead.");
            ***REMOVED***
            return new DocumentReference(key, this._firestore);
        ***REMOVED***
        else ***REMOVED***
            return value.value(options);
        ***REMOVED***
    ***REMOVED***;
    DocumentSnapshot.prototype.convertArray = function (data, options) ***REMOVED***
        var _this = this;
        return data.internalValue.map(function (value) ***REMOVED***
            return _this.convertValue(value, options);
        ***REMOVED***);
    ***REMOVED***;
    return DocumentSnapshot;
***REMOVED***());
export ***REMOVED*** DocumentSnapshot ***REMOVED***;
var QueryDocumentSnapshot = /** @class */ (function (_super) ***REMOVED***
    __extends(QueryDocumentSnapshot, _super);
    function QueryDocumentSnapshot(firestore, key, document, fromCache) ***REMOVED***
        return _super.call(this, firestore, key, document, fromCache) || this;
    ***REMOVED***
    QueryDocumentSnapshot.prototype.data = function (options) ***REMOVED***
        var data = _super.prototype.data.call(this, options);
        assert(typeof data === 'object', 'Document in a QueryDocumentSnapshot should exist');
        return data;
    ***REMOVED***;
    return QueryDocumentSnapshot;
***REMOVED***(DocumentSnapshot));
export ***REMOVED*** QueryDocumentSnapshot ***REMOVED***;
var Query = /** @class */ (function () ***REMOVED***
    function Query(_query, firestore) ***REMOVED***
        this._query = _query;
        this.firestore = firestore;
    ***REMOVED***
    Query.prototype.where = function (field, opStr, value) ***REMOVED***
        validateExactNumberOfArgs('Query.where', arguments, 3);
        validateArgType('Query.where', 'string', 2, opStr);
        validateDefined('Query.where', 3, value);
        var fieldValue;
        var fieldPath = fieldPathFromArgument('Query.where', field);
        if (fieldPath.isKeyField()) ***REMOVED***
            if (typeof value === 'string') ***REMOVED***
                if (value.indexOf('/') !== -1) ***REMOVED***
                    // TODO(dimond): Allow slashes once ancestor queries are supported
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +
                        'valid document ID if the first parameter is ' +
                        'FieldPath.documentId(), but it contains a slash.');
                ***REMOVED***
                if (value === '') ***REMOVED***
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +
                        'valid document ID if the first parameter is ' +
                        'FieldPath.documentId(), but it was an empty string.');
                ***REMOVED***
                var path = this._query.path.child(new ResourcePath([value]));
                assert(path.length % 2 === 0, 'Path should be a document key');
                fieldValue = new RefValue(this.firestore._databaseId, new DocumentKey(path));
            ***REMOVED***
            else if (value instanceof DocumentReference) ***REMOVED***
                var ref = value;
                fieldValue = new RefValue(this.firestore._databaseId, ref._key);
            ***REMOVED***
            else ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.where() requires its third parameter to be a " +
                    "string or a DocumentReference if the first parameter is " +
                    "FieldPath.documentId(), but it was: " +
                    (valueDescription(value) + "."));
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            fieldValue = this.firestore._dataConverter.parseQueryValue('Query.where', value);
        ***REMOVED***
        var filter = fieldFilter(fieldPath, RelationOp.fromString(opStr), fieldValue);
        this.validateNewFilter(filter);
        return new Query(this._query.addFilter(filter), this.firestore);
    ***REMOVED***;
    Query.prototype.orderBy = function (field, directionStr) ***REMOVED***
        validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);
        validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);
        var direction;
        if (directionStr === undefined || directionStr === 'asc') ***REMOVED***
            direction = Direction.ASCENDING;
        ***REMOVED***
        else if (directionStr === 'desc') ***REMOVED***
            direction = Direction.DESCENDING;
        ***REMOVED***
        else ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.orderBy() has unknown direction '" + directionStr + "', " +
                "expected 'asc' or 'desc'.");
        ***REMOVED***
        if (this._query.startAt !== null) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.startAt() or ' +
                'Query.startAfter() before calling Query.orderBy().');
        ***REMOVED***
        if (this._query.endAt !== null) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.endAt() or ' +
                'Query.endBefore() before calling Query.orderBy().');
        ***REMOVED***
        var fieldPath = fieldPathFromArgument('Query.orderBy', field);
        var orderBy = new OrderBy(fieldPath, direction);
        this.validateNewOrderBy(orderBy);
        return new Query(this._query.addOrderBy(orderBy), this.firestore);
    ***REMOVED***;
    Query.prototype.limit = function (n) ***REMOVED***
        validateExactNumberOfArgs('Query.limit', arguments, 1);
        validateArgType('Query.limit', 'number', 1, n);
        if (n <= 0) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. Query limit (" + n + ") is invalid. Limit must be " +
                'positive.');
        ***REMOVED***
        return new Query(this._query.withLimit(n), this.firestore);
    ***REMOVED***;
    Query.prototype.startAt = function (docOrField) ***REMOVED***
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) ***REMOVED***
            fields[_i - 1] = arguments[_i];
        ***REMOVED***
        validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);
        var bound = this.boundFromDocOrFields('Query.startAt', docOrField, fields, 
        /*before=*/ true);
        return new Query(this._query.withStartAt(bound), this.firestore);
    ***REMOVED***;
    Query.prototype.startAfter = function (docOrField) ***REMOVED***
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) ***REMOVED***
            fields[_i - 1] = arguments[_i];
        ***REMOVED***
        validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);
        var bound = this.boundFromDocOrFields('Query.startAfter', docOrField, fields, 
        /*before=*/ false);
        return new Query(this._query.withStartAt(bound), this.firestore);
    ***REMOVED***;
    Query.prototype.endBefore = function (docOrField) ***REMOVED***
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) ***REMOVED***
            fields[_i - 1] = arguments[_i];
        ***REMOVED***
        validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);
        var bound = this.boundFromDocOrFields('Query.endBefore', docOrField, fields, 
        /*before=*/ true);
        return new Query(this._query.withEndAt(bound), this.firestore);
    ***REMOVED***;
    Query.prototype.endAt = function (docOrField) ***REMOVED***
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) ***REMOVED***
            fields[_i - 1] = arguments[_i];
        ***REMOVED***
        validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);
        var bound = this.boundFromDocOrFields('Query.endAt', docOrField, fields, 
        /*before=*/ false);
        return new Query(this._query.withEndAt(bound), this.firestore);
    ***REMOVED***;
    Query.prototype.isEqual = function (other) ***REMOVED***
        if (!(other instanceof Query)) ***REMOVED***
            throw invalidClassError('isEqual', 'Query', 1, other);
        ***REMOVED***
        return (this.firestore === other.firestore && this._query.isEqual(other._query));
    ***REMOVED***;
    /** Helper function to create a bound from a document or fields */
    Query.prototype.boundFromDocOrFields = function (methodName, docOrField, fields, before) ***REMOVED***
        validateDefined(methodName, 1, docOrField);
        if (docOrField instanceof DocumentSnapshot) ***REMOVED***
            if (fields.length > 0) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "().");
            ***REMOVED***
            var snap = docOrField;
            if (!snap.exists) ***REMOVED***
                throw new FirestoreError(Code.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for " +
                    (methodName + "()."));
            ***REMOVED***
            return this.boundFromDocument(methodName, snap._document, before);
        ***REMOVED***
        else ***REMOVED***
            var allFields = [docOrField].concat(fields);
            return this.boundFromFields(methodName, allFields, before);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Create a Bound from a query and a document.
     *
     * Note that the Bound will always include the key of the document
     * and so only the provided document will compare equal to the returned
     * position.
     *
     * Will throw if the document does not contain all fields of the order by
     * of the query.
     */
    Query.prototype.boundFromDocument = function (methodName, doc, before) ***REMOVED***
        var components = [];
        // Because people expect to continue/end a query at the exact document
        // provided, we need to use the implicit sort order rather than the explicit
        // sort order, because it's guaranteed to contain the document key. That way
        // the position becomes unambiguous and the query continues/ends exactly at
        // the provided document. Without the key (by using the explicit sort
        // orders), multiple documents could match the position, yielding duplicate
        // results.
        for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) ***REMOVED***
            var orderBy = _a[_i];
            if (orderBy.field.isKeyField()) ***REMOVED***
                components.push(new RefValue(this.firestore._databaseId, doc.key));
            ***REMOVED***
            else ***REMOVED***
                var value = doc.field(orderBy.field);
                if (value !== undefined) ***REMOVED***
                    components.push(value);
                ***REMOVED***
                else ***REMOVED***
                    var field = orderBy.field.canonicalString();
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a " +
                        ("document for which the field '" + field + "' (used as the ") +
                        "orderBy) does not exist.");
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        return new Bound(components, before);
    ***REMOVED***;
    /**
     * Converts a list of field values to a Bound for the given query.
     */
    Query.prototype.boundFromFields = function (methodName, values, before) ***REMOVED***
        // Use explicit order by's because it has to match the query the user made
        var orderBy = this._query.explicitOrderBy;
        if (values.length > orderBy.length) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "(). " +
                "The number of arguments must be less than or equal to the " +
                "number of Query.orderBy() clauses");
        ***REMOVED***
        var components = [];
        for (var i = 0; i < values.length; i++) ***REMOVED***
            var rawValue = values[i];
            var orderByComponent = orderBy[i];
            if (orderByComponent.field.isKeyField()) ***REMOVED***
                if (typeof rawValue !== 'string') ***REMOVED***
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in " +
                        (methodName + "(), but got a " + typeof rawValue));
                ***REMOVED***
                if (rawValue.indexOf('/') !== -1) ***REMOVED***
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Document ID '" + rawValue + "' contains a slash in " +
                        (methodName + "()"));
                ***REMOVED***
                var key = new DocumentKey(this._query.path.child(rawValue));
                components.push(new RefValue(this.firestore._databaseId, key));
            ***REMOVED***
            else ***REMOVED***
                var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);
                components.push(wrapped);
            ***REMOVED***
        ***REMOVED***
        return new Bound(components, before);
    ***REMOVED***;
    Query.prototype.onSnapshot = function () ***REMOVED***
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            args[_i] = arguments[_i];
        ***REMOVED***
        validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);
        var options = ***REMOVED******REMOVED***;
        var observer;
        var currArg = 0;
        if (typeof args[currArg] === 'object' &&
            !isPartialObserver(args[currArg])) ***REMOVED***
            options = args[currArg];
            validateOptionNames('Query.onSnapshot', options, [
                'includeQueryMetadataChanges',
                'includeDocumentMetadataChanges'
            ]);
            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeDocumentMetadataChanges', options.includeDocumentMetadataChanges);
            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeQueryMetadataChanges', options.includeQueryMetadataChanges);
            currArg++;
        ***REMOVED***
        if (isPartialObserver(args[currArg])) ***REMOVED***
            observer = args[currArg];
        ***REMOVED***
        else ***REMOVED***
            validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);
            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 1, args[currArg + 1]);
            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 2, args[currArg + 2]);
            observer = ***REMOVED***
                next: args[currArg],
                error: args[currArg + 1],
                complete: args[currArg + 2]
            ***REMOVED***;
        ***REMOVED***
        return this.onSnapshotInternal(options, observer);
    ***REMOVED***;
    Query.prototype.onSnapshotInternal = function (options, observer) ***REMOVED***
        var _this = this;
        var errHandler = function (err) ***REMOVED***
            console.error('Uncaught Error in onSnapshot:', err);
        ***REMOVED***;
        if (observer.error) ***REMOVED***
            errHandler = observer.error.bind(observer);
        ***REMOVED***
        var asyncObserver = new AsyncObserver(***REMOVED***
            next: function (result) ***REMOVED***
                if (observer.next) ***REMOVED***
                    observer.next(new QuerySnapshot(_this.firestore, _this._query, result));
                ***REMOVED***
            ***REMOVED***,
            error: errHandler
        ***REMOVED***);
        var firestoreClient = this.firestore.ensureClientConfigured();
        var internalListener = firestoreClient.listen(this._query, asyncObserver, options);
        return function () ***REMOVED***
            asyncObserver.mute();
            firestoreClient.unlisten(internalListener);
        ***REMOVED***;
    ***REMOVED***;
    Query.prototype.get = function () ***REMOVED***
        var _this = this;
        validateExactNumberOfArgs('Query.get', arguments, 0);
        return new Promise(function (resolve, reject) ***REMOVED***
            var unlisten = _this.onSnapshotInternal(***REMOVED***
                includeDocumentMetadataChanges: false,
                includeQueryMetadataChanges: true,
                waitForSyncWhenOnline: true
            ***REMOVED***, ***REMOVED***
                next: function (result) ***REMOVED***
                    // Remove query first before passing event to user to avoid
                    // user actions affecting the now stale query.
                    unlisten();
                    resolve(result);
                ***REMOVED***,
                error: reject
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    Query.prototype.validateNewFilter = function (filter) ***REMOVED***
        if (filter instanceof RelationFilter && filter.isInequality()) ***REMOVED***
            var existingField = this._query.getInequalityFilterField();
            if (existingField !== null && !existingField.isEqual(filter.field)) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' +
                    ' (<, <=, >, or >=) must be on the same field. But you have' +
                    (" inequality filters on '" + existingField.toString() + "'") +
                    (" and '" + filter.field.toString() + "'"));
            ***REMOVED***
            var firstOrderByField = this._query.getFirstOrderByField();
            if (firstOrderByField !== null) ***REMOVED***
                this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    Query.prototype.validateNewOrderBy = function (orderBy) ***REMOVED***
        if (this._query.getFirstOrderByField() === null) ***REMOVED***
            // This is the first order by. It must match any inequality.
            var inequalityField = this._query.getInequalityFilterField();
            if (inequalityField !== null) ***REMOVED***
                this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    Query.prototype.validateOrderByAndInequalityMatch = function (inequality, orderBy) ***REMOVED***
        if (!orderBy.isEqual(inequality)) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality " +
                ("(<, <=, >, or >=) on field '" + inequality.toString() + "' ") +
                ("and so you must also use '" + inequality.toString() + "' ") +
                "as your first Query.orderBy(), but your first Query.orderBy() " +
                ("is on field '" + orderBy.toString() + "' instead."));
        ***REMOVED***
    ***REMOVED***;
    return Query;
***REMOVED***());
export ***REMOVED*** Query ***REMOVED***;
var QuerySnapshot = /** @class */ (function () ***REMOVED***
    function QuerySnapshot(_firestore, _originalQuery, _snapshot) ***REMOVED***
        this._firestore = _firestore;
        this._originalQuery = _originalQuery;
        this._snapshot = _snapshot;
        this._cachedChanges = null;
        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);
    ***REMOVED***
    Object.defineProperty(QuerySnapshot.prototype, "docs", ***REMOVED***
        get: function () ***REMOVED***
            var result = [];
            this.forEach(function (doc) ***REMOVED*** return result.push(doc); ***REMOVED***);
            return result;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(QuerySnapshot.prototype, "empty", ***REMOVED***
        get: function () ***REMOVED***
            return this._snapshot.docs.isEmpty();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(QuerySnapshot.prototype, "size", ***REMOVED***
        get: function () ***REMOVED***
            return this._snapshot.docs.size;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    QuerySnapshot.prototype.forEach = function (callback, thisArg) ***REMOVED***
        var _this = this;
        validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);
        validateArgType('QuerySnapshot.forEach', 'function', 1, callback);
        this._snapshot.docs.forEach(function (doc) ***REMOVED***
            callback.call(thisArg, _this.convertToDocumentImpl(doc));
        ***REMOVED***);
    ***REMOVED***;
    Object.defineProperty(QuerySnapshot.prototype, "query", ***REMOVED***
        get: function () ***REMOVED***
            return new Query(this._originalQuery, this._firestore);
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(QuerySnapshot.prototype, "docChanges", ***REMOVED***
        get: function () ***REMOVED***
            if (!this._cachedChanges) ***REMOVED***
                this._cachedChanges = changesFromSnapshot(this._firestore, this._snapshot);
            ***REMOVED***
            return this._cachedChanges;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /** Check the equality. The call can be very expensive. */
    QuerySnapshot.prototype.isEqual = function (other) ***REMOVED***
        if (!(other instanceof QuerySnapshot)) ***REMOVED***
            throw invalidClassError('isEqual', 'QuerySnapshot', 1, other);
        ***REMOVED***
        return (this._firestore === other._firestore &&
            this._originalQuery.isEqual(other._originalQuery) &&
            this._snapshot.isEqual(other._snapshot));
    ***REMOVED***;
    QuerySnapshot.prototype.convertToDocumentImpl = function (doc) ***REMOVED***
        return new QueryDocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache);
    ***REMOVED***;
    return QuerySnapshot;
***REMOVED***());
export ***REMOVED*** QuerySnapshot ***REMOVED***;
var CollectionReference = /** @class */ (function (_super) ***REMOVED***
    __extends(CollectionReference, _super);
    function CollectionReference(path, firestore) ***REMOVED***
        var _this = _super.call(this, InternalQuery.atPath(path), firestore) || this;
        if (path.length % 2 !== 1) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid collection reference. Collection ' +
                'references must have an odd number of segments, but ' +
                (path.canonicalString() + " has " + path.length));
        ***REMOVED***
        return _this;
    ***REMOVED***
    Object.defineProperty(CollectionReference.prototype, "id", ***REMOVED***
        get: function () ***REMOVED***
            return this._query.path.lastSegment();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(CollectionReference.prototype, "parent", ***REMOVED***
        get: function () ***REMOVED***
            var parentPath = this._query.path.popLast();
            if (parentPath.isEmpty()) ***REMOVED***
                return null;
            ***REMOVED***
            else ***REMOVED***
                return new DocumentReference(new DocumentKey(parentPath), this.firestore);
            ***REMOVED***
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(CollectionReference.prototype, "path", ***REMOVED***
        get: function () ***REMOVED***
            return this._query.path.canonicalString();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    CollectionReference.prototype.doc = function (pathString) ***REMOVED***
        validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);
        // We allow omission of 'pathString' but explicitly prohibit passing in both
        // 'undefined' and 'null'.
        if (arguments.length === 0) ***REMOVED***
            pathString = AutoId.newId();
        ***REMOVED***
        validateArgType('CollectionReference.doc', 'string', 1, pathString);
        if (pathString === '') ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document path must be a non-empty string');
        ***REMOVED***
        var path = ResourcePath.fromString(pathString);
        return DocumentReference.forPath(this._query.path.child(path), this.firestore);
    ***REMOVED***;
    CollectionReference.prototype.add = function (value) ***REMOVED***
        validateExactNumberOfArgs('CollectionReference.add', arguments, 1);
        validateArgType('CollectionReference.add', 'object', 1, value);
        var docRef = this.doc();
        return docRef.set(value).then(function () ***REMOVED*** return docRef; ***REMOVED***);
    ***REMOVED***;
    return CollectionReference;
***REMOVED***(Query));
export ***REMOVED*** CollectionReference ***REMOVED***;
function validateSetOptions(methodName, options) ***REMOVED***
    if (options === undefined) ***REMOVED***
        return ***REMOVED***
            merge: false
        ***REMOVED***;
    ***REMOVED***
    validateOptionNames(methodName, options, ['merge']);
    validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);
    return options;
***REMOVED***
function validateSnapshotOptions(methodName, options) ***REMOVED***
    if (options === undefined) ***REMOVED***
        return ***REMOVED******REMOVED***;
    ***REMOVED***
    validateOptionNames(methodName, options, ['serverTimestamps']);
    validateNamedOptionalPropertyEquals(methodName, 'options', 'serverTimestamps', options.serverTimestamps, ['estimate', 'previous', 'none']);
    return options;
***REMOVED***
function validateReference(methodName, documentRef, firestore) ***REMOVED***
    if (!(documentRef instanceof DocumentReference)) ***REMOVED***
        throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);
    ***REMOVED***
    else if (documentRef.firestore !== firestore) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');
    ***REMOVED***
    else ***REMOVED***
        return documentRef;
    ***REMOVED***
***REMOVED***
/**
 * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.
 *
 * Exported for testing.
 */
export function changesFromSnapshot(firestore, snapshot) ***REMOVED***
    if (snapshot.oldDocs.isEmpty()) ***REMOVED***
        // Special case the first snapshot because index calculation is easy and
        // fast
        var lastDoc_1;
        var index_1 = 0;
        return snapshot.docChanges.map(function (change) ***REMOVED***
            var doc = new QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);
            assert(change.type === ChangeType.Added, 'Invalid event type for first snapshot');
            assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, 'Got added events in wrong order');
            lastDoc_1 = change.doc;
            return ***REMOVED***
                type: 'added',
                doc: doc,
                oldIndex: -1,
                newIndex: index_1++
            ***REMOVED***;
        ***REMOVED***);
    ***REMOVED***
    else ***REMOVED***
        // A DocumentSet that is updated incrementally as changes are applied to use
        // to lookup the index of a document.
        var indexTracker_1 = snapshot.oldDocs;
        return snapshot.docChanges.map(function (change) ***REMOVED***
            var doc = new QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);
            var oldIndex = -1;
            var newIndex = -1;
            if (change.type !== ChangeType.Added) ***REMOVED***
                oldIndex = indexTracker_1.indexOf(change.doc.key);
                assert(oldIndex >= 0, 'Index for document not found');
                indexTracker_1 = indexTracker_1.delete(change.doc.key);
            ***REMOVED***
            if (change.type !== ChangeType.Removed) ***REMOVED***
                indexTracker_1 = indexTracker_1.add(change.doc);
                newIndex = indexTracker_1.indexOf(change.doc.key);
            ***REMOVED***
            return ***REMOVED*** type: resultChangeType(change.type), doc: doc, oldIndex: oldIndex, newIndex: newIndex ***REMOVED***;
        ***REMOVED***);
    ***REMOVED***
***REMOVED***
function resultChangeType(type) ***REMOVED***
    switch (type) ***REMOVED***
        case ChangeType.Added:
            return 'added';
        case ChangeType.Modified:
        case ChangeType.Metadata:
            return 'modified';
        case ChangeType.Removed:
            return 'removed';
        default:
            return fail('Unknown change type: ' + type);
    ***REMOVED***
***REMOVED***
// Export the classes with a private constructor (it will fail if invoked
// at runtime). Note that this still allows instanceof checks.
// We're treating the variables as class names, so disable checking for lower
// case variable names.
// tslint:disable:variable-name
export var PublicFirestore = makeConstructorPrivate(Firestore, 'Use firebase.firestore() instead.');
export var PublicTransaction = makeConstructorPrivate(Transaction, 'Use firebase.firestore().runTransaction() instead.');
export var PublicWriteBatch = makeConstructorPrivate(WriteBatch, 'Use firebase.firestore().batch() instead.');
export var PublicDocumentReference = makeConstructorPrivate(DocumentReference, 'Use firebase.firestore().doc() instead.');
export var PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);
export var PublicQueryDocumentSnapshot = makeConstructorPrivate(QueryDocumentSnapshot);
export var PublicQuery = makeConstructorPrivate(Query);
export var PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);
export var PublicCollectionReference = makeConstructorPrivate(CollectionReference, 'Use firebase.firestore().collection() instead.');
// tslint:enable:variable-name

//# sourceMappingURL=database.js.map
