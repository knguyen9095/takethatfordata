/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** User ***REMOVED*** from '../auth/user';
import ***REMOVED*** assert, fail ***REMOVED*** from '../util/assert';
import ***REMOVED*** Code, FirestoreError ***REMOVED*** from '../util/error';
var OAuthToken = /** @class */ (function () ***REMOVED***
    function OAuthToken(value, user) ***REMOVED***
        this.user = user;
        this.type = 'OAuth';
        this.authHeaders = ***REMOVED*** Authorization: "Bearer " + value ***REMOVED***;
    ***REMOVED***
    return OAuthToken;
***REMOVED***());
export ***REMOVED*** OAuthToken ***REMOVED***;
/** A CredentialsProvider that always yields an empty token. */
var EmptyCredentialsProvider = /** @class */ (function () ***REMOVED***
    function EmptyCredentialsProvider() ***REMOVED***
        /**
         * Stores the User listener registered with setUserChangeListener()
         * This isn't actually necessary since the UID never changes, but we use this
         * to verify the listen contract is adhered to in tests.
         */
        this.userListener = null;
    ***REMOVED***
    EmptyCredentialsProvider.prototype.getToken = function (forceRefresh) ***REMOVED***
        return Promise.resolve(null);
    ***REMOVED***;
    EmptyCredentialsProvider.prototype.setUserChangeListener = function (listener) ***REMOVED***
        assert(!this.userListener, 'Can only call setUserChangeListener() once.');
        this.userListener = listener;
        // Fire with initial user.
        listener(User.UNAUTHENTICATED);
    ***REMOVED***;
    EmptyCredentialsProvider.prototype.removeUserChangeListener = function () ***REMOVED***
        assert(this.userListener !== null, 'removeUserChangeListener() when no listener registered');
        this.userListener = null;
    ***REMOVED***;
    return EmptyCredentialsProvider;
***REMOVED***());
export ***REMOVED*** EmptyCredentialsProvider ***REMOVED***;
var FirebaseCredentialsProvider = /** @class */ (function () ***REMOVED***
    function FirebaseCredentialsProvider(app) ***REMOVED***
        var _this = this;
        this.app = app;
        /**
         * The auth token listener registered with FirebaseApp, retained here so we
         * can unregister it.
         */
        this.tokenListener = null;
        /**
         * Counter used to detect if the user changed while a getToken request was
         * outstanding.
         */
        this.userCounter = 0;
        /** The User listener registered with setUserChangeListener(). */
        this.userListener = null;
        // We listen for token changes but all we really care about is knowing when
        // the uid may have changed.
        this.tokenListener = function () ***REMOVED***
            var newUser = _this.getUser();
            if (!_this.currentUser || !newUser.isEqual(_this.currentUser)) ***REMOVED***
                _this.currentUser = newUser;
                _this.userCounter++;
                if (_this.userListener) ***REMOVED***
                    _this.userListener(_this.currentUser);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
        this.userCounter = 0;
        // Will fire at least once where we set this.currentUser
        this.app.INTERNAL.addAuthTokenListener(this.tokenListener);
    ***REMOVED***
    FirebaseCredentialsProvider.prototype.getToken = function (forceRefresh) ***REMOVED***
        var _this = this;
        assert(this.tokenListener != null, 'getToken cannot be called after listener removed.');
        // Take note of the current value of the userCounter so that this method can
        // fail (with an ABORTED error) if there is a user change while the request
        // is outstanding.
        var initialUserCounter = this.userCounter;
        return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) ***REMOVED***
            // Cancel the request since the user changed while the request was
            // outstanding so the response is likely for a previous user (which
            // user, we can't be sure).
            if (_this.userCounter !== initialUserCounter) ***REMOVED***
                throw new FirestoreError(Code.ABORTED, 'getToken aborted due to uid change.');
            ***REMOVED***
            else ***REMOVED***
                if (tokenData) ***REMOVED***
                    assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);
                    return new OAuthToken(tokenData.accessToken, _this.currentUser);
                ***REMOVED***
                else ***REMOVED***
                    return null;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    FirebaseCredentialsProvider.prototype.setUserChangeListener = function (listener) ***REMOVED***
        assert(!this.userListener, 'Can only call setUserChangeListener() once.');
        this.userListener = listener;
        // Fire the initial event, but only if we received the initial user
        if (this.currentUser) ***REMOVED***
            listener(this.currentUser);
        ***REMOVED***
    ***REMOVED***;
    FirebaseCredentialsProvider.prototype.removeUserChangeListener = function () ***REMOVED***
        assert(this.tokenListener != null, 'removeUserChangeListener() called twice');
        assert(this.userListener !== null, 'removeUserChangeListener() called when no listener registered');
        this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);
        this.tokenListener = null;
        this.userListener = null;
    ***REMOVED***;
    FirebaseCredentialsProvider.prototype.getUser = function () ***REMOVED***
        // TODO(mikelehen): Remove this check once we're shipping with firebase.js.
        if (typeof this.app.INTERNAL.getUid !== 'function') ***REMOVED***
            fail('This version of the Firestore SDK requires at least version' +
                ' 3.7.0 of firebase.js.');
        ***REMOVED***
        var currentUid = this.app.INTERNAL.getUid();
        assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);
        return new User(currentUid);
    ***REMOVED***;
    return FirebaseCredentialsProvider;
***REMOVED***());
export ***REMOVED*** FirebaseCredentialsProvider ***REMOVED***;
/*
 * FirstPartyToken provides a fresh token each time its value
 * is requested, because if the token is too old, requests will be rejected.
 * TODO(b/33147818) this implementation violates the current assumption that
 * tokens are immutable.  We need to either revisit this assumption or come
 * up with some way for FPA to use the listen/unlisten interface.
 */
var FirstPartyToken = /** @class */ (function () ***REMOVED***
    function FirstPartyToken(gapi, sessionIndex) ***REMOVED***
        this.gapi = gapi;
        this.sessionIndex = sessionIndex;
        this.type = 'FirstParty';
        this.user = User.FIRST_PARTY;
        assert(this.gapi &&
            this.gapi['auth'] &&
            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');
    ***REMOVED***
    Object.defineProperty(FirstPartyToken.prototype, "authHeaders", ***REMOVED***
        get: function () ***REMOVED***
            return ***REMOVED***
                Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),
                'X-Goog-AuthUser': this.sessionIndex
            ***REMOVED***;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    return FirstPartyToken;
***REMOVED***());
export ***REMOVED*** FirstPartyToken ***REMOVED***;
/*
 * Provides user credentials required for the Firestore JavaScript SDK
 * to authenticate the user, using technique that is only available
 * to applications hosted by Google.
 */
var FirstPartyCredentialsProvider = /** @class */ (function () ***REMOVED***
    function FirstPartyCredentialsProvider(gapi, sessionIndex) ***REMOVED***
        this.gapi = gapi;
        this.sessionIndex = sessionIndex;
        assert(this.gapi &&
            this.gapi['auth'] &&
            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');
    ***REMOVED***
    FirstPartyCredentialsProvider.prototype.getToken = function (forceRefresh) ***REMOVED***
        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));
    ***REMOVED***;
    // TODO(33108925): can someone switch users w/o a page refresh?
    // TODO(33110621): need to understand token/session lifecycle
    FirstPartyCredentialsProvider.prototype.setUserChangeListener = function (listener) ***REMOVED***
        // Fire with initial uid.
        listener(User.FIRST_PARTY);
    ***REMOVED***;
    FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function () ***REMOVED*** ***REMOVED***;
    return FirstPartyCredentialsProvider;
***REMOVED***());
export ***REMOVED*** FirstPartyCredentialsProvider ***REMOVED***;
/**
 * Builds a CredentialsProvider depending on the type of
 * the credentials passed in.
 */
export function makeCredentialsProvider(credentials) ***REMOVED***
    if (!credentials) ***REMOVED***
        return new EmptyCredentialsProvider();
    ***REMOVED***
    switch (credentials.type) ***REMOVED***
        case 'gapi':
            return new FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');
        case 'provider':
            return credentials.client;
        default:
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');
    ***REMOVED***
***REMOVED***

//# sourceMappingURL=credentials.js.map
