/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** assert, fail ***REMOVED*** from './assert';
// An immutable sorted map implementation, based on a Left-leaning Red-Black
// tree.
var SortedMap = /** @class */ (function () ***REMOVED***
    function SortedMap(comparator, root) ***REMOVED***
        this.comparator = comparator;
        this.root = root ? root : LLRBNode.EMPTY;
    ***REMOVED***
    // Returns a copy of the map, with the specified key/value added or replaced.
    SortedMap.prototype.insert = function (key, value) ***REMOVED***
        return new SortedMap(this.comparator, this.root
            .insert(key, value, this.comparator)
            .copy(null, null, LLRBNode.BLACK, null, null));
    ***REMOVED***;
    // Returns a copy of the map, with the specified key removed.
    SortedMap.prototype.remove = function (key) ***REMOVED***
        return new SortedMap(this.comparator, this.root
            .remove(key, this.comparator)
            .copy(null, null, LLRBNode.BLACK, null, null));
    ***REMOVED***;
    // Returns the value of the node with the given key, or null.
    SortedMap.prototype.get = function (key) ***REMOVED***
        var node = this.root;
        while (!node.isEmpty()) ***REMOVED***
            var cmp = this.comparator(key, node.key);
            if (cmp === 0) ***REMOVED***
                return node.value;
            ***REMOVED***
            else if (cmp < 0) ***REMOVED***
                node = node.left;
            ***REMOVED***
            else if (cmp > 0) ***REMOVED***
                node = node.right;
            ***REMOVED***
        ***REMOVED***
        return null;
    ***REMOVED***;
    // Returns the index of the element in this sorted map, or -1 if it doesn't
    // exist.
    SortedMap.prototype.indexOf = function (key) ***REMOVED***
        // Number of nodes that were pruned when descending right
        var prunedNodes = 0;
        var node = this.root;
        while (!node.isEmpty()) ***REMOVED***
            var cmp = this.comparator(key, node.key);
            if (cmp === 0) ***REMOVED***
                return prunedNodes + node.left.size;
            ***REMOVED***
            else if (cmp < 0) ***REMOVED***
                node = node.left;
            ***REMOVED***
            else ***REMOVED***
                // Count all nodes left of the node plus the node itself
                prunedNodes += node.left.size + 1;
                node = node.right;
            ***REMOVED***
        ***REMOVED***
        // Node not found
        return -1;
    ***REMOVED***;
    SortedMap.prototype.isEmpty = function () ***REMOVED***
        return this.root.isEmpty();
    ***REMOVED***;
    Object.defineProperty(SortedMap.prototype, "size", ***REMOVED***
        // Returns the total number of nodes in the map.
        get: function () ***REMOVED***
            return this.root.size;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    // Returns the minimum key in the map.
    SortedMap.prototype.minKey = function () ***REMOVED***
        return this.root.minKey();
    ***REMOVED***;
    // Returns the maximum key in the map.
    SortedMap.prototype.maxKey = function () ***REMOVED***
        return this.root.maxKey();
    ***REMOVED***;
    // Traverses the map in key order and calls the specified action function
    // for each key/value pair. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    SortedMap.prototype.inorderTraversal = function (action) ***REMOVED***
        return this.root.inorderTraversal(action);
    ***REMOVED***;
    SortedMap.prototype.forEach = function (fn) ***REMOVED***
        this.inorderTraversal(function (k, v) ***REMOVED***
            fn(k, v);
            return false;
        ***REMOVED***);
    ***REMOVED***;
    // Traverses the map in reverse key order and calls the specified action
    // function for each key/value pair. If action returns true, traversal is
    // aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    SortedMap.prototype.reverseTraversal = function (action) ***REMOVED***
        return this.root.reverseTraversal(action);
    ***REMOVED***;
    // Returns an iterator over the SortedMap.
    SortedMap.prototype.getIterator = function () ***REMOVED***
        return new SortedMapIterator(this.root, null, this.comparator, false);
    ***REMOVED***;
    SortedMap.prototype.getIteratorFrom = function (key) ***REMOVED***
        return new SortedMapIterator(this.root, key, this.comparator, false);
    ***REMOVED***;
    SortedMap.prototype.getReverseIterator = function () ***REMOVED***
        return new SortedMapIterator(this.root, null, this.comparator, true);
    ***REMOVED***;
    SortedMap.prototype.getReverseIteratorFrom = function (key) ***REMOVED***
        return new SortedMapIterator(this.root, key, this.comparator, true);
    ***REMOVED***;
    return SortedMap;
***REMOVED***()); // end SortedMap
export ***REMOVED*** SortedMap ***REMOVED***;
// An iterator over an LLRBNode.
var SortedMapIterator = /** @class */ (function () ***REMOVED***
    function SortedMapIterator(node, startKey, comparator, isReverse) ***REMOVED***
        this.isReverse = isReverse;
        this.nodeStack = [];
        var cmp = 1;
        while (!node.isEmpty()) ***REMOVED***
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse)
                cmp *= -1;
            if (cmp < 0) ***REMOVED***
                // This node is less than our start key. ignore it
                if (this.isReverse) ***REMOVED***
                    node = node.left;
                ***REMOVED***
                else ***REMOVED***
                    node = node.right;
                ***REMOVED***
            ***REMOVED***
            else if (cmp === 0) ***REMOVED***
                // This node is exactly equal to our start key. Push it on the stack,
                // but stop iterating;
                this.nodeStack.push(node);
                break;
            ***REMOVED***
            else ***REMOVED***
                // This node is greater than our start key, add it to the stack and move
                // to the next one
                this.nodeStack.push(node);
                if (this.isReverse) ***REMOVED***
                    node = node.right;
                ***REMOVED***
                else ***REMOVED***
                    node = node.left;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    SortedMapIterator.prototype.getNext = function () ***REMOVED***
        assert(this.nodeStack.length > 0, 'getNext() called on iterator when hasNext() is false.');
        var node = this.nodeStack.pop();
        var result = ***REMOVED*** key: node.key, value: node.value ***REMOVED***;
        if (this.isReverse) ***REMOVED***
            node = node.left;
            while (!node.isEmpty()) ***REMOVED***
                this.nodeStack.push(node);
                node = node.right;
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            node = node.right;
            while (!node.isEmpty()) ***REMOVED***
                this.nodeStack.push(node);
                node = node.left;
            ***REMOVED***
        ***REMOVED***
        return result;
    ***REMOVED***;
    SortedMapIterator.prototype.hasNext = function () ***REMOVED***
        return this.nodeStack.length > 0;
    ***REMOVED***;
    SortedMapIterator.prototype.peek = function () ***REMOVED***
        if (this.nodeStack.length === 0)
            return null;
        var node = this.nodeStack[this.nodeStack.length - 1];
        return ***REMOVED*** key: node.key, value: node.value ***REMOVED***;
    ***REMOVED***;
    return SortedMapIterator;
***REMOVED***()); // end SortedMapIterator
export ***REMOVED*** SortedMapIterator ***REMOVED***;
// Represents a node in a Left-leaning Red-Black tree.
var LLRBNode = /** @class */ (function () ***REMOVED***
    function LLRBNode(key, value, color, left, right) ***REMOVED***
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left = left != null ? left : LLRBNode.EMPTY;
        this.right = right != null ? right : LLRBNode.EMPTY;
        this.size = this.left.size + 1 + this.right.size;
    ***REMOVED***
    // Returns a copy of the current node, optionally replacing pieces of it.
    LLRBNode.prototype.copy = function (key, value, color, left, right) ***REMOVED***
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    ***REMOVED***;
    LLRBNode.prototype.isEmpty = function () ***REMOVED***
        return false;
    ***REMOVED***;
    // Traverses the tree in key order and calls the specified action function
    // for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    LLRBNode.prototype.inorderTraversal = function (action) ***REMOVED***
        return (this.left.inorderTraversal(action) ||
            action(this.key, this.value) ||
            this.right.inorderTraversal(action));
    ***REMOVED***;
    // Traverses the tree in reverse key order and calls the specified action
    // function for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    LLRBNode.prototype.reverseTraversal = function (action) ***REMOVED***
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
    ***REMOVED***;
    // Returns the minimum node in the tree.
    LLRBNode.prototype.min = function () ***REMOVED***
        if (this.left.isEmpty()) ***REMOVED***
            return this;
        ***REMOVED***
        else ***REMOVED***
            return this.left.min();
        ***REMOVED***
    ***REMOVED***;
    // Returns the maximum key in the tree.
    LLRBNode.prototype.minKey = function () ***REMOVED***
        return this.min().key;
    ***REMOVED***;
    // Returns the maximum key in the tree.
    LLRBNode.prototype.maxKey = function () ***REMOVED***
        if (this.right.isEmpty()) ***REMOVED***
            return this.key;
        ***REMOVED***
        else ***REMOVED***
            return this.right.maxKey();
        ***REMOVED***
    ***REMOVED***;
    // Returns new tree, with the key/value added.
    LLRBNode.prototype.insert = function (key, value, comparator) ***REMOVED***
        var n = this;
        var cmp = comparator(key, n.key);
        if (cmp < 0) ***REMOVED***
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        ***REMOVED***
        else if (cmp === 0) ***REMOVED***
            n = n.copy(null, value, null, null, null);
        ***REMOVED***
        else ***REMOVED***
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        ***REMOVED***
        return n.fixUp();
    ***REMOVED***;
    LLRBNode.prototype.removeMin = function () ***REMOVED***
        if (this.left.isEmpty()) ***REMOVED***
            return LLRBNode.EMPTY;
        ***REMOVED***
        var n = this;
        if (!n.left.isRed() && !n.left.left.isRed())
            n = n.moveRedLeft();
        n = n.copy(null, null, null, n.left.removeMin(), null);
        return n.fixUp();
    ***REMOVED***;
    // Returns new tree, with the specified item removed.
    LLRBNode.prototype.remove = function (key, comparator) ***REMOVED***
        var smallest;
        var n = this;
        if (comparator(key, n.key) < 0) ***REMOVED***
            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) ***REMOVED***
                n = n.moveRedLeft();
            ***REMOVED***
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        ***REMOVED***
        else ***REMOVED***
            if (n.left.isRed())
                n = n.rotateRight();
            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) ***REMOVED***
                n = n.moveRedRight();
            ***REMOVED***
            if (comparator(key, n.key) === 0) ***REMOVED***
                if (n.right.isEmpty()) ***REMOVED***
                    return LLRBNode.EMPTY;
                ***REMOVED***
                else ***REMOVED***
                    smallest = n.right.min();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());
                ***REMOVED***
            ***REMOVED***
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        ***REMOVED***
        return n.fixUp();
    ***REMOVED***;
    LLRBNode.prototype.isRed = function () ***REMOVED***
        return this.color;
    ***REMOVED***;
    // Returns new tree after performing any needed rotations.
    LLRBNode.prototype.fixUp = function () ***REMOVED***
        var n = this;
        if (n.right.isRed() && !n.left.isRed())
            n = n.rotateLeft();
        if (n.left.isRed() && n.left.left.isRed())
            n = n.rotateRight();
        if (n.left.isRed() && n.right.isRed())
            n = n.colorFlip();
        return n;
    ***REMOVED***;
    LLRBNode.prototype.moveRedLeft = function () ***REMOVED***
        var n = this.colorFlip();
        if (n.right.left.isRed()) ***REMOVED***
            n = n.copy(null, null, null, null, n.right.rotateRight());
            n = n.rotateLeft();
            n = n.colorFlip();
        ***REMOVED***
        return n;
    ***REMOVED***;
    LLRBNode.prototype.moveRedRight = function () ***REMOVED***
        var n = this.colorFlip();
        if (n.left.left.isRed()) ***REMOVED***
            n = n.rotateRight();
            n = n.colorFlip();
        ***REMOVED***
        return n;
    ***REMOVED***;
    LLRBNode.prototype.rotateLeft = function () ***REMOVED***
        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
    ***REMOVED***;
    LLRBNode.prototype.rotateRight = function () ***REMOVED***
        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
    ***REMOVED***;
    LLRBNode.prototype.colorFlip = function () ***REMOVED***
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
    ***REMOVED***;
    // For testing.
    LLRBNode.prototype.checkMaxDepth = function () ***REMOVED***
        var blackDepth = this.check();
        if (Math.pow(2.0, blackDepth) <= this.size + 1) ***REMOVED***
            return true;
        ***REMOVED***
        else ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***;
    // In a balanced RB tree, the black-depth (number of black nodes) from root to
    // leaves is equal on both sides.  This function verifies that or asserts.
    LLRBNode.prototype.check = function () ***REMOVED***
        if (this.isRed() && this.left.isRed()) ***REMOVED***
            throw fail('Red node has red child(' + this.key + ',' + this.value + ')');
        ***REMOVED***
        if (this.right.isRed()) ***REMOVED***
            throw fail('Right child of (' + this.key + ',' + this.value + ') is red');
        ***REMOVED***
        var blackDepth = this.left.check();
        if (blackDepth !== this.right.check()) ***REMOVED***
            throw fail('Black depths differ');
        ***REMOVED***
        else ***REMOVED***
            return blackDepth + (this.isRed() ? 0 : 1);
        ***REMOVED***
    ***REMOVED***;
    // tslint:disable-next-line:no-any Empty node is shared between all LLRB trees.
    LLRBNode.EMPTY = null;
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    return LLRBNode;
***REMOVED***()); // end LLRBNode
export ***REMOVED*** LLRBNode ***REMOVED***;
// Represents an empty node (a leaf node in the Red-Black Tree).
var LLRBEmptyNode = /** @class */ (function () ***REMOVED***
    function LLRBEmptyNode() ***REMOVED***
        this.size = 0;
    ***REMOVED***
    // Returns a copy of the current node.
    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) ***REMOVED***
        return this;
    ***REMOVED***;
    // Returns a copy of the tree, with the specified key/value added.
    LLRBEmptyNode.prototype.insert = function (key, value, comparator) ***REMOVED***
        return new LLRBNode(key, value);
    ***REMOVED***;
    // Returns a copy of the tree, with the specified key removed.
    LLRBEmptyNode.prototype.remove = function (key, comparator) ***REMOVED***
        return this;
    ***REMOVED***;
    LLRBEmptyNode.prototype.isEmpty = function () ***REMOVED***
        return true;
    ***REMOVED***;
    LLRBEmptyNode.prototype.inorderTraversal = function (action) ***REMOVED***
        return false;
    ***REMOVED***;
    LLRBEmptyNode.prototype.reverseTraversal = function (action) ***REMOVED***
        return false;
    ***REMOVED***;
    LLRBEmptyNode.prototype.minKey = function () ***REMOVED***
        return null;
    ***REMOVED***;
    LLRBEmptyNode.prototype.maxKey = function () ***REMOVED***
        return null;
    ***REMOVED***;
    LLRBEmptyNode.prototype.isRed = function () ***REMOVED***
        return false;
    ***REMOVED***;
    // For testing.
    LLRBEmptyNode.prototype.checkMaxDepth = function () ***REMOVED***
        return true;
    ***REMOVED***;
    LLRBEmptyNode.prototype.check = function () ***REMOVED***
        return 0;
    ***REMOVED***;
    return LLRBEmptyNode;
***REMOVED***()); // end LLRBEmptyNode
export ***REMOVED*** LLRBEmptyNode ***REMOVED***;
LLRBNode.EMPTY = new LLRBEmptyNode();

//# sourceMappingURL=sorted_map.js.map
