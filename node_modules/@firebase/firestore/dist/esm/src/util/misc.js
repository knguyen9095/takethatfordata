/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** assert ***REMOVED*** from './assert';
// tslint:disable-next-line:class-as-namespace
var AutoId = /** @class */ (function () ***REMOVED***
    function AutoId() ***REMOVED***
    ***REMOVED***
    AutoId.newId = function () ***REMOVED***
        // Alphanumeric characters
        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var autoId = '';
        for (var i = 0; i < 20; i++) ***REMOVED***
            autoId += chars.charAt(Math.floor(Math.random() * chars.length));
        ***REMOVED***
        assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);
        return autoId;
    ***REMOVED***;
    return AutoId;
***REMOVED***());
export ***REMOVED*** AutoId ***REMOVED***;
export function primitiveComparator(left, right) ***REMOVED***
    if (left < right)
        return -1;
    if (left > right)
        return 1;
    return 0;
***REMOVED***
/** Helper to compare nullable (or undefined-able) objects using isEqual(). */
export function equals(left, right) ***REMOVED***
    if (left !== null && left !== undefined) ***REMOVED***
        return !!(right && left.isEqual(right));
    ***REMOVED***
    else ***REMOVED***
        // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't
        // smart enough.
        return left === right;
    ***REMOVED***
***REMOVED***
/** Helper to compare arrays using isEqual(). */
export function arrayEquals(left, right) ***REMOVED***
    if (left.length !== right.length) ***REMOVED***
        return false;
    ***REMOVED***
    for (var i = 0; i < left.length; i++) ***REMOVED***
        if (!left[i].isEqual(right[i])) ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***
    return true;
***REMOVED***
/**
 * Returns the largest lexicographically smaller string of equal or smaller
 * length. Returns an empty string if there is no such predecessor (if the input
 * is empty).
 *
 * Strings returned from this method can be invalid UTF-16 but this is sufficent
 * in use for indexeddb because that depends on lexicographical ordering but
 * shouldn't be used elsewhere.
 */
export function immediatePredecessor(s) ***REMOVED***
    // We can decrement the last character in the string and be done
    // unless that character is 0 (0x0000), in which case we have to erase the
    // last character.
    var lastIndex = s.length - 1;
    if (s.length === 0) ***REMOVED***
        // Special case the empty string.
        return '';
    ***REMOVED***
    else if (s.charAt(lastIndex) === '\0') ***REMOVED***
        return s.substring(0, lastIndex);
    ***REMOVED***
    else ***REMOVED***
        return (s.substring(0, lastIndex) +
            String.fromCharCode(s.charCodeAt(lastIndex) - 1));
    ***REMOVED***
***REMOVED***
/**
 * Returns the immediate lexicographically-following string. This is useful to
 * construct an inclusive range for indexeddb iterators.
 */
export function immediateSuccessor(s) ***REMOVED***
    // Return the input string, with an additional NUL byte appended.
    return s + '\0';
***REMOVED***

//# sourceMappingURL=misc.js.map
