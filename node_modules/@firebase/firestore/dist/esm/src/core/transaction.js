/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** SnapshotVersion ***REMOVED*** from './snapshot_version';
import ***REMOVED*** documentVersionMap ***REMOVED*** from '../model/collections';
import ***REMOVED*** NoDocument ***REMOVED*** from '../model/document';
import ***REMOVED*** DeleteMutation, Precondition ***REMOVED*** from '../model/mutation';
import ***REMOVED*** Code, FirestoreError ***REMOVED*** from '../util/error';
/**
 * Internal transaction object responsible for accumulating the mutations to
 * perform and the base versions for any documents read.
 */
var Transaction = /** @class */ (function () ***REMOVED***
    function Transaction(datastore) ***REMOVED***
        this.datastore = datastore;
        // The version of each document that was read during this transaction.
        this.readVersions = documentVersionMap();
        this.mutations = [];
        this.committed = false;
    ***REMOVED***
    Transaction.prototype.recordVersion = function (doc) ***REMOVED***
        var docVersion = doc.version;
        if (doc instanceof NoDocument) ***REMOVED***
            // For deleted docs, we must use baseVersion 0 when we overwrite them.
            docVersion = SnapshotVersion.forDeletedDoc();
        ***REMOVED***
        var existingVersion = this.readVersions.get(doc.key);
        if (existingVersion !== null) ***REMOVED***
            if (!docVersion.isEqual(existingVersion)) ***REMOVED***
                // This transaction will fail no matter what.
                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            this.readVersions = this.readVersions.insert(doc.key, docVersion);
        ***REMOVED***
    ***REMOVED***;
    Transaction.prototype.lookup = function (keys) ***REMOVED***
        var _this = this;
        if (this.committed) ***REMOVED***
            return Promise.reject('Transaction has already completed.');
        ***REMOVED***
        if (this.mutations.length > 0) ***REMOVED***
            return Promise.reject('Transactions lookups are invalid after writes.');
        ***REMOVED***
        return this.datastore.lookup(keys).then(function (docs) ***REMOVED***
            docs.forEach(function (doc) ***REMOVED*** return _this.recordVersion(doc); ***REMOVED***);
            return docs;
        ***REMOVED***);
    ***REMOVED***;
    Transaction.prototype.write = function (mutations) ***REMOVED***
        if (this.committed) ***REMOVED***
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');
        ***REMOVED***
        this.mutations = this.mutations.concat(mutations);
    ***REMOVED***;
    /**
     * Returns the version of this document when it was read in this transaction,
     * as a precondition, or no precondition if it was not read.
     */
    Transaction.prototype.precondition = function (key) ***REMOVED***
        var version = this.readVersions.get(key);
        if (version) ***REMOVED***
            return Precondition.updateTime(version);
        ***REMOVED***
        else ***REMOVED***
            return Precondition.NONE;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns the precondition for a document if the operation is an update.
     */
    Transaction.prototype.preconditionForUpdate = function (key) ***REMOVED***
        var version = this.readVersions.get(key);
        if (version && version.isEqual(SnapshotVersion.forDeletedDoc())) ***REMOVED***
            // The document doesn't exist, so fail the transaction.
            throw new FirestoreError(Code.FAILED_PRECONDITION, "Can't update a document that doesn't exist.");
        ***REMOVED***
        else if (version) ***REMOVED***
            // Document exists, base precondition on document update time.
            return Precondition.updateTime(version);
        ***REMOVED***
        else ***REMOVED***
            // Document was not read, so we just use the preconditions for a blind
            // update.
            return Precondition.exists(true);
        ***REMOVED***
    ***REMOVED***;
    Transaction.prototype.set = function (key, data) ***REMOVED***
        this.write(data.toMutations(key, this.precondition(key)));
    ***REMOVED***;
    Transaction.prototype.update = function (key, data) ***REMOVED***
        this.write(data.toMutations(key, this.preconditionForUpdate(key)));
    ***REMOVED***;
    Transaction.prototype.delete = function (key) ***REMOVED***
        this.write([new DeleteMutation(key, this.precondition(key))]);
        // Since the delete will be applied before all following writes, we need to
        // ensure that the precondition for the next write will be exists: false.
        this.readVersions = this.readVersions.insert(key, SnapshotVersion.forDeletedDoc());
    ***REMOVED***;
    Transaction.prototype.commit = function () ***REMOVED***
        var _this = this;
        var unwritten = this.readVersions;
        // For each mutation, note that the doc was written.
        this.mutations.forEach(function (mutation) ***REMOVED***
            unwritten = unwritten.remove(mutation.key);
        ***REMOVED***);
        if (!unwritten.isEmpty()) ***REMOVED***
            return Promise.reject(Error('Every document read in a transaction must also be written.'));
        ***REMOVED***
        return this.datastore.commit(this.mutations).then(function () ***REMOVED***
            _this.committed = true;
        ***REMOVED***);
    ***REMOVED***;
    return Transaction;
***REMOVED***());
export ***REMOVED*** Transaction ***REMOVED***;

//# sourceMappingURL=transaction.js.map
