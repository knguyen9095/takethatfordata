/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** OnlineState ***REMOVED*** from './types';
import ***REMOVED*** ChangeType, ViewSnapshot ***REMOVED*** from './view_snapshot';
import ***REMOVED*** DocumentSet ***REMOVED*** from '../model/document_set';
import ***REMOVED*** assert ***REMOVED*** from '../util/assert';
import ***REMOVED*** ObjectMap ***REMOVED*** from '../util/obj_map';
/**
 * Holds the listeners and the last received ViewSnapshot for a query being
 * tracked by EventManager.
 */
var QueryListenersInfo = /** @class */ (function () ***REMOVED***
    function QueryListenersInfo() ***REMOVED***
        this.listeners = [];
    ***REMOVED***
    return QueryListenersInfo;
***REMOVED***());
/**
 * EventManager is responsible for mapping queries to query event emitters.
 * It handles "fan-out". -- Identical queries will re-use the same watch on the
 * backend.
 */
var EventManager = /** @class */ (function () ***REMOVED***
    function EventManager(syncEngine) ***REMOVED***
        this.syncEngine = syncEngine;
        this.queries = new ObjectMap(function (q) ***REMOVED***
            return q.canonicalId();
        ***REMOVED***);
        this.onlineState = OnlineState.Unknown;
        this.syncEngine.subscribe(this.onChange.bind(this), this.onError.bind(this));
    ***REMOVED***
    EventManager.prototype.listen = function (listener) ***REMOVED***
        var query = listener.query;
        var firstListen = false;
        var queryInfo = this.queries.get(query);
        if (!queryInfo) ***REMOVED***
            firstListen = true;
            queryInfo = new QueryListenersInfo();
            this.queries.set(query, queryInfo);
        ***REMOVED***
        queryInfo.listeners.push(listener);
        listener.applyOnlineStateChange(this.onlineState);
        if (queryInfo.viewSnap)
            listener.onViewSnapshot(queryInfo.viewSnap);
        if (firstListen) ***REMOVED***
            return this.syncEngine.listen(query).then(function (targetId) ***REMOVED***
                queryInfo.targetId = targetId;
                return targetId;
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            return Promise.resolve(queryInfo.targetId);
        ***REMOVED***
    ***REMOVED***;
    EventManager.prototype.unlisten = function (listener) ***REMOVED***
        var query = listener.query;
        var lastListen = false;
        var queryInfo = this.queries.get(query);
        if (queryInfo) ***REMOVED***
            var i = queryInfo.listeners.indexOf(listener);
            if (i >= 0) ***REMOVED***
                queryInfo.listeners.splice(i, 1);
                lastListen = queryInfo.listeners.length === 0;
            ***REMOVED***
        ***REMOVED***
        if (lastListen) ***REMOVED***
            this.queries.delete(query);
            return this.syncEngine.unlisten(query);
        ***REMOVED***
        else ***REMOVED***
            return Promise.resolve();
        ***REMOVED***
    ***REMOVED***;
    EventManager.prototype.onChange = function (viewSnaps) ***REMOVED***
        for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) ***REMOVED***
            var viewSnap = viewSnaps_1[_i];
            var query = viewSnap.query;
            var queryInfo = this.queries.get(query);
            if (queryInfo) ***REMOVED***
                for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) ***REMOVED***
                    var listener = _b[_a];
                    listener.onViewSnapshot(viewSnap);
                ***REMOVED***
                queryInfo.viewSnap = viewSnap;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    EventManager.prototype.onError = function (query, error) ***REMOVED***
        var queryInfo = this.queries.get(query);
        if (queryInfo) ***REMOVED***
            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) ***REMOVED***
                var listener = _a[_i];
                listener.onError(error);
            ***REMOVED***
        ***REMOVED***
        // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()
        // after an error.
        this.queries.delete(query);
    ***REMOVED***;
    EventManager.prototype.applyOnlineStateChange = function (onlineState) ***REMOVED***
        this.onlineState = onlineState;
        this.queries.forEach(function (_, queryInfo) ***REMOVED***
            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) ***REMOVED***
                var listener = _a[_i];
                listener.applyOnlineStateChange(onlineState);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    return EventManager;
***REMOVED***());
export ***REMOVED*** EventManager ***REMOVED***;
/**
 * QueryListener takes a series of internal view snapshots and determines
 * when to raise the event.
 *
 * It uses an Observer to dispatch events.
 */
var QueryListener = /** @class */ (function () ***REMOVED***
    function QueryListener(query, queryObserver, options) ***REMOVED***
        this.query = query;
        this.queryObserver = queryObserver;
        /**
         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
         * observer. This flag is set to true once we've actually raised an event.
         */
        this.raisedInitialEvent = false;
        this.onlineState = OnlineState.Unknown;
        this.options = options || ***REMOVED******REMOVED***;
    ***REMOVED***
    QueryListener.prototype.onViewSnapshot = function (snap) ***REMOVED***
        assert(snap.docChanges.length > 0 || snap.syncStateChanged, 'We got a new snapshot with no changes?');
        if (!this.options.includeDocumentMetadataChanges) ***REMOVED***
            // Remove the metadata only changes.
            var docChanges = [];
            for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) ***REMOVED***
                var docChange = _a[_i];
                if (docChange.type !== ChangeType.Metadata) ***REMOVED***
                    docChanges.push(docChange);
                ***REMOVED***
            ***REMOVED***
            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.fromCache, snap.hasPendingWrites, snap.syncStateChanged);
        ***REMOVED***
        if (!this.raisedInitialEvent) ***REMOVED***
            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) ***REMOVED***
                this.raiseInitialEvent(snap);
            ***REMOVED***
        ***REMOVED***
        else if (this.shouldRaiseEvent(snap)) ***REMOVED***
            this.queryObserver.next(snap);
        ***REMOVED***
        this.snap = snap;
    ***REMOVED***;
    QueryListener.prototype.onError = function (error) ***REMOVED***
        this.queryObserver.error(error);
    ***REMOVED***;
    QueryListener.prototype.applyOnlineStateChange = function (onlineState) ***REMOVED***
        this.onlineState = onlineState;
        if (this.snap &&
            !this.raisedInitialEvent &&
            this.shouldRaiseInitialEvent(this.snap, onlineState)) ***REMOVED***
            this.raiseInitialEvent(this.snap);
        ***REMOVED***
    ***REMOVED***;
    QueryListener.prototype.shouldRaiseInitialEvent = function (snap, onlineState) ***REMOVED***
        assert(!this.raisedInitialEvent, 'Determining whether to raise first event but already had first event');
        // Always raise the first event when we're synced
        if (!snap.fromCache) ***REMOVED***
            return true;
        ***REMOVED***
        // NOTE: We consider OnlineState.Unknown as online (it should become Failed
        // or Online if we wait long enough).
        var maybeOnline = onlineState !== OnlineState.Failed;
        // Don't raise the event if we're online, aren't synced yet (checked
        // above) and are waiting for a sync.
        if (this.options.waitForSyncWhenOnline && maybeOnline) ***REMOVED***
            assert(snap.fromCache, 'Waiting for sync, but snapshot is not from cache');
            return false;
        ***REMOVED***
        // Raise data from cache if we have any documents or we are offline
        return !snap.docs.isEmpty() || onlineState === OnlineState.Failed;
    ***REMOVED***;
    QueryListener.prototype.shouldRaiseEvent = function (snap) ***REMOVED***
        // We don't need to handle includeDocumentMetadataChanges here because
        // the Metadata only changes have already been stripped out if needed.
        // At this point the only changes we will see are the ones we should
        // propagate.
        if (snap.docChanges.length > 0) ***REMOVED***
            return true;
        ***REMOVED***
        var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;
        if (snap.syncStateChanged || hasPendingWritesChanged) ***REMOVED***
            return this.options.includeQueryMetadataChanges === true;
        ***REMOVED***
        // Generally we should have hit one of the cases above, but it's possible
        // to get here if there were only metadata docChanges and they got
        // stripped out.
        return false;
    ***REMOVED***;
    QueryListener.prototype.raiseInitialEvent = function (snap) ***REMOVED***
        assert(!this.raisedInitialEvent, 'Trying to raise initial events for second time');
        snap = new ViewSnapshot(snap.query, snap.docs, DocumentSet.emptySet(snap.docs), QueryListener.getInitialViewChanges(snap), snap.fromCache, snap.hasPendingWrites, true);
        this.raisedInitialEvent = true;
        this.queryObserver.next(snap);
    ***REMOVED***;
    /** Returns changes as if all documents in the snap were added. */
    QueryListener.getInitialViewChanges = function (snap) ***REMOVED***
        var result = [];
        snap.docs.forEach(function (doc) ***REMOVED***
            result.push(***REMOVED*** type: ChangeType.Added, doc: doc ***REMOVED***);
        ***REMOVED***);
        return result;
    ***REMOVED***;
    return QueryListener;
***REMOVED***());
export ***REMOVED*** QueryListener ***REMOVED***;

//# sourceMappingURL=event_manager.js.map
