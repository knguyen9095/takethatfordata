/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import ***REMOVED*** Document ***REMOVED*** from '../model/document';
import ***REMOVED*** DocumentKey ***REMOVED*** from '../model/document_key';
import ***REMOVED*** DoubleValue, NullValue, RefValue ***REMOVED*** from '../model/field_value';
import ***REMOVED*** FieldPath ***REMOVED*** from '../model/path';
import ***REMOVED*** assert, fail ***REMOVED*** from '../util/assert';
import ***REMOVED*** Code, FirestoreError ***REMOVED*** from '../util/error';
import ***REMOVED*** isNullOrUndefined ***REMOVED*** from '../util/types';
var Query = /** @class */ (function () ***REMOVED***
    function Query(path, explicitOrderBy, filters, limit, startAt, endAt) ***REMOVED***
        if (explicitOrderBy === void 0) ***REMOVED*** explicitOrderBy = []; ***REMOVED***
        if (filters === void 0) ***REMOVED*** filters = []; ***REMOVED***
        if (limit === void 0) ***REMOVED*** limit = null; ***REMOVED***
        if (startAt === void 0) ***REMOVED*** startAt = null; ***REMOVED***
        if (endAt === void 0) ***REMOVED*** endAt = null; ***REMOVED***
        this.path = path;
        this.explicitOrderBy = explicitOrderBy;
        this.filters = filters;
        this.limit = limit;
        this.startAt = startAt;
        this.endAt = endAt;
        this.memoizedCanonicalId = null;
        this.memoizedOrderBy = null;
        if (this.startAt) ***REMOVED***
            this.assertValidBound(this.startAt);
        ***REMOVED***
        if (this.endAt) ***REMOVED***
            this.assertValidBound(this.endAt);
        ***REMOVED***
    ***REMOVED***
    Query.atPath = function (path) ***REMOVED***
        return new Query(path);
    ***REMOVED***;
    Object.defineProperty(Query.prototype, "orderBy", ***REMOVED***
        get: function () ***REMOVED***
            if (this.memoizedOrderBy === null) ***REMOVED***
                var inequalityField = this.getInequalityFilterField();
                var firstOrderByField = this.getFirstOrderByField();
                if (inequalityField !== null && firstOrderByField === null) ***REMOVED***
                    // In order to implicitly add key ordering, we must also add the
                    // inequality filter field for it to be a valid query.
                    // Note that the default inequality field and key ordering is ascending.
                    if (inequalityField.isKeyField()) ***REMOVED***
                        this.memoizedOrderBy = [KEY_ORDERING_ASC];
                    ***REMOVED***
                    else ***REMOVED***
                        this.memoizedOrderBy = [
                            new OrderBy(inequalityField),
                            KEY_ORDERING_ASC
                        ];
                    ***REMOVED***
                ***REMOVED***
                else ***REMOVED***
                    assert(inequalityField === null ||
                        (firstOrderByField !== null &&
                            inequalityField.isEqual(firstOrderByField)), 'First orderBy should match inequality field.');
                    this.memoizedOrderBy = [];
                    var foundKeyOrdering = false;
                    for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) ***REMOVED***
                        var orderBy = _a[_i];
                        this.memoizedOrderBy.push(orderBy);
                        if (orderBy.field.isKeyField()) ***REMOVED***
                            foundKeyOrdering = true;
                        ***REMOVED***
                    ***REMOVED***
                    if (!foundKeyOrdering) ***REMOVED***
                        // The order of the implicit key ordering always matches the last
                        // explicit order by
                        var lastDirection = this.explicitOrderBy.length > 0
                            ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir
                            : Direction.ASCENDING;
                        this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING
                            ? KEY_ORDERING_ASC
                            : KEY_ORDERING_DESC);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return this.memoizedOrderBy;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Query.prototype.addFilter = function (filter) ***REMOVED***
        assert(this.getInequalityFilterField() == null ||
            !(filter instanceof RelationFilter) ||
            !filter.isInequality() ||
            filter.field.isEqual(this.getInequalityFilterField()), 'Query must only have one inequality field.');
        assert(!DocumentKey.isDocumentKey(this.path), 'No filtering allowed for document query');
        var newFilters = this.filters.concat([filter]);
        return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);
    ***REMOVED***;
    Query.prototype.addOrderBy = function (orderBy) ***REMOVED***
        assert(!DocumentKey.isDocumentKey(this.path), 'No ordering allowed for document query');
        assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');
        // TODO(dimond): validate that orderBy does not list the same key twice.
        var newOrderBy = this.explicitOrderBy.concat([orderBy]);
        return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);
    ***REMOVED***;
    Query.prototype.withLimit = function (limit) ***REMOVED***
        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);
    ***REMOVED***;
    Query.prototype.withStartAt = function (bound) ***REMOVED***
        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);
    ***REMOVED***;
    Query.prototype.withEndAt = function (bound) ***REMOVED***
        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);
    ***REMOVED***;
    // TODO(b/29183165): This is used to get a unique string from a query to, for
    // example, use as a dictionary key, but the implementation is subject to
    // collisions. Make it collision-free.
    Query.prototype.canonicalId = function () ***REMOVED***
        if (this.memoizedCanonicalId === null) ***REMOVED***
            var canonicalId = this.path.canonicalString();
            canonicalId += '|f:';
            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) ***REMOVED***
                var filter = _a[_i];
                canonicalId += filter.canonicalId();
                canonicalId += ',';
            ***REMOVED***
            canonicalId += '|ob:';
            // TODO(dimond): make this collision resistant
            for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) ***REMOVED***
                var orderBy = _c[_b];
                canonicalId += orderBy.canonicalId();
                canonicalId += ',';
            ***REMOVED***
            if (!isNullOrUndefined(this.limit)) ***REMOVED***
                canonicalId += '|l:';
                canonicalId += this.limit;
            ***REMOVED***
            if (this.startAt) ***REMOVED***
                canonicalId += '|lb:';
                canonicalId += this.startAt.canonicalId();
            ***REMOVED***
            if (this.endAt) ***REMOVED***
                canonicalId += '|ub:';
                canonicalId += this.endAt.canonicalId();
            ***REMOVED***
            this.memoizedCanonicalId = canonicalId;
        ***REMOVED***
        return this.memoizedCanonicalId;
    ***REMOVED***;
    Query.prototype.toString = function () ***REMOVED***
        var str = 'Query(' + this.path.canonicalString();
        if (this.filters.length > 0) ***REMOVED***
            str += ", filters: [" + this.filters.join(', ') + "]";
        ***REMOVED***
        if (!isNullOrUndefined(this.limit)) ***REMOVED***
            str += ', limit: ' + this.limit;
        ***REMOVED***
        if (this.explicitOrderBy.length > 0) ***REMOVED***
            str += ", orderBy: [" + this.explicitOrderBy.join(', ') + "]";
        ***REMOVED***
        if (this.startAt) ***REMOVED***
            str += ', startAt: ' + this.startAt.canonicalId();
        ***REMOVED***
        if (this.endAt) ***REMOVED***
            str += ', endAt: ' + this.endAt.canonicalId();
        ***REMOVED***
        return str + ')';
    ***REMOVED***;
    Query.prototype.isEqual = function (other) ***REMOVED***
        if (this.limit !== other.limit) ***REMOVED***
            return false;
        ***REMOVED***
        if (this.orderBy.length !== other.orderBy.length) ***REMOVED***
            return false;
        ***REMOVED***
        for (var i = 0; i < this.orderBy.length; i++) ***REMOVED***
            if (!this.orderBy[i].isEqual(other.orderBy[i])) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        if (this.filters.length !== other.filters.length) ***REMOVED***
            return false;
        ***REMOVED***
        for (var i = 0; i < this.filters.length; i++) ***REMOVED***
            if (!this.filters[i].isEqual(other.filters[i])) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        if (!this.path.isEqual(other.path)) ***REMOVED***
            return false;
        ***REMOVED***
        if (this.startAt !== null
            ? !this.startAt.isEqual(other.startAt)
            : other.startAt !== null) ***REMOVED***
            return false;
        ***REMOVED***
        return this.endAt !== null
            ? this.endAt.isEqual(other.endAt)
            : other.endAt === null;
    ***REMOVED***;
    Query.prototype.docComparator = function (d1, d2) ***REMOVED***
        var comparedOnKeyField = false;
        for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) ***REMOVED***
            var orderBy = _a[_i];
            var comp = orderBy.compare(d1, d2);
            if (comp !== 0)
                return comp;
            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();
        ***REMOVED***
        // Assert that we actually compared by key
        assert(comparedOnKeyField, "orderBy used that doesn't compare on key field");
        return 0;
    ***REMOVED***;
    Query.prototype.matches = function (doc) ***REMOVED***
        return (this.matchesAncestor(doc) &&
            this.matchesOrderBy(doc) &&
            this.matchesFilters(doc) &&
            this.matchesBounds(doc));
    ***REMOVED***;
    Query.prototype.hasLimit = function () ***REMOVED***
        return !isNullOrUndefined(this.limit);
    ***REMOVED***;
    Query.prototype.getFirstOrderByField = function () ***REMOVED***
        return this.explicitOrderBy.length > 0
            ? this.explicitOrderBy[0].field
            : null;
    ***REMOVED***;
    Query.prototype.getInequalityFilterField = function () ***REMOVED***
        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) ***REMOVED***
            var filter = _a[_i];
            if (filter instanceof RelationFilter && filter.isInequality()) ***REMOVED***
                return filter.field;
            ***REMOVED***
        ***REMOVED***
        return null;
    ***REMOVED***;
    Query.prototype.isDocumentQuery = function () ***REMOVED***
        return DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;
    ***REMOVED***;
    Query.prototype.matchesAncestor = function (doc) ***REMOVED***
        var docPath = doc.key.path;
        if (DocumentKey.isDocumentKey(this.path)) ***REMOVED***
            // exact match for document queries
            return this.path.isEqual(docPath);
        ***REMOVED***
        else ***REMOVED***
            // shallow ancestor queries by default
            return (this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1);
        ***REMOVED***
    ***REMOVED***;
    /**
     * A document must have a value for every ordering clause in order to show up
     * in the results.
     */
    Query.prototype.matchesOrderBy = function (doc) ***REMOVED***
        for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) ***REMOVED***
            var orderBy = _a[_i];
            // order by key always matches
            if (!orderBy.field.isKeyField() &&
                doc.field(orderBy.field) === undefined) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        return true;
    ***REMOVED***;
    Query.prototype.matchesFilters = function (doc) ***REMOVED***
        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) ***REMOVED***
            var filter = _a[_i];
            if (!filter.matches(doc)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        return true;
    ***REMOVED***;
    /**
     * Makes sure a document is within the bounds, if provided.
     */
    Query.prototype.matchesBounds = function (doc) ***REMOVED***
        if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) ***REMOVED***
            return false;
        ***REMOVED***
        if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) ***REMOVED***
            return false;
        ***REMOVED***
        return true;
    ***REMOVED***;
    Query.prototype.assertValidBound = function (bound) ***REMOVED***
        assert(bound.position.length <= this.orderBy.length, 'Bound is longer than orderBy');
    ***REMOVED***;
    return Query;
***REMOVED***());
export ***REMOVED*** Query ***REMOVED***;
var RelationOp = /** @class */ (function () ***REMOVED***
    function RelationOp(name) ***REMOVED***
        this.name = name;
    ***REMOVED***
    RelationOp.fromString = function (op) ***REMOVED***
        switch (op) ***REMOVED***
            case '<':
                return RelationOp.LESS_THAN;
            case '<=':
                return RelationOp.LESS_THAN_OR_EQUAL;
            case '==':
                return RelationOp.EQUAL;
            case '>=':
                return RelationOp.GREATER_THAN_OR_EQUAL;
            case '>':
                return RelationOp.GREATER_THAN;
            default:
                return fail('Unknown relation: ' + op);
        ***REMOVED***
    ***REMOVED***;
    RelationOp.prototype.toString = function () ***REMOVED***
        return this.name;
    ***REMOVED***;
    RelationOp.prototype.isEqual = function (other) ***REMOVED***
        return this.name === other.name;
    ***REMOVED***;
    RelationOp.LESS_THAN = new RelationOp('<');
    RelationOp.LESS_THAN_OR_EQUAL = new RelationOp('<=');
    RelationOp.EQUAL = new RelationOp('==');
    RelationOp.GREATER_THAN = new RelationOp('>');
    RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp('>=');
    return RelationOp;
***REMOVED***());
export ***REMOVED*** RelationOp ***REMOVED***;
var RelationFilter = /** @class */ (function () ***REMOVED***
    function RelationFilter(field, op, value) ***REMOVED***
        this.field = field;
        this.op = op;
        this.value = value;
    ***REMOVED***
    RelationFilter.prototype.matches = function (doc) ***REMOVED***
        if (this.field.isKeyField()) ***REMOVED***
            assert(this.value instanceof RefValue, 'Comparing on key, but filter value not a RefValue');
            var refValue = this.value;
            var comparison = DocumentKey.comparator(doc.key, refValue.key);
            return this.matchesComparison(comparison);
        ***REMOVED***
        else ***REMOVED***
            var val = doc.field(this.field);
            return val !== undefined && this.matchesValue(val);
        ***REMOVED***
    ***REMOVED***;
    RelationFilter.prototype.matchesValue = function (value) ***REMOVED***
        // Only compare types with matching backend order (such as double and int).
        if (this.value.typeOrder !== value.typeOrder) ***REMOVED***
            return false;
        ***REMOVED***
        return this.matchesComparison(value.compareTo(this.value));
    ***REMOVED***;
    RelationFilter.prototype.matchesComparison = function (comparison) ***REMOVED***
        switch (this.op) ***REMOVED***
            case RelationOp.LESS_THAN:
                return comparison < 0;
            case RelationOp.LESS_THAN_OR_EQUAL:
                return comparison <= 0;
            case RelationOp.EQUAL:
                return comparison === 0;
            case RelationOp.GREATER_THAN:
                return comparison > 0;
            case RelationOp.GREATER_THAN_OR_EQUAL:
                return comparison >= 0;
            default:
                return fail('Unknown relation op' + this.op);
        ***REMOVED***
    ***REMOVED***;
    RelationFilter.prototype.isInequality = function () ***REMOVED***
        return this.op !== RelationOp.EQUAL;
    ***REMOVED***;
    RelationFilter.prototype.canonicalId = function () ***REMOVED***
        // TODO(b/29183165): Technically, this won't be unique if two values have
        // the same description, such as the int 3 and the string "3". So we should
        // add the types in here somehow, too.
        return (this.field.canonicalString() + this.op.toString() + this.value.toString());
    ***REMOVED***;
    RelationFilter.prototype.isEqual = function (other) ***REMOVED***
        if (other instanceof RelationFilter) ***REMOVED***
            return (this.op.isEqual(other.op) &&
                this.field.isEqual(other.field) &&
                this.value.isEqual(other.value));
        ***REMOVED***
        else ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***;
    RelationFilter.prototype.toString = function () ***REMOVED***
        return this.field.canonicalString() + " " + this.op + " " + this.value.value();
    ***REMOVED***;
    return RelationFilter;
***REMOVED***());
export ***REMOVED*** RelationFilter ***REMOVED***;
/**
 * Filter that matches 'null' values.
 */
var NullFilter = /** @class */ (function () ***REMOVED***
    function NullFilter(field) ***REMOVED***
        this.field = field;
    ***REMOVED***
    NullFilter.prototype.matches = function (doc) ***REMOVED***
        var val = doc.field(this.field);
        return val !== undefined && val.value() === null;
    ***REMOVED***;
    NullFilter.prototype.canonicalId = function () ***REMOVED***
        return this.field.canonicalString() + ' IS null';
    ***REMOVED***;
    NullFilter.prototype.toString = function () ***REMOVED***
        return this.field.canonicalString() + " IS null";
    ***REMOVED***;
    NullFilter.prototype.isEqual = function (other) ***REMOVED***
        if (other instanceof NullFilter) ***REMOVED***
            return this.field.isEqual(other.field);
        ***REMOVED***
        else ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***;
    return NullFilter;
***REMOVED***());
export ***REMOVED*** NullFilter ***REMOVED***;
/**
 * Filter that matches 'NaN' values.
 */
var NanFilter = /** @class */ (function () ***REMOVED***
    function NanFilter(field) ***REMOVED***
        this.field = field;
    ***REMOVED***
    NanFilter.prototype.matches = function (doc) ***REMOVED***
        var val = doc.field(this.field).value();
        return typeof val === 'number' && isNaN(val);
    ***REMOVED***;
    NanFilter.prototype.canonicalId = function () ***REMOVED***
        return this.field.canonicalString() + ' IS NaN';
    ***REMOVED***;
    NanFilter.prototype.toString = function () ***REMOVED***
        return this.field.canonicalString() + " IS NaN";
    ***REMOVED***;
    NanFilter.prototype.isEqual = function (other) ***REMOVED***
        if (other instanceof NanFilter) ***REMOVED***
            return this.field.isEqual(other.field);
        ***REMOVED***
        else ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***;
    return NanFilter;
***REMOVED***());
export ***REMOVED*** NanFilter ***REMOVED***;
/**
 * Creates a filter based on the provided arguments.
 */
export function fieldFilter(field, op, value) ***REMOVED***
    if (value.isEqual(NullValue.INSTANCE)) ***REMOVED***
        if (op !== RelationOp.EQUAL) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on null.');
        ***REMOVED***
        return new NullFilter(field);
    ***REMOVED***
    else if (value.isEqual(DoubleValue.NAN)) ***REMOVED***
        if (op !== RelationOp.EQUAL) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on NaN.');
        ***REMOVED***
        return new NanFilter(field);
    ***REMOVED***
    else ***REMOVED***
        return new RelationFilter(field, op, value);
    ***REMOVED***
***REMOVED***
/**
 * The direction of sorting in an order by.
 */
var Direction = /** @class */ (function () ***REMOVED***
    function Direction(name) ***REMOVED***
        this.name = name;
    ***REMOVED***
    Direction.prototype.toString = function () ***REMOVED***
        return this.name;
    ***REMOVED***;
    Direction.ASCENDING = new Direction('asc');
    Direction.DESCENDING = new Direction('desc');
    return Direction;
***REMOVED***());
export ***REMOVED*** Direction ***REMOVED***;
/**
 * Represents a bound of a query.
 *
 * The bound is specified with the given components representing a position and
 * whether it's just before or just after the position (relative to whatever the
 * query order is).
 *
 * The position represents a logical index position for a query. It's a prefix
 * of values for the (potentially implicit) order by clauses of a query.
 *
 * Bound provides a function to determine whether a document comes before or
 * after a bound. This is influenced by whether the position is just before or
 * just after the provided values.
 */
var Bound = /** @class */ (function () ***REMOVED***
    function Bound(position, before) ***REMOVED***
        this.position = position;
        this.before = before;
    ***REMOVED***
    Bound.prototype.canonicalId = function () ***REMOVED***
        // TODO(b/29183165): Make this collision robust.
        var canonicalId = this.before ? 'b:' : 'a:';
        for (var _i = 0, _a = this.position; _i < _a.length; _i++) ***REMOVED***
            var component = _a[_i];
            canonicalId += component.toString();
        ***REMOVED***
        return canonicalId;
    ***REMOVED***;
    /**
     * Returns true if a document sorts before a bound using the provided sort
     * order.
     */
    Bound.prototype.sortsBeforeDocument = function (orderBy, doc) ***REMOVED***
        assert(this.position.length <= orderBy.length, "Bound has more components than query's orderBy");
        var comparison = 0;
        for (var i = 0; i < this.position.length; i++) ***REMOVED***
            var orderByComponent = orderBy[i];
            var component = this.position[i];
            if (orderByComponent.field.isKeyField()) ***REMOVED***
                assert(component instanceof RefValue, 'Bound has a non-key value where the key path is being used.');
                comparison = DocumentKey.comparator(component.key, doc.key);
            ***REMOVED***
            else ***REMOVED***
                var docValue = doc.field(orderByComponent.field);
                assert(docValue !== undefined, 'Field should exist since document matched the orderBy already.');
                comparison = component.compareTo(docValue);
            ***REMOVED***
            if (orderByComponent.dir === Direction.DESCENDING) ***REMOVED***
                comparison = comparison * -1;
            ***REMOVED***
            if (comparison !== 0) ***REMOVED***
                break;
            ***REMOVED***
        ***REMOVED***
        return this.before ? comparison <= 0 : comparison < 0;
    ***REMOVED***;
    Bound.prototype.isEqual = function (other) ***REMOVED***
        if (other === null) ***REMOVED***
            return false;
        ***REMOVED***
        if (this.before !== other.before ||
            this.position.length !== other.position.length) ***REMOVED***
            return false;
        ***REMOVED***
        for (var i = 0; i < this.position.length; i++) ***REMOVED***
            var thisPosition = this.position[i];
            var otherPosition = other.position[i];
            return thisPosition.isEqual(otherPosition);
        ***REMOVED***
        return true;
    ***REMOVED***;
    return Bound;
***REMOVED***());
export ***REMOVED*** Bound ***REMOVED***;
/**
 * An ordering on a field, in some Direction. Direction defaults to ASCENDING.
 */
var OrderBy = /** @class */ (function () ***REMOVED***
    function OrderBy(field, dir) ***REMOVED***
        this.field = field;
        if (dir === undefined) ***REMOVED***
            dir = Direction.ASCENDING;
        ***REMOVED***
        this.dir = dir;
        this.isKeyOrderBy = field.isKeyField();
    ***REMOVED***
    OrderBy.prototype.compare = function (d1, d2) ***REMOVED***
        var comparison = this.isKeyOrderBy
            ? Document.compareByKey(d1, d2)
            : Document.compareByField(this.field, d1, d2);
        switch (this.dir) ***REMOVED***
            case Direction.ASCENDING:
                return comparison;
            case Direction.DESCENDING:
                return -1 * comparison;
            default:
                return fail('Unknown direction: ' + this.dir);
        ***REMOVED***
    ***REMOVED***;
    OrderBy.prototype.canonicalId = function () ***REMOVED***
        // TODO(b/29183165): Make this collision robust.
        return this.field.canonicalString() + this.dir.toString();
    ***REMOVED***;
    OrderBy.prototype.toString = function () ***REMOVED***
        return this.field.canonicalString() + " (" + this.dir + ")";
    ***REMOVED***;
    OrderBy.prototype.isEqual = function (other) ***REMOVED***
        return this.dir === other.dir && this.field.isEqual(other.field);
    ***REMOVED***;
    return OrderBy;
***REMOVED***());
export ***REMOVED*** OrderBy ***REMOVED***;
var KEY_ORDERING_ASC = new OrderBy(FieldPath.keyField(), Direction.ASCENDING);
var KEY_ORDERING_DESC = new OrderBy(FieldPath.keyField(), Direction.DESCENDING);

//# sourceMappingURL=query.js.map
