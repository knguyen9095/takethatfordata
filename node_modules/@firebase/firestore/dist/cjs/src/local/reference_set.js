"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var collections_1 = require("../model/collections");
var document_key_1 = require("../model/document_key");
var misc_1 = require("../util/misc");
var sorted_set_1 = require("../util/sorted_set");
var persistence_promise_1 = require("./persistence_promise");
/**
 * A collection of references to a document from some kind of numbered entity
 * (either a target ID or batch ID). As references are added to or removed from
 * the set corresponding events are emitted to a registered garbage collector.
 *
 * Each reference is represented by a DocumentReference object. Each of them
 * contains enough information to uniquely identify the reference. They are all
 * stored primarily in a set sorted by key. A document is considered garbage if
 * there's no references in that set (this can be efficiently checked thanks to
 * sorting by key).
 *
 * ReferenceSet also keeps a secondary set that contains references sorted by
 * IDs. This one is used to efficiently implement removal of all references by
 * some target ID.
 */
var ReferenceSet = /** @class */ (function () ***REMOVED***
    function ReferenceSet() ***REMOVED***
        // A set of outstanding references to a document sorted by key.
        this.refsByKey = new sorted_set_1.SortedSet(DocReference.compareByKey);
        // A set of outstanding references to a document sorted by target id.
        this.refsByTarget = new sorted_set_1.SortedSet(DocReference.compareByTargetId);
        /** Keeps track of keys that have references */
        this.garbageCollector = null;
    ***REMOVED***
    /** Returns true if the reference set contains no references. */
    ReferenceSet.prototype.isEmpty = function () ***REMOVED***
        return this.refsByKey.isEmpty();
    ***REMOVED***;
    /** Adds a reference to the given document key for the given ID. */
    ReferenceSet.prototype.addReference = function (key, id) ***REMOVED***
        var ref = new DocReference(key, id);
        this.refsByKey = this.refsByKey.add(ref);
        this.refsByTarget = this.refsByTarget.add(ref);
    ***REMOVED***;
    /** Add references to the given document keys for the given ID. */
    ReferenceSet.prototype.addReferences = function (keys, id) ***REMOVED***
        var _this = this;
        keys.forEach(function (key) ***REMOVED*** return _this.addReference(key, id); ***REMOVED***);
    ***REMOVED***;
    /**
     * Removes a reference to the given document key for the given
     * ID.
     */
    ReferenceSet.prototype.removeReference = function (key, id) ***REMOVED***
        this.removeRef(new DocReference(key, id));
    ***REMOVED***;
    ReferenceSet.prototype.removeReferences = function (keys, id) ***REMOVED***
        var _this = this;
        keys.forEach(function (key) ***REMOVED*** return _this.removeReference(key, id); ***REMOVED***);
    ***REMOVED***;
    /**
     * Clears all references with a given ID. Calls removeRef() for each key
     * removed.
     */
    ReferenceSet.prototype.removeReferencesForId = function (id) ***REMOVED***
        var _this = this;
        var emptyKey = document_key_1.DocumentKey.EMPTY;
        var startRef = new DocReference(emptyKey, id);
        var endRef = new DocReference(emptyKey, id + 1);
        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) ***REMOVED***
            _this.removeRef(ref);
        ***REMOVED***);
    ***REMOVED***;
    ReferenceSet.prototype.removeAllReferences = function () ***REMOVED***
        var _this = this;
        this.refsByKey.forEach(function (ref) ***REMOVED*** return _this.removeRef(ref); ***REMOVED***);
    ***REMOVED***;
    ReferenceSet.prototype.removeRef = function (ref) ***REMOVED***
        this.refsByKey = this.refsByKey.delete(ref);
        this.refsByTarget = this.refsByTarget.delete(ref);
        if (this.garbageCollector !== null) ***REMOVED***
            this.garbageCollector.addPotentialGarbageKey(ref.key);
        ***REMOVED***
    ***REMOVED***;
    ReferenceSet.prototype.referencesForId = function (id) ***REMOVED***
        var emptyKey = document_key_1.DocumentKey.EMPTY;
        var startRef = new DocReference(emptyKey, id);
        var endRef = new DocReference(emptyKey, id + 1);
        var keys = collections_1.documentKeySet();
        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) ***REMOVED***
            keys = keys.add(ref.key);
        ***REMOVED***);
        return keys;
    ***REMOVED***;
    ReferenceSet.prototype.setGarbageCollector = function (garbageCollector) ***REMOVED***
        this.garbageCollector = garbageCollector;
    ***REMOVED***;
    ReferenceSet.prototype.containsKey = function (txn, key) ***REMOVED***
        var ref = new DocReference(key, 0);
        var firstRef = this.refsByKey.firstAfterOrEqual(ref);
        return persistence_promise_1.PersistencePromise.resolve(firstRef !== null && key.isEqual(firstRef.key));
    ***REMOVED***;
    return ReferenceSet;
***REMOVED***());
exports.ReferenceSet = ReferenceSet;
var DocReference = /** @class */ (function () ***REMOVED***
    function DocReference(key, targetOrBatchId) ***REMOVED***
        this.key = key;
        this.targetOrBatchId = targetOrBatchId;
    ***REMOVED***
    /** Compare by key then by ID */
    DocReference.compareByKey = function (left, right) ***REMOVED***
        return (document_key_1.DocumentKey.comparator(left.key, right.key) ||
            misc_1.primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));
    ***REMOVED***;
    /** Compare by ID then by key */
    DocReference.compareByTargetId = function (left, right) ***REMOVED***
        return (misc_1.primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||
            document_key_1.DocumentKey.comparator(left.key, right.key));
    ***REMOVED***;
    return DocReference;
***REMOVED***());
exports.DocReference = DocReference;

//# sourceMappingURL=reference_set.js.map
