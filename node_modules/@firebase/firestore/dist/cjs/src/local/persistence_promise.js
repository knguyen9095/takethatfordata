"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var assert_1 = require("../util/assert");
/**
 * PersistencePromise<> is essentially a re-implementation of Promise<> except
 * it has a .next() method instead of .then() and .next() and .catch() callbacks
 * are executed synchronously when a PersistencePromise resolves rather than
 * asynchronously (Promise<> implementations use setImmediate() or similar).
 *
 * This is necessary to interoperate with IndexedDB which will automatically
 * commit transactions if control is returned to the event loop without
 * synchronously initiating another operation on the transaction.
 *
 * NOTE: .then() and .catch() only allow a single consumer, unlike normal
 * Promises.
 */
var PersistencePromise = /** @class */ (function () ***REMOVED***
    function PersistencePromise(callback) ***REMOVED***
        var _this = this;
        // NOTE: next/catchCallback will always point to our own wrapper functions,
        // not the user's raw next() or catch() callbacks.
        // tslint:disable-next-line:no-any Accept any result type for the next call in the Promise chain.
        this.nextCallback = null;
        // tslint:disable-next-line:no-any Accept any result type for the error handler.
        this.catchCallback = null;
        // When the operation resolves, we'll set result or error and mark isDone.
        this.result = undefined;
        this.error = undefined;
        this.isDone = false;
        // Set to true when .then() or .catch() are called and prevents additional
        // chaining.
        this.callbackAttached = false;
        callback(function (value) ***REMOVED***
            _this.isDone = true;
            _this.result = value;
            if (_this.nextCallback) ***REMOVED***
                // value should be defined unless T is Void, but we can't express
                // that in the type system.
                _this.nextCallback(value);
            ***REMOVED***
        ***REMOVED***, function (error) ***REMOVED***
            _this.isDone = true;
            _this.error = error;
            if (_this.catchCallback) ***REMOVED***
                _this.catchCallback(error);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
    PersistencePromise.prototype.catch = function (fn) ***REMOVED***
        return this.next(undefined, fn);
    ***REMOVED***;
    PersistencePromise.prototype.next = function (nextFn, catchFn) ***REMOVED***
        var _this = this;
        if (this.callbackAttached) ***REMOVED***
            assert_1.fail('Called next() or catch() twice for PersistencePromise');
        ***REMOVED***
        this.callbackAttached = true;
        if (this.isDone) ***REMOVED***
            if (!this.error) ***REMOVED***
                return this.wrapSuccess(nextFn, this.result);
            ***REMOVED***
            else ***REMOVED***
                return this.wrapFailure(catchFn, this.error);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            return new PersistencePromise(function (resolve, reject) ***REMOVED***
                _this.nextCallback = function (value) ***REMOVED***
                    _this.wrapSuccess(nextFn, value).next(resolve, reject);
                ***REMOVED***;
                _this.catchCallback = function (error) ***REMOVED***
                    _this.wrapFailure(catchFn, error).next(resolve, reject);
                ***REMOVED***;
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;
    PersistencePromise.prototype.toPromise = function () ***REMOVED***
        var _this = this;
        return new Promise(function (resolve, reject) ***REMOVED***
            _this.next(resolve, reject);
        ***REMOVED***);
    ***REMOVED***;
    PersistencePromise.prototype.wrapUserFunction = function (fn) ***REMOVED***
        try ***REMOVED***
            var result = fn();
            if (result instanceof PersistencePromise) ***REMOVED***
                return result;
            ***REMOVED***
            else ***REMOVED***
                return PersistencePromise.resolve(result);
            ***REMOVED***
        ***REMOVED***
        catch (e) ***REMOVED***
            return PersistencePromise.reject(e);
        ***REMOVED***
    ***REMOVED***;
    PersistencePromise.prototype.wrapSuccess = function (nextFn, value) ***REMOVED***
        if (nextFn) ***REMOVED***
            return this.wrapUserFunction(function () ***REMOVED*** return nextFn(value); ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            // If there's no nextFn, then R must be the same as T but we
            // can't express that in the type system.
            // tslint:disable-next-line:no-any
            return PersistencePromise.resolve(value);
        ***REMOVED***
    ***REMOVED***;
    PersistencePromise.prototype.wrapFailure = function (catchFn, error) ***REMOVED***
        if (catchFn) ***REMOVED***
            return this.wrapUserFunction(function () ***REMOVED*** return catchFn(error); ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            return PersistencePromise.reject(error);
        ***REMOVED***
    ***REMOVED***;
    PersistencePromise.resolve = function (result) ***REMOVED***
        return new PersistencePromise(function (resolve, reject) ***REMOVED***
            resolve(result);
        ***REMOVED***);
    ***REMOVED***;
    PersistencePromise.reject = function (error) ***REMOVED***
        return new PersistencePromise(function (resolve, reject) ***REMOVED***
            reject(error);
        ***REMOVED***);
    ***REMOVED***;
    PersistencePromise.waitFor = function (
        // tslint:disable-next-line:no-any Accept all Promise types in waitFor().
        all) ***REMOVED***
        return all.reduce(function (promise, nextPromise, idx) ***REMOVED***
            return promise.next(function () ***REMOVED***
                return nextPromise;
            ***REMOVED***);
        ***REMOVED***, PersistencePromise.resolve());
    ***REMOVED***;
    PersistencePromise.map = function (all) ***REMOVED***
        var results = [];
        var first = true;
        // initial is ignored, so we can cheat on the type.
        // tslint:disable-next-line:no-any
        var initial = PersistencePromise.resolve(null);
        return all
            .reduce(function (promise, nextPromise) ***REMOVED***
            return promise.next(function (result) ***REMOVED***
                if (!first) ***REMOVED***
                    results.push(result);
                ***REMOVED***
                first = false;
                return nextPromise;
            ***REMOVED***);
        ***REMOVED***, initial)
            .next(function (result) ***REMOVED***
            results.push(result);
            return results;
        ***REMOVED***);
    ***REMOVED***;
    return PersistencePromise;
***REMOVED***());
exports.PersistencePromise = PersistencePromise;

//# sourceMappingURL=persistence_promise.js.map
