***REMOVED***"version":3,"sources":["../src/remote/watch_change.ts"],"names":[],"mappings":"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","file":"watch_change.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport ***REMOVED*** SnapshotVersion ***REMOVED*** from '../core/snapshot_version';\nimport ***REMOVED*** ProtoByteString, TargetId ***REMOVED*** from '../core/types';\nimport ***REMOVED*** QueryData ***REMOVED*** from '../local/query_data';\nimport ***REMOVED*** maybeDocumentMap ***REMOVED*** from '../model/collections';\nimport ***REMOVED*** Document, NoDocument ***REMOVED*** from '../model/document';\nimport ***REMOVED*** DocumentKey ***REMOVED*** from '../model/document_key';\nimport ***REMOVED*** emptyByteString ***REMOVED*** from '../platform/platform';\nimport ***REMOVED*** assert, fail ***REMOVED*** from '../util/assert';\nimport ***REMOVED*** FirestoreError ***REMOVED*** from '../util/error';\nimport * as objUtils from '../util/obj';\n\nimport ***REMOVED*** ExistenceFilter ***REMOVED*** from './existence_filter';\nimport ***REMOVED***\n  CurrentStatusUpdate,\n  RemoteEvent,\n  ResetMapping,\n  TargetChange,\n  UpdateMapping\n***REMOVED*** from './remote_event';\n\n/**\n * Internal representation of the watcher API protocol buffers.\n */\nexport type WatchChange =\n  | DocumentWatchChange\n  | WatchTargetChange\n  | ExistenceFilterChange;\n\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nexport class DocumentWatchChange ***REMOVED***\n  constructor(\n    /** The new document applies to all of these targets. */\n    public updatedTargetIds: TargetId[],\n    /** The new document is removed from all of these targets. */\n    public removedTargetIds: TargetId[],\n    /** The key of the document for this change. */\n    public key: DocumentKey,\n    /**\n     * The new document or NoDocument if it was deleted. Is null if the\n     * document went out of view without the server sending a new document.\n     */\n    public newDoc: Document | NoDocument | null\n  ) ***REMOVED******REMOVED***\n***REMOVED***\n\nexport class ExistenceFilterChange ***REMOVED***\n  constructor(\n    public targetId: TargetId,\n    public existenceFilter: ExistenceFilter\n  ) ***REMOVED******REMOVED***\n***REMOVED***\n\nexport enum WatchTargetChangeState ***REMOVED***\n  NoChange,\n  Added,\n  Removed,\n  Current,\n  Reset\n***REMOVED***\n\nexport class WatchTargetChange ***REMOVED***\n  constructor(\n    /** What kind of change occurred to the watch target. */\n    public state: WatchTargetChangeState,\n    /** The target IDs that were added/removed/set. */\n    public targetIds: TargetId[],\n    /**\n     * An opaque, server-assigned token that allows watching a query to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the query. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    public resumeToken: ProtoByteString = emptyByteString(),\n    /** An RPC error indicating why the watch failed. */\n    public cause: FirestoreError | null = null\n  ) ***REMOVED******REMOVED***\n***REMOVED***\n\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\nexport class WatchChangeAggregator ***REMOVED***\n  constructor(\n    private snapshotVersion: SnapshotVersion,\n    private readonly listenTargets: ***REMOVED*** [targetId: number]: QueryData ***REMOVED***,\n    pendingTargetResponses: ***REMOVED*** [targetId: number]: number ***REMOVED***\n  ) ***REMOVED***\n    this.pendingTargetResponses = objUtils.shallowCopy(pendingTargetResponses);\n  ***REMOVED***\n\n  /** The existence filter - if any - for the given target IDs. */\n  readonly existenceFilters: ***REMOVED*** [targetId: number]: ExistenceFilter ***REMOVED*** = ***REMOVED******REMOVED***;\n\n  /** The number of pending responses that we are waiting on from watch. */\n  readonly pendingTargetResponses: ***REMOVED*** [targetId: number]: number ***REMOVED***;\n\n  /** Keeps track of the current target mappings */\n  private targetChanges: ***REMOVED*** [targetId: number]: TargetChange ***REMOVED*** = ***REMOVED******REMOVED***;\n\n  /** Keeps track of document to update */\n  private documentUpdates = maybeDocumentMap();\n\n  /** Whether this aggregator was frozen and can no longer be modified */\n  private frozen = false;\n\n  /** Aggregates a watch change into the current state */\n  add(watchChange: WatchChange): void ***REMOVED***\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    if (watchChange instanceof DocumentWatchChange) ***REMOVED***\n      this.addDocumentChange(watchChange);\n    ***REMOVED*** else if (watchChange instanceof WatchTargetChange) ***REMOVED***\n      this.addTargetChange(watchChange);\n    ***REMOVED*** else if (watchChange instanceof ExistenceFilterChange) ***REMOVED***\n      this.addExistenceFilterChange(watchChange);\n    ***REMOVED*** else ***REMOVED***\n      fail('Unknown watch change: ' + watchChange);\n    ***REMOVED***\n  ***REMOVED***\n\n  /** Aggregates all provided watch changes to the current state in order */\n  addChanges(watchChanges: WatchChange[]): void ***REMOVED***\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    watchChanges.forEach(change => this.add(change));\n  ***REMOVED***\n\n  /**\n   * Converts the current state into a remote event with the snapshot version\n   * provided via the constructor.\n   */\n  createRemoteEvent(): RemoteEvent ***REMOVED***\n    const targetChanges = this.targetChanges;\n\n    // Remove all the non-active targets from the remote event.\n    objUtils.forEachNumber(this.targetChanges, targetId => ***REMOVED***\n      if (!this.isActiveTarget(targetId)) ***REMOVED***\n        delete targetChanges[targetId];\n      ***REMOVED***\n    ***REMOVED***);\n\n    // Mark this aggregator as frozen so no further modifications are made\n    this.frozen = true;\n    return new RemoteEvent(\n      this.snapshotVersion,\n      targetChanges,\n      this.documentUpdates\n    );\n  ***REMOVED***\n\n  private ensureTargetChange(targetId: TargetId): TargetChange ***REMOVED***\n    let change = this.targetChanges[targetId];\n    if (!change) ***REMOVED***\n      // Create an UpdateMapping by default, since resets are always explicit.\n      change = ***REMOVED***\n        currentStatusUpdate: CurrentStatusUpdate.None,\n        snapshotVersion: this.snapshotVersion,\n        mapping: new UpdateMapping(),\n        resumeToken: emptyByteString()\n      ***REMOVED***;\n      this.targetChanges[targetId] = change;\n    ***REMOVED***\n    return change;\n  ***REMOVED***\n\n  /**\n   * We need to wait for watch to ack targets before we process those events,\n   * so to know if a target is active, there must be no pending acks we're\n   * waiting for and it must be in the current list of targets that the client\n   * cares about.\n   *\n   * This method is visible for testing.\n   */\n  protected isActiveTarget(targetId: TargetId): boolean ***REMOVED***\n    return (\n      !objUtils.contains(this.pendingTargetResponses, targetId) &&\n      objUtils.contains(this.listenTargets, targetId)\n    );\n  ***REMOVED***\n\n  private addDocumentChange(docChange: DocumentWatchChange) ***REMOVED***\n    let relevant = false;\n\n    for (const targetId of docChange.updatedTargetIds) ***REMOVED***\n      if (this.isActiveTarget(targetId)) ***REMOVED***\n        const change = this.ensureTargetChange(targetId);\n        change.mapping.add(docChange.key);\n        relevant = true;\n      ***REMOVED***\n    ***REMOVED***\n\n    for (const targetId of docChange.removedTargetIds) ***REMOVED***\n      if (this.isActiveTarget(targetId)) ***REMOVED***\n        const change = this.ensureTargetChange(targetId);\n        change.mapping.delete(docChange.key);\n        relevant = true;\n      ***REMOVED***\n    ***REMOVED***\n\n    // Only update the document if there is a new document to replace to an\n    // active target that is being listened to, this might be just a target\n    // update instead.\n    if (docChange.newDoc && relevant) ***REMOVED***\n      this.documentUpdates = this.documentUpdates.insert(\n        docChange.key,\n        docChange.newDoc\n      );\n    ***REMOVED***\n  ***REMOVED***\n\n  private addTargetChange(targetChange: WatchTargetChange) ***REMOVED***\n    targetChange.targetIds.forEach(targetId => ***REMOVED***\n      const change = this.ensureTargetChange(targetId);\n      switch (targetChange.state) ***REMOVED***\n        case WatchTargetChangeState.NoChange:\n          if (this.isActiveTarget(targetId)) ***REMOVED***\n            // Creating the change above satisfies the semantics of no-change.\n            applyResumeToken(change, targetChange.resumeToken);\n          ***REMOVED***\n          break;\n        case WatchTargetChangeState.Added:\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          this.recordTargetResponse(targetId);\n          if (!objUtils.contains(this.pendingTargetResponses, targetId)) ***REMOVED***\n            // We have a freshly added target, so we need to reset any state\n            // that we had previously This can happen e.g. when remove and add\n            // back a target for existence filter mismatches.\n            change.mapping = new UpdateMapping();\n            change.currentStatusUpdate = CurrentStatusUpdate.None;\n            delete this.existenceFilters[targetId];\n          ***REMOVED***\n          applyResumeToken(change, targetChange.resumeToken);\n          break;\n        case WatchTargetChangeState.Removed:\n          // We need to keep track of removed targets to we can\n          // post-filter and remove any target changes.\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          this.recordTargetResponse(targetId);\n          assert(\n            !targetChange.cause,\n            'WatchChangeAggregator does not handle errored targets'\n          );\n          break;\n        case WatchTargetChangeState.Current:\n          if (this.isActiveTarget(targetId)) ***REMOVED***\n            change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n            applyResumeToken(change, targetChange.resumeToken);\n          ***REMOVED***\n          break;\n        case WatchTargetChangeState.Reset:\n          if (this.isActiveTarget(targetId)) ***REMOVED***\n            // Overwrite any existing target mapping with a reset\n            // mapping. Every subsequent update will modify the reset\n            // mapping, not an update mapping.\n            change.mapping = new ResetMapping();\n            applyResumeToken(change, targetChange.resumeToken);\n          ***REMOVED***\n          break;\n        default:\n          fail('Unknown target watch change state: ' + targetChange.state);\n      ***REMOVED***\n    ***REMOVED***);\n  ***REMOVED***\n\n  /**\n   * Record that we get a watch target add/remove by decrementing the number of\n   * pending target responses that we have.\n   */\n  private recordTargetResponse(targetId: TargetId): void ***REMOVED***\n    const newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n    if (newCount === 0) ***REMOVED***\n      delete this.pendingTargetResponses[targetId];\n    ***REMOVED*** else ***REMOVED***\n      this.pendingTargetResponses[targetId] = newCount;\n    ***REMOVED***\n  ***REMOVED***\n\n  private addExistenceFilterChange(change: ExistenceFilterChange): void ***REMOVED***\n    if (this.isActiveTarget(change.targetId)) ***REMOVED***\n      this.existenceFilters[change.targetId] = change.existenceFilter;\n    ***REMOVED***\n  ***REMOVED***\n***REMOVED***\n\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\nfunction applyResumeToken(\n  change: TargetChange,\n  resumeToken: ProtoByteString\n): void ***REMOVED***\n  if (resumeToken.length > 0) ***REMOVED***\n    change.resumeToken = resumeToken;\n  ***REMOVED***\n***REMOVED***\n"]***REMOVED***