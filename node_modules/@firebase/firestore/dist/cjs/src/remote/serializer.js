"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var blob_1 = require("../api/blob");
var geo_point_1 = require("../api/geo_point");
var database_info_1 = require("../core/database_info");
var query_1 = require("../core/query");
var snapshot_version_1 = require("../core/snapshot_version");
var timestamp_1 = require("../core/timestamp");
var query_data_1 = require("../local/query_data");
var document_1 = require("../model/document");
var document_key_1 = require("../model/document_key");
var fieldValue = require("../model/field_value");
var mutation_1 = require("../model/mutation");
var path_1 = require("../model/path");
var assert_1 = require("../util/assert");
var error_1 = require("../util/error");
var obj = require("../util/obj");
var typeUtils = require("../util/types");
var existence_filter_1 = require("./existence_filter");
var rpc_error_1 = require("./rpc_error");
var watch_change_1 = require("./watch_change");
var DIRECTIONS = (function () ***REMOVED***
    var dirs = ***REMOVED******REMOVED***;
    dirs[query_1.Direction.ASCENDING.name] = 'ASCENDING';
    dirs[query_1.Direction.DESCENDING.name] = 'DESCENDING';
    return dirs;
***REMOVED***)();
var OPERATORS = (function () ***REMOVED***
    var ops = ***REMOVED******REMOVED***;
    ops[query_1.RelationOp.LESS_THAN.name] = 'LESS_THAN';
    ops[query_1.RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';
    ops[query_1.RelationOp.GREATER_THAN.name] = 'GREATER_THAN';
    ops[query_1.RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';
    ops[query_1.RelationOp.EQUAL.name] = 'EQUAL';
    return ops;
***REMOVED***)();
function assertPresent(value, description) ***REMOVED***
    assert_1.assert(!typeUtils.isNullOrUndefined(value), description + ' is missing');
***REMOVED***
function parseInt64(value) ***REMOVED***
    // TODO(bjornick): Handle int64 greater than 53 bits.
    if (typeof value === 'number') ***REMOVED***
        return value;
    ***REMOVED***
    else if (typeof value === 'string') ***REMOVED***
        return Number(value);
    ***REMOVED***
    else ***REMOVED***
        return assert_1.fail("can't parse " + value);
    ***REMOVED***
***REMOVED***
/**
 * Generates JsonObject values for the Datastore API suitable for sending to
 * either GRPC stub methods or via the JSON/HTTP REST API.
 * TODO(klimt): We can remove the databaseId argument if we keep the full
 * resource name in documents.
 */
var JsonProtoSerializer = /** @class */ (function () ***REMOVED***
    function JsonProtoSerializer(databaseId, options) ***REMOVED***
        this.databaseId = databaseId;
        this.options = options;
    ***REMOVED***
    JsonProtoSerializer.prototype.emptyByteString = function () ***REMOVED***
        if (this.options.useProto3Json) ***REMOVED***
            return '';
        ***REMOVED***
        else ***REMOVED***
            return new Uint8Array(0);
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.unsafeCastProtoByteString = function (byteString) ***REMOVED***
        // byteStrings can be either string or UInt8Array, but the typings say
        // it's always a string. Cast as string to avoid type check failing
        return byteString;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromRpcStatus = function (status) ***REMOVED***
        var code = status.code === undefined
            ? error_1.Code.UNKNOWN
            : rpc_error_1.mapCodeFromRpcCode(status.code);
        return new error_1.FirestoreError(code, status.message || '');
    ***REMOVED***;
    /**
     * Returns a value for a number (or undefined) that's appropriate to put into
     * a google.protobuf.Int32Value proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as returning "number" because that's what
     * our generated proto interfaces say Int32Value must be. But GRPC actually
     * expects a ***REMOVED*** value: <number> ***REMOVED*** struct.
     */
    JsonProtoSerializer.prototype.toInt32Value = function (val) ***REMOVED***
        if (!typeUtils.isNullOrUndefined(val)) ***REMOVED***
            // tslint:disable-next-line:no-any We need to match generated Proto types.
            return ***REMOVED*** value: val ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            return undefined;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns a number (or null) from a google.protobuf.Int32Value proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as accepting "number" because that's what
     * our generated proto interfaces say Int32Value must be, but it actually
     * accepts ***REMOVED*** value: number ***REMOVED*** to match our serialization in toInt32Value().
     */
    JsonProtoSerializer.prototype.fromInt32Value = function (val) ***REMOVED***
        var result;
        if (typeof val === 'object') ***REMOVED***
            // tslint:disable-next-line:no-any We need to match generated Proto types.
            result = val.value;
        ***REMOVED***
        else ***REMOVED***
            // We accept raw numbers (without the ***REMOVED***value: ... ***REMOVED*** wrapper) for
            // compatibility with legacy persisted data.
            result = val;
        ***REMOVED***
        return typeUtils.isNullOrUndefined(result) ? null : result;
    ***REMOVED***;
    /**
     * Returns a value for a Date that's appropriate to put into a proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as returning "string" because that's what
     * our generated proto interfaces say dates must be. But it's easier and safer
     * to actually return a Timestamp proto.
     */
    JsonProtoSerializer.prototype.toTimestamp = function (timestamp) ***REMOVED***
        return ***REMOVED***
            seconds: timestamp.seconds,
            nanos: timestamp.nanos
            // tslint:disable-next-line:no-any
        ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromTimestamp = function (date) ***REMOVED***
        // The json interface (for the browser) will return an iso timestamp string,
        // while the proto js library (for node) will return a
        // google.protobuf.Timestamp instance.
        if (typeof date === 'string') ***REMOVED***
            // TODO(b/37282237): Use strings for Proto3 timestamps
            // assert(this.options.useProto3Json,
            //   'The timestamp string format requires Proto3.');
            return timestamp_1.Timestamp.fromISOString(date);
        ***REMOVED***
        else ***REMOVED***
            assert_1.assert(!!date, 'Cannot deserialize null or undefined timestamp.');
            // TODO(b/37282237): Use strings for Proto3 timestamps
            // assert(!this.options.useProto3Json,
            //   'The timestamp instance format requires Proto JS.');
            var seconds = parseInt64(date.seconds || '0');
            var nanos = date.nanos || 0;
            return new timestamp_1.Timestamp(seconds, nanos);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns a value for bytes that's appropriate to put in a proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as returning "string" because that's what
     * our generated proto interfaces say bytes must be. But it should return
     * an Uint8Array in Node.
     */
    JsonProtoSerializer.prototype.toBytes = function (bytes) ***REMOVED***
        if (this.options.useProto3Json) ***REMOVED***
            return bytes.toBase64();
        ***REMOVED***
        else ***REMOVED***
            // The typings say it's a string, but it needs to be a Uint8Array in Node.
            return this.unsafeCastProtoByteString(bytes.toUint8Array());
        ***REMOVED***
    ***REMOVED***;
    /**
     * Parse the blob from the protos into the internal Blob class. Note that the
     * typings assume all blobs are strings, but they are actually Uint8Arrays
     * on Node.
     */
    JsonProtoSerializer.prototype.fromBlob = function (blob) ***REMOVED***
        if (typeof blob === 'string') ***REMOVED***
            assert_1.assert(this.options.useProto3Json, 'Expected bytes to be passed in as Uint8Array, but got a string instead.');
            return blob_1.Blob.fromBase64String(blob);
        ***REMOVED***
        else ***REMOVED***
            assert_1.assert(!this.options.useProto3Json, 'Expected bytes to be passed in as string, but got something else instead.');
            return blob_1.Blob.fromUint8Array(blob);
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.toVersion = function (version) ***REMOVED***
        return this.toTimestamp(version.toTimestamp());
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromVersion = function (version) ***REMOVED***
        assert_1.assert(!!version, "Trying to deserialize version that isn't set");
        return snapshot_version_1.SnapshotVersion.fromTimestamp(this.fromTimestamp(version));
    ***REMOVED***;
    JsonProtoSerializer.prototype.toResourceName = function (databaseId, path) ***REMOVED***
        return this.fullyQualifiedPrefixPath(databaseId)
            .child('documents')
            .child(path)
            .canonicalString();
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromResourceName = function (name) ***REMOVED***
        var resource = path_1.ResourcePath.fromString(name);
        assert_1.assert(this.isValidResourceName(resource), 'Tried to deserialize invalid key ' + resource.toString());
        return resource;
    ***REMOVED***;
    JsonProtoSerializer.prototype.toName = function (key) ***REMOVED***
        return this.toResourceName(this.databaseId, key.path);
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromName = function (name) ***REMOVED***
        var resource = this.fromResourceName(name);
        assert_1.assert(resource.get(1) === this.databaseId.projectId, 'Tried to deserialize key from different project: ' +
            resource.get(1) +
            ' vs ' +
            this.databaseId.projectId);
        assert_1.assert((!resource.get(3) && !this.databaseId.database) ||
            resource.get(3) === this.databaseId.database, 'Tried to deserialize key from different database: ' +
            resource.get(3) +
            ' vs ' +
            this.databaseId.database);
        return new document_key_1.DocumentKey(this.extractLocalPathFromResourceName(resource));
    ***REMOVED***;
    JsonProtoSerializer.prototype.toQueryPath = function (path) ***REMOVED***
        if (path.length === 0) ***REMOVED***
            // If the path is empty, the backend requires we leave off the /documents
            // at the end.
            return this.encodedDatabaseId;
        ***REMOVED***
        return this.toResourceName(this.databaseId, path);
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromQueryPath = function (name) ***REMOVED***
        var resourceName = this.fromResourceName(name);
        if (resourceName.length === 4) ***REMOVED***
            return path_1.ResourcePath.EMPTY_PATH;
        ***REMOVED***
        return this.extractLocalPathFromResourceName(resourceName);
    ***REMOVED***;
    Object.defineProperty(JsonProtoSerializer.prototype, "encodedDatabaseId", ***REMOVED***
        get: function () ***REMOVED***
            var path = new path_1.ResourcePath([
                'projects',
                this.databaseId.projectId,
                'databases',
                this.databaseId.database
            ]);
            return path.canonicalString();
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function (databaseId) ***REMOVED***
        return new path_1.ResourcePath([
            'projects',
            databaseId.projectId,
            'databases',
            databaseId.database
        ]);
    ***REMOVED***;
    JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function (resourceName) ***REMOVED***
        assert_1.assert(resourceName.length > 4 && resourceName.get(4) === 'documents', 'tried to deserialize invalid key ' + resourceName.toString());
        return resourceName.popFirst(5);
    ***REMOVED***;
    JsonProtoSerializer.prototype.isValidResourceName = function (path) ***REMOVED***
        // Resource names have at least 4 components (project ID, database ID)
        return (path.length >= 4 &&
            path.get(0) === 'projects' &&
            path.get(2) === 'databases');
    ***REMOVED***;
    JsonProtoSerializer.prototype.toValue = function (val) ***REMOVED***
        if (val instanceof fieldValue.NullValue) ***REMOVED***
            return ***REMOVED*** nullValue: 'NULL_VALUE' ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.BooleanValue) ***REMOVED***
            return ***REMOVED*** booleanValue: val.value() ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.IntegerValue) ***REMOVED***
            return ***REMOVED*** integerValue: '' + val.value() ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.DoubleValue) ***REMOVED***
            var doubleValue = val.value();
            if (this.options.useProto3Json) ***REMOVED***
                // Proto 3 let's us encode NaN and Infinity as string values as
                // expected by the backend. This is currently not checked by our unit
                // tests because they rely on protobuf.js.
                if (isNaN(doubleValue)) ***REMOVED***
                    return ***REMOVED*** doubleValue: 'NaN' ***REMOVED***;
                ***REMOVED***
                else if (doubleValue === Infinity) ***REMOVED***
                    return ***REMOVED*** doubleValue: 'Infinity' ***REMOVED***;
                ***REMOVED***
                else if (doubleValue === -Infinity) ***REMOVED***
                    return ***REMOVED*** doubleValue: '-Infinity' ***REMOVED***;
                ***REMOVED***
            ***REMOVED***
            return ***REMOVED*** doubleValue: val.value() ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.StringValue) ***REMOVED***
            return ***REMOVED*** stringValue: val.value() ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.ObjectValue) ***REMOVED***
            return ***REMOVED*** mapValue: this.toMapValue(val) ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.ArrayValue) ***REMOVED***
            return ***REMOVED*** arrayValue: this.toArrayValue(val) ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.TimestampValue) ***REMOVED***
            return ***REMOVED***
                timestampValue: this.toTimestamp(val.internalValue)
            ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.GeoPointValue) ***REMOVED***
            return ***REMOVED***
                geoPointValue: ***REMOVED***
                    latitude: val.value().latitude,
                    longitude: val.value().longitude
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.BlobValue) ***REMOVED***
            return ***REMOVED***
                bytesValue: this.toBytes(val.value())
            ***REMOVED***;
        ***REMOVED***
        else if (val instanceof fieldValue.RefValue) ***REMOVED***
            return ***REMOVED***
                referenceValue: this.toResourceName(val.databaseId, val.key.path)
            ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('Unknown FieldValue ' + JSON.stringify(val));
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromValue = function (obj) ***REMOVED***
        var _this = this;
        // tslint:disable-next-line:no-any
        var type = obj['value_type'];
        if (hasTag(obj, type, 'nullValue')) ***REMOVED***
            return fieldValue.NullValue.INSTANCE;
        ***REMOVED***
        else if (hasTag(obj, type, 'booleanValue')) ***REMOVED***
            return fieldValue.BooleanValue.of(obj.booleanValue);
        ***REMOVED***
        else if (hasTag(obj, type, 'integerValue')) ***REMOVED***
            return new fieldValue.IntegerValue(parseInt64(obj.integerValue));
        ***REMOVED***
        else if (hasTag(obj, type, 'doubleValue')) ***REMOVED***
            if (this.options.useProto3Json) ***REMOVED***
                // Proto 3 uses the string values 'NaN' and 'Infinity'.
                if (obj.doubleValue === 'NaN') ***REMOVED***
                    return fieldValue.DoubleValue.NAN;
                ***REMOVED***
                else if (obj.doubleValue === 'Infinity') ***REMOVED***
                    return fieldValue.DoubleValue.POSITIVE_INFINITY;
                ***REMOVED***
                else if (obj.doubleValue === '-Infinity') ***REMOVED***
                    return fieldValue.DoubleValue.NEGATIVE_INFINITY;
                ***REMOVED***
            ***REMOVED***
            return new fieldValue.DoubleValue(obj.doubleValue);
        ***REMOVED***
        else if (hasTag(obj, type, 'stringValue')) ***REMOVED***
            return new fieldValue.StringValue(obj.stringValue);
        ***REMOVED***
        else if (hasTag(obj, type, 'mapValue')) ***REMOVED***
            return this.fromFields(obj.mapValue.fields || ***REMOVED******REMOVED***);
        ***REMOVED***
        else if (hasTag(obj, type, 'arrayValue')) ***REMOVED***
            // "values" is not present if the array is empty
            assertPresent(obj.arrayValue, 'arrayValue');
            var values = obj.arrayValue.values || [];
            return new fieldValue.ArrayValue(values.map(function (v) ***REMOVED*** return _this.fromValue(v); ***REMOVED***));
        ***REMOVED***
        else if (hasTag(obj, type, 'timestampValue')) ***REMOVED***
            assertPresent(obj.timestampValue, 'timestampValue');
            return new fieldValue.TimestampValue(this.fromTimestamp(obj.timestampValue));
        ***REMOVED***
        else if (hasTag(obj, type, 'geoPointValue')) ***REMOVED***
            assertPresent(obj.geoPointValue, 'geoPointValue');
            var latitude = obj.geoPointValue.latitude || 0;
            var longitude = obj.geoPointValue.longitude || 0;
            return new fieldValue.GeoPointValue(new geo_point_1.GeoPoint(latitude, longitude));
        ***REMOVED***
        else if (hasTag(obj, type, 'bytesValue')) ***REMOVED***
            assertPresent(obj.bytesValue, 'bytesValue');
            var blob = this.fromBlob(obj.bytesValue);
            return new fieldValue.BlobValue(blob);
        ***REMOVED***
        else if (hasTag(obj, type, 'referenceValue')) ***REMOVED***
            assertPresent(obj.referenceValue, 'referenceValue');
            var resourceName = this.fromResourceName(obj.referenceValue);
            var dbId = new database_info_1.DatabaseId(resourceName.get(1), resourceName.get(3));
            var key = new document_key_1.DocumentKey(this.extractLocalPathFromResourceName(resourceName));
            return new fieldValue.RefValue(dbId, key);
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('Unknown Value proto ' + JSON.stringify(obj));
        ***REMOVED***
    ***REMOVED***;
    /** Creates an api.Document from key and fields (but no create/update time) */
    JsonProtoSerializer.prototype.toMutationDocument = function (key, fields) ***REMOVED***
        return ***REMOVED***
            name: this.toName(key),
            fields: this.toFields(fields)
        ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.toDocument = function (document) ***REMOVED***
        assert_1.assert(!document.hasLocalMutations, "Can't serialize documents with mutations.");
        return ***REMOVED***
            name: this.toName(document.key),
            fields: this.toFields(document.data),
            updateTime: this.toTimestamp(document.version.toTimestamp())
        ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromDocument = function (document) ***REMOVED***
        return new document_1.Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || ***REMOVED******REMOVED***), ***REMOVED*** hasLocalMutations: false ***REMOVED***);
    ***REMOVED***;
    JsonProtoSerializer.prototype.toFields = function (fields) ***REMOVED***
        var _this = this;
        var result = ***REMOVED******REMOVED***;
        fields.forEach(function (key, value) ***REMOVED***
            result[key] = _this.toValue(value);
        ***REMOVED***);
        return result;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromFields = function (object) ***REMOVED***
        var _this = this;
        // Proto map<string, Value> gets mapped to Object, so cast it.
        var map = object;
        var result = fieldValue.ObjectValue.EMPTY;
        obj.forEach(map, function (key, value) ***REMOVED***
            result = result.set(new path_1.FieldPath([key]), _this.fromValue(value));
        ***REMOVED***);
        return result;
    ***REMOVED***;
    JsonProtoSerializer.prototype.toMapValue = function (map) ***REMOVED***
        return ***REMOVED***
            fields: this.toFields(map)
        ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.toArrayValue = function (array) ***REMOVED***
        var _this = this;
        var result = [];
        array.forEach(function (value) ***REMOVED***
            result.push(_this.toValue(value));
        ***REMOVED***);
        return ***REMOVED*** values: result ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromFound = function (doc) ***REMOVED***
        assert_1.assert(!!doc.found, 'Tried to deserialize a found document from a missing document.');
        assertPresent(doc.found.name, 'doc.found.name');
        assertPresent(doc.found.updateTime, 'doc.found.updateTime');
        var key = this.fromName(doc.found.name);
        var version = this.fromVersion(doc.found.updateTime);
        var fields = this.fromFields(doc.found.fields || ***REMOVED******REMOVED***);
        return new document_1.Document(key, version, fields, ***REMOVED*** hasLocalMutations: false ***REMOVED***);
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromMissing = function (result) ***REMOVED***
        assert_1.assert(!!result.missing, 'Tried to deserialize a missing document from a found document.');
        assert_1.assert(!!result.readTime, 'Tried to deserialize a missing document without a read time.');
        var key = this.fromName(result.missing);
        var version = this.fromVersion(result.readTime);
        return new document_1.NoDocument(key, version);
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromMaybeDocument = function (result) ***REMOVED***
        // tslint:disable-next-line:no-any
        var type = result['result'];
        if (hasTag(result, type, 'found')) ***REMOVED***
            return this.fromFound(result);
        ***REMOVED***
        else if (hasTag(result, type, 'missing')) ***REMOVED***
            return this.fromMissing(result);
        ***REMOVED***
        return assert_1.fail('invalid batch get response: ' + JSON.stringify(result));
    ***REMOVED***;
    JsonProtoSerializer.prototype.toWatchTargetChangeState = function (state) ***REMOVED***
        switch (state) ***REMOVED***
            case watch_change_1.WatchTargetChangeState.Added:
                return 'ADD';
            case watch_change_1.WatchTargetChangeState.Current:
                return 'CURRENT';
            case watch_change_1.WatchTargetChangeState.NoChange:
                return 'NO_CHANGE';
            case watch_change_1.WatchTargetChangeState.Removed:
                return 'REMOVE';
            case watch_change_1.WatchTargetChangeState.Reset:
                return 'RESET';
            default:
                return assert_1.fail('Unknown WatchTargetChangeState: ' + state);
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.toTestWatchChange = function (watchChange) ***REMOVED***
        if (watchChange instanceof watch_change_1.ExistenceFilterChange) ***REMOVED***
            return ***REMOVED***
                filter: ***REMOVED***
                    count: watchChange.existenceFilter.count,
                    targetId: watchChange.targetId
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***
        if (watchChange instanceof watch_change_1.DocumentWatchChange) ***REMOVED***
            if (watchChange.newDoc instanceof document_1.Document) ***REMOVED***
                var doc = watchChange.newDoc;
                return ***REMOVED***
                    documentChange: ***REMOVED***
                        document: ***REMOVED***
                            name: this.toName(doc.key),
                            fields: this.toFields(doc.data),
                            updateTime: this.toVersion(doc.version)
                        ***REMOVED***,
                        targetIds: watchChange.updatedTargetIds,
                        removedTargetIds: watchChange.removedTargetIds
                    ***REMOVED***
                ***REMOVED***;
            ***REMOVED***
            else if (watchChange.newDoc instanceof document_1.NoDocument) ***REMOVED***
                var doc = watchChange.newDoc;
                return ***REMOVED***
                    documentDelete: ***REMOVED***
                        document: this.toName(doc.key),
                        readTime: this.toVersion(doc.version),
                        removedTargetIds: watchChange.removedTargetIds
                    ***REMOVED***
                ***REMOVED***;
            ***REMOVED***
            else if (watchChange.newDoc === null) ***REMOVED***
                return ***REMOVED***
                    documentRemove: ***REMOVED***
                        document: this.toName(watchChange.key),
                        removedTargetIds: watchChange.removedTargetIds
                    ***REMOVED***
                ***REMOVED***;
            ***REMOVED***
        ***REMOVED***
        if (watchChange instanceof watch_change_1.WatchTargetChange) ***REMOVED***
            var cause = undefined;
            if (watchChange.cause) ***REMOVED***
                cause = ***REMOVED***
                    code: rpc_error_1.mapRpcCodeFromCode(watchChange.cause.code),
                    message: watchChange.cause.message
                ***REMOVED***;
            ***REMOVED***
            return ***REMOVED***
                targetChange: ***REMOVED***
                    targetChangeType: this.toWatchTargetChangeState(watchChange.state),
                    targetIds: watchChange.targetIds,
                    resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),
                    cause: cause
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***
        return assert_1.fail('Unrecognized watch change: ' + JSON.stringify(watchChange));
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromWatchChange = function (change) ***REMOVED***
        // tslint:disable-next-line:no-any
        var type = change['response_type'];
        var watchChange;
        if (hasTag(change, type, 'targetChange')) ***REMOVED***
            assertPresent(change.targetChange, 'targetChange');
            // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'
            // if unset
            var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');
            var targetIds = change.targetChange.targetIds || [];
            var resumeToken = change.targetChange.resumeToken || this.emptyByteString();
            var causeProto = change.targetChange.cause;
            var cause = causeProto && this.fromRpcStatus(causeProto);
            watchChange = new watch_change_1.WatchTargetChange(state, targetIds, resumeToken, cause || null);
        ***REMOVED***
        else if (hasTag(change, type, 'documentChange')) ***REMOVED***
            assertPresent(change.documentChange, 'documentChange');
            assertPresent(change.documentChange.document, 'documentChange.name');
            assertPresent(change.documentChange.document.name, 'documentChange.document.name');
            assertPresent(change.documentChange.document.updateTime, 'documentChange.document.updateTime');
            var entityChange = change.documentChange;
            var key = this.fromName(entityChange.document.name);
            var version = this.fromVersion(entityChange.document.updateTime);
            var fields = this.fromFields(entityChange.document.fields || ***REMOVED******REMOVED***);
            var doc = new document_1.Document(key, version, fields, ***REMOVED***
                hasLocalMutations: false
            ***REMOVED***);
            var updatedTargetIds = entityChange.targetIds || [];
            var removedTargetIds = entityChange.removedTargetIds || [];
            watchChange = new watch_change_1.DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);
        ***REMOVED***
        else if (hasTag(change, type, 'documentDelete')) ***REMOVED***
            assertPresent(change.documentDelete, 'documentDelete');
            assertPresent(change.documentDelete.document, 'documentDelete.document');
            var docDelete = change.documentDelete;
            var key = this.fromName(docDelete.document);
            var version = docDelete.readTime
                ? this.fromVersion(docDelete.readTime)
                : snapshot_version_1.SnapshotVersion.forDeletedDoc();
            var doc = new document_1.NoDocument(key, version);
            var removedTargetIds = docDelete.removedTargetIds || [];
            watchChange = new watch_change_1.DocumentWatchChange([], removedTargetIds, doc.key, doc);
        ***REMOVED***
        else if (hasTag(change, type, 'documentRemove')) ***REMOVED***
            assertPresent(change.documentRemove, 'documentRemove');
            assertPresent(change.documentRemove.document, 'documentRemove');
            var docRemove = change.documentRemove;
            var key = this.fromName(docRemove.document);
            var removedTargetIds = docRemove.removedTargetIds || [];
            watchChange = new watch_change_1.DocumentWatchChange([], removedTargetIds, key, null);
        ***REMOVED***
        else if (hasTag(change, type, 'filter')) ***REMOVED***
            // TODO(dimond): implement existence filter parsing with strategy.
            assertPresent(change.filter, 'filter');
            assertPresent(change.filter.targetId, 'filter.targetId');
            var filter = change.filter;
            var count = filter.count || 0;
            var existenceFilter = new existence_filter_1.ExistenceFilter(count);
            var targetId = filter.targetId;
            watchChange = new watch_change_1.ExistenceFilterChange(targetId, existenceFilter);
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('Unknown change type ' + JSON.stringify(change));
        ***REMOVED***
        return watchChange;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromWatchTargetChangeState = function (state) ***REMOVED***
        if (state === 'NO_CHANGE') ***REMOVED***
            return watch_change_1.WatchTargetChangeState.NoChange;
        ***REMOVED***
        else if (state === 'ADD') ***REMOVED***
            return watch_change_1.WatchTargetChangeState.Added;
        ***REMOVED***
        else if (state === 'REMOVE') ***REMOVED***
            return watch_change_1.WatchTargetChangeState.Removed;
        ***REMOVED***
        else if (state === 'CURRENT') ***REMOVED***
            return watch_change_1.WatchTargetChangeState.Current;
        ***REMOVED***
        else if (state === 'RESET') ***REMOVED***
            return watch_change_1.WatchTargetChangeState.Reset;
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('Got unexpected TargetChange.state: ' + state);
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.versionFromListenResponse = function (change) ***REMOVED***
        // We have only reached a consistent snapshot for the entire stream if there
        // is a read_time set and it applies to all targets (i.e. the list of
        // targets is empty). The backend is guaranteed to send such responses.
        // tslint:disable-next-line:no-any
        var type = change['response_type'];
        if (!hasTag(change, type, 'targetChange')) ***REMOVED***
            return snapshot_version_1.SnapshotVersion.MIN;
        ***REMOVED***
        var targetChange = change.targetChange;
        if (targetChange.targetIds && targetChange.targetIds.length) ***REMOVED***
            return snapshot_version_1.SnapshotVersion.MIN;
        ***REMOVED***
        if (!targetChange.readTime) ***REMOVED***
            return snapshot_version_1.SnapshotVersion.MIN;
        ***REMOVED***
        return this.fromVersion(targetChange.readTime);
    ***REMOVED***;
    JsonProtoSerializer.prototype.toMutation = function (mutation) ***REMOVED***
        var _this = this;
        var result;
        if (mutation instanceof mutation_1.SetMutation) ***REMOVED***
            result = ***REMOVED***
                update: this.toMutationDocument(mutation.key, mutation.value)
            ***REMOVED***;
        ***REMOVED***
        else if (mutation instanceof mutation_1.DeleteMutation) ***REMOVED***
            result = ***REMOVED*** delete: this.toName(mutation.key) ***REMOVED***;
        ***REMOVED***
        else if (mutation instanceof mutation_1.PatchMutation) ***REMOVED***
            result = ***REMOVED***
                update: this.toMutationDocument(mutation.key, mutation.data),
                updateMask: this.toDocumentMask(mutation.fieldMask)
            ***REMOVED***;
        ***REMOVED***
        else if (mutation instanceof mutation_1.TransformMutation) ***REMOVED***
            result = ***REMOVED***
                transform: ***REMOVED***
                    document: this.toName(mutation.key),
                    fieldTransforms: mutation.fieldTransforms.map(function (transform) ***REMOVED***
                        return _this.toFieldTransform(transform);
                    ***REMOVED***)
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('Unknown mutation type ' + mutation.type);
        ***REMOVED***
        if (!mutation.precondition.isNone) ***REMOVED***
            result.currentDocument = this.toPrecondition(mutation.precondition);
        ***REMOVED***
        return result;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromMutation = function (proto) ***REMOVED***
        var _this = this;
        var precondition = proto.currentDocument
            ? this.fromPrecondition(proto.currentDocument)
            : mutation_1.Precondition.NONE;
        if (proto.update) ***REMOVED***
            assertPresent(proto.update.name, 'name');
            var key = this.fromName(proto.update.name);
            var value = this.fromFields(proto.update.fields || ***REMOVED******REMOVED***);
            if (proto.updateMask) ***REMOVED***
                var fieldMask = this.fromDocumentMask(proto.updateMask);
                return new mutation_1.PatchMutation(key, value, fieldMask, precondition);
            ***REMOVED***
            else ***REMOVED***
                return new mutation_1.SetMutation(key, value, precondition);
            ***REMOVED***
        ***REMOVED***
        else if (proto.delete) ***REMOVED***
            var key = this.fromName(proto.delete);
            return new mutation_1.DeleteMutation(key, precondition);
        ***REMOVED***
        else if (proto.transform) ***REMOVED***
            var key = this.fromName(proto.transform.document);
            var fieldTransforms = proto.transform.fieldTransforms.map(function (transform) ***REMOVED***
                return _this.fromFieldTransform(transform);
            ***REMOVED***);
            assert_1.assert(precondition.exists === true, 'Transforms only support precondition "exists == true"');
            return new mutation_1.TransformMutation(key, fieldTransforms);
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('unknown mutation proto: ' + JSON.stringify(proto));
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.toPrecondition = function (precondition) ***REMOVED***
        assert_1.assert(!precondition.isNone, "Can't serialize an empty precondition");
        if (precondition.updateTime !== undefined) ***REMOVED***
            return ***REMOVED***
                updateTime: this.toVersion(precondition.updateTime)
            ***REMOVED***;
        ***REMOVED***
        else if (precondition.exists !== undefined) ***REMOVED***
            return ***REMOVED*** exists: precondition.exists ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('Unknown precondition');
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromPrecondition = function (precondition) ***REMOVED***
        if (precondition.updateTime !== undefined) ***REMOVED***
            return mutation_1.Precondition.updateTime(this.fromVersion(precondition.updateTime));
        ***REMOVED***
        else if (precondition.exists !== undefined) ***REMOVED***
            return mutation_1.Precondition.exists(precondition.exists);
        ***REMOVED***
        else ***REMOVED***
            return mutation_1.Precondition.NONE;
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromWriteResult = function (proto) ***REMOVED***
        var _this = this;
        // NOTE: Deletes don't have an updateTime.
        var version = proto.updateTime
            ? this.fromVersion(proto.updateTime)
            : null;
        var transformResults = null;
        if (proto.transformResults && proto.transformResults.length > 0) ***REMOVED***
            transformResults = proto.transformResults.map(function (result) ***REMOVED***
                return _this.fromValue(result);
            ***REMOVED***);
        ***REMOVED***
        return new mutation_1.MutationResult(version, transformResults);
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromWriteResults = function (protos) ***REMOVED***
        var _this = this;
        return (protos || []).map(function (proto) ***REMOVED*** return _this.fromWriteResult(proto); ***REMOVED***);
    ***REMOVED***;
    JsonProtoSerializer.prototype.toFieldTransform = function (fieldTransform) ***REMOVED***
        assert_1.assert(fieldTransform.transform instanceof mutation_1.ServerTimestampTransform, 'Unknown transform: ' + fieldTransform.transform);
        return ***REMOVED***
            fieldPath: fieldTransform.field.canonicalString(),
            setToServerValue: 'REQUEST_TIME'
        ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromFieldTransform = function (proto) ***REMOVED***
        assert_1.assert(proto.setToServerValue === 'REQUEST_TIME', 'Unknown transform proto: ' + JSON.stringify(proto));
        var fieldPath = path_1.FieldPath.fromServerFormat(proto.fieldPath);
        return new mutation_1.FieldTransform(fieldPath, mutation_1.ServerTimestampTransform.instance);
    ***REMOVED***;
    JsonProtoSerializer.prototype.toDocumentsTarget = function (query) ***REMOVED***
        return ***REMOVED*** documents: [this.toQueryPath(query.path)] ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromDocumentsTarget = function (documentsTarget) ***REMOVED***
        var count = documentsTarget.documents.length;
        assert_1.assert(count === 1, 'DocumentsTarget contained other than 1 document: ' + count);
        var name = documentsTarget.documents[0];
        return query_1.Query.atPath(this.fromQueryPath(name));
    ***REMOVED***;
    JsonProtoSerializer.prototype.toQueryTarget = function (query) ***REMOVED***
        // Dissect the path into parent, collectionId, and optional key filter.
        var result = ***REMOVED*** structuredQuery: ***REMOVED******REMOVED*** ***REMOVED***;
        if (query.path.isEmpty()) ***REMOVED***
            result.parent = this.toQueryPath(path_1.ResourcePath.EMPTY_PATH);
        ***REMOVED***
        else ***REMOVED***
            var path = query.path;
            assert_1.assert(path.length % 2 !== 0, 'Document queries with filters are not supported.');
            result.parent = this.toQueryPath(path.popLast());
            result.structuredQuery.from = [***REMOVED*** collectionId: path.lastSegment() ***REMOVED***];
        ***REMOVED***
        var where = this.toFilter(query.filters);
        if (where) ***REMOVED***
            result.structuredQuery.where = where;
        ***REMOVED***
        var orderBy = this.toOrder(query.orderBy);
        if (orderBy) ***REMOVED***
            result.structuredQuery.orderBy = orderBy;
        ***REMOVED***
        var limit = this.toInt32Value(query.limit);
        if (limit !== undefined) ***REMOVED***
            result.structuredQuery.limit = limit;
        ***REMOVED***
        if (query.startAt) ***REMOVED***
            result.structuredQuery.startAt = this.toCursor(query.startAt);
        ***REMOVED***
        if (query.endAt) ***REMOVED***
            result.structuredQuery.endAt = this.toCursor(query.endAt);
        ***REMOVED***
        return result;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromQueryTarget = function (target) ***REMOVED***
        var path = this.fromQueryPath(target.parent);
        var query = target.structuredQuery;
        var fromCount = query.from ? query.from.length : 0;
        if (fromCount > 0) ***REMOVED***
            assert_1.assert(fromCount === 1, 'StructuredQuery.from with more than one collection is not supported.');
            var from = query.from[0];
            path = path.child(from.collectionId);
        ***REMOVED***
        var filterBy = [];
        if (query.where) ***REMOVED***
            filterBy = this.fromFilter(query.where);
        ***REMOVED***
        var orderBy = [];
        if (query.orderBy) ***REMOVED***
            orderBy = this.fromOrder(query.orderBy);
        ***REMOVED***
        var limit = null;
        if (query.limit) ***REMOVED***
            limit = this.fromInt32Value(query.limit);
        ***REMOVED***
        var startAt = null;
        if (query.startAt) ***REMOVED***
            startAt = this.fromCursor(query.startAt);
        ***REMOVED***
        var endAt = null;
        if (query.endAt) ***REMOVED***
            endAt = this.fromCursor(query.endAt);
        ***REMOVED***
        return new query_1.Query(path, orderBy, filterBy, limit, startAt, endAt);
    ***REMOVED***;
    JsonProtoSerializer.prototype.toListenRequestLabels = function (queryData) ***REMOVED***
        var value = this.toLabel(queryData.purpose);
        if (value == null) ***REMOVED***
            return null;
        ***REMOVED***
        else ***REMOVED***
            return ***REMOVED***
                'goog-listen-tags': value
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.toLabel = function (purpose) ***REMOVED***
        switch (purpose) ***REMOVED***
            case query_data_1.QueryPurpose.Listen:
                return null;
            case query_data_1.QueryPurpose.ExistenceFilterMismatch:
                return 'existence-filter-mismatch';
            case query_data_1.QueryPurpose.LimboResolution:
                return 'limbo-document';
            default:
                return assert_1.fail('Unrecognized query purpose: ' + purpose);
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.toTarget = function (queryData) ***REMOVED***
        var result;
        var query = queryData.query;
        if (query.isDocumentQuery()) ***REMOVED***
            result = ***REMOVED*** documents: this.toDocumentsTarget(query) ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            result = ***REMOVED*** query: this.toQueryTarget(query) ***REMOVED***;
        ***REMOVED***
        result.targetId = queryData.targetId;
        if (queryData.resumeToken.length > 0) ***REMOVED***
            result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken);
        ***REMOVED***
        return result;
    ***REMOVED***;
    JsonProtoSerializer.prototype.toFilter = function (filters) ***REMOVED***
        var _this = this;
        if (filters.length === 0)
            return;
        var protos = filters.map(function (filter) ***REMOVED***
            return filter instanceof query_1.RelationFilter
                ? _this.toRelationFilter(filter)
                : _this.toUnaryFilter(filter);
        ***REMOVED***);
        if (protos.length === 1) ***REMOVED***
            return protos[0];
        ***REMOVED***
        return ***REMOVED*** compositeFilter: ***REMOVED*** op: 'AND', filters: protos ***REMOVED*** ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromFilter = function (filter) ***REMOVED***
        var _this = this;
        if (!filter) ***REMOVED***
            return [];
        ***REMOVED***
        else if (filter.unaryFilter !== undefined) ***REMOVED***
            return [this.fromUnaryFilter(filter)];
        ***REMOVED***
        else if (filter.fieldFilter !== undefined) ***REMOVED***
            return [this.fromRelationFilter(filter)];
        ***REMOVED***
        else if (filter.compositeFilter !== undefined) ***REMOVED***
            return filter.compositeFilter.filters
                .map(function (f) ***REMOVED*** return _this.fromFilter(f); ***REMOVED***)
                .reduce(function (accum, current) ***REMOVED*** return accum.concat(current); ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('Unknown filter: ' + JSON.stringify(filter));
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.toOrder = function (orderBys) ***REMOVED***
        var _this = this;
        if (orderBys.length === 0)
            return;
        return orderBys.map(function (order) ***REMOVED*** return _this.toPropertyOrder(order); ***REMOVED***);
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromOrder = function (orderBys) ***REMOVED***
        var _this = this;
        return orderBys.map(function (order) ***REMOVED*** return _this.fromPropertyOrder(order); ***REMOVED***);
    ***REMOVED***;
    JsonProtoSerializer.prototype.toCursor = function (cursor) ***REMOVED***
        var _this = this;
        return ***REMOVED***
            before: cursor.before,
            values: cursor.position.map(function (component) ***REMOVED*** return _this.toValue(component); ***REMOVED***)
        ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromCursor = function (cursor) ***REMOVED***
        var _this = this;
        var before = !!cursor.before;
        var position = cursor.values.map(function (component) ***REMOVED*** return _this.fromValue(component); ***REMOVED***);
        return new query_1.Bound(position, before);
    ***REMOVED***;
    // visible for testing
    JsonProtoSerializer.prototype.toDirection = function (dir) ***REMOVED***
        return DIRECTIONS[dir.name];
    ***REMOVED***;
    // visible for testing
    JsonProtoSerializer.prototype.fromDirection = function (dir) ***REMOVED***
        switch (dir) ***REMOVED***
            case 'ASCENDING':
                return query_1.Direction.ASCENDING;
            case 'DESCENDING':
                return query_1.Direction.DESCENDING;
            default:
                return undefined;
        ***REMOVED***
    ***REMOVED***;
    // visible for testing
    JsonProtoSerializer.prototype.toOperatorName = function (op) ***REMOVED***
        return OPERATORS[op.name];
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromOperatorName = function (op) ***REMOVED***
        switch (op) ***REMOVED***
            case 'EQUAL':
                return query_1.RelationOp.EQUAL;
            case 'GREATER_THAN':
                return query_1.RelationOp.GREATER_THAN;
            case 'GREATER_THAN_OR_EQUAL':
                return query_1.RelationOp.GREATER_THAN_OR_EQUAL;
            case 'LESS_THAN':
                return query_1.RelationOp.LESS_THAN;
            case 'LESS_THAN_OR_EQUAL':
                return query_1.RelationOp.LESS_THAN_OR_EQUAL;
            case 'OPERATOR_UNSPECIFIED':
                return assert_1.fail('Unspecified relation');
            default:
                return assert_1.fail('Unknown relation');
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.toFieldPathReference = function (path) ***REMOVED***
        return ***REMOVED*** fieldPath: path.canonicalString() ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromFieldPathReference = function (fieldReference) ***REMOVED***
        return path_1.FieldPath.fromServerFormat(fieldReference.fieldPath);
    ***REMOVED***;
    // visible for testing
    JsonProtoSerializer.prototype.toPropertyOrder = function (orderBy) ***REMOVED***
        return ***REMOVED***
            field: this.toFieldPathReference(orderBy.field),
            direction: this.toDirection(orderBy.dir)
        ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromPropertyOrder = function (orderBy) ***REMOVED***
        return new query_1.OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));
    ***REMOVED***;
    // visible for testing
    JsonProtoSerializer.prototype.toRelationFilter = function (filter) ***REMOVED***
        if (filter instanceof query_1.RelationFilter) ***REMOVED***
            return ***REMOVED***
                fieldFilter: ***REMOVED***
                    field: this.toFieldPathReference(filter.field),
                    op: this.toOperatorName(filter.op),
                    value: this.toValue(filter.value)
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('Unrecognized filter: ' + JSON.stringify(filter));
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromRelationFilter = function (filter) ***REMOVED***
        return new query_1.RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));
    ***REMOVED***;
    // visible for testing
    JsonProtoSerializer.prototype.toUnaryFilter = function (filter) ***REMOVED***
        if (filter instanceof query_1.NanFilter) ***REMOVED***
            return ***REMOVED***
                unaryFilter: ***REMOVED***
                    field: this.toFieldPathReference(filter.field),
                    op: 'IS_NAN'
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***
        else if (filter instanceof query_1.NullFilter) ***REMOVED***
            return ***REMOVED***
                unaryFilter: ***REMOVED***
                    field: this.toFieldPathReference(filter.field),
                    op: 'IS_NULL'
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            return assert_1.fail('Unrecognized filter: ' + JSON.stringify(filter));
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromUnaryFilter = function (filter) ***REMOVED***
        switch (filter.unaryFilter.op) ***REMOVED***
            case 'IS_NAN':
                var nanField = this.fromFieldPathReference(filter.unaryFilter.field);
                return new query_1.NanFilter(nanField);
            case 'IS_NULL':
                var nullField = this.fromFieldPathReference(filter.unaryFilter.field);
                return new query_1.NullFilter(nullField);
            case 'OPERATOR_UNSPECIFIED':
                return assert_1.fail('Unspecified filter');
            default:
                return assert_1.fail('Unknown filter');
        ***REMOVED***
    ***REMOVED***;
    JsonProtoSerializer.prototype.toDocumentMask = function (fieldMask) ***REMOVED***
        return ***REMOVED***
            fieldPaths: fieldMask.fields.map(function (field) ***REMOVED*** return field.canonicalString(); ***REMOVED***)
        ***REMOVED***;
    ***REMOVED***;
    JsonProtoSerializer.prototype.fromDocumentMask = function (proto) ***REMOVED***
        var paths = proto.fieldPaths || [];
        var fields = paths.map(function (path) ***REMOVED*** return path_1.FieldPath.fromServerFormat(path); ***REMOVED***);
        return new mutation_1.FieldMask(fields);
    ***REMOVED***;
    return JsonProtoSerializer;
***REMOVED***());
exports.JsonProtoSerializer = JsonProtoSerializer;
/**
 * Checks for a specific oneof tag in a protocol buffer message.
 *
 * This intentionally accommodates two distinct cases:
 *
 * 1) Messages containing a type tag: these are the format produced by GRPC in
 * return values. These may contain default-value mappings for all tags in the
 * oneof but the type tag specifies which one was actually set.
 *
 * 2) Messages that don't contain a type tag: these are the format required by
 * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would
 * choke claiming that the tags aren't fields in the Message.
 *
 * Allowing both formats here makes the serializer able to consume the outputs
 * it produces: for all messages it supports, fromX(toX(value)) == value.
 *
 * Note that case 2 suffers from ambiguity: if multiple tags are present
 * without a type tag then the callers are structured in such a way that the
 * first invocation will win. Since we only parse in this mode when parsing
 * the output of a serialize method this works, but it's not a general
 * solution.
 *
 * Unfortunately there is no general solution here because proto3 makes it
 * impossible to distinguish unset from explicitly set fields: both have the
 * default value for the type. Without the type tag but multiple value tags
 * it's possible to have default values for each tag in the oneof and not be
 * able to know which was actually in effect.
 */
function hasTag(obj, type, tag) ***REMOVED***
    return type === tag || (!type && tag in obj);
***REMOVED***

//# sourceMappingURL=serializer.js.map
