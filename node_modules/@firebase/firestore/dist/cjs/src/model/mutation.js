"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var snapshot_version_1 = require("../core/snapshot_version");
var assert_1 = require("../util/assert");
var misc = require("../util/misc");
var document_1 = require("./document");
var field_value_1 = require("./field_value");
/**
 * Provides a set of fields that can be used to partially patch a document.
 * FieldMask is used in conjunction with ObjectValue.
 * Examples:
 *   foo - Overwrites foo entirely with the provided value. If foo is not
 *         present in the companion ObjectValue, the field is deleted.
 *   foo.bar - Overwrites only the field bar of the object foo.
 *             If foo is not an object, foo is replaced with an object
 *             containing foo
 */
var FieldMask = /** @class */ (function () ***REMOVED***
    function FieldMask(fields) ***REMOVED***
        this.fields = fields;
        // TODO(dimond): validation of FieldMask
    ***REMOVED***
    FieldMask.prototype.isEqual = function (other) ***REMOVED***
        return misc.arrayEquals(this.fields, other.fields);
    ***REMOVED***;
    return FieldMask;
***REMOVED***());
exports.FieldMask = FieldMask;
/** Transforms a value into a server-generated timestamp. */
var ServerTimestampTransform = /** @class */ (function () ***REMOVED***
    function ServerTimestampTransform() ***REMOVED***
    ***REMOVED***
    ServerTimestampTransform.prototype.isEqual = function (other) ***REMOVED***
        return other instanceof ServerTimestampTransform;
    ***REMOVED***;
    ServerTimestampTransform.instance = new ServerTimestampTransform();
    return ServerTimestampTransform;
***REMOVED***());
exports.ServerTimestampTransform = ServerTimestampTransform;
/** A field path and the TransformOperation to perform upon it. */
var FieldTransform = /** @class */ (function () ***REMOVED***
    function FieldTransform(field, transform) ***REMOVED***
        this.field = field;
        this.transform = transform;
    ***REMOVED***
    FieldTransform.prototype.isEqual = function (other) ***REMOVED***
        return (this.field.isEqual(other.field) && this.transform.isEqual(other.transform));
    ***REMOVED***;
    return FieldTransform;
***REMOVED***());
exports.FieldTransform = FieldTransform;
/** The result of successfully applying a mutation to the backend. */
var MutationResult = /** @class */ (function () ***REMOVED***
    function MutationResult(
        /**
         * The version at which the mutation was committed or null for a delete.
         */
        version, 
        /**
         * The resulting fields returned from the backend after a
         * TransformMutation has been committed. Contains one FieldValue for each
         * FieldTransform that was in the mutation.
         *
         * Will be null if the mutation was not a TransformMutation.
         */
        transformResults) ***REMOVED***
        this.version = version;
        this.transformResults = transformResults;
    ***REMOVED***
    return MutationResult;
***REMOVED***());
exports.MutationResult = MutationResult;
var MutationType;
(function (MutationType) ***REMOVED***
    MutationType[MutationType["Set"] = 0] = "Set";
    MutationType[MutationType["Patch"] = 1] = "Patch";
    MutationType[MutationType["Transform"] = 2] = "Transform";
    MutationType[MutationType["Delete"] = 3] = "Delete";
***REMOVED***)(MutationType = exports.MutationType || (exports.MutationType = ***REMOVED******REMOVED***));
/**
 * Encodes a precondition for a mutation. This follows the model that the
 * backend accepts with the special case of an explicit "empty" precondition
 * (meaning no precondition).
 */
var Precondition = /** @class */ (function () ***REMOVED***
    function Precondition(updateTime, exists) ***REMOVED***
        this.updateTime = updateTime;
        this.exists = exists;
        assert_1.assert(updateTime === undefined || exists === undefined, 'Precondition can specify "exists" or "updateTime" but not both');
    ***REMOVED***
    /** Creates a new Precondition with an exists flag. */
    Precondition.exists = function (exists) ***REMOVED***
        return new Precondition(undefined, exists);
    ***REMOVED***;
    /** Creates a new Precondition based on a version a document exists at. */
    Precondition.updateTime = function (version) ***REMOVED***
        return new Precondition(version);
    ***REMOVED***;
    Object.defineProperty(Precondition.prototype, "isNone", ***REMOVED***
        /** Returns whether this Precondition is empty. */
        get: function () ***REMOVED***
            return this.updateTime === undefined && this.exists === undefined;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /**
     * Returns true if the preconditions is valid for the given document
     * (or null if no document is available).
     */
    Precondition.prototype.isValidFor = function (maybeDoc) ***REMOVED***
        if (this.updateTime !== undefined) ***REMOVED***
            return (maybeDoc instanceof document_1.Document &&
                maybeDoc.version.isEqual(this.updateTime));
        ***REMOVED***
        else if (this.exists !== undefined) ***REMOVED***
            if (this.exists) ***REMOVED***
                return maybeDoc instanceof document_1.Document;
            ***REMOVED***
            else ***REMOVED***
                return maybeDoc === null || maybeDoc instanceof document_1.NoDocument;
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            assert_1.assert(this.isNone, 'Precondition should be empty');
            return true;
        ***REMOVED***
    ***REMOVED***;
    Precondition.prototype.isEqual = function (other) ***REMOVED***
        return (misc.equals(this.updateTime, other.updateTime) &&
            this.exists === other.exists);
    ***REMOVED***;
    Precondition.NONE = new Precondition();
    return Precondition;
***REMOVED***());
exports.Precondition = Precondition;
/**
 * A mutation describes a self-contained change to a document. Mutations can
 * create, replace, delete, and update subsets of documents.
 *
 * Mutations not only act on the value of the document but also it version.
 * In the case of Set, Patch, and Transform mutations we preserve the existing
 * version. In the case of Delete mutations, we reset the version to 0.
 *
 * Here's the expected transition table.
 *
 * MUTATION           APPLIED TO            RESULTS IN
 *
 * SetMutation        Document(v3)          Document(v3)
 * SetMutation        NoDocument(v3)        Document(v0)
 * SetMutation        null                  Document(v0)
 * PatchMutation      Document(v3)          Document(v3)
 * PatchMutation      NoDocument(v3)        NoDocument(v3)
 * PatchMutation      null                  null
 * TransformMutation  Document(v3)          Document(v3)
 * TransformMutation  NoDocument(v3)        NoDocument(v3)
 * TransformMutation  null                  null
 * DeleteMutation     Document(v3)          NoDocument(v0)
 * DeleteMutation     NoDocument(v3)        NoDocument(v0)
 * DeleteMutation     null                  NoDocument(v0)
 *
 * Note that TransformMutations don't create Documents (in the case of being
 * applied to a NoDocument), even though they would on the backend. This is
 * because the client always combines the TransformMutation with a SetMutation
 * or PatchMutation and we only want to apply the transform if the prior
 * mutation resulted in a Document (always true for a SetMutation, but not
 * necessarily for a PatchMutation).
 *
 * ## Subclassing Notes
 *
 * Subclasses of Mutation need to implement applyToRemoteDocument() and
 * applyToLocalView() to implement the actual behavior of applying the mutation
 * to some source document.
 */
var Mutation = /** @class */ (function () ***REMOVED***
    function Mutation() ***REMOVED***
    ***REMOVED***
    Mutation.prototype.verifyKeyMatches = function (maybeDoc) ***REMOVED***
        if (maybeDoc != null) ***REMOVED***
            assert_1.assert(maybeDoc.key.isEqual(this.key), 'Can only apply a mutation to a document with the same key');
        ***REMOVED***
    ***REMOVED***;
    /**
     * Returns the version from the given document for use as the result of a
     * mutation. Mutations are defined to return the version of the base document
     * only if it is an existing document. Deleted and unknown documents have a
     * post-mutation version of SnapshotVersion.MIN.
     */
    Mutation.getPostMutationVersion = function (maybeDoc) ***REMOVED***
        if (maybeDoc instanceof document_1.Document) ***REMOVED***
            return maybeDoc.version;
        ***REMOVED***
        else ***REMOVED***
            return snapshot_version_1.SnapshotVersion.MIN;
        ***REMOVED***
    ***REMOVED***;
    return Mutation;
***REMOVED***());
exports.Mutation = Mutation;
/**
 * A mutation that creates or replaces the document at the given key with the
 * object value contents.
 */
var SetMutation = /** @class */ (function (_super) ***REMOVED***
    __extends(SetMutation, _super);
    function SetMutation(key, value, precondition) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.value = value;
        _this.precondition = precondition;
        _this.type = MutationType.Set;
        return _this;
    ***REMOVED***
    SetMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) ***REMOVED***
        this.verifyKeyMatches(maybeDoc);
        assert_1.assert(mutationResult.transformResults == null, 'Transform results received by SetMutation.');
        // Unlike applyToLocalView, if we're applying a mutation to a remote
        // document the server has accepted the mutation so the precondition must
        // have held.
        var version = Mutation.getPostMutationVersion(maybeDoc);
        return new document_1.Document(this.key, version, this.value, ***REMOVED***
            hasLocalMutations: false
        ***REMOVED***);
    ***REMOVED***;
    SetMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) ***REMOVED***
        this.verifyKeyMatches(maybeDoc);
        if (!this.precondition.isValidFor(maybeDoc)) ***REMOVED***
            return maybeDoc;
        ***REMOVED***
        var version = Mutation.getPostMutationVersion(maybeDoc);
        return new document_1.Document(this.key, version, this.value, ***REMOVED***
            hasLocalMutations: true
        ***REMOVED***);
    ***REMOVED***;
    SetMutation.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof SetMutation &&
            this.key.isEqual(other.key) &&
            this.value.isEqual(other.value) &&
            this.precondition.isEqual(other.precondition));
    ***REMOVED***;
    return SetMutation;
***REMOVED***(Mutation));
exports.SetMutation = SetMutation;
/**
 * A mutation that modifies fields of the document at the given key with the
 * given values. The values are applied through a field mask:
 *
 *  * When a field is in both the mask and the values, the corresponding field
 *    is updated.
 *  * When a field is in neither the mask nor the values, the corresponding
 *    field is unmodified.
 *  * When a field is in the mask but not in the values, the corresponding field
 *    is deleted.
 *  * When a field is not in the mask but is in the values, the values map is
 *    ignored.
 */
var PatchMutation = /** @class */ (function (_super) ***REMOVED***
    __extends(PatchMutation, _super);
    function PatchMutation(key, data, fieldMask, precondition) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.data = data;
        _this.fieldMask = fieldMask;
        _this.precondition = precondition;
        _this.type = MutationType.Patch;
        return _this;
    ***REMOVED***
    PatchMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) ***REMOVED***
        this.verifyKeyMatches(maybeDoc);
        assert_1.assert(mutationResult.transformResults == null, 'Transform results received by PatchMutation.');
        // TODO(mcg): Relax enforcement of this precondition
        //
        // We shouldn't actually enforce the precondition since it already passed on
        // the backend, but we may not have a local version of the document to
        // patch, so we use the precondition to prevent incorrectly putting a
        // partial document into our cache.
        if (!this.precondition.isValidFor(maybeDoc)) ***REMOVED***
            return maybeDoc;
        ***REMOVED***
        var version = Mutation.getPostMutationVersion(maybeDoc);
        var newData = this.patchDocument(maybeDoc);
        return new document_1.Document(this.key, version, newData, ***REMOVED***
            hasLocalMutations: false
        ***REMOVED***);
    ***REMOVED***;
    PatchMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) ***REMOVED***
        this.verifyKeyMatches(maybeDoc);
        if (!this.precondition.isValidFor(maybeDoc)) ***REMOVED***
            return maybeDoc;
        ***REMOVED***
        var version = Mutation.getPostMutationVersion(maybeDoc);
        var newData = this.patchDocument(maybeDoc);
        return new document_1.Document(this.key, version, newData, ***REMOVED***
            hasLocalMutations: true
        ***REMOVED***);
    ***REMOVED***;
    PatchMutation.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof PatchMutation &&
            this.key.isEqual(other.key) &&
            this.fieldMask.isEqual(other.fieldMask) &&
            this.precondition.isEqual(other.precondition));
    ***REMOVED***;
    /**
     * Patches the data of document if available or creates a new document. Note
     * that this does not check whether or not the precondition of this patch
     * holds.
     */
    PatchMutation.prototype.patchDocument = function (maybeDoc) ***REMOVED***
        var data;
        if (maybeDoc instanceof document_1.Document) ***REMOVED***
            data = maybeDoc.data;
        ***REMOVED***
        else ***REMOVED***
            data = field_value_1.ObjectValue.EMPTY;
        ***REMOVED***
        return this.patchObject(data);
    ***REMOVED***;
    PatchMutation.prototype.patchObject = function (data) ***REMOVED***
        for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) ***REMOVED***
            var fieldPath = _a[_i];
            var newValue = this.data.field(fieldPath);
            if (newValue !== undefined) ***REMOVED***
                data = data.set(fieldPath, newValue);
            ***REMOVED***
            else ***REMOVED***
                data = data.delete(fieldPath);
            ***REMOVED***
        ***REMOVED***
        return data;
    ***REMOVED***;
    return PatchMutation;
***REMOVED***(Mutation));
exports.PatchMutation = PatchMutation;
/**
 * A mutation that modifies specific fields of the document with transform
 * operations. Currently the only supported transform is a server timestamp, but
 * IP Address, increment(n), etc. could be supported in the future.
 *
 * It is somewhat similar to a PatchMutation in that it patches specific fields
 * and has no effect when applied to a null or NoDocument (see comment on
 * Mutation for rationale).
 */
var TransformMutation = /** @class */ (function (_super) ***REMOVED***
    __extends(TransformMutation, _super);
    function TransformMutation(key, fieldTransforms) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.fieldTransforms = fieldTransforms;
        _this.type = MutationType.Transform;
        // NOTE: We set a precondition of exists: true as a safety-check, since we
        // always combine TransformMutations with a SetMutation or PatchMutation which
        // (if successful) should end up with an existing document.
        _this.precondition = Precondition.exists(true);
        return _this;
    ***REMOVED***
    TransformMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) ***REMOVED***
        this.verifyKeyMatches(maybeDoc);
        assert_1.assert(mutationResult.transformResults != null, 'Transform results missing for TransformMutation.');
        var transformResults = mutationResult.transformResults;
        // TODO(mcg): Relax enforcement of this precondition
        //
        // We shouldn't actually enforce the precondition since it already passed on
        // the backend, but we may not have a local version of the document to
        // patch, so we use the precondition to prevent incorrectly putting a
        // partial document into our cache.
        if (!this.precondition.isValidFor(maybeDoc)) ***REMOVED***
            return maybeDoc;
        ***REMOVED***
        var doc = this.requireDocument(maybeDoc);
        var newData = this.transformObject(doc.data, transformResults);
        return new document_1.Document(this.key, doc.version, newData, ***REMOVED***
            hasLocalMutations: false
        ***REMOVED***);
    ***REMOVED***;
    TransformMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) ***REMOVED***
        this.verifyKeyMatches(maybeDoc);
        if (!this.precondition.isValidFor(maybeDoc)) ***REMOVED***
            return maybeDoc;
        ***REMOVED***
        var doc = this.requireDocument(maybeDoc);
        var transformResults = this.localTransformResults(localWriteTime, baseDoc);
        var newData = this.transformObject(doc.data, transformResults);
        return new document_1.Document(this.key, doc.version, newData, ***REMOVED***
            hasLocalMutations: true
        ***REMOVED***);
    ***REMOVED***;
    TransformMutation.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof TransformMutation &&
            this.key.isEqual(other.key) &&
            misc.arrayEquals(this.fieldTransforms, other.fieldTransforms) &&
            this.precondition.isEqual(other.precondition));
    ***REMOVED***;
    /**
     * Asserts that the given MaybeDocument is actually a Document and verifies
     * that it matches the key for this mutation. Since we only support
     * transformations with precondition exists this method is guaranteed to be
     * safe.
     */
    TransformMutation.prototype.requireDocument = function (maybeDoc) ***REMOVED***
        assert_1.assert(maybeDoc instanceof document_1.Document, 'Unknown MaybeDocument type ' + maybeDoc);
        var doc = maybeDoc;
        assert_1.assert(doc.key.isEqual(this.key), 'Can only transform a document with the same key');
        return doc;
    ***REMOVED***;
    /**
     * Creates a list of "transform results" (a transform result is a field value
     * representing the result of applying a transform) for use when applying a
     * TransformMutation locally.
     *
     * @param localWriteTime The local time of the transform mutation (used to
     *     generate ServerTimestampValues).
     * @param baseDoc The document prior to applying this mutation batch.
     * @return The transform results list.
     */
    TransformMutation.prototype.localTransformResults = function (localWriteTime, baseDoc) ***REMOVED***
        var transformResults = [];
        for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) ***REMOVED***
            var fieldTransform = _a[_i];
            var transform = fieldTransform.transform;
            if (transform instanceof ServerTimestampTransform) ***REMOVED***
                var previousValue = null;
                if (baseDoc instanceof document_1.Document) ***REMOVED***
                    previousValue = baseDoc.field(fieldTransform.field) || null;
                ***REMOVED***
                transformResults.push(new field_value_1.ServerTimestampValue(localWriteTime, previousValue));
            ***REMOVED***
            else ***REMOVED***
                return assert_1.fail('Encountered unknown transform: ' + transform);
            ***REMOVED***
        ***REMOVED***
        return transformResults;
    ***REMOVED***;
    TransformMutation.prototype.transformObject = function (data, transformResults) ***REMOVED***
        assert_1.assert(transformResults.length === this.fieldTransforms.length, 'TransformResults length mismatch.');
        for (var i = 0; i < this.fieldTransforms.length; i++) ***REMOVED***
            var fieldTransform = this.fieldTransforms[i];
            var transform = fieldTransform.transform;
            var fieldPath = fieldTransform.field;
            if (transform instanceof ServerTimestampTransform) ***REMOVED***
                data = data.set(fieldPath, transformResults[i]);
            ***REMOVED***
            else ***REMOVED***
                return assert_1.fail('Encountered unknown transform: ' + transform);
            ***REMOVED***
        ***REMOVED***
        return data;
    ***REMOVED***;
    return TransformMutation;
***REMOVED***(Mutation));
exports.TransformMutation = TransformMutation;
/** A mutation that deletes the document at the given key. */
var DeleteMutation = /** @class */ (function (_super) ***REMOVED***
    __extends(DeleteMutation, _super);
    function DeleteMutation(key, precondition) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.precondition = precondition;
        _this.type = MutationType.Delete;
        return _this;
    ***REMOVED***
    DeleteMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) ***REMOVED***
        this.verifyKeyMatches(maybeDoc);
        assert_1.assert(mutationResult.transformResults == null, 'Transform results received by DeleteMutation.');
        // Unlike applyToLocalView, if we're applying a mutation to a remote
        // document the server has accepted the mutation so the precondition must
        // have held.
        return new document_1.NoDocument(this.key, snapshot_version_1.SnapshotVersion.MIN);
    ***REMOVED***;
    DeleteMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) ***REMOVED***
        this.verifyKeyMatches(maybeDoc);
        if (!this.precondition.isValidFor(maybeDoc)) ***REMOVED***
            return maybeDoc;
        ***REMOVED***
        if (maybeDoc) ***REMOVED***
            assert_1.assert(maybeDoc.key.isEqual(this.key), 'Can only apply mutation to document with same key');
        ***REMOVED***
        return new document_1.NoDocument(this.key, snapshot_version_1.SnapshotVersion.forDeletedDoc());
    ***REMOVED***;
    DeleteMutation.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof DeleteMutation &&
            this.key.isEqual(other.key) &&
            this.precondition.isEqual(other.precondition));
    ***REMOVED***;
    return DeleteMutation;
***REMOVED***(Mutation));
exports.DeleteMutation = DeleteMutation;

//# sourceMappingURL=mutation.js.map
