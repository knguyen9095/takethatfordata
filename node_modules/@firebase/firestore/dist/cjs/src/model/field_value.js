"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var assert_1 = require("../util/assert");
var misc_1 = require("../util/misc");
var sorted_map_1 = require("../util/sorted_map");
var document_key_1 = require("./document_key");
var TypeOrder;
(function (TypeOrder) ***REMOVED***
    // This order is defined by the backend.
    TypeOrder[TypeOrder["NullValue"] = 0] = "NullValue";
    TypeOrder[TypeOrder["BooleanValue"] = 1] = "BooleanValue";
    TypeOrder[TypeOrder["NumberValue"] = 2] = "NumberValue";
    TypeOrder[TypeOrder["TimestampValue"] = 3] = "TimestampValue";
    TypeOrder[TypeOrder["StringValue"] = 4] = "StringValue";
    TypeOrder[TypeOrder["BlobValue"] = 5] = "BlobValue";
    TypeOrder[TypeOrder["RefValue"] = 6] = "RefValue";
    TypeOrder[TypeOrder["GeoPointValue"] = 7] = "GeoPointValue";
    TypeOrder[TypeOrder["ArrayValue"] = 8] = "ArrayValue";
    TypeOrder[TypeOrder["ObjectValue"] = 9] = "ObjectValue";
***REMOVED***)(TypeOrder = exports.TypeOrder || (exports.TypeOrder = ***REMOVED******REMOVED***));
/** Defines the return value for pending server timestamps. */
var ServerTimestampBehavior;
(function (ServerTimestampBehavior) ***REMOVED***
    ServerTimestampBehavior[ServerTimestampBehavior["Default"] = 0] = "Default";
    ServerTimestampBehavior[ServerTimestampBehavior["Estimate"] = 1] = "Estimate";
    ServerTimestampBehavior[ServerTimestampBehavior["Previous"] = 2] = "Previous";
***REMOVED***)(ServerTimestampBehavior = exports.ServerTimestampBehavior || (exports.ServerTimestampBehavior = ***REMOVED******REMOVED***));
/** Holds properties that define field value deserialization options. */
var FieldValueOptions = /** @class */ (function () ***REMOVED***
    function FieldValueOptions(serverTimestampBehavior) ***REMOVED***
        this.serverTimestampBehavior = serverTimestampBehavior;
    ***REMOVED***
    FieldValueOptions.fromSnapshotOptions = function (options) ***REMOVED***
        switch (options.serverTimestamps) ***REMOVED***
            case 'estimate':
                return new FieldValueOptions(ServerTimestampBehavior.Estimate);
            case 'previous':
                return new FieldValueOptions(ServerTimestampBehavior.Previous);
            case 'none': // Fall-through intended.
            case undefined:
                return FieldValueOptions.defaultOptions;
            default:
                return assert_1.fail('fromSnapshotOptions() called with invalid options.');
        ***REMOVED***
    ***REMOVED***;
    FieldValueOptions.defaultOptions = new FieldValueOptions(ServerTimestampBehavior.Default);
    return FieldValueOptions;
***REMOVED***());
exports.FieldValueOptions = FieldValueOptions;
/**
 * A field value represents a datatype as stored by Firestore.
 */
var FieldValue = /** @class */ (function () ***REMOVED***
    function FieldValue() ***REMOVED***
    ***REMOVED***
    FieldValue.prototype.toString = function () ***REMOVED***
        var val = this.value();
        return val === null ? 'null' : val.toString();
    ***REMOVED***;
    FieldValue.prototype.defaultCompareTo = function (other) ***REMOVED***
        assert_1.assert(this.typeOrder !== other.typeOrder, 'Default compareTo should not be used for values of same type.');
        var cmp = misc_1.primitiveComparator(this.typeOrder, other.typeOrder);
        return cmp;
    ***REMOVED***;
    return FieldValue;
***REMOVED***());
exports.FieldValue = FieldValue;
var NullValue = /** @class */ (function (_super) ***REMOVED***
    __extends(NullValue, _super);
    function NullValue() ***REMOVED***
        var _this = _super.call(this) || this;
        _this.typeOrder = TypeOrder.NullValue;
        // internalValue is unused but we add it to work around
        // https://github.com/Microsoft/TypeScript/issues/15585
        _this.internalValue = null;
        return _this;
    ***REMOVED***
    NullValue.prototype.value = function (options) ***REMOVED***
        return null;
    ***REMOVED***;
    NullValue.prototype.isEqual = function (other) ***REMOVED***
        return other instanceof NullValue;
    ***REMOVED***;
    NullValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof NullValue) ***REMOVED***
            return 0;
        ***REMOVED***
        return this.defaultCompareTo(other);
    ***REMOVED***;
    NullValue.INSTANCE = new NullValue();
    return NullValue;
***REMOVED***(FieldValue));
exports.NullValue = NullValue;
var BooleanValue = /** @class */ (function (_super) ***REMOVED***
    __extends(BooleanValue, _super);
    function BooleanValue(internalValue) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.BooleanValue;
        return _this;
    ***REMOVED***
    BooleanValue.prototype.value = function (options) ***REMOVED***
        return this.internalValue;
    ***REMOVED***;
    BooleanValue.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof BooleanValue &&
            this.internalValue === other.internalValue);
    ***REMOVED***;
    BooleanValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof BooleanValue) ***REMOVED***
            return misc_1.primitiveComparator(this, other);
        ***REMOVED***
        return this.defaultCompareTo(other);
    ***REMOVED***;
    BooleanValue.of = function (value) ***REMOVED***
        return value ? BooleanValue.TRUE : BooleanValue.FALSE;
    ***REMOVED***;
    BooleanValue.TRUE = new BooleanValue(true);
    BooleanValue.FALSE = new BooleanValue(false);
    return BooleanValue;
***REMOVED***(FieldValue));
exports.BooleanValue = BooleanValue;
/** Base class for IntegerValue and DoubleValue. */
var NumberValue = /** @class */ (function (_super) ***REMOVED***
    __extends(NumberValue, _super);
    function NumberValue(internalValue) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.NumberValue;
        return _this;
    ***REMOVED***
    NumberValue.prototype.value = function (options) ***REMOVED***
        return this.internalValue;
    ***REMOVED***;
    NumberValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof NumberValue) ***REMOVED***
            return numericComparator(this.internalValue, other.internalValue);
        ***REMOVED***
        return this.defaultCompareTo(other);
    ***REMOVED***;
    return NumberValue;
***REMOVED***(FieldValue));
exports.NumberValue = NumberValue;
/** Utility function to compare doubles (using Firestore semantics for NaN). */
function numericComparator(left, right) ***REMOVED***
    if (left < right) ***REMOVED***
        return -1;
    ***REMOVED***
    else if (left > right) ***REMOVED***
        return 1;
    ***REMOVED***
    else if (left === right) ***REMOVED***
        return 0;
    ***REMOVED***
    else ***REMOVED***
        // one or both are NaN.
        if (isNaN(left)) ***REMOVED***
            return isNaN(right) ? 0 : -1;
        ***REMOVED***
        else ***REMOVED***
            return 1;
        ***REMOVED***
    ***REMOVED***
***REMOVED***
/**
 * Utility function to check numbers for equality using Firestore semantics
 * (NaN === NaN, -0.0 !== 0.0).
 */
function numericEquals(left, right) ***REMOVED***
    // Implemented based on Object.is() polyfill from
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
    if (left === right) ***REMOVED***
        // +0 != -0
        return left !== 0 || 1 / left === 1 / right;
    ***REMOVED***
    else ***REMOVED***
        // NaN == NaN
        return left !== left && right !== right;
    ***REMOVED***
***REMOVED***
var IntegerValue = /** @class */ (function (_super) ***REMOVED***
    __extends(IntegerValue, _super);
    function IntegerValue(internalValue) ***REMOVED***
        return _super.call(this, internalValue) || this;
    ***REMOVED***
    IntegerValue.prototype.isEqual = function (other) ***REMOVED***
        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,
        // but that doesn't make them equal via isEqual().
        if (other instanceof IntegerValue) ***REMOVED***
            return numericEquals(this.internalValue, other.internalValue);
        ***REMOVED***
        else ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***;
    return IntegerValue;
***REMOVED***(NumberValue));
exports.IntegerValue = IntegerValue;
var DoubleValue = /** @class */ (function (_super) ***REMOVED***
    __extends(DoubleValue, _super);
    function DoubleValue(internalValue) ***REMOVED***
        var _this = _super.call(this, internalValue) || this;
        _this.internalValue = internalValue;
        return _this;
    ***REMOVED***
    DoubleValue.prototype.isEqual = function (other) ***REMOVED***
        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,
        // but that doesn't make them equal via isEqual().
        if (other instanceof DoubleValue) ***REMOVED***
            return numericEquals(this.internalValue, other.internalValue);
        ***REMOVED***
        else ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***;
    DoubleValue.NAN = new DoubleValue(NaN);
    DoubleValue.POSITIVE_INFINITY = new DoubleValue(Infinity);
    DoubleValue.NEGATIVE_INFINITY = new DoubleValue(-Infinity);
    return DoubleValue;
***REMOVED***(NumberValue));
exports.DoubleValue = DoubleValue;
// TODO(b/37267885): Add truncation support
var StringValue = /** @class */ (function (_super) ***REMOVED***
    __extends(StringValue, _super);
    function StringValue(internalValue) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.StringValue;
        return _this;
    ***REMOVED***
    StringValue.prototype.value = function (options) ***REMOVED***
        return this.internalValue;
    ***REMOVED***;
    StringValue.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof StringValue && this.internalValue === other.internalValue);
    ***REMOVED***;
    StringValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof StringValue) ***REMOVED***
            return misc_1.primitiveComparator(this.internalValue, other.internalValue);
        ***REMOVED***
        return this.defaultCompareTo(other);
    ***REMOVED***;
    return StringValue;
***REMOVED***(FieldValue));
exports.StringValue = StringValue;
var TimestampValue = /** @class */ (function (_super) ***REMOVED***
    __extends(TimestampValue, _super);
    function TimestampValue(internalValue) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.TimestampValue;
        return _this;
    ***REMOVED***
    TimestampValue.prototype.value = function (options) ***REMOVED***
        return this.internalValue.toDate();
    ***REMOVED***;
    TimestampValue.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof TimestampValue &&
            this.internalValue.isEqual(other.internalValue));
    ***REMOVED***;
    TimestampValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof TimestampValue) ***REMOVED***
            return this.internalValue.compareTo(other.internalValue);
        ***REMOVED***
        else if (other instanceof ServerTimestampValue) ***REMOVED***
            // Concrete timestamps come before server timestamps.
            return -1;
        ***REMOVED***
        else ***REMOVED***
            return this.defaultCompareTo(other);
        ***REMOVED***
    ***REMOVED***;
    return TimestampValue;
***REMOVED***(FieldValue));
exports.TimestampValue = TimestampValue;
/**
 * Represents a locally-applied ServerTimestamp.
 *
 * Notes:
 * - ServerTimestampValue instances are created as the result of applying a
 *   TransformMutation (see TransformMutation.applyTo()). They can only exist in
 *   the local view of a document. Therefore they do not need to be parsed or
 *   serialized.
 * - When evaluated locally (e.g. for snapshot.data()), they by default
 *   evaluate to `null`. This behavior can be configured by passing custom
 *   FieldValueOptions to value().
 * - With respect to other ServerTimestampValues, they sort by their
 *   localWriteTime.
 */
var ServerTimestampValue = /** @class */ (function (_super) ***REMOVED***
    __extends(ServerTimestampValue, _super);
    function ServerTimestampValue(localWriteTime, previousValue) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.localWriteTime = localWriteTime;
        _this.previousValue = previousValue;
        _this.typeOrder = TypeOrder.TimestampValue;
        return _this;
    ***REMOVED***
    ServerTimestampValue.prototype.value = function (options) ***REMOVED***
        if (options &&
            options.serverTimestampBehavior === ServerTimestampBehavior.Estimate) ***REMOVED***
            return this.localWriteTime.toDate();
        ***REMOVED***
        else if (options &&
            options.serverTimestampBehavior === ServerTimestampBehavior.Previous) ***REMOVED***
            return this.previousValue ? this.previousValue.value(options) : null;
        ***REMOVED***
        else ***REMOVED***
            return null;
        ***REMOVED***
    ***REMOVED***;
    ServerTimestampValue.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof ServerTimestampValue &&
            this.localWriteTime.isEqual(other.localWriteTime));
    ***REMOVED***;
    ServerTimestampValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof ServerTimestampValue) ***REMOVED***
            return this.localWriteTime.compareTo(other.localWriteTime);
        ***REMOVED***
        else if (other instanceof TimestampValue) ***REMOVED***
            // Server timestamps come after all concrete timestamps.
            return 1;
        ***REMOVED***
        else ***REMOVED***
            return this.defaultCompareTo(other);
        ***REMOVED***
    ***REMOVED***;
    ServerTimestampValue.prototype.toString = function () ***REMOVED***
        return '<ServerTimestamp localTime=' + this.localWriteTime.toString() + '>';
    ***REMOVED***;
    return ServerTimestampValue;
***REMOVED***(FieldValue));
exports.ServerTimestampValue = ServerTimestampValue;
var BlobValue = /** @class */ (function (_super) ***REMOVED***
    __extends(BlobValue, _super);
    function BlobValue(internalValue) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.BlobValue;
        return _this;
    ***REMOVED***
    BlobValue.prototype.value = function (options) ***REMOVED***
        return this.internalValue;
    ***REMOVED***;
    BlobValue.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof BlobValue &&
            this.internalValue.isEqual(other.internalValue));
    ***REMOVED***;
    BlobValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof BlobValue) ***REMOVED***
            return this.internalValue._compareTo(other.internalValue);
        ***REMOVED***
        return this.defaultCompareTo(other);
    ***REMOVED***;
    return BlobValue;
***REMOVED***(FieldValue));
exports.BlobValue = BlobValue;
var RefValue = /** @class */ (function (_super) ***REMOVED***
    __extends(RefValue, _super);
    function RefValue(databaseId, key) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.databaseId = databaseId;
        _this.key = key;
        _this.typeOrder = TypeOrder.RefValue;
        return _this;
    ***REMOVED***
    RefValue.prototype.value = function (options) ***REMOVED***
        return this.key;
    ***REMOVED***;
    RefValue.prototype.isEqual = function (other) ***REMOVED***
        if (other instanceof RefValue) ***REMOVED***
            return (this.key.isEqual(other.key) && this.databaseId.isEqual(other.databaseId));
        ***REMOVED***
        else ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***;
    RefValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof RefValue) ***REMOVED***
            var cmp = this.databaseId.compareTo(other.databaseId);
            return cmp !== 0 ? cmp : document_key_1.DocumentKey.comparator(this.key, other.key);
        ***REMOVED***
        return this.defaultCompareTo(other);
    ***REMOVED***;
    return RefValue;
***REMOVED***(FieldValue));
exports.RefValue = RefValue;
var GeoPointValue = /** @class */ (function (_super) ***REMOVED***
    __extends(GeoPointValue, _super);
    function GeoPointValue(internalValue) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.GeoPointValue;
        return _this;
    ***REMOVED***
    GeoPointValue.prototype.value = function (options) ***REMOVED***
        return this.internalValue;
    ***REMOVED***;
    GeoPointValue.prototype.isEqual = function (other) ***REMOVED***
        return (other instanceof GeoPointValue &&
            this.internalValue.isEqual(other.internalValue));
    ***REMOVED***;
    GeoPointValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof GeoPointValue) ***REMOVED***
            return this.internalValue._compareTo(other.internalValue);
        ***REMOVED***
        return this.defaultCompareTo(other);
    ***REMOVED***;
    return GeoPointValue;
***REMOVED***(FieldValue));
exports.GeoPointValue = GeoPointValue;
var ObjectValue = /** @class */ (function (_super) ***REMOVED***
    __extends(ObjectValue, _super);
    function ObjectValue(internalValue) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.ObjectValue;
        return _this;
    ***REMOVED***
    ObjectValue.prototype.value = function (options) ***REMOVED***
        var result = ***REMOVED******REMOVED***;
        this.internalValue.inorderTraversal(function (key, val) ***REMOVED***
            result[key] = val.value(options);
        ***REMOVED***);
        return result;
    ***REMOVED***;
    ObjectValue.prototype.forEach = function (action) ***REMOVED***
        this.internalValue.inorderTraversal(action);
    ***REMOVED***;
    ObjectValue.prototype.isEqual = function (other) ***REMOVED***
        if (other instanceof ObjectValue) ***REMOVED***
            var it1 = this.internalValue.getIterator();
            var it2 = other.internalValue.getIterator();
            while (it1.hasNext() && it2.hasNext()) ***REMOVED***
                var next1 = it1.getNext();
                var next2 = it2.getNext();
                if (next1.key !== next2.key || !next1.value.isEqual(next2.value)) ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***
            return !it1.hasNext() && !it2.hasNext();
        ***REMOVED***
        return false;
    ***REMOVED***;
    ObjectValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof ObjectValue) ***REMOVED***
            var it1 = this.internalValue.getIterator();
            var it2 = other.internalValue.getIterator();
            while (it1.hasNext() && it2.hasNext()) ***REMOVED***
                var next1 = it1.getNext();
                var next2 = it2.getNext();
                var cmp = misc_1.primitiveComparator(next1.key, next2.key) ||
                    next1.value.compareTo(next2.value);
                if (cmp) ***REMOVED***
                    return cmp;
                ***REMOVED***
            ***REMOVED***
            // Only equal if both iterators are exhausted
            return misc_1.primitiveComparator(it1.hasNext(), it2.hasNext());
        ***REMOVED***
        else ***REMOVED***
            return this.defaultCompareTo(other);
        ***REMOVED***
    ***REMOVED***;
    ObjectValue.prototype.set = function (path, to) ***REMOVED***
        assert_1.assert(!path.isEmpty(), 'Cannot set field for empty path on ObjectValue');
        if (path.length === 1) ***REMOVED***
            return this.setChild(path.firstSegment(), to);
        ***REMOVED***
        else ***REMOVED***
            var child = this.child(path.firstSegment());
            if (!(child instanceof ObjectValue)) ***REMOVED***
                child = ObjectValue.EMPTY;
            ***REMOVED***
            var newChild = child.set(path.popFirst(), to);
            return this.setChild(path.firstSegment(), newChild);
        ***REMOVED***
    ***REMOVED***;
    ObjectValue.prototype.delete = function (path) ***REMOVED***
        assert_1.assert(!path.isEmpty(), 'Cannot delete field for empty path on ObjectValue');
        if (path.length === 1) ***REMOVED***
            return new ObjectValue(this.internalValue.remove(path.firstSegment()));
        ***REMOVED***
        else ***REMOVED***
            // nested field
            var child = this.child(path.firstSegment());
            if (child instanceof ObjectValue) ***REMOVED***
                var newChild = child.delete(path.popFirst());
                return new ObjectValue(this.internalValue.insert(path.firstSegment(), newChild));
            ***REMOVED***
            else ***REMOVED***
                // Don't actually change a primitive value to an object for a delete
                return this;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    ObjectValue.prototype.contains = function (path) ***REMOVED***
        return this.field(path) !== undefined;
    ***REMOVED***;
    ObjectValue.prototype.field = function (path) ***REMOVED***
        assert_1.assert(!path.isEmpty(), "Can't get field of empty path");
        var field = this;
        path.forEach(function (pathSegment) ***REMOVED***
            if (field instanceof ObjectValue) ***REMOVED***
                field = field.internalValue.get(pathSegment) || undefined;
            ***REMOVED***
            else ***REMOVED***
                field = undefined;
            ***REMOVED***
        ***REMOVED***);
        return field;
    ***REMOVED***;
    ObjectValue.prototype.toString = function () ***REMOVED***
        return JSON.stringify(this.value());
    ***REMOVED***;
    ObjectValue.prototype.child = function (childName) ***REMOVED***
        return this.internalValue.get(childName) || undefined;
    ***REMOVED***;
    ObjectValue.prototype.setChild = function (childName, value) ***REMOVED***
        return new ObjectValue(this.internalValue.insert(childName, value));
    ***REMOVED***;
    ObjectValue.EMPTY = new ObjectValue(new sorted_map_1.SortedMap(misc_1.primitiveComparator));
    return ObjectValue;
***REMOVED***(FieldValue));
exports.ObjectValue = ObjectValue;
var ArrayValue = /** @class */ (function (_super) ***REMOVED***
    __extends(ArrayValue, _super);
    function ArrayValue(internalValue) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.ArrayValue;
        return _this;
    ***REMOVED***
    ArrayValue.prototype.value = function (options) ***REMOVED***
        return this.internalValue.map(function (v) ***REMOVED*** return v.value(options); ***REMOVED***);
    ***REMOVED***;
    ArrayValue.prototype.forEach = function (action) ***REMOVED***
        this.internalValue.forEach(action);
    ***REMOVED***;
    ArrayValue.prototype.isEqual = function (other) ***REMOVED***
        if (other instanceof ArrayValue) ***REMOVED***
            if (this.internalValue.length !== other.internalValue.length) ***REMOVED***
                return false;
            ***REMOVED***
            for (var i = 0; i < this.internalValue.length; i++) ***REMOVED***
                if (!this.internalValue[i].isEqual(other.internalValue[i])) ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***
            return true;
        ***REMOVED***
        return false;
    ***REMOVED***;
    ArrayValue.prototype.compareTo = function (other) ***REMOVED***
        if (other instanceof ArrayValue) ***REMOVED***
            var minLength = Math.min(this.internalValue.length, other.internalValue.length);
            for (var i = 0; i < minLength; i++) ***REMOVED***
                var cmp = this.internalValue[i].compareTo(other.internalValue[i]);
                if (cmp) ***REMOVED***
                    return cmp;
                ***REMOVED***
            ***REMOVED***
            return misc_1.primitiveComparator(this.internalValue.length, other.internalValue.length);
        ***REMOVED***
        else ***REMOVED***
            return this.defaultCompareTo(other);
        ***REMOVED***
    ***REMOVED***;
    ArrayValue.prototype.toString = function () ***REMOVED***
        return JSON.stringify(this.value());
    ***REMOVED***;
    return ArrayValue;
***REMOVED***(FieldValue));
exports.ArrayValue = ArrayValue;

//# sourceMappingURL=field_value.js.map
