"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var assert_1 = require("../util/assert");
var error_1 = require("../util/error");
exports.DOCUMENT_KEY_NAME = '__name__';
/**
 * Path represents an ordered sequence of string segments.
 */
var Path = /** @class */ (function () ***REMOVED***
    function Path(segments, offset, length) ***REMOVED***
        this.init(segments, offset, length);
    ***REMOVED***
    /**
     * An initialization method that can be called from outside the constructor.
     * We need this so that we can have a non-static construct method that returns
     * the polymorphic `this` type.
     */
    Path.prototype.init = function (segments, offset, length) ***REMOVED***
        if (offset === undefined) ***REMOVED***
            offset = 0;
        ***REMOVED***
        else if (offset > segments.length) ***REMOVED***
            assert_1.fail('offset ' + offset + ' out of range ' + segments.length);
        ***REMOVED***
        if (length === undefined) ***REMOVED***
            length = segments.length - offset;
        ***REMOVED***
        else if (length > segments.length - offset) ***REMOVED***
            assert_1.fail('length ' + length + ' out of range ' + (segments.length - offset));
        ***REMOVED***
        this.segments = segments;
        this.offset = offset;
        this.len = length;
    ***REMOVED***;
    /**
     * Constructs a new instance of Path using the same concrete type as `this`.
     * We need this instead of using the normal constructor, because polymorphic
     * `this` doesn't work on static methods.
     */
    Path.prototype.construct = function (segments, offset, length) ***REMOVED***
        var path = Object.create(Object.getPrototypeOf(this));
        path.init(segments, offset, length);
        return path;
    ***REMOVED***;
    Object.defineProperty(Path.prototype, "length", ***REMOVED***
        get: function () ***REMOVED***
            return this.len;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Path.prototype.isEqual = function (other) ***REMOVED***
        return Path.comparator(this, other) === 0;
    ***REMOVED***;
    Path.prototype.child = function (nameOrPath) ***REMOVED***
        var segments = this.segments.slice(this.offset, this.limit());
        if (nameOrPath instanceof Path) ***REMOVED***
            nameOrPath.forEach(function (segment) ***REMOVED***
                segments.push(segment);
            ***REMOVED***);
        ***REMOVED***
        else if (typeof nameOrPath === 'string') ***REMOVED***
            segments.push(nameOrPath);
        ***REMOVED***
        else ***REMOVED***
            assert_1.fail('Unknown parameter type for Path.child(): ' + nameOrPath);
        ***REMOVED***
        return this.construct(segments);
    ***REMOVED***;
    /** The index of one past the last segment of the path. */
    Path.prototype.limit = function () ***REMOVED***
        return this.offset + this.length;
    ***REMOVED***;
    Path.prototype.popFirst = function (size) ***REMOVED***
        size = size === undefined ? 1 : size;
        assert_1.assert(this.length >= size, "Can't call popFirst() with less segments");
        return this.construct(this.segments, this.offset + size, this.length - size);
    ***REMOVED***;
    Path.prototype.popLast = function () ***REMOVED***
        assert_1.assert(!this.isEmpty(), "Can't call popLast() on empty path");
        return this.construct(this.segments, this.offset, this.length - 1);
    ***REMOVED***;
    Path.prototype.firstSegment = function () ***REMOVED***
        assert_1.assert(!this.isEmpty(), "Can't call firstSegment() on empty path");
        return this.segments[this.offset];
    ***REMOVED***;
    Path.prototype.lastSegment = function () ***REMOVED***
        assert_1.assert(!this.isEmpty(), "Can't call lastSegment() on empty path");
        return this.segments[this.limit() - 1];
    ***REMOVED***;
    Path.prototype.get = function (index) ***REMOVED***
        assert_1.assert(index < this.length, 'Index out of range');
        return this.segments[this.offset + index];
    ***REMOVED***;
    Path.prototype.isEmpty = function () ***REMOVED***
        return this.length === 0;
    ***REMOVED***;
    Path.prototype.isPrefixOf = function (other) ***REMOVED***
        if (other.length < this.length) ***REMOVED***
            return false;
        ***REMOVED***
        for (var i = 0; i < this.length; i++) ***REMOVED***
            if (this.get(i) !== other.get(i)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        return true;
    ***REMOVED***;
    Path.prototype.forEach = function (fn) ***REMOVED***
        for (var i = this.offset, end = this.limit(); i < end; i++) ***REMOVED***
            fn(this.segments[i]);
        ***REMOVED***
    ***REMOVED***;
    Path.prototype.toArray = function () ***REMOVED***
        return this.segments.slice(this.offset, this.limit());
    ***REMOVED***;
    Path.comparator = function (p1, p2) ***REMOVED***
        var len = Math.min(p1.length, p2.length);
        for (var i = 0; i < len; i++) ***REMOVED***
            var left = p1.get(i);
            var right = p2.get(i);
            if (left < right)
                return -1;
            if (left > right)
                return 1;
        ***REMOVED***
        if (p1.length < p2.length)
            return -1;
        if (p1.length > p2.length)
            return 1;
        return 0;
    ***REMOVED***;
    return Path;
***REMOVED***());
exports.Path = Path;
/**
 * A slash-separated path for navigating resources (documents and collections)
 * within Firestore.
 */
var ResourcePath = /** @class */ (function (_super) ***REMOVED***
    __extends(ResourcePath, _super);
    function ResourcePath() ***REMOVED***
        return _super !== null && _super.apply(this, arguments) || this;
    ***REMOVED***
    ResourcePath.prototype.canonicalString = function () ***REMOVED***
        // NOTE: The client is ignorant of any path segments containing escape
        // sequences (e.g. __id123__) and just passes them through raw (they exist
        // for legacy reasons and should not be used frequently).
        return this.toArray().join('/');
    ***REMOVED***;
    ResourcePath.prototype.toString = function () ***REMOVED***
        return this.canonicalString();
    ***REMOVED***;
    /**
     * Creates a resource path from the given slash-delimited string.
     */
    ResourcePath.fromString = function (path) ***REMOVED***
        // NOTE: The client is ignorant of any path segments containing escape
        // sequences (e.g. __id123__) and just passes them through raw (they exist
        // for legacy reasons and should not be used frequently).
        if (path.indexOf('//') >= 0) ***REMOVED***
            throw new error_1.FirestoreError(error_1.Code.INVALID_ARGUMENT, "Invalid path (" + path + "). Paths must not contain // in them.");
        ***REMOVED***
        // We may still have an empty segment at the beginning or end if they had a
        // leading or trailing slash (which we allow).
        var segments = path.split('/').filter(function (segment) ***REMOVED*** return segment.length > 0; ***REMOVED***);
        return new ResourcePath(segments);
    ***REMOVED***;
    ResourcePath.EMPTY_PATH = new ResourcePath([]);
    return ResourcePath;
***REMOVED***(Path));
exports.ResourcePath = ResourcePath;
var identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
/** A dot-separated path for navigating sub-objects within a document. */
var FieldPath = /** @class */ (function (_super) ***REMOVED***
    __extends(FieldPath, _super);
    function FieldPath() ***REMOVED***
        return _super !== null && _super.apply(this, arguments) || this;
    ***REMOVED***
    /**
     * Returns true if the string could be used as a segment in a field path
     * without escaping.
     */
    FieldPath.isValidIdentifier = function (segment) ***REMOVED***
        return identifierRegExp.test(segment);
    ***REMOVED***;
    FieldPath.prototype.canonicalString = function () ***REMOVED***
        return this.toArray()
            .map(function (str) ***REMOVED***
            str = str.replace('\\', '\\\\').replace('`', '\\`');
            if (!FieldPath.isValidIdentifier(str)) ***REMOVED***
                str = '`' + str + '`';
            ***REMOVED***
            return str;
        ***REMOVED***)
            .join('.');
    ***REMOVED***;
    FieldPath.prototype.toString = function () ***REMOVED***
        return this.canonicalString();
    ***REMOVED***;
    /**
     * Returns true if this field references the key of a document.
     */
    FieldPath.prototype.isKeyField = function () ***REMOVED***
        return this.length === 1 && this.get(0) === exports.DOCUMENT_KEY_NAME;
    ***REMOVED***;
    /**
     * The field designating the key of a document.
     */
    FieldPath.keyField = function () ***REMOVED***
        return new FieldPath([exports.DOCUMENT_KEY_NAME]);
    ***REMOVED***;
    /**
     * Parses a field string from the given server-formatted string.
     *
     * - Splitting the empty string is not allowed (for now at least).
     * - Empty segments within the string (e.g. if there are two consecutive
     *   separators) are not allowed.
     *
     * TODO(b/37244157): we should make this more strict. Right now, it allows
     * non-identifier path components, even if they aren't escaped.
     */
    FieldPath.fromServerFormat = function (path) ***REMOVED***
        var segments = [];
        var current = '';
        var i = 0;
        var addCurrentSegment = function () ***REMOVED***
            if (current.length === 0) ***REMOVED***
                throw new error_1.FirestoreError(error_1.Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not be empty, begin " +
                    "with '.', end with '.', or contain '..'");
            ***REMOVED***
            segments.push(current);
            current = '';
        ***REMOVED***;
        var inBackticks = false;
        while (i < path.length) ***REMOVED***
            var c = path[i];
            if (c === '\\') ***REMOVED***
                if (i + 1 === path.length) ***REMOVED***
                    throw new error_1.FirestoreError(error_1.Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);
                ***REMOVED***
                var next = path[i + 1];
                if (!(next === '\\' || next === '.' || next === '`')) ***REMOVED***
                    throw new error_1.FirestoreError(error_1.Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);
                ***REMOVED***
                current += next;
                i += 2;
            ***REMOVED***
            else if (c === '`') ***REMOVED***
                inBackticks = !inBackticks;
                i++;
            ***REMOVED***
            else if (c === '.' && !inBackticks) ***REMOVED***
                addCurrentSegment();
                i++;
            ***REMOVED***
            else ***REMOVED***
                current += c;
                i++;
            ***REMOVED***
        ***REMOVED***
        addCurrentSegment();
        if (inBackticks) ***REMOVED***
            throw new error_1.FirestoreError(error_1.Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);
        ***REMOVED***
        return new FieldPath(segments);
    ***REMOVED***;
    FieldPath.EMPTY_PATH = new FieldPath([]);
    return FieldPath;
***REMOVED***(Path));
exports.FieldPath = FieldPath;

//# sourceMappingURL=path.js.map
