/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import ***REMOVED*** assert ***REMOVED*** from 'chai';
import * as sinon from 'sinon';
import ***REMOVED***
  async,
  CompleteFn,
  createSubscribe,
  ErrorFn,
  NextFn,
  Observer,
  Subscribe,
  Unsubscribe
***REMOVED*** from '../src/subscribe';

describe('createSubscribe', function() ***REMOVED***
  let spy: any;
  beforeEach(() => ***REMOVED***
    // Listen to console.error calls.
    spy = sinon.spy(console, 'error');
  ***REMOVED***);

  afterEach(() => ***REMOVED***
    spy.restore();
  ***REMOVED***);

  it('Creation', done => ***REMOVED***
    let subscribe = createSubscribe<number>(
      (observer: Observer<number, Error>) => ***REMOVED***
        observer.next(123);
      ***REMOVED***
    );

    let unsub = subscribe((value: number) => ***REMOVED***
      unsub();
      assert.equal(value, 123);
      done();
    ***REMOVED***);
  ***REMOVED***);

  it('Logging observer error to console', done => ***REMOVED***
    let uncatchableError = new Error('uncatchable');
    let subscribe = createSubscribe<number>(
      (observer: Observer<number, Error>) => ***REMOVED***
        observer.next(123);
        observer.complete();
      ***REMOVED***
    );

    subscribe(***REMOVED***
      next(value) ***REMOVED***
        assert.equal(value, 123);
        // Simulate an error is thrown in the next callback.
        // This should log to the console as an error.
        throw uncatchableError;
      ***REMOVED***,
      complete() ***REMOVED***
        // By this point, the error should have been logged.
        assert.ok(spy.calledWith(uncatchableError));
        done();
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  it('Well-defined subscription order', done => ***REMOVED***
    let subscribe = createSubscribe<number>(observer => ***REMOVED***
      observer.next(123);
      // Subscription after value emitted should NOT be received.
      subscribe(***REMOVED***
        next(value) ***REMOVED***
          assert.ok(false);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
    // Subscription before value emitted should be recieved.
    subscribe(***REMOVED***
      next(value) ***REMOVED***
        done();
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  it('Subscribing to already complete Subscribe', done => ***REMOVED***
    let seq = 0;
    let subscribe = createSubscribe<number>(observer => ***REMOVED***
      observer.next(456);
      observer.complete();
    ***REMOVED***);
    subscribe(***REMOVED***
      next(value: number) ***REMOVED***
        assert.equal(seq++, 0);
        assert.equal(value, 456);
      ***REMOVED***,
      complete() ***REMOVED***
        subscribe(***REMOVED***
          complete() ***REMOVED***
            assert.equal(seq++, 1);
            done();
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  it('Subscribing to errored Subscribe', done => ***REMOVED***
    let seq = 0;
    let subscribe = createSubscribe<number>(observer => ***REMOVED***
      observer.next(246);
      observer.error(new Error('failure'));
    ***REMOVED***);
    subscribe(***REMOVED***
      next(value: number) ***REMOVED***
        assert.equal(seq++, 0);
        assert.equal(value, 246);
      ***REMOVED***,
      error(e) ***REMOVED***
        assert.equal(seq++, 1);
        subscribe(***REMOVED***
          error(e2) ***REMOVED***
            assert.equal(seq++, 2);
            assert.equal(e.message, 'failure');
            done();
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***,
      complete() ***REMOVED***
        assert.ok(false);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  it('Delayed value', done => ***REMOVED***
    let subscribe = createSubscribe<number>(
      (observer: Observer<number, Error>) => ***REMOVED***
        setTimeout(() => observer.next(123), 10);
      ***REMOVED***
    );

    subscribe((value: number) => ***REMOVED***
      assert.equal(value, 123);
      done();
    ***REMOVED***);
  ***REMOVED***);

  it('Executor throws => Error', () => ***REMOVED***
    // It's an application error to throw an exception in the executor -
    // but since it is called asynchronously, our only option is
    // to emit that Error and terminate the Subscribe.
    let subscribe = createSubscribe<number>(
      (observer: Observer<number, Error>) => ***REMOVED***
        throw new Error('Executor throws');
      ***REMOVED***
    );
    subscribe(***REMOVED***
      error(e) ***REMOVED***
        assert.equal(e.message, 'Executor throws');
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  it('Sequence', done => ***REMOVED***
    let subscribe = makeCounter(10);

    let j = 1;
    subscribe(***REMOVED***
      next(value: number) ***REMOVED***
        assert.equal(value, j++);
      ***REMOVED***,
      complete() ***REMOVED***
        assert.equal(j, 11);
        done();
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  it('unlisten', done => ***REMOVED***
    let subscribe = makeCounter(10);

    subscribe(***REMOVED***
      complete: () => ***REMOVED***
        async(done)();
      ***REMOVED***
    ***REMOVED***);

    let j = 1;
    let unsub = subscribe(***REMOVED***
      next: (value: number) => ***REMOVED***
        assert.ok(value <= 5);
        assert.equal(value, j++);
        if (value === 5) ***REMOVED***
          unsub();
        ***REMOVED***
      ***REMOVED***,
      complete: () => ***REMOVED***
        assert.ok(false, 'Does not call completed if unsubscribed');
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  it('onNoObservers', done => ***REMOVED***
    let subscribe = makeCounter(10);

    let j = 1;
    let unsub = subscribe(***REMOVED***
      next: (value: number) => ***REMOVED***
        assert.ok(value <= 5);
        assert.equal(value, j++);
        if (value === 5) ***REMOVED***
          unsub();
          async(done)();
        ***REMOVED***
      ***REMOVED***,
      complete: () => ***REMOVED***
        assert.ok(false, 'Does not call completed if unsubscribed');
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  // TODO(koss): Add test for partial Observer (missing methods).
  it('Partial Observer', done => ***REMOVED***
    let subscribe = makeCounter(10);

    let unsub = subscribe(***REMOVED***
      complete: () => ***REMOVED***
        done();
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***);

function makeCounter(maxCount: number, ms = 10): Subscribe<number> ***REMOVED***
  let id: any;

  return createSubscribe<number>(
    (observer: Observer<number, Error>) => ***REMOVED***
      let i = 1;
      id = setInterval(() => ***REMOVED***
        observer.next(i++);
        if (i > maxCount) ***REMOVED***
          if (id) ***REMOVED***
            clearInterval(id);
            id = undefined;
          ***REMOVED***
          observer.complete();
        ***REMOVED***
      ***REMOVED***, ms);
    ***REMOVED***,
    (observer: Observer<number, Error>) => ***REMOVED***
      clearInterval(id);
      id = undefined;
    ***REMOVED***
  );
***REMOVED***
