/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
export function createSubscribe(executor, onNoObservers) ***REMOVED***
    var proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
***REMOVED***
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
var ObserverProxy = /** @class */ (function () ***REMOVED***
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    function ObserverProxy(executor, onNoObservers) ***REMOVED***
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task
            .then(function () ***REMOVED***
            executor(_this);
        ***REMOVED***)
            .catch(function (e) ***REMOVED***
            _this.error(e);
        ***REMOVED***);
    ***REMOVED***
    ObserverProxy.prototype.next = function (value) ***REMOVED***
        this.forEachObserver(function (observer) ***REMOVED***
            observer.next(value);
        ***REMOVED***);
    ***REMOVED***;
    ObserverProxy.prototype.error = function (error) ***REMOVED***
        this.forEachObserver(function (observer) ***REMOVED***
            observer.error(error);
        ***REMOVED***);
        this.close(error);
    ***REMOVED***;
    ObserverProxy.prototype.complete = function () ***REMOVED***
        this.forEachObserver(function (observer) ***REMOVED***
            observer.complete();
        ***REMOVED***);
        this.close();
    ***REMOVED***;
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber sychronously to their
     *   call to subscribe().
     */
    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) ***REMOVED***
        var _this = this;
        var observer;
        if (nextOrObserver === undefined &&
            error === undefined &&
            complete === undefined) ***REMOVED***
            throw new Error('Missing Observer.');
        ***REMOVED***
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) ***REMOVED***
            observer = nextOrObserver;
        ***REMOVED***
        else ***REMOVED***
            observer = ***REMOVED***
                next: nextOrObserver,
                error: error,
                complete: complete
            ***REMOVED***;
        ***REMOVED***
        if (observer.next === undefined) ***REMOVED***
            observer.next = noop;
        ***REMOVED***
        if (observer.error === undefined) ***REMOVED***
            observer.error = noop;
        ***REMOVED***
        if (observer.complete === undefined) ***REMOVED***
            observer.complete = noop;
        ***REMOVED***
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) ***REMOVED***
            this.task.then(function () ***REMOVED***
                try ***REMOVED***
                    if (_this.finalError) ***REMOVED***
                        observer.error(_this.finalError);
                    ***REMOVED***
                    else ***REMOVED***
                        observer.complete();
                    ***REMOVED***
                ***REMOVED***
                catch (e) ***REMOVED***
                    // nothing
                ***REMOVED***
                return;
            ***REMOVED***);
        ***REMOVED***
        this.observers.push(observer);
        return unsub;
    ***REMOVED***;
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    ObserverProxy.prototype.unsubscribeOne = function (i) ***REMOVED***
        if (this.observers === undefined || this.observers[i] === undefined) ***REMOVED***
            return;
        ***REMOVED***
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) ***REMOVED***
            this.onNoObservers(this);
        ***REMOVED***
    ***REMOVED***;
    ObserverProxy.prototype.forEachObserver = function (fn) ***REMOVED***
        if (this.finalized) ***REMOVED***
            // Already closed by previous event....just eat the additional values.
            return;
        ***REMOVED***
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (var i = 0; i < this.observers.length; i++) ***REMOVED***
            this.sendOne(i, fn);
        ***REMOVED***
    ***REMOVED***;
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    ObserverProxy.prototype.sendOne = function (i, fn) ***REMOVED***
        var _this = this;
        // Execute the callback asynchronously
        this.task.then(function () ***REMOVED***
            if (_this.observers !== undefined && _this.observers[i] !== undefined) ***REMOVED***
                try ***REMOVED***
                    fn(_this.observers[i]);
                ***REMOVED***
                catch (e) ***REMOVED***
                    // Ignore exceptions raised in Observers or missing methods of an
                    // Observer.
                    // Log error to console. b/31404806
                    if (typeof console !== 'undefined' && console.error) ***REMOVED***
                        console.error(e);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    ObserverProxy.prototype.close = function (err) ***REMOVED***
        var _this = this;
        if (this.finalized) ***REMOVED***
            return;
        ***REMOVED***
        this.finalized = true;
        if (err !== undefined) ***REMOVED***
            this.finalError = err;
        ***REMOVED***
        // Proxy is no longer needed - garbage collect references
        this.task.then(function () ***REMOVED***
            _this.observers = undefined;
            _this.onNoObservers = undefined;
        ***REMOVED***);
    ***REMOVED***;
    return ObserverProxy;
***REMOVED***());
/** Turn synchronous function into one called asynchronously. */
export function async(fn, onError) ***REMOVED***
    return function () ***REMOVED***
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            args[_i] = arguments[_i];
        ***REMOVED***
        Promise.resolve(true)
            .then(function () ***REMOVED***
            fn.apply(void 0, args);
        ***REMOVED***)
            .catch(function (error) ***REMOVED***
            if (onError) ***REMOVED***
                onError(error);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
***REMOVED***
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) ***REMOVED***
    if (typeof obj !== 'object' || obj === null) ***REMOVED***
        return false;
    ***REMOVED***
    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) ***REMOVED***
        var method = methods_1[_i];
        if (method in obj && typeof obj[method] === 'function') ***REMOVED***
            return true;
        ***REMOVED***
    ***REMOVED***
    return false;
***REMOVED***
function noop() ***REMOVED***
    // do nothing
***REMOVED***

//# sourceMappingURL=subscribe.js.map
