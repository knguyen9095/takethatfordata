"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var stringToByteArray = function (str) ***REMOVED***
    // TODO(user): Use native implementations if/when available
    var out = [], p = 0;
    for (var i = 0; i < str.length; i++) ***REMOVED***
        var c = str.charCodeAt(i);
        if (c < 128) ***REMOVED***
            out[p++] = c;
        ***REMOVED***
        else if (c < 2048) ***REMOVED***
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        ***REMOVED***
        else if ((c & 0xfc00) == 0xd800 &&
            i + 1 < str.length &&
            (str.charCodeAt(i + 1) & 0xfc00) == 0xdc00) ***REMOVED***
            // Surrogate Pair
            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        ***REMOVED***
        else ***REMOVED***
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        ***REMOVED***
    ***REMOVED***
    return out;
***REMOVED***;
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param ***REMOVED***Array<number>***REMOVED*** bytes Array of numbers representing characters.
 * @return ***REMOVED***string***REMOVED*** Stringification of the array.
 */
var byteArrayToString = function (bytes) ***REMOVED***
    // TODO(user): Use native implementations if/when available
    var out = [], pos = 0, c = 0;
    while (pos < bytes.length) ***REMOVED***
        var c1 = bytes[pos++];
        if (c1 < 128) ***REMOVED***
            out[c++] = String.fromCharCode(c1);
        ***REMOVED***
        else if (c1 > 191 && c1 < 224) ***REMOVED***
            var c2 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
        ***REMOVED***
        else if (c1 > 239 && c1 < 365) ***REMOVED***
            // Surrogate Pair
            var c2 = bytes[pos++];
            var c3 = bytes[pos++];
            var c4 = bytes[pos++];
            var u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -
                0x10000;
            out[c++] = String.fromCharCode(0xd800 + (u >> 10));
            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
        ***REMOVED***
        else ***REMOVED***
            var c2 = bytes[pos++];
            var c3 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        ***REMOVED***
    ***REMOVED***
    return out.join('');
***REMOVED***;
// Static lookup maps, lazily populated by init_()
exports.base64 = ***REMOVED***
    /**
     * Maps bytes to characters.
     * @type ***REMOVED***Object***REMOVED***
     * @private
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     * @type ***REMOVED***Object***REMOVED***
     * @private
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @type ***REMOVED***Object***REMOVED***
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @type ***REMOVED***Object***REMOVED***
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     * @type ***REMOVED***string***REMOVED***
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     * @type ***REMOVED***string***REMOVED***
     */
    get ENCODED_VALS() ***REMOVED***
        return this.ENCODED_VALS_BASE + '+/=';
    ***REMOVED***,
    /**
     * Our websafe alphabet.
     * @type ***REMOVED***string***REMOVED***
     */
    get ENCODED_VALS_WEBSAFE() ***REMOVED***
        return this.ENCODED_VALS_BASE + '-_.';
    ***REMOVED***,
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     * @type ***REMOVED***boolean***REMOVED***
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param ***REMOVED***Array<number>|Uint8Array***REMOVED*** input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param ***REMOVED***boolean=***REMOVED*** opt_webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return ***REMOVED***string***REMOVED*** The base64 encoded string.
     */
    encodeByteArray: function (input, opt_webSafe) ***REMOVED***
        if (!Array.isArray(input)) ***REMOVED***
            throw Error('encodeByteArray takes an array as a parameter');
        ***REMOVED***
        this.init_();
        var byteToCharMap = opt_webSafe
            ? this.byteToCharMapWebSafe_
            : this.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) ***REMOVED***
            var byte1 = input[i];
            var haveByte2 = i + 1 < input.length;
            var byte2 = haveByte2 ? input[i + 1] : 0;
            var haveByte3 = i + 2 < input.length;
            var byte3 = haveByte3 ? input[i + 2] : 0;
            var outByte1 = byte1 >> 2;
            var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            var outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            var outByte4 = byte3 & 0x3f;
            if (!haveByte3) ***REMOVED***
                outByte4 = 64;
                if (!haveByte2) ***REMOVED***
                    outByte3 = 64;
                ***REMOVED***
            ***REMOVED***
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        ***REMOVED***
        return output.join('');
    ***REMOVED***,
    /**
     * Base64-encode a string.
     *
     * @param ***REMOVED***string***REMOVED*** input A string to encode.
     * @param ***REMOVED***boolean=***REMOVED*** opt_webSafe If true, we should use the
     *     alternative alphabet.
     * @return ***REMOVED***string***REMOVED*** The base64 encoded string.
     */
    encodeString: function (input, opt_webSafe) ***REMOVED***
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) ***REMOVED***
            return btoa(input);
        ***REMOVED***
        return this.encodeByteArray(stringToByteArray(input), opt_webSafe);
    ***REMOVED***,
    /**
     * Base64-decode a string.
     *
     * @param ***REMOVED***string***REMOVED*** input to decode.
     * @param ***REMOVED***boolean=***REMOVED*** opt_webSafe True if we should use the
     *     alternative alphabet.
     * @return ***REMOVED***string***REMOVED*** string representing the decoded value.
     */
    decodeString: function (input, opt_webSafe) ***REMOVED***
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) ***REMOVED***
            return atob(input);
        ***REMOVED***
        return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));
    ***REMOVED***,
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param ***REMOVED***string***REMOVED*** input Input to decode.
     * @param ***REMOVED***boolean=***REMOVED*** opt_webSafe True if we should use the web-safe alphabet.
     * @return ***REMOVED***!Array<number>***REMOVED*** bytes representing the decoded value.
     */
    decodeStringToByteArray: function (input, opt_webSafe) ***REMOVED***
        this.init_();
        var charToByteMap = opt_webSafe
            ? this.charToByteMapWebSafe_
            : this.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length;) ***REMOVED***
            var byte1 = charToByteMap[input.charAt(i++)];
            var haveByte2 = i < input.length;
            var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            var haveByte3 = i < input.length;
            var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            var haveByte4 = i < input.length;
            var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) ***REMOVED***
                throw Error();
            ***REMOVED***
            var outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);
            if (byte3 != 64) ***REMOVED***
                var outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);
                output.push(outByte2);
                if (byte4 != 64) ***REMOVED***
                    var outByte3 = ((byte3 << 6) & 0xc0) | byte4;
                    output.push(outByte3);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        return output;
    ***REMOVED***,
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_: function () ***REMOVED***
        if (!this.byteToCharMap_) ***REMOVED***
            this.byteToCharMap_ = ***REMOVED******REMOVED***;
            this.charToByteMap_ = ***REMOVED******REMOVED***;
            this.byteToCharMapWebSafe_ = ***REMOVED******REMOVED***;
            this.charToByteMapWebSafe_ = ***REMOVED******REMOVED***;
            // We want quick mappings back and forth, so we precompute two maps.
            for (var i = 0; i < this.ENCODED_VALS.length; i++) ***REMOVED***
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) ***REMOVED***
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
/**
 * URL-safe base64 encoding
 * @param ***REMOVED***!string***REMOVED*** str
 * @return ***REMOVED***!string***REMOVED***
 */
exports.base64Encode = function (str) ***REMOVED***
    var utf8Bytes = stringToByteArray(str);
    return exports.base64.encodeByteArray(utf8Bytes, true);
***REMOVED***;
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param ***REMOVED***string***REMOVED*** str To be decoded
 * @return ***REMOVED***?string***REMOVED*** Decoded result, if possible
 */
exports.base64Decode = function (str) ***REMOVED***
    try ***REMOVED***
        return exports.base64.decodeString(str, true);
    ***REMOVED***
    catch (e) ***REMOVED***
        console.error('base64Decode failed: ', e);
    ***REMOVED***
    return null;
***REMOVED***;

//# sourceMappingURL=crypt.js.map
