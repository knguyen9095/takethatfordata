/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Standardized Firebase Error.
 *
 * Usage:
 *
 *   // Typescript string literals for type-safe codes
 *   type Err =
 *     'unknown' |
 *     'object-not-found'
 *     ;
 *
 *   // Closure enum for type-safe error codes
 *   // at-enum ***REMOVED***string***REMOVED***
 *   var Err = ***REMOVED***
 *     UNKNOWN: 'unknown',
 *     OBJECT_NOT_FOUND: 'object-not-found',
 *   ***REMOVED***
 *
 *   let errors: Map<Err, string> = ***REMOVED***
 *     'generic-error': "Unknown error",
 *     'file-not-found': "Could not find file: ***REMOVED***$file***REMOVED***",
 *   ***REMOVED***;
 *
 *   // Type-safe function - must pass a valid error code as param.
 *   let error = new ErrorFactory<Err>('service', 'Service', errors);
 *
 *   ...
 *   throw error.create(Err.GENERIC);
 *   ...
 *   throw error.create(Err.FILE_NOT_FOUND, ***REMOVED***'file': fileName***REMOVED***);
 *   ...
 *   // Service: Could not file file: foo.txt (service/file-not-found).
 *
 *   catch (e) ***REMOVED***
 *     assert(e.message === "Could not find file: foo.txt.");
 *     if (e.code === 'service/file-not-found') ***REMOVED***
 *       console.log("Could not read file: " + e['file']);
 *     ***REMOVED***
 *   ***REMOVED***
 */
export type ErrorList<T> = ***REMOVED*** [code: string]: string ***REMOVED***;

const ERROR_NAME = 'FirebaseError';

export interface StringLike ***REMOVED***
  toString: () => string;
***REMOVED***

let captureStackTrace: (obj: Object, fn?: Function) => void = (Error as any)
  .captureStackTrace;

// Export for faking in tests
export function patchCapture(captureFake?: any): any ***REMOVED***
  let result: any = captureStackTrace;
  captureStackTrace = captureFake;
  return result;
***REMOVED***

export interface FirebaseError ***REMOVED***
  // Unique code for error - format is service/error-code-string
  code: string;

  // Developer-friendly error message.
  message: string;

  // Always 'FirebaseError'
  name: string;

  // Where available - stack backtrace in a string
  stack: string;
***REMOVED***

export class FirebaseError implements FirebaseError ***REMOVED***
  public stack: string;
  public name: string;

  constructor(public code: string, public message: string) ***REMOVED***
    let stack: string;
    // We want the stack value, if implemented by Error
    if (captureStackTrace) ***REMOVED***
      // Patches this.stack, omitted calls above ErrorFactory#create
      captureStackTrace(this, ErrorFactory.prototype.create);
    ***REMOVED*** else ***REMOVED***
      let err = Error.apply(this, arguments);
      this.name = ERROR_NAME;
      // Make non-enumerable getter for the property.
      Object.defineProperty(this, 'stack', ***REMOVED***
        get: function() ***REMOVED***
          return err.stack;
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

// Back-door inheritance
FirebaseError.prototype = Object.create(Error.prototype) as FirebaseError;
FirebaseError.prototype.constructor = FirebaseError;
(FirebaseError.prototype as any).name = ERROR_NAME;

export class ErrorFactory<T extends string> ***REMOVED***
  // Matches ***REMOVED***$name***REMOVED***, by default.
  public pattern = /\***REMOVED***\$([^***REMOVED***]+)***REMOVED***/g;

  constructor(
    private service: string,
    private serviceName: string,
    private errors: ErrorList<T>
  ) ***REMOVED***
    // empty
  ***REMOVED***

  create(code: T, data?: ***REMOVED*** [prop: string]: StringLike ***REMOVED***): FirebaseError ***REMOVED***
    if (data === undefined) ***REMOVED***
      data = ***REMOVED******REMOVED***;
    ***REMOVED***

    let template = this.errors[code as string];

    let fullCode = this.service + '/' + code;
    let message: string;

    if (template === undefined) ***REMOVED***
      message = 'Error';
    ***REMOVED*** else ***REMOVED***
      message = template.replace(this.pattern, (match, key) => ***REMOVED***
        let value = data![key];
        return value !== undefined ? value.toString() : '<' + key + '?>';
      ***REMOVED***);
    ***REMOVED***

    // Service: Error message (service/code).
    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';
    let err = new FirebaseError(fullCode, message);

    // Populate the Error object with message parts for programmatic
    // accesses (e.g., e.file).
    for (let prop in data) ***REMOVED***
      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') ***REMOVED***
        continue;
      ***REMOVED***
      (err as any)[prop] = data[prop];
    ***REMOVED***

    return err;
  ***REMOVED***
***REMOVED***
