/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
export type NextFn<T> = (value: T) => void;
export type ErrorFn = (error: Error) => void;
export type CompleteFn = () => void;

export interface Observer<V, E> ***REMOVED***
  // Called once for each value in a stream of values.
  next(value: V | null): any;

  // A stream terminates by a single call to EITHER error() or complete().
  error(error: E): any;

  // No events will be sent to next() once complete() is called.
  complete(): any;
***REMOVED***

// Allow for any of the Observer methods to be undefined.
export interface PartialObserver<T> ***REMOVED***
  next?: NextFn<T>;
  error?: ErrorFn;
  complete?: CompleteFn;
***REMOVED***

// TODO: Support also Unsubscribe.unsubscribe?
export type Unsubscribe = () => void;

/**
 * The Subscribe interface has two forms - passing the inline function
 * callbacks, or a object interface with callback properties.
 */
export interface Subscribe<T> ***REMOVED***
  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
  (observer: PartialObserver<T>): Unsubscribe;
***REMOVED***

export interface Observable<T> ***REMOVED***
  // Subscribe method
  subscribe: Subscribe<T>;
***REMOVED***

export type Executor<T> = (observer: Observer<T, Error>) => void;

/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
export function createSubscribe<T>(
  executor: Executor<T>,
  onNoObservers?: Executor<T>
): Subscribe<T> ***REMOVED***
  let proxy = new ObserverProxy<T>(executor, onNoObservers);
  return proxy.subscribe.bind(proxy);
***REMOVED***

/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
class ObserverProxy<T> implements Observer<T, Error> ***REMOVED***
  private observers: Array<Observer<T, Error>> | undefined = [];
  private unsubscribes: Unsubscribe[] = [];
  private onNoObservers: Executor<T> | undefined;
  private observerCount = 0;
  // Micro-task scheduling by calling task.then().
  private task = Promise.resolve();
  private finalized = false;
  private finalError: Error;

  /**
   * @param executor Function which can make calls to a single Observer
   *     as a proxy.
   * @param onNoObservers Callback when count of Observers goes to zero.
   */
  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) ***REMOVED***
    this.onNoObservers = onNoObservers;
    // Call the executor asynchronously so subscribers that are called
    // synchronously after the creation of the subscribe function
    // can still receive the very first value generated in the executor.
    this.task
      .then(() => ***REMOVED***
        executor(this);
      ***REMOVED***)
      .catch(e => ***REMOVED***
        this.error(e);
      ***REMOVED***);
  ***REMOVED***

  next(value: T) ***REMOVED***
    this.forEachObserver((observer: Observer<T, Error>) => ***REMOVED***
      observer.next(value);
    ***REMOVED***);
  ***REMOVED***

  error(error: Error) ***REMOVED***
    this.forEachObserver((observer: Observer<T, Error>) => ***REMOVED***
      observer.error(error);
    ***REMOVED***);
    this.close(error);
  ***REMOVED***

  complete() ***REMOVED***
    this.forEachObserver((observer: Observer<T, Error>) => ***REMOVED***
      observer.complete();
    ***REMOVED***);
    this.close();
  ***REMOVED***

  /**
   * Subscribe function that can be used to add an Observer to the fan-out list.
   *
   * - We require that no event is sent to a subscriber sychronously to their
   *   call to subscribe().
   */
  subscribe(
    nextOrObserver: PartialObserver<T> | Function,
    error?: ErrorFn,
    complete?: CompleteFn
  ): Unsubscribe ***REMOVED***
    let observer: Observer<T, Error>;

    if (
      nextOrObserver === undefined &&
      error === undefined &&
      complete === undefined
    ) ***REMOVED***
      throw new Error('Missing Observer.');
    ***REMOVED***

    // Assemble an Observer object when passed as callback functions.
    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) ***REMOVED***
      observer = nextOrObserver as Observer<T, Error>;
    ***REMOVED*** else ***REMOVED***
      observer = ***REMOVED***
        next: (nextOrObserver as any) as NextFn<T>,
        error: error,
        complete: complete
      ***REMOVED*** as Observer<T, Error>;
    ***REMOVED***

    if (observer.next === undefined) ***REMOVED***
      observer.next = noop as NextFn<T>;
    ***REMOVED***
    if (observer.error === undefined) ***REMOVED***
      observer.error = noop as ErrorFn;
    ***REMOVED***
    if (observer.complete === undefined) ***REMOVED***
      observer.complete = noop as CompleteFn;
    ***REMOVED***

    let unsub = this.unsubscribeOne.bind(this, this.observers!.length);

    // Attempt to subscribe to a terminated Observable - we
    // just respond to the Observer with the final error or complete
    // event.
    if (this.finalized) ***REMOVED***
      this.task.then(() => ***REMOVED***
        try ***REMOVED***
          if (this.finalError) ***REMOVED***
            observer.error(this.finalError);
          ***REMOVED*** else ***REMOVED***
            observer.complete();
          ***REMOVED***
        ***REMOVED*** catch (e) ***REMOVED***
          // nothing
        ***REMOVED***
        return;
      ***REMOVED***);
    ***REMOVED***

    this.observers!.push(observer as Observer<T, Error>);

    return unsub;
  ***REMOVED***

  // Unsubscribe is synchronous - we guarantee that no events are sent to
  // any unsubscribed Observer.
  private unsubscribeOne(i: number) ***REMOVED***
    if (this.observers === undefined || this.observers[i] === undefined) ***REMOVED***
      return;
    ***REMOVED***

    delete this.observers[i];

    this.observerCount -= 1;
    if (this.observerCount === 0 && this.onNoObservers !== undefined) ***REMOVED***
      this.onNoObservers(this);
    ***REMOVED***
  ***REMOVED***

  private forEachObserver(fn: (observer: Observer<T, Error>) => void): void ***REMOVED***
    if (this.finalized) ***REMOVED***
      // Already closed by previous event....just eat the additional values.
      return;
    ***REMOVED***

    // Since sendOne calls asynchronously - there is no chance that
    // this.observers will become undefined.
    for (let i = 0; i < this.observers!.length; i++) ***REMOVED***
      this.sendOne(i, fn);
    ***REMOVED***
  ***REMOVED***

  // Call the Observer via one of it's callback function. We are careful to
  // confirm that the observe has not been unsubscribed since this asynchronous
  // function had been queued.
  private sendOne(i: number, fn: (observer: Observer<T, Error>) => void): void ***REMOVED***
    // Execute the callback asynchronously
    this.task.then(() => ***REMOVED***
      if (this.observers !== undefined && this.observers[i] !== undefined) ***REMOVED***
        try ***REMOVED***
          fn(this.observers[i]);
        ***REMOVED*** catch (e) ***REMOVED***
          // Ignore exceptions raised in Observers or missing methods of an
          // Observer.
          // Log error to console. b/31404806
          if (typeof console !== 'undefined' && console.error) ***REMOVED***
            console.error(e);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  private close(err?: Error): void ***REMOVED***
    if (this.finalized) ***REMOVED***
      return;
    ***REMOVED***
    this.finalized = true;
    if (err !== undefined) ***REMOVED***
      this.finalError = err;
    ***REMOVED***
    // Proxy is no longer needed - garbage collect references
    this.task.then(() => ***REMOVED***
      this.observers = undefined;
      this.onNoObservers = undefined;
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/** Turn synchronous function into one called asynchronously. */
export function async(fn: Function, onError?: ErrorFn): Function ***REMOVED***
  return (...args: any[]) => ***REMOVED***
    Promise.resolve(true)
      .then(() => ***REMOVED***
        fn(...args);
      ***REMOVED***)
      .catch((error: Error) => ***REMOVED***
        if (onError) ***REMOVED***
          onError(error);
        ***REMOVED***
      ***REMOVED***);
  ***REMOVED***;
***REMOVED***

/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj: any, methods: string[]): boolean ***REMOVED***
  if (typeof obj !== 'object' || obj === null) ***REMOVED***
    return false;
  ***REMOVED***

  for (let method of methods) ***REMOVED***
    if (method in obj && typeof obj[method] === 'function') ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***

function noop(): void ***REMOVED***
  // do nothing
***REMOVED***
