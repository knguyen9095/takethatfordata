(function (global, factory) ***REMOVED***
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.acorn = global.acorn || ***REMOVED******REMOVED***, global.acorn.walk = ***REMOVED******REMOVED***)));
***REMOVED***(this, (function (exports) ***REMOVED*** 'use strict';

// AST walker module for Mozilla Parser API compatible trees

// A simple walk is one where you simply specify callbacks to be
// called on specific nodes. The last two arguments are optional. A
// simple use would be
//
//     walk.simple(myTree, ***REMOVED***
//         Expression: function(node) ***REMOVED*** ... ***REMOVED***
//     ***REMOVED***);
//
// to do something with all expressions. All Parser API node types
// can be used to identify node types, as well as Expression,
// Statement, and ScopeBody, which denote categories of nodes.
//
// The base argument can be used to pass a custom (recursive)
// walker, and state can be used to give this walked an initial
// state.

function simple(node, visitors, base, state, override) ***REMOVED***
  if (!base) ***REMOVED*** base = exports.base
  ; ***REMOVED***(function c(node, st, override) ***REMOVED***
    var type = override || node.type, found = visitors[type];
    base[type](node, st, c);
    if (found) ***REMOVED*** found(node, st); ***REMOVED***
  ***REMOVED***)(node, state, override);
***REMOVED***

// An ancestor walk keeps an array of ancestor nodes (including the
// current node) and passes them to the callback as third parameter
// (and also as state parameter when no other state is present).
function ancestor(node, visitors, base, state) ***REMOVED***
  if (!base) ***REMOVED*** base = exports.base; ***REMOVED***
  var ancestors = [];(function c(node, st, override) ***REMOVED***
    var type = override || node.type, found = visitors[type];
    var isNew = node != ancestors[ancestors.length - 1];
    if (isNew) ***REMOVED*** ancestors.push(node); ***REMOVED***
    base[type](node, st, c);
    if (found) ***REMOVED*** found(node, st || ancestors, ancestors); ***REMOVED***
    if (isNew) ***REMOVED*** ancestors.pop(); ***REMOVED***
  ***REMOVED***)(node, state);
***REMOVED***

// A recursive walk is one where your functions override the default
// walkers. They can modify and replace the state parameter that's
// threaded through the walk, and can opt how and whether to walk
// their child nodes (by calling their third argument on these
// nodes).
function recursive(node, state, funcs, base, override) ***REMOVED***
  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) ***REMOVED***
    visitor[override || node.type](node, st, c);
  ***REMOVED***)(node, state, override);
***REMOVED***

function makeTest(test) ***REMOVED***
  if (typeof test == "string")
    ***REMOVED*** return function (type) ***REMOVED*** return type == test; ***REMOVED*** ***REMOVED***
  else if (!test)
    ***REMOVED*** return function () ***REMOVED*** return true; ***REMOVED*** ***REMOVED***
  else
    ***REMOVED*** return test ***REMOVED***
***REMOVED***

var Found = function Found(node, state) ***REMOVED*** this.node = node; this.state = state; ***REMOVED***;

// A full walk triggers the callback on each node
function full(node, callback, base, state, override) ***REMOVED***
  if (!base) ***REMOVED*** base = exports.base
  ; ***REMOVED***(function c(node, st, override) ***REMOVED***
    var type = override || node.type;
    base[type](node, st, c);
    if (!override) ***REMOVED*** callback(node, st, type); ***REMOVED***
  ***REMOVED***)(node, state, override);
***REMOVED***

// An fullAncestor walk is like an ancestor walk, but triggers
// the callback on each node
function fullAncestor(node, callback, base, state) ***REMOVED***
  if (!base) ***REMOVED*** base = exports.base; ***REMOVED***
  var ancestors = [];(function c(node, st, override) ***REMOVED***
    var type = override || node.type;
    var isNew = node != ancestors[ancestors.length - 1];
    if (isNew) ***REMOVED*** ancestors.push(node); ***REMOVED***
    base[type](node, st, c);
    if (!override) ***REMOVED*** callback(node, st || ancestors, ancestors, type); ***REMOVED***
    if (isNew) ***REMOVED*** ancestors.pop(); ***REMOVED***
  ***REMOVED***)(node, state);
***REMOVED***

// Find a node with a given start, end, and type (all are optional,
// null can be used as wildcard). Returns a ***REMOVED***node, state***REMOVED*** object, or
// undefined when it doesn't find a matching node.
function findNodeAt(node, start, end, test, base, state) ***REMOVED***
  test = makeTest(test);
  if (!base) ***REMOVED*** base = exports.base; ***REMOVED***
  try ***REMOVED***
    (function c(node, st, override) ***REMOVED***
      var type = override || node.type;
      if ((start == null || node.start <= start) &&
          (end == null || node.end >= end))
        ***REMOVED*** base[type](node, st, c); ***REMOVED***
      if ((start == null || node.start == start) &&
          (end == null || node.end == end) &&
          test(type, node))
        ***REMOVED*** throw new Found(node, st) ***REMOVED***
    ***REMOVED***)(node, state);
  ***REMOVED*** catch (e) ***REMOVED***
    if (e instanceof Found) ***REMOVED*** return e ***REMOVED***
    throw e
  ***REMOVED***
***REMOVED***

// Find the innermost node of a given type that contains the given
// position. Interface similar to findNodeAt.
function findNodeAround(node, pos, test, base, state) ***REMOVED***
  test = makeTest(test);
  if (!base) ***REMOVED*** base = exports.base; ***REMOVED***
  try ***REMOVED***
    (function c(node, st, override) ***REMOVED***
      var type = override || node.type;
      if (node.start > pos || node.end < pos) ***REMOVED*** return ***REMOVED***
      base[type](node, st, c);
      if (test(type, node)) ***REMOVED*** throw new Found(node, st) ***REMOVED***
    ***REMOVED***)(node, state);
  ***REMOVED*** catch (e) ***REMOVED***
    if (e instanceof Found) ***REMOVED*** return e ***REMOVED***
    throw e
  ***REMOVED***
***REMOVED***

// Find the outermost matching node after a given position.
function findNodeAfter(node, pos, test, base, state) ***REMOVED***
  test = makeTest(test);
  if (!base) ***REMOVED*** base = exports.base; ***REMOVED***
  try ***REMOVED***
    (function c(node, st, override) ***REMOVED***
      if (node.end < pos) ***REMOVED*** return ***REMOVED***
      var type = override || node.type;
      if (node.start >= pos && test(type, node)) ***REMOVED*** throw new Found(node, st) ***REMOVED***
      base[type](node, st, c);
    ***REMOVED***)(node, state);
  ***REMOVED*** catch (e) ***REMOVED***
    if (e instanceof Found) ***REMOVED*** return e ***REMOVED***
    throw e
  ***REMOVED***
***REMOVED***

// Find the outermost matching node before a given position.
function findNodeBefore(node, pos, test, base, state) ***REMOVED***
  test = makeTest(test);
  if (!base) ***REMOVED*** base = exports.base; ***REMOVED***
  var max;(function c(node, st, override) ***REMOVED***
    if (node.start > pos) ***REMOVED*** return ***REMOVED***
    var type = override || node.type;
    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))
      ***REMOVED*** max = new Found(node, st); ***REMOVED***
    base[type](node, st, c);
  ***REMOVED***)(node, state);
  return max
***REMOVED***

// Fallback to an Object.create polyfill for older environments.
var create = Object.create || function(proto) ***REMOVED***
  function Ctor() ***REMOVED******REMOVED***
  Ctor.prototype = proto;
  return new Ctor
***REMOVED***;

// Used to create a custom walker. Will fill in all missing node
// type properties with the defaults.
function make(funcs, base) ***REMOVED***
  if (!base) ***REMOVED*** base = exports.base; ***REMOVED***
  var visitor = create(base);
  for (var type in funcs) ***REMOVED*** visitor[type] = funcs[type]; ***REMOVED***
  return visitor
***REMOVED***

function skipThrough(node, st, c) ***REMOVED*** c(node, st); ***REMOVED***
function ignore(_node, _st, _c) ***REMOVED******REMOVED***

// Node walkers.

var base = ***REMOVED******REMOVED***;

base.Program = base.BlockStatement = function (node, st, c) ***REMOVED***
  for (var i = 0, list = node.body; i < list.length; i += 1)
    ***REMOVED***
    var stmt = list[i];

    c(stmt, st, "Statement");
  ***REMOVED***
***REMOVED***;
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression =
  function (node, st, c) ***REMOVED*** return c(node.expression, st, "Expression"); ***REMOVED***;
base.IfStatement = function (node, st, c) ***REMOVED***
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) ***REMOVED*** c(node.alternate, st, "Statement"); ***REMOVED***
***REMOVED***;
base.LabeledStatement = function (node, st, c) ***REMOVED*** return c(node.body, st, "Statement"); ***REMOVED***;
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function (node, st, c) ***REMOVED***
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
***REMOVED***;
base.SwitchStatement = function (node, st, c) ***REMOVED***
  c(node.discriminant, st, "Expression");
  for (var i = 0, list = node.cases; i < list.length; i += 1) ***REMOVED***
    var cs = list[i];

    if (cs.test) ***REMOVED*** c(cs.test, st, "Expression"); ***REMOVED***
    for (var i$1 = 0, list$1 = cs.consequent; i$1 < list$1.length; i$1 += 1)
      ***REMOVED***
      var cons = list$1[i$1];

      c(cons, st, "Statement");
    ***REMOVED***
  ***REMOVED***
***REMOVED***;
base.SwitchCase = function (node, st, c) ***REMOVED***
  if (node.test) ***REMOVED*** c(node.test, st, "Expression"); ***REMOVED***
  for (var i = 0, list = node.consequent; i < list.length; i += 1)
    ***REMOVED***
    var cons = list[i];

    c(cons, st, "Statement");
  ***REMOVED***
***REMOVED***;
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) ***REMOVED***
  if (node.argument) ***REMOVED*** c(node.argument, st, "Expression"); ***REMOVED***
***REMOVED***;
base.ThrowStatement = base.SpreadElement =
  function (node, st, c) ***REMOVED*** return c(node.argument, st, "Expression"); ***REMOVED***;
base.TryStatement = function (node, st, c) ***REMOVED***
  c(node.block, st, "Statement");
  if (node.handler) ***REMOVED*** c(node.handler, st); ***REMOVED***
  if (node.finalizer) ***REMOVED*** c(node.finalizer, st, "Statement"); ***REMOVED***
***REMOVED***;
base.CatchClause = function (node, st, c) ***REMOVED***
  c(node.param, st, "Pattern");
  c(node.body, st, "ScopeBody");
***REMOVED***;
base.WhileStatement = base.DoWhileStatement = function (node, st, c) ***REMOVED***
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
***REMOVED***;
base.ForStatement = function (node, st, c) ***REMOVED***
  if (node.init) ***REMOVED*** c(node.init, st, "ForInit"); ***REMOVED***
  if (node.test) ***REMOVED*** c(node.test, st, "Expression"); ***REMOVED***
  if (node.update) ***REMOVED*** c(node.update, st, "Expression"); ***REMOVED***
  c(node.body, st, "Statement");
***REMOVED***;
base.ForInStatement = base.ForOfStatement = function (node, st, c) ***REMOVED***
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
***REMOVED***;
base.ForInit = function (node, st, c) ***REMOVED***
  if (node.type == "VariableDeclaration") ***REMOVED*** c(node, st); ***REMOVED***
  else ***REMOVED*** c(node, st, "Expression"); ***REMOVED***
***REMOVED***;
base.DebuggerStatement = ignore;

base.FunctionDeclaration = function (node, st, c) ***REMOVED*** return c(node, st, "Function"); ***REMOVED***;
base.VariableDeclaration = function (node, st, c) ***REMOVED***
  for (var i = 0, list = node.declarations; i < list.length; i += 1)
    ***REMOVED***
    var decl = list[i];

    c(decl, st);
  ***REMOVED***
***REMOVED***;
base.VariableDeclarator = function (node, st, c) ***REMOVED***
  c(node.id, st, "Pattern");
  if (node.init) ***REMOVED*** c(node.init, st, "Expression"); ***REMOVED***
***REMOVED***;

base.Function = function (node, st, c) ***REMOVED***
  if (node.id) ***REMOVED*** c(node.id, st, "Pattern"); ***REMOVED***
  for (var i = 0, list = node.params; i < list.length; i += 1)
    ***REMOVED***
    var param = list[i];

    c(param, st, "Pattern");
  ***REMOVED***
  c(node.body, st, node.expression ? "ScopeExpression" : "ScopeBody");
***REMOVED***;
// FIXME drop these node types in next major version
// (They are awkward, and in ES6 every block can be a scope.)
base.ScopeBody = function (node, st, c) ***REMOVED*** return c(node, st, "Statement"); ***REMOVED***;
base.ScopeExpression = function (node, st, c) ***REMOVED*** return c(node, st, "Expression"); ***REMOVED***;

base.Pattern = function (node, st, c) ***REMOVED***
  if (node.type == "Identifier")
    ***REMOVED*** c(node, st, "VariablePattern"); ***REMOVED***
  else if (node.type == "MemberExpression")
    ***REMOVED*** c(node, st, "MemberPattern"); ***REMOVED***
  else
    ***REMOVED*** c(node, st); ***REMOVED***
***REMOVED***;
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function (node, st, c) ***REMOVED*** return c(node.argument, st, "Pattern"); ***REMOVED***;
base.ArrayPattern = function (node, st, c) ***REMOVED***
  for (var i = 0, list = node.elements; i < list.length; i += 1) ***REMOVED***
    var elt = list[i];

    if (elt) ***REMOVED*** c(elt, st, "Pattern"); ***REMOVED***
  ***REMOVED***
***REMOVED***;
base.ObjectPattern = function (node, st, c) ***REMOVED***
  for (var i = 0, list = node.properties; i < list.length; i += 1)
    ***REMOVED***
    var prop = list[i];

    c(prop.value, st, "Pattern");
  ***REMOVED***
***REMOVED***;

base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function (node, st, c) ***REMOVED***
  for (var i = 0, list = node.elements; i < list.length; i += 1) ***REMOVED***
    var elt = list[i];

    if (elt) ***REMOVED*** c(elt, st, "Expression"); ***REMOVED***
  ***REMOVED***
***REMOVED***;
base.ObjectExpression = function (node, st, c) ***REMOVED***
  for (var i = 0, list = node.properties; i < list.length; i += 1)
    ***REMOVED***
    var prop = list[i];

    c(prop, st);
  ***REMOVED***
***REMOVED***;
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = base.TemplateLiteral = function (node, st, c) ***REMOVED***
  for (var i = 0, list = node.expressions; i < list.length; i += 1)
    ***REMOVED***
    var expr = list[i];

    c(expr, st, "Expression");
  ***REMOVED***
***REMOVED***;
base.UnaryExpression = base.UpdateExpression = function (node, st, c) ***REMOVED***
  c(node.argument, st, "Expression");
***REMOVED***;
base.BinaryExpression = base.LogicalExpression = function (node, st, c) ***REMOVED***
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
***REMOVED***;
base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) ***REMOVED***
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
***REMOVED***;
base.ConditionalExpression = function (node, st, c) ***REMOVED***
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
***REMOVED***;
base.NewExpression = base.CallExpression = function (node, st, c) ***REMOVED***
  c(node.callee, st, "Expression");
  if (node.arguments)
    ***REMOVED*** for (var i = 0, list = node.arguments; i < list.length; i += 1)
      ***REMOVED***
        var arg = list[i];

        c(arg, st, "Expression");
      ***REMOVED*** ***REMOVED***
***REMOVED***;
base.MemberExpression = function (node, st, c) ***REMOVED***
  c(node.object, st, "Expression");
  if (node.computed) ***REMOVED*** c(node.property, st, "Expression"); ***REMOVED***
***REMOVED***;
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) ***REMOVED***
  if (node.declaration)
    ***REMOVED*** c(node.declaration, st, node.type == "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); ***REMOVED***
  if (node.source) ***REMOVED*** c(node.source, st, "Expression"); ***REMOVED***
***REMOVED***;
base.ExportAllDeclaration = function (node, st, c) ***REMOVED***
  c(node.source, st, "Expression");
***REMOVED***;
base.ImportDeclaration = function (node, st, c) ***REMOVED***
  for (var i = 0, list = node.specifiers; i < list.length; i += 1)
    ***REMOVED***
    var spec = list[i];

    c(spec, st);
  ***REMOVED***
  c(node.source, st, "Expression");
***REMOVED***;
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

base.TaggedTemplateExpression = function (node, st, c) ***REMOVED***
  c(node.tag, st, "Expression");
  c(node.quasi, st, "Expression");
***REMOVED***;
base.ClassDeclaration = base.ClassExpression = function (node, st, c) ***REMOVED*** return c(node, st, "Class"); ***REMOVED***;
base.Class = function (node, st, c) ***REMOVED***
  if (node.id) ***REMOVED*** c(node.id, st, "Pattern"); ***REMOVED***
  if (node.superClass) ***REMOVED*** c(node.superClass, st, "Expression"); ***REMOVED***
  for (var i = 0, list = node.body.body; i < list.length; i += 1)
    ***REMOVED***
    var item = list[i];

    c(item, st);
  ***REMOVED***
***REMOVED***;
base.MethodDefinition = base.Property = function (node, st, c) ***REMOVED***
  if (node.computed) ***REMOVED*** c(node.key, st, "Expression"); ***REMOVED***
  c(node.value, st, "Expression");
***REMOVED***;

exports.simple = simple;
exports.ancestor = ancestor;
exports.recursive = recursive;
exports.full = full;
exports.fullAncestor = fullAncestor;
exports.findNodeAt = findNodeAt;
exports.findNodeAround = findNodeAround;
exports.findNodeAfter = findNodeAfter;
exports.findNodeBefore = findNodeBefore;
exports.make = make;
exports.base = base;

Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true ***REMOVED***);

***REMOVED***)));
