// this file handles outputting usage instructions,
// failures, etc. keeps logging in one place.
const stringWidth = require('string-width')
const objFilter = require('./obj-filter')
const setBlocking = require('set-blocking')
const YError = require('./yerror')

module.exports = function (yargs, y18n) ***REMOVED***
  const __ = y18n.__
  const self = ***REMOVED******REMOVED***

  // methods for ouputting/building failure message.
  var fails = []
  self.failFn = function (f) ***REMOVED***
    fails.push(f)
  ***REMOVED***

  var failMessage = null
  var showHelpOnFail = true
  self.showHelpOnFail = function (enabled, message) ***REMOVED***
    if (typeof enabled === 'string') ***REMOVED***
      message = enabled
      enabled = true
    ***REMOVED*** else if (typeof enabled === 'undefined') ***REMOVED***
      enabled = true
    ***REMOVED***
    failMessage = message
    showHelpOnFail = enabled
    return self
  ***REMOVED***

  var failureOutput = false
  self.fail = function (msg, err) ***REMOVED***
    const logger = yargs._getLoggerInstance()

    if (fails.length) ***REMOVED***
      for (var i = fails.length - 1; i >= 0; --i) ***REMOVED***
        fails[i](msg, err, self)
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (yargs.getExitProcess()) setBlocking(true)

      // don't output failure message more than once
      if (!failureOutput) ***REMOVED***
        failureOutput = true
        if (showHelpOnFail) yargs.showHelp('error')
        if (msg) logger.error(msg)
        if (failMessage) ***REMOVED***
          if (msg) logger.error('')
          logger.error(failMessage)
        ***REMOVED***
      ***REMOVED***

      err = err || new YError(msg)
      if (yargs.getExitProcess()) ***REMOVED***
        return yargs.exit(1)
      ***REMOVED*** else if (yargs._hasParseCallback()) ***REMOVED***
        return yargs.exit(1, err)
      ***REMOVED*** else ***REMOVED***
        throw err
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // methods for ouputting/building help (usage) message.
  var usage
  self.usage = function (msg) ***REMOVED***
    usage = msg
  ***REMOVED***
  self.getUsage = function () ***REMOVED***
    return usage
  ***REMOVED***

  var examples = []
  self.example = function (cmd, description) ***REMOVED***
    examples.push([cmd, description || ''])
  ***REMOVED***

  var commands = []
  self.command = function (cmd, description, isDefault, aliases) ***REMOVED***
    // the last default wins, so cancel out any previously set default
    if (isDefault) ***REMOVED***
      commands = commands.map(function (cmdArray) ***REMOVED***
        cmdArray[2] = false
        return cmdArray
      ***REMOVED***)
    ***REMOVED***
    commands.push([cmd, description || '', isDefault, aliases])
  ***REMOVED***
  self.getCommands = function () ***REMOVED***
    return commands
  ***REMOVED***

  var descriptions = ***REMOVED******REMOVED***
  self.describe = function (key, desc) ***REMOVED***
    if (typeof key === 'object') ***REMOVED***
      Object.keys(key).forEach(function (k) ***REMOVED***
        self.describe(k, key[k])
      ***REMOVED***)
    ***REMOVED*** else ***REMOVED***
      descriptions[key] = desc
    ***REMOVED***
  ***REMOVED***
  self.getDescriptions = function () ***REMOVED***
    return descriptions
  ***REMOVED***

  var epilog
  self.epilog = function (msg) ***REMOVED***
    epilog = msg
  ***REMOVED***

  var wrapSet = false
  var wrap
  self.wrap = function (cols) ***REMOVED***
    wrapSet = true
    wrap = cols
  ***REMOVED***

  function getWrap () ***REMOVED***
    if (!wrapSet) ***REMOVED***
      wrap = windowWidth()
      wrapSet = true
    ***REMOVED***

    return wrap
  ***REMOVED***

  var deferY18nLookupPrefix = '__yargsString__:'
  self.deferY18nLookup = function (str) ***REMOVED***
    return deferY18nLookupPrefix + str
  ***REMOVED***

  var defaultGroup = 'Options:'
  self.help = function () ***REMOVED***
    normalizeAliases()

    // handle old demanded API
    var demandedOptions = yargs.getDemandedOptions()
    var demandedCommands = yargs.getDemandedCommands()
    var groups = yargs.getGroups()
    var options = yargs.getOptions()
    var keys = Object.keys(
      Object.keys(descriptions)
      .concat(Object.keys(demandedOptions))
      .concat(Object.keys(demandedCommands))
      .concat(Object.keys(options.default))
      .reduce(function (acc, key) ***REMOVED***
        if (key !== '_') acc[key] = true
        return acc
      ***REMOVED***, ***REMOVED******REMOVED***)
    )

    var theWrap = getWrap()
    var ui = require('cliui')(***REMOVED***
      width: theWrap,
      wrap: !!theWrap
    ***REMOVED***)

    // the usage string.
    if (usage) ***REMOVED***
      var u = usage.replace(/\$0/g, yargs.$0)
      ui.div(u + '\n')
    ***REMOVED***

    // your application's commands, i.e., non-option
    // arguments populated in '_'.
    if (commands.length) ***REMOVED***
      ui.div(__('Commands:'))

      commands.forEach(function (command) ***REMOVED***
        ui.span(
          ***REMOVED***text: command[0], padding: [0, 2, 0, 2], width: maxWidth(commands, theWrap) + 4***REMOVED***,
          ***REMOVED***text: command[1]***REMOVED***
        )
        var hints = []
        if (command[2]) hints.push('[' + __('default:').slice(0, -1) + ']') // TODO hacking around i18n here
        if (command[3] && command[3].length) ***REMOVED***
          hints.push('[' + __('aliases:') + ' ' + command[3].join(', ') + ']')
        ***REMOVED***
        if (hints.length) ***REMOVED***
          ui.div(***REMOVED***text: hints.join(' '), padding: [0, 0, 0, 2], align: 'right'***REMOVED***)
        ***REMOVED*** else ***REMOVED***
          ui.div()
        ***REMOVED***
      ***REMOVED***)

      ui.div()
    ***REMOVED***

    // perform some cleanup on the keys array, making it
    // only include top-level keys not their aliases.
    var aliasKeys = (Object.keys(options.alias) || [])
      .concat(Object.keys(yargs.parsed.newAliases) || [])

    keys = keys.filter(function (key) ***REMOVED***
      return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) ***REMOVED***
        return (options.alias[alias] || []).indexOf(key) === -1
      ***REMOVED***)
    ***REMOVED***)

    // populate 'Options:' group with any keys that have not
    // explicitly had a group set.
    if (!groups[defaultGroup]) groups[defaultGroup] = []
    addUngroupedKeys(keys, options.alias, groups)

    // display 'Options:' table along with any custom tables:
    Object.keys(groups).forEach(function (groupName) ***REMOVED***
      if (!groups[groupName].length) return

      ui.div(__(groupName))

      // if we've grouped the key 'f', but 'f' aliases 'foobar',
      // normalizedKeys should contain only 'foobar'.
      var normalizedKeys = groups[groupName].map(function (key) ***REMOVED***
        if (~aliasKeys.indexOf(key)) return key
        for (var i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) ***REMOVED***
          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey
        ***REMOVED***
        return key
      ***REMOVED***)

      // actually generate the switches string --foo, -f, --bar.
      var switches = normalizedKeys.reduce(function (acc, key) ***REMOVED***
        acc[key] = [ key ].concat(options.alias[key] || [])
          .map(function (sw) ***REMOVED***
            return (sw.length > 1 ? '--' : '-') + sw
          ***REMOVED***)
          .join(', ')

        return acc
      ***REMOVED***, ***REMOVED******REMOVED***)

      normalizedKeys.forEach(function (key) ***REMOVED***
        var kswitch = switches[key]
        var desc = descriptions[key] || ''
        var type = null

        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length))

        if (~options.boolean.indexOf(key)) type = '[' + __('boolean') + ']'
        if (~options.count.indexOf(key)) type = '[' + __('count') + ']'
        if (~options.string.indexOf(key)) type = '[' + __('string') + ']'
        if (~options.normalize.indexOf(key)) type = '[' + __('string') + ']'
        if (~options.array.indexOf(key)) type = '[' + __('array') + ']'
        if (~options.number.indexOf(key)) type = '[' + __('number') + ']'

        var extra = [
          type,
          (key in demandedOptions) ? '[' + __('required') + ']' : null,
          options.choices && options.choices[key] ? '[' + __('choices:') + ' ' +
            self.stringifiedValues(options.choices[key]) + ']' : null,
          defaultString(options.default[key], options.defaultDescription[key])
        ].filter(Boolean).join(' ')

        ui.span(
          ***REMOVED***text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4***REMOVED***,
          desc
        )

        if (extra) ui.div(***REMOVED***text: extra, padding: [0, 0, 0, 2], align: 'right'***REMOVED***)
        else ui.div()
      ***REMOVED***)

      ui.div()
    ***REMOVED***)

    // describe some common use-cases for your application.
    if (examples.length) ***REMOVED***
      ui.div(__('Examples:'))

      examples.forEach(function (example) ***REMOVED***
        example[0] = example[0].replace(/\$0/g, yargs.$0)
      ***REMOVED***)

      examples.forEach(function (example) ***REMOVED***
        if (example[1] === '') ***REMOVED***
          ui.div(
            ***REMOVED***
              text: example[0],
              padding: [0, 2, 0, 2]
            ***REMOVED***
          )
        ***REMOVED*** else ***REMOVED***
          ui.div(
            ***REMOVED***
              text: example[0],
              padding: [0, 2, 0, 2],
              width: maxWidth(examples, theWrap) + 4
            ***REMOVED***, ***REMOVED***
              text: example[1]
            ***REMOVED***
          )
        ***REMOVED***
      ***REMOVED***)

      ui.div()
    ***REMOVED***

    // the usage string.
    if (epilog) ***REMOVED***
      var e = epilog.replace(/\$0/g, yargs.$0)
      ui.div(e + '\n')
    ***REMOVED***

    return ui.toString()
  ***REMOVED***

  // return the maximum width of a string
  // in the left-hand column of a table.
  function maxWidth (table, theWrap) ***REMOVED***
    var width = 0

    // table might be of the form [leftColumn],
    // or ***REMOVED***key: leftColumn***REMOVED***
    if (!Array.isArray(table)) ***REMOVED***
      table = Object.keys(table).map(function (key) ***REMOVED***
        return [table[key]]
      ***REMOVED***)
    ***REMOVED***

    table.forEach(function (v) ***REMOVED***
      width = Math.max(stringWidth(v[0]), width)
    ***REMOVED***)

    // if we've enabled 'wrap' we should limit
    // the max-width of the left-column.
    if (theWrap) width = Math.min(width, parseInt(theWrap * 0.5, 10))

    return width
  ***REMOVED***

  // make sure any options set for aliases,
  // are copied to the keys being aliased.
  function normalizeAliases () ***REMOVED***
    // handle old demanded API
    var demandedOptions = yargs.getDemandedOptions()
    var options = yargs.getOptions()

    ;(Object.keys(options.alias) || []).forEach(function (key) ***REMOVED***
      options.alias[key].forEach(function (alias) ***REMOVED***
        // copy descriptions.
        if (descriptions[alias]) self.describe(key, descriptions[alias])
        // copy demanded.
        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias])
        // type messages.
        if (~options.boolean.indexOf(alias)) yargs.boolean(key)
        if (~options.count.indexOf(alias)) yargs.count(key)
        if (~options.string.indexOf(alias)) yargs.string(key)
        if (~options.normalize.indexOf(alias)) yargs.normalize(key)
        if (~options.array.indexOf(alias)) yargs.array(key)
        if (~options.number.indexOf(alias)) yargs.number(key)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***

  // given a set of keys, place any keys that are
  // ungrouped under the 'Options:' grouping.
  function addUngroupedKeys (keys, aliases, groups) ***REMOVED***
    var groupedKeys = []
    var toCheck = null
    Object.keys(groups).forEach(function (group) ***REMOVED***
      groupedKeys = groupedKeys.concat(groups[group])
    ***REMOVED***)

    keys.forEach(function (key) ***REMOVED***
      toCheck = [key].concat(aliases[key])
      if (!toCheck.some(function (k) ***REMOVED***
        return groupedKeys.indexOf(k) !== -1
      ***REMOVED***)) ***REMOVED***
        groups[defaultGroup].push(key)
      ***REMOVED***
    ***REMOVED***)
    return groupedKeys
  ***REMOVED***

  self.showHelp = function (level) ***REMOVED***
    const logger = yargs._getLoggerInstance()
    if (!level) level = 'error'
    var emit = typeof level === 'function' ? level : logger[level]
    emit(self.help())
  ***REMOVED***

  self.functionDescription = function (fn) ***REMOVED***
    var description = fn.name ? require('decamelize')(fn.name, '-') : __('generated-value')
    return ['(', description, ')'].join('')
  ***REMOVED***

  self.stringifiedValues = function (values, separator) ***REMOVED***
    var string = ''
    var sep = separator || ', '
    var array = [].concat(values)

    if (!values || !array.length) return string

    array.forEach(function (value) ***REMOVED***
      if (string.length) string += sep
      string += JSON.stringify(value)
    ***REMOVED***)

    return string
  ***REMOVED***

  // format the default-value-string displayed in
  // the right-hand column.
  function defaultString (value, defaultDescription) ***REMOVED***
    var string = '[' + __('default:') + ' '

    if (value === undefined && !defaultDescription) return null

    if (defaultDescription) ***REMOVED***
      string += defaultDescription
    ***REMOVED*** else ***REMOVED***
      switch (typeof value) ***REMOVED***
        case 'string':
          string += JSON.stringify(value)
          break
        case 'object':
          string += JSON.stringify(value)
          break
        default:
          string += value
      ***REMOVED***
    ***REMOVED***

    return string + ']'
  ***REMOVED***

  // guess the width of the console window, max-width 80.
  function windowWidth () ***REMOVED***
    var maxWidth = 80
    if (typeof process === 'object' && process.stdout && process.stdout.columns) ***REMOVED***
      return Math.min(maxWidth, process.stdout.columns)
    ***REMOVED*** else ***REMOVED***
      return maxWidth
    ***REMOVED***
  ***REMOVED***

  // logic for displaying application version.
  var version = null
  self.version = function (ver) ***REMOVED***
    version = ver
  ***REMOVED***

  self.showVersion = function () ***REMOVED***
    const logger = yargs._getLoggerInstance()
    if (typeof version === 'function') logger.log(version())
    else logger.log(version)
  ***REMOVED***

  self.reset = function (localLookup) ***REMOVED***
    // do not reset wrap here
    // do not reset fails here
    failMessage = null
    failureOutput = false
    usage = undefined
    epilog = undefined
    examples = []
    commands = []
    descriptions = objFilter(descriptions, function (k, v) ***REMOVED***
      return !localLookup[k]
    ***REMOVED***)
    return self
  ***REMOVED***

  var frozen
  self.freeze = function () ***REMOVED***
    frozen = ***REMOVED******REMOVED***
    frozen.failMessage = failMessage
    frozen.failureOutput = failureOutput
    frozen.usage = usage
    frozen.epilog = epilog
    frozen.examples = examples
    frozen.commands = commands
    frozen.descriptions = descriptions
  ***REMOVED***
  self.unfreeze = function () ***REMOVED***
    failMessage = frozen.failMessage
    failureOutput = frozen.failureOutput
    usage = frozen.usage
    epilog = frozen.epilog
    examples = frozen.examples
    commands = frozen.commands
    descriptions = frozen.descriptions
    frozen = undefined
  ***REMOVED***

  return self
***REMOVED***
