const path = require('path')
const inspect = require('util').inspect
const camelCase = require('camelcase')

const DEFAULT_MARKER = '*'

// handles parsing positional arguments,
// and populating argv with said positional
// arguments.
module.exports = function (yargs, usage, validation) ***REMOVED***
  const self = ***REMOVED******REMOVED***

  var handlers = ***REMOVED******REMOVED***
  var aliasMap = ***REMOVED******REMOVED***
  var defaultCommand
  self.addHandler = function (cmd, description, builder, handler) ***REMOVED***
    var aliases = []
    handler = handler || function () ***REMOVED******REMOVED***

    if (Array.isArray(cmd)) ***REMOVED***
      aliases = cmd.slice(1)
      cmd = cmd[0]
    ***REMOVED*** else if (typeof cmd === 'object') ***REMOVED***
      var command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd)
      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases)
      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler)
      return
    ***REMOVED***

    // allow a module to be provided instead of separate builder and handler
    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') ***REMOVED***
      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler)
      return
    ***REMOVED***

    // parse positionals out of cmd string
    var parsedCommand = self.parseCommand(cmd)

    // remove positional args from aliases only
    aliases = aliases.map(function (alias) ***REMOVED***
      return self.parseCommand(alias).cmd
    ***REMOVED***)

    // check for default and filter out '*''
    var isDefault = false
    var parsedAliases = [parsedCommand.cmd].concat(aliases).filter(function (c) ***REMOVED***
      if (c === DEFAULT_MARKER) ***REMOVED***
        isDefault = true
        return false
      ***REMOVED***
      return true
    ***REMOVED***)

    // short-circuit if default with no aliases
    if (isDefault && parsedAliases.length === 0) ***REMOVED***
      defaultCommand = ***REMOVED***
        original: cmd.replace(DEFAULT_MARKER, '').trim(),
        handler: handler,
        builder: builder || ***REMOVED******REMOVED***,
        demanded: parsedCommand.demanded,
        optional: parsedCommand.optional
      ***REMOVED***
      return
    ***REMOVED***

    // shift cmd and aliases after filtering out '*'
    if (isDefault) ***REMOVED***
      parsedCommand.cmd = parsedAliases[0]
      aliases = parsedAliases.slice(1)
      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd)
    ***REMOVED***

    // populate aliasMap
    aliases.forEach(function (alias) ***REMOVED***
      aliasMap[alias] = parsedCommand.cmd
    ***REMOVED***)

    if (description !== false) ***REMOVED***
      usage.command(cmd, description, isDefault, aliases)
    ***REMOVED***

    handlers[parsedCommand.cmd] = ***REMOVED***
      original: cmd,
      handler: handler,
      builder: builder || ***REMOVED******REMOVED***,
      demanded: parsedCommand.demanded,
      optional: parsedCommand.optional
    ***REMOVED***

    if (isDefault) defaultCommand = handlers[parsedCommand.cmd]
  ***REMOVED***

  self.addDirectory = function (dir, context, req, callerFile, opts) ***REMOVED***
    opts = opts || ***REMOVED******REMOVED***
    // disable recursion to support nested directories of subcommands
    if (typeof opts.recurse !== 'boolean') opts.recurse = false
    // exclude 'json', 'coffee' from require-directory defaults
    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']
    // allow consumer to define their own visitor function
    const parentVisit = typeof opts.visit === 'function' ? opts.visit : function (o) ***REMOVED*** return o ***REMOVED***
    // call addHandler via visitor function
    opts.visit = function (obj, joined, filename) ***REMOVED***
      const visited = parentVisit(obj, joined, filename)
      // allow consumer to skip modules with their own visitor
      if (visited) ***REMOVED***
        // check for cyclic reference
        // each command file path should only be seen once per execution
        if (~context.files.indexOf(joined)) return visited
        // keep track of visited files in context.files
        context.files.push(joined)
        self.addHandler(visited)
      ***REMOVED***
      return visited
    ***REMOVED***
    require('require-directory')(***REMOVED*** require: req, filename: callerFile ***REMOVED***, dir, opts)
  ***REMOVED***

  // lookup module object from require()d command and derive name
  // if module was not require()d and no name given, throw error
  function moduleName (obj) ***REMOVED***
    const mod = require('which-module')(obj)
    if (!mod) throw new Error('No command name given for module: ' + inspect(obj))
    return commandFromFilename(mod.filename)
  ***REMOVED***

  // derive command name from filename
  function commandFromFilename (filename) ***REMOVED***
    return path.basename(filename, path.extname(filename))
  ***REMOVED***

  function extractDesc (obj) ***REMOVED***
    for (var keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) ***REMOVED***
      test = obj[keys[i]]
      if (typeof test === 'string' || typeof test === 'boolean') return test
    ***REMOVED***
    return false
  ***REMOVED***

  self.parseCommand = function (cmd) ***REMOVED***
    var extraSpacesStrippedCommand = cmd.replace(/\s***REMOVED***2,***REMOVED***/g, ' ')
    var splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/)
    var bregex = /\.*[\][<>]/g
    var parsedCommand = ***REMOVED***
      cmd: (splitCommand.shift()).replace(bregex, ''),
      demanded: [],
      optional: []
    ***REMOVED***
    splitCommand.forEach(function (cmd, i) ***REMOVED***
      var variadic = false
      cmd = cmd.replace(/\s/g, '')
      if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true
      if (/^\[/.test(cmd)) ***REMOVED***
        parsedCommand.optional.push(***REMOVED***
          cmd: cmd.replace(bregex, '').split('|'),
          variadic: variadic
        ***REMOVED***)
      ***REMOVED*** else ***REMOVED***
        parsedCommand.demanded.push(***REMOVED***
          cmd: cmd.replace(bregex, '').split('|'),
          variadic: variadic
        ***REMOVED***)
      ***REMOVED***
    ***REMOVED***)
    return parsedCommand
  ***REMOVED***

  self.getCommands = function () ***REMOVED***
    return Object.keys(handlers).concat(Object.keys(aliasMap))
  ***REMOVED***

  self.getCommandHandlers = function () ***REMOVED***
    return handlers
  ***REMOVED***

  self.hasDefaultCommand = function () ***REMOVED***
    return !!defaultCommand
  ***REMOVED***

  self.runCommand = function (command, yargs, parsed, commandIndex) ***REMOVED***
    var aliases = parsed.aliases
    var commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand
    var currentContext = yargs.getContext()
    var numFiles = currentContext.files.length
    var parentCommands = currentContext.commands.slice()

    // what does yargs look like after the buidler is run?
    var innerArgv = parsed.argv
    var innerYargs = null
    var positionalMap = ***REMOVED******REMOVED***

    if (command) currentContext.commands.push(command)
    if (typeof commandHandler.builder === 'function') ***REMOVED***
      // a function can be provided, which builds
      // up a yargs chain and possibly returns it.
      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases))
      // if the builder function did not yet parse argv with reset yargs
      // and did not explicitly set a usage() string, then apply the
      // original command string as usage() for consistent behavior with
      // options object below.
      if (yargs.parsed === false) ***REMOVED***
        if (typeof yargs.getUsageInstance().getUsage() === 'undefined') ***REMOVED***
          yargs.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original)
        ***REMOVED***
        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex)
      ***REMOVED*** else ***REMOVED***
        innerArgv = yargs.parsed.argv
      ***REMOVED***

      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases
      else aliases = yargs.parsed.aliases
    ***REMOVED*** else if (typeof commandHandler.builder === 'object') ***REMOVED***
      // as a short hand, an object can instead be provided, specifying
      // the options that a command takes.
      innerYargs = yargs.reset(parsed.aliases)
      innerYargs.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original)
      Object.keys(commandHandler.builder).forEach(function (key) ***REMOVED***
        innerYargs.option(key, commandHandler.builder[key])
      ***REMOVED***)
      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex)
      aliases = innerYargs.parsed.aliases
    ***REMOVED***

    if (!yargs._hasOutput()) ***REMOVED***
      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs)
    ***REMOVED***

    // we apply validation post-hoc, so that custom
    // checks get passed populated positional arguments.
    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error)

    if (commandHandler.handler && !yargs._hasOutput()) ***REMOVED***
      yargs._setHasOutput()
      commandHandler.handler(innerArgv)
    ***REMOVED***

    if (command) currentContext.commands.pop()
    numFiles = currentContext.files.length - numFiles
    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles)

    return innerArgv
  ***REMOVED***

  // transcribe all positional arguments "command <foo> <bar> [apple]"
  // onto argv.
  function populatePositionals (commandHandler, argv, context, yargs) ***REMOVED***
    argv._ = argv._.slice(context.commands.length) // nuke the current commands
    var demanded = commandHandler.demanded.slice(0)
    var optional = commandHandler.optional.slice(0)
    var positionalMap = ***REMOVED******REMOVED***

    validation.positionalCount(demanded.length, argv._.length)

    while (demanded.length) ***REMOVED***
      var demand = demanded.shift()
      populatePositional(demand, argv, yargs, positionalMap)
    ***REMOVED***

    while (optional.length) ***REMOVED***
      var maybe = optional.shift()
      populatePositional(maybe, argv, yargs, positionalMap)
    ***REMOVED***

    argv._ = context.commands.concat(argv._)
    return positionalMap
  ***REMOVED***

  // populate a single positional argument and its
  // aliases onto argv.
  function populatePositional (positional, argv, yargs, positionalMap) ***REMOVED***
    // "positional" consists of the positional.cmd, an array representing
    // the positional's name and aliases, and positional.variadic
    // indicating whether or not it is a variadic array.
    var variadics = null
    var value = null
    for (var i = 0, cmd; (cmd = positional.cmd[i]) !== undefined; i++) ***REMOVED***
      if (positional.variadic) ***REMOVED***
        if (variadics) argv[cmd] = variadics.slice(0)
        else argv[cmd] = variadics = argv._.splice(0)
      ***REMOVED*** else ***REMOVED***
        if (!value && !argv._.length) continue
        if (value) argv[cmd] = value
        else argv[cmd] = value = argv._.shift()
      ***REMOVED***
      positionalMap[cmd] = true
      postProcessPositional(yargs, argv, cmd)
      addCamelCaseExpansions(argv, cmd)
    ***REMOVED***
  ***REMOVED***

  // TODO move positional arg logic to yargs-parser and remove this duplication
  function postProcessPositional (yargs, argv, key) ***REMOVED***
    var coerce = yargs.getOptions().coerce[key]
    if (typeof coerce === 'function') ***REMOVED***
      try ***REMOVED***
        argv[key] = coerce(argv[key])
      ***REMOVED*** catch (err) ***REMOVED***
        yargs.getUsageInstance().fail(err.message, err)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function addCamelCaseExpansions (argv, option) ***REMOVED***
    if (/-/.test(option)) ***REMOVED***
      const cc = camelCase(option)
      if (typeof argv[option] === 'object') argv[cc] = argv[option].slice(0)
      else argv[cc] = argv[option]
    ***REMOVED***
  ***REMOVED***

  self.reset = function () ***REMOVED***
    handlers = ***REMOVED******REMOVED***
    aliasMap = ***REMOVED******REMOVED***
    defaultCommand = undefined
    return self
  ***REMOVED***

  // used by yargs.parse() to freeze
  // the state of commands such that
  // we can apply .parse() multiple times
  // with the same yargs instance.
  var frozen
  self.freeze = function () ***REMOVED***
    frozen = ***REMOVED******REMOVED***
    frozen.handlers = handlers
    frozen.aliasMap = aliasMap
    frozen.defaultCommand = defaultCommand
  ***REMOVED***
  self.unfreeze = function () ***REMOVED***
    handlers = frozen.handlers
    aliasMap = frozen.aliasMap
    defaultCommand = frozen.defaultCommand
    frozen = undefined
  ***REMOVED***

  return self
***REMOVED***
