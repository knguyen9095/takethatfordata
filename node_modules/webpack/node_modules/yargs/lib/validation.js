const objFilter = require('./obj-filter')
const specialKeys = ['$0', '--', '_']

// validation-type-stuff, missing params,
// bad implications, custom checks.
module.exports = function (yargs, usage, y18n) ***REMOVED***
  const __ = y18n.__
  const __n = y18n.__n
  const self = ***REMOVED******REMOVED***

  // validate appropriate # of non-option
  // arguments were provided, i.e., '_'.
  self.nonOptionCount = function (argv) ***REMOVED***
    const demandedCommands = yargs.getDemandedCommands()
    // don't count currently executing commands
    const _s = argv._.length - yargs.getContext().commands.length

    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) ***REMOVED***
      if (_s < demandedCommands._.min) ***REMOVED***
        if (demandedCommands._.minMsg !== undefined) ***REMOVED***
          usage.fail(
            // replace $0 with observed, $1 with expected.
            demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s).replace(/\$1/, demandedCommands._.min) : null
          )
        ***REMOVED*** else ***REMOVED***
          usage.fail(
            __('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min)
          )
        ***REMOVED***
      ***REMOVED*** else if (_s > demandedCommands._.max) ***REMOVED***
        if (demandedCommands._.maxMsg !== undefined) ***REMOVED***
          usage.fail(
            // replace $0 with observed, $1 with expected.
            demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s).replace(/\$1/, demandedCommands._.max) : null
          )
        ***REMOVED*** else ***REMOVED***
          usage.fail(
          __('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max)
          )
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // validate the appropriate # of <required>
  // positional arguments were provided:
  self.positionalCount = function (required, observed) ***REMOVED***
    if (observed < required) ***REMOVED***
      usage.fail(
        __('Not enough non-option arguments: got %s, need at least %s', observed, required)
      )
    ***REMOVED***
  ***REMOVED***

  // make sure that any args that require an
  // value (--foo=bar), have a value.
  self.missingArgumentValue = function (argv) ***REMOVED***
    const defaultValues = [true, false, '']
    const options = yargs.getOptions()

    if (options.requiresArg.length > 0) ***REMOVED***
      const missingRequiredArgs = []

      options.requiresArg.forEach(function (key) ***REMOVED***
        const value = argv[key]

        // if a value is explicitly requested,
        // flag argument as missing if it does not
        // look like foo=bar was entered.
        if (~defaultValues.indexOf(value) ||
          (Array.isArray(value) && !value.length)) ***REMOVED***
          missingRequiredArgs.push(key)
        ***REMOVED***
      ***REMOVED***)

      if (missingRequiredArgs.length > 0) ***REMOVED***
        usage.fail(__n(
          'Missing argument value: %s',
          'Missing argument values: %s',
          missingRequiredArgs.length,
          missingRequiredArgs.join(', ')
        ))
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // make sure all the required arguments are present.
  self.requiredArguments = function (argv) ***REMOVED***
    const demandedOptions = yargs.getDemandedOptions()
    var missing = null

    Object.keys(demandedOptions).forEach(function (key) ***REMOVED***
      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') ***REMOVED***
        missing = missing || ***REMOVED******REMOVED***
        missing[key] = demandedOptions[key]
      ***REMOVED***
    ***REMOVED***)

    if (missing) ***REMOVED***
      const customMsgs = []
      Object.keys(missing).forEach(function (key) ***REMOVED***
        const msg = missing[key]
        if (msg && customMsgs.indexOf(msg) < 0) ***REMOVED***
          customMsgs.push(msg)
        ***REMOVED***
      ***REMOVED***)

      const customMsg = customMsgs.length ? '\n' + customMsgs.join('\n') : ''

      usage.fail(__n(
        'Missing required argument: %s',
        'Missing required arguments: %s',
        Object.keys(missing).length,
        Object.keys(missing).join(', ') + customMsg
      ))
    ***REMOVED***
  ***REMOVED***

  // check for unknown arguments (strict-mode).
  self.unknownArguments = function (argv, aliases, positionalMap) ***REMOVED***
    const aliasLookup = ***REMOVED******REMOVED***
    const descriptions = usage.getDescriptions()
    const demandedOptions = yargs.getDemandedOptions()
    const commandKeys = yargs.getCommandInstance().getCommands()
    const unknown = []
    const currentContext = yargs.getContext()

    Object.keys(aliases).forEach(function (key) ***REMOVED***
      aliases[key].forEach(function (alias) ***REMOVED***
        aliasLookup[alias] = key
      ***REMOVED***)
    ***REMOVED***)

    Object.keys(argv).forEach(function (key) ***REMOVED***
      if (specialKeys.indexOf(key) === -1 &&
        !descriptions.hasOwnProperty(key) &&
        !demandedOptions.hasOwnProperty(key) &&
        !positionalMap.hasOwnProperty(key) &&
        !yargs._getParseContext().hasOwnProperty(key) &&
        !aliasLookup.hasOwnProperty(key)) ***REMOVED***
        unknown.push(key)
      ***REMOVED***
    ***REMOVED***)

    if (commandKeys.length > 0) ***REMOVED***
      argv._.slice(currentContext.commands.length).forEach(function (key) ***REMOVED***
        if (commandKeys.indexOf(key) === -1) ***REMOVED***
          unknown.push(key)
        ***REMOVED***
      ***REMOVED***)
    ***REMOVED***

    if (unknown.length > 0) ***REMOVED***
      usage.fail(__n(
        'Unknown argument: %s',
        'Unknown arguments: %s',
        unknown.length,
        unknown.join(', ')
      ))
    ***REMOVED***
  ***REMOVED***

  // validate arguments limited to enumerated choices
  self.limitedChoices = function (argv) ***REMOVED***
    const options = yargs.getOptions()
    const invalid = ***REMOVED******REMOVED***

    if (!Object.keys(options.choices).length) return

    Object.keys(argv).forEach(function (key) ***REMOVED***
      if (specialKeys.indexOf(key) === -1 &&
        options.choices.hasOwnProperty(key)) ***REMOVED***
        [].concat(argv[key]).forEach(function (value) ***REMOVED***
          // TODO case-insensitive configurability
          if (options.choices[key].indexOf(value) === -1) ***REMOVED***
            invalid[key] = (invalid[key] || []).concat(value)
          ***REMOVED***
        ***REMOVED***)
      ***REMOVED***
    ***REMOVED***)

    const invalidKeys = Object.keys(invalid)

    if (!invalidKeys.length) return

    var msg = __('Invalid values:')
    invalidKeys.forEach(function (key) ***REMOVED***
      msg += '\n  ' + __(
        'Argument: %s, Given: %s, Choices: %s',
        key,
        usage.stringifiedValues(invalid[key]),
        usage.stringifiedValues(options.choices[key])
      )
    ***REMOVED***)
    usage.fail(msg)
  ***REMOVED***

  // custom checks, added using the `check` option on yargs.
  var checks = []
  self.check = function (f, global) ***REMOVED***
    checks.push(***REMOVED***
      func: f,
      global: global
    ***REMOVED***)
  ***REMOVED***

  self.customChecks = function (argv, aliases) ***REMOVED***
    for (var i = 0, f; (f = checks[i]) !== undefined; i++) ***REMOVED***
      var func = f.func
      var result = null
      try ***REMOVED***
        result = func(argv, aliases)
      ***REMOVED*** catch (err) ***REMOVED***
        usage.fail(err.message ? err.message : err, err)
        continue
      ***REMOVED***

      if (!result) ***REMOVED***
        usage.fail(__('Argument check failed: %s', func.toString()))
      ***REMOVED*** else if (typeof result === 'string' || result instanceof Error) ***REMOVED***
        usage.fail(result.toString(), result)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // check implications, argument foo implies => argument bar.
  var implied = ***REMOVED******REMOVED***
  self.implies = function (key, value) ***REMOVED***
    if (typeof key === 'object') ***REMOVED***
      Object.keys(key).forEach(function (k) ***REMOVED***
        self.implies(k, key[k])
      ***REMOVED***)
    ***REMOVED*** else ***REMOVED***
      yargs.global(key)
      implied[key] = value
    ***REMOVED***
  ***REMOVED***
  self.getImplied = function () ***REMOVED***
    return implied
  ***REMOVED***

  self.implications = function (argv) ***REMOVED***
    const implyFail = []

    Object.keys(implied).forEach(function (key) ***REMOVED***
      var num
      const origKey = key
      var value = implied[key]

      // convert string '1' to number 1
      num = Number(key)
      key = isNaN(num) ? key : num

      if (typeof key === 'number') ***REMOVED***
        // check length of argv._
        key = argv._.length >= key
      ***REMOVED*** else if (key.match(/^--no-.+/)) ***REMOVED***
        // check if key doesn't exist
        key = key.match(/^--no-(.+)/)[1]
        key = !argv[key]
      ***REMOVED*** else ***REMOVED***
        // check if key exists
        key = argv[key]
      ***REMOVED***

      num = Number(value)
      value = isNaN(num) ? value : num

      if (typeof value === 'number') ***REMOVED***
        value = argv._.length >= value
      ***REMOVED*** else if (value.match(/^--no-.+/)) ***REMOVED***
        value = value.match(/^--no-(.+)/)[1]
        value = !argv[value]
      ***REMOVED*** else ***REMOVED***
        value = argv[value]
      ***REMOVED***

      if (key && !value) ***REMOVED***
        implyFail.push(origKey)
      ***REMOVED***
    ***REMOVED***)

    if (implyFail.length) ***REMOVED***
      var msg = __('Implications failed:') + '\n'

      implyFail.forEach(function (key) ***REMOVED***
        msg += ('  ' + key + ' -> ' + implied[key])
      ***REMOVED***)

      usage.fail(msg)
    ***REMOVED***
  ***REMOVED***

  var conflicting = ***REMOVED******REMOVED***
  self.conflicts = function (key, value) ***REMOVED***
    if (typeof key === 'object') ***REMOVED***
      Object.keys(key).forEach(function (k) ***REMOVED***
        self.conflicts(k, key[k])
      ***REMOVED***)
    ***REMOVED*** else ***REMOVED***
      yargs.global(key)
      conflicting[key] = value
    ***REMOVED***
  ***REMOVED***
  self.getConflicting = function () ***REMOVED***
    return conflicting
  ***REMOVED***

  self.conflicting = function (argv) ***REMOVED***
    var args = Object.getOwnPropertyNames(argv)

    args.forEach(function (arg) ***REMOVED***
      if (conflicting[arg] && args.indexOf(conflicting[arg]) !== -1) ***REMOVED***
        usage.fail(__('Arguments %s and %s are mutually exclusive', arg, conflicting[arg]))
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  self.recommendCommands = function (cmd, potentialCommands) ***REMOVED***
    const distance = require('./levenshtein')
    const threshold = 3 // if it takes more than three edits, let's move on.
    potentialCommands = potentialCommands.sort(function (a, b) ***REMOVED*** return b.length - a.length ***REMOVED***)

    var recommended = null
    var bestDistance = Infinity
    for (var i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) ***REMOVED***
      var d = distance(cmd, candidate)
      if (d <= threshold && d < bestDistance) ***REMOVED***
        bestDistance = d
        recommended = candidate
      ***REMOVED***
    ***REMOVED***
    if (recommended) usage.fail(__('Did you mean %s?', recommended))
  ***REMOVED***

  self.reset = function (localLookup) ***REMOVED***
    implied = objFilter(implied, function (k, v) ***REMOVED***
      return !localLookup[k]
    ***REMOVED***)
    conflicting = objFilter(conflicting, function (k, v) ***REMOVED***
      return !localLookup[k]
    ***REMOVED***)
    checks = checks.filter(function (c) ***REMOVED***
      return c.global
    ***REMOVED***)
    return self
  ***REMOVED***

  var frozen
  self.freeze = function () ***REMOVED***
    frozen = ***REMOVED******REMOVED***
    frozen.implied = implied
    frozen.checks = checks
    frozen.conflicting = conflicting
  ***REMOVED***
  self.unfreeze = function () ***REMOVED***
    implied = frozen.implied
    checks = frozen.checks
    conflicting = frozen.conflicting
    frozen = undefined
  ***REMOVED***

  return self
***REMOVED***
