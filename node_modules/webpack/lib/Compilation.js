/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
	*/
"use strict";

const asyncLib = require("async");
const crypto = require("crypto");
const Tapable = require("tapable");
const EntryModuleNotFoundError = require("./EntryModuleNotFoundError");
const ModuleNotFoundError = require("./ModuleNotFoundError");
const ModuleDependencyWarning = require("./ModuleDependencyWarning");
const ModuleDependencyError = require("./ModuleDependencyError");
const Module = require("./Module");
const Chunk = require("./Chunk");
const Entrypoint = require("./Entrypoint");
const MainTemplate = require("./MainTemplate");
const ChunkTemplate = require("./ChunkTemplate");
const HotUpdateChunkTemplate = require("./HotUpdateChunkTemplate");
const ModuleTemplate = require("./ModuleTemplate");
const Dependency = require("./Dependency");
const ChunkRenderError = require("./ChunkRenderError");
const AsyncDependencyToInitialChunkWarning = require("./AsyncDependencyToInitialChunkWarning");
const CachedSource = require("webpack-sources").CachedSource;
const Stats = require("./Stats");
const Semaphore = require("./util/Semaphore");
const Queue = require("./util/Queue");

function byId(a, b) ***REMOVED***
	if(a.id < b.id) return -1;
	if(a.id > b.id) return 1;
	return 0;
***REMOVED***

function iterationBlockVariable(variables, fn) ***REMOVED***
	for(let indexVariable = 0; indexVariable < variables.length; indexVariable++) ***REMOVED***
		let varDep = variables[indexVariable].dependencies;
		for(let indexVDep = 0; indexVDep < varDep.length; indexVDep++) ***REMOVED***
			fn(varDep[indexVDep]);
		***REMOVED***
	***REMOVED***
***REMOVED***

function iterationOfArrayCallback(arr, fn) ***REMOVED***
	for(let index = 0; index < arr.length; index++) ***REMOVED***
		fn(arr[index]);
	***REMOVED***
***REMOVED***

class Compilation extends Tapable ***REMOVED***
	constructor(compiler) ***REMOVED***
		super();
		this.compiler = compiler;
		this.resolvers = compiler.resolvers;
		this.inputFileSystem = compiler.inputFileSystem;

		const options = this.options = compiler.options;
		this.outputOptions = options && options.output;
		this.bail = options && options.bail;
		this.profile = options && options.profile;
		this.performance = options && options.performance;

		this.mainTemplate = new MainTemplate(this.outputOptions);
		this.chunkTemplate = new ChunkTemplate(this.outputOptions);
		this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(this.outputOptions);
		this.moduleTemplate = new ModuleTemplate(this.outputOptions);

		this.semaphore = new Semaphore(options.parallelism || 100);

		this.entries = [];
		this.preparedChunks = [];
		this.entrypoints = ***REMOVED******REMOVED***;
		this.chunks = [];
		this.namedChunks = ***REMOVED******REMOVED***;
		this.modules = [];
		this._modules = ***REMOVED******REMOVED***;
		this.cache = null;
		this.records = null;
		this.nextFreeModuleIndex = undefined;
		this.nextFreeModuleIndex2 = undefined;
		this.additionalChunkAssets = [];
		this.assets = ***REMOVED******REMOVED***;
		this.errors = [];
		this.warnings = [];
		this.children = [];
		this.dependencyFactories = new Map();
		this.dependencyTemplates = new Map();
		this.dependencyTemplates.set("hash", "");
		this.childrenCounters = ***REMOVED******REMOVED***;
	***REMOVED***

	getStats() ***REMOVED***
		return new Stats(this);
	***REMOVED***

	templatesPlugin(name, fn) ***REMOVED***
		this.mainTemplate.plugin(name, fn);
		this.chunkTemplate.plugin(name, fn);
	***REMOVED***

	addModule(module, cacheGroup) ***REMOVED***
		const identifier = module.identifier();
		if(this._modules[identifier]) ***REMOVED***
			return false;
		***REMOVED***
		const cacheName = (cacheGroup || "m") + identifier;
		if(this.cache && this.cache[cacheName]) ***REMOVED***
			const cacheModule = this.cache[cacheName];

			let rebuild = true;
			if(!cacheModule.error && cacheModule.cacheable && this.fileTimestamps && this.contextTimestamps) ***REMOVED***
				rebuild = cacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps);
			***REMOVED***

			if(!rebuild) ***REMOVED***
				cacheModule.disconnect();
				this._modules[identifier] = cacheModule;
				this.modules.push(cacheModule);
				cacheModule.errors.forEach(err => this.errors.push(err), this);
				cacheModule.warnings.forEach(err => this.warnings.push(err), this);
				return cacheModule;
			***REMOVED***
		***REMOVED***
		module.unbuild();
		this._modules[identifier] = module;
		if(this.cache) ***REMOVED***
			this.cache[cacheName] = module;
		***REMOVED***
		this.modules.push(module);
		return true;
	***REMOVED***

	getModule(module) ***REMOVED***
		const identifier = module.identifier();
		return this._modules[identifier];
	***REMOVED***

	findModule(identifier) ***REMOVED***
		return this._modules[identifier];
	***REMOVED***

	buildModule(module, optional, origin, dependencies, thisCallback) ***REMOVED***
		this.applyPlugins1("build-module", module);
		if(module.building) return module.building.push(thisCallback);
		const building = module.building = [thisCallback];

		function callback(err) ***REMOVED***
			module.building = undefined;
			building.forEach(cb => cb(err));
		***REMOVED***
		module.build(this.options, this, this.resolvers.normal, this.inputFileSystem, (error) => ***REMOVED***
			const errors = module.errors;
			for(let indexError = 0; indexError < errors.length; indexError++) ***REMOVED***
				const err = errors[indexError];
				err.origin = origin;
				err.dependencies = dependencies;
				if(optional)
					this.warnings.push(err);
				else
					this.errors.push(err);
			***REMOVED***

			const warnings = module.warnings;
			for(let indexWarning = 0; indexWarning < warnings.length; indexWarning++) ***REMOVED***
				const war = warnings[indexWarning];
				war.origin = origin;
				war.dependencies = dependencies;
				this.warnings.push(war);
			***REMOVED***
			module.dependencies.sort(Dependency.compare);
			if(error) ***REMOVED***
				this.applyPlugins2("failed-module", module, error);
				return callback(error);
			***REMOVED***
			this.applyPlugins1("succeed-module", module);
			return callback();
		***REMOVED***);
	***REMOVED***

	processModuleDependencies(module, callback) ***REMOVED***
		const dependencies = [];

		function addDependency(dep) ***REMOVED***
			for(let i = 0; i < dependencies.length; i++) ***REMOVED***
				if(dep.isEqualResource(dependencies[i][0])) ***REMOVED***
					return dependencies[i].push(dep);
				***REMOVED***
			***REMOVED***
			dependencies.push([dep]);
		***REMOVED***

		function addDependenciesBlock(block) ***REMOVED***
			if(block.dependencies) ***REMOVED***
				iterationOfArrayCallback(block.dependencies, addDependency);
			***REMOVED***
			if(block.blocks) ***REMOVED***
				iterationOfArrayCallback(block.blocks, addDependenciesBlock);
			***REMOVED***
			if(block.variables) ***REMOVED***
				iterationBlockVariable(block.variables, addDependency);
			***REMOVED***
		***REMOVED***
		addDependenciesBlock(module);
		this.addModuleDependencies(module, dependencies, this.bail, null, true, callback);
	***REMOVED***

	addModuleDependencies(module, dependencies, bail, cacheGroup, recursive, callback) ***REMOVED***
		let _this = this;
		const start = _this.profile && Date.now();

		const factories = [];
		for(let i = 0; i < dependencies.length; i++) ***REMOVED***
			const factory = _this.dependencyFactories.get(dependencies[i][0].constructor);
			if(!factory) ***REMOVED***
				return callback(new Error(`No module factory available for dependency type: $***REMOVED***dependencies[i][0].constructor.name***REMOVED***`));
			***REMOVED***
			factories[i] = [factory, dependencies[i]];
		***REMOVED***
		asyncLib.forEach(factories, function iteratorFactory(item, callback) ***REMOVED***
			const dependencies = item[1];

			const errorAndCallback = function errorAndCallback(err) ***REMOVED***
				err.origin = module;
				_this.errors.push(err);
				if(bail) ***REMOVED***
					callback(err);
				***REMOVED*** else ***REMOVED***
					callback();
				***REMOVED***
			***REMOVED***;
			const warningAndCallback = function warningAndCallback(err) ***REMOVED***
				err.origin = module;
				_this.warnings.push(err);
				callback();
			***REMOVED***;

			const semaphore = _this.semaphore;
			semaphore.acquire(() => ***REMOVED***
				if(_this === null) return semaphore.release();

				const factory = item[0];
				factory.create(***REMOVED***
					contextInfo: ***REMOVED***
						issuer: module.nameForCondition && module.nameForCondition(),
						compiler: _this.compiler.name
					***REMOVED***,
					context: module.context,
					dependencies: dependencies
				***REMOVED***, function factoryCallback(err, dependentModule) ***REMOVED***
					if(_this === null) return semaphore.release();

					let afterFactory;

					function isOptional() ***REMOVED***
						return dependencies.filter(d => !d.optional).length === 0;
					***REMOVED***

					function errorOrWarningAndCallback(err) ***REMOVED***
						if(isOptional()) ***REMOVED***
							return warningAndCallback(err);
						***REMOVED*** else ***REMOVED***
							return errorAndCallback(err);
						***REMOVED***
					***REMOVED***

					function iterationDependencies(depend) ***REMOVED***
						for(let index = 0; index < depend.length; index++) ***REMOVED***
							const dep = depend[index];
							dep.module = dependentModule;
							dependentModule.addReason(module, dep);
						***REMOVED***
					***REMOVED***

					if(err) ***REMOVED***
						semaphore.release();
						return errorOrWarningAndCallback(new ModuleNotFoundError(module, err, dependencies));
					***REMOVED***
					if(!dependentModule) ***REMOVED***
						semaphore.release();
						return process.nextTick(callback);
					***REMOVED***
					if(_this.profile) ***REMOVED***
						if(!dependentModule.profile) ***REMOVED***
							dependentModule.profile = ***REMOVED******REMOVED***;
						***REMOVED***
						afterFactory = Date.now();
						dependentModule.profile.factory = afterFactory - start;
					***REMOVED***

					dependentModule.issuer = module;
					const newModule = _this.addModule(dependentModule, cacheGroup);

					if(!newModule) ***REMOVED*** // from cache
						dependentModule = _this.getModule(dependentModule);

						if(dependentModule.optional) ***REMOVED***
							dependentModule.optional = isOptional();
						***REMOVED***

						iterationDependencies(dependencies);

						if(_this.profile) ***REMOVED***
							if(!module.profile) ***REMOVED***
								module.profile = ***REMOVED******REMOVED***;
							***REMOVED***
							const time = Date.now() - start;
							if(!module.profile.dependencies || time > module.profile.dependencies) ***REMOVED***
								module.profile.dependencies = time;
							***REMOVED***
						***REMOVED***

						semaphore.release();
						return process.nextTick(callback);
					***REMOVED***

					if(newModule instanceof Module) ***REMOVED***
						if(_this.profile) ***REMOVED***
							newModule.profile = dependentModule.profile;
						***REMOVED***

						newModule.optional = isOptional();
						newModule.issuer = dependentModule.issuer;
						dependentModule = newModule;

						iterationDependencies(dependencies);

						if(_this.profile) ***REMOVED***
							const afterBuilding = Date.now();
							module.profile.building = afterBuilding - afterFactory;
						***REMOVED***

						semaphore.release();
						if(recursive) ***REMOVED***
							return process.nextTick(_this.processModuleDependencies.bind(_this, dependentModule, callback));
						***REMOVED*** else ***REMOVED***
							return process.nextTick(callback);
						***REMOVED***
					***REMOVED***

					dependentModule.optional = isOptional();

					iterationDependencies(dependencies);

					_this.buildModule(dependentModule, isOptional(), module, dependencies, err => ***REMOVED***
						if(_this === null) return semaphore.release();

						if(err) ***REMOVED***
							semaphore.release();
							return errorOrWarningAndCallback(err);
						***REMOVED***

						if(_this.profile) ***REMOVED***
							const afterBuilding = Date.now();
							dependentModule.profile.building = afterBuilding - afterFactory;
						***REMOVED***

						semaphore.release();
						if(recursive) ***REMOVED***
							_this.processModuleDependencies(dependentModule, callback);
						***REMOVED*** else ***REMOVED***
							return callback();
						***REMOVED***
					***REMOVED***);

				***REMOVED***);
			***REMOVED***);
		***REMOVED***, function finalCallbackAddModuleDependencies(err) ***REMOVED***
			// In V8, the Error objects keep a reference to the functions on the stack. These warnings &
			// errors are created inside closures that keep a reference to the Compilation, so errors are
			// leaking the Compilation object. Setting _this to null workarounds the following issue in V8.
			// https://bugs.chromium.org/p/chromium/issues/detail?id=612191
			_this = null;

			if(err) ***REMOVED***
				return callback(err);
			***REMOVED***

			return process.nextTick(callback);
		***REMOVED***);
	***REMOVED***

	_addModuleChain(context, dependency, onModule, callback) ***REMOVED***
		const start = this.profile && Date.now();

		const errorAndCallback = this.bail ? (err) => ***REMOVED***
			callback(err);
		***REMOVED*** : (err) => ***REMOVED***
			err.dependencies = [dependency];
			this.errors.push(err);
			callback();
		***REMOVED***;

		if(typeof dependency !== "object" || dependency === null || !dependency.constructor) ***REMOVED***
			throw new Error("Parameter 'dependency' must be a Dependency");
		***REMOVED***

		const moduleFactory = this.dependencyFactories.get(dependency.constructor);
		if(!moduleFactory) ***REMOVED***
			throw new Error(`No dependency factory available for this dependency type: $***REMOVED***dependency.constructor.name***REMOVED***`);
		***REMOVED***

		this.semaphore.acquire(() => ***REMOVED***
			moduleFactory.create(***REMOVED***
				contextInfo: ***REMOVED***
					issuer: "",
					compiler: this.compiler.name
				***REMOVED***,
				context: context,
				dependencies: [dependency]
			***REMOVED***, (err, module) => ***REMOVED***
				if(err) ***REMOVED***
					this.semaphore.release();
					return errorAndCallback(new EntryModuleNotFoundError(err));
				***REMOVED***

				let afterFactory;

				if(this.profile) ***REMOVED***
					if(!module.profile) ***REMOVED***
						module.profile = ***REMOVED******REMOVED***;
					***REMOVED***
					afterFactory = Date.now();
					module.profile.factory = afterFactory - start;
				***REMOVED***

				const result = this.addModule(module);
				if(!result) ***REMOVED***
					module = this.getModule(module);

					onModule(module);

					if(this.profile) ***REMOVED***
						const afterBuilding = Date.now();
						module.profile.building = afterBuilding - afterFactory;
					***REMOVED***

					this.semaphore.release();
					return callback(null, module);
				***REMOVED***

				if(result instanceof Module) ***REMOVED***
					if(this.profile) ***REMOVED***
						result.profile = module.profile;
					***REMOVED***

					module = result;

					onModule(module);

					moduleReady.call(this);
					return;
				***REMOVED***

				onModule(module);

				this.buildModule(module, false, null, null, (err) => ***REMOVED***
					if(err) ***REMOVED***
						this.semaphore.release();
						return errorAndCallback(err);
					***REMOVED***

					if(this.profile) ***REMOVED***
						const afterBuilding = Date.now();
						module.profile.building = afterBuilding - afterFactory;
					***REMOVED***

					moduleReady.call(this);
				***REMOVED***);

				function moduleReady() ***REMOVED***
					this.semaphore.release();
					this.processModuleDependencies(module, err => ***REMOVED***
						if(err) ***REMOVED***
							return callback(err);
						***REMOVED***

						return callback(null, module);
					***REMOVED***);
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	addEntry(context, entry, name, callback) ***REMOVED***
		const slot = ***REMOVED***
			name: name,
			module: null
		***REMOVED***;
		this.preparedChunks.push(slot);
		this._addModuleChain(context, entry, (module) => ***REMOVED***

			entry.module = module;
			this.entries.push(module);
			module.issuer = null;

		***REMOVED***, (err, module) => ***REMOVED***
			if(err) ***REMOVED***
				return callback(err);
			***REMOVED***

			if(module) ***REMOVED***
				slot.module = module;
			***REMOVED*** else ***REMOVED***
				const idx = this.preparedChunks.indexOf(slot);
				this.preparedChunks.splice(idx, 1);
			***REMOVED***
			return callback(null, module);
		***REMOVED***);
	***REMOVED***

	prefetch(context, dependency, callback) ***REMOVED***
		this._addModuleChain(context, dependency, module => ***REMOVED***

			module.prefetched = true;
			module.issuer = null;

		***REMOVED***, callback);
	***REMOVED***

	rebuildModule(module, thisCallback) ***REMOVED***
		if(module.variables.length || module.blocks.length)
			throw new Error("Cannot rebuild a complex module with variables or blocks");
		if(module.rebuilding) ***REMOVED***
			return module.rebuilding.push(thisCallback);
		***REMOVED***
		const rebuilding = module.rebuilding = [thisCallback];

		function callback(err) ***REMOVED***
			module.rebuilding = undefined;
			rebuilding.forEach(cb => cb(err));
		***REMOVED***
		const deps = module.dependencies.slice();
		this.buildModule(module, false, module, null, (err) => ***REMOVED***
			if(err) return callback(err);

			this.processModuleDependencies(module, (err) => ***REMOVED***
				if(err) return callback(err);
				deps.forEach(d => ***REMOVED***
					if(d.module && d.module.removeReason(module, d)) ***REMOVED***
						module.forEachChunk(chunk => ***REMOVED***
							if(!d.module.hasReasonForChunk(chunk)) ***REMOVED***
								if(d.module.removeChunk(chunk)) ***REMOVED***
									this.removeChunkFromDependencies(d.module, chunk);
								***REMOVED***
							***REMOVED***
						***REMOVED***);
					***REMOVED***
				***REMOVED***);
				callback();
			***REMOVED***);

		***REMOVED***);
	***REMOVED***

	finish() ***REMOVED***
		const modules = this.modules;
		this.applyPlugins1("finish-modules", modules);

		for(let index = 0; index < modules.length; index++) ***REMOVED***
			const module = modules[index];
			this.reportDependencyErrorsAndWarnings(module, [module]);
		***REMOVED***
	***REMOVED***

	unseal() ***REMOVED***
		this.applyPlugins0("unseal");
		this.chunks.length = 0;
		this.namedChunks = ***REMOVED******REMOVED***;
		this.additionalChunkAssets.length = 0;
		this.assets = ***REMOVED******REMOVED***;
		this.modules.forEach(module => module.unseal());
	***REMOVED***

	seal(callback) ***REMOVED***
		const self = this;
		self.applyPlugins0("seal");
		self.nextFreeModuleIndex = 0;
		self.nextFreeModuleIndex2 = 0;
		self.preparedChunks.forEach(preparedChunk => ***REMOVED***
			const module = preparedChunk.module;
			const chunk = self.addChunk(preparedChunk.name, module);
			const entrypoint = self.entrypoints[chunk.name] = new Entrypoint(chunk.name);
			entrypoint.unshiftChunk(chunk);

			chunk.addModule(module);
			module.addChunk(chunk);
			chunk.entryModule = module;
			self.assignIndex(module);
			self.assignDepth(module);
		***REMOVED***);
		self.processDependenciesBlocksForChunks(self.chunks.slice());
		self.sortModules(self.modules);
		self.applyPlugins0("optimize");

		while(self.applyPluginsBailResult1("optimize-modules-basic", self.modules) ||
			self.applyPluginsBailResult1("optimize-modules", self.modules) ||
			self.applyPluginsBailResult1("optimize-modules-advanced", self.modules)) ***REMOVED*** /* empty */ ***REMOVED***
		self.applyPlugins1("after-optimize-modules", self.modules);

		while(self.applyPluginsBailResult1("optimize-chunks-basic", self.chunks) ||
			self.applyPluginsBailResult1("optimize-chunks", self.chunks) ||
			self.applyPluginsBailResult1("optimize-chunks-advanced", self.chunks)) ***REMOVED*** /* empty */ ***REMOVED***
		self.applyPlugins1("after-optimize-chunks", self.chunks);

		self.applyPluginsAsyncSeries("optimize-tree", self.chunks, self.modules, function sealPart2(err) ***REMOVED***
			if(err) ***REMOVED***
				return callback(err);
			***REMOVED***

			self.applyPlugins2("after-optimize-tree", self.chunks, self.modules);

			while(self.applyPluginsBailResult("optimize-chunk-modules-basic", self.chunks, self.modules) ||
				self.applyPluginsBailResult("optimize-chunk-modules", self.chunks, self.modules) ||
				self.applyPluginsBailResult("optimize-chunk-modules-advanced", self.chunks, self.modules)) ***REMOVED*** /* empty */ ***REMOVED***
			self.applyPlugins2("after-optimize-chunk-modules", self.chunks, self.modules);

			const shouldRecord = self.applyPluginsBailResult("should-record") !== false;

			self.applyPlugins2("revive-modules", self.modules, self.records);
			self.applyPlugins1("optimize-module-order", self.modules);
			self.applyPlugins1("advanced-optimize-module-order", self.modules);
			self.applyPlugins1("before-module-ids", self.modules);
			self.applyPlugins1("module-ids", self.modules);
			self.applyModuleIds();
			self.applyPlugins1("optimize-module-ids", self.modules);
			self.applyPlugins1("after-optimize-module-ids", self.modules);

			self.sortItemsWithModuleIds();

			self.applyPlugins2("revive-chunks", self.chunks, self.records);
			self.applyPlugins1("optimize-chunk-order", self.chunks);
			self.applyPlugins1("before-chunk-ids", self.chunks);
			self.applyChunkIds();
			self.applyPlugins1("optimize-chunk-ids", self.chunks);
			self.applyPlugins1("after-optimize-chunk-ids", self.chunks);

			self.sortItemsWithChunkIds();

			if(shouldRecord)
				self.applyPlugins2("record-modules", self.modules, self.records);
			if(shouldRecord)
				self.applyPlugins2("record-chunks", self.chunks, self.records);

			self.applyPlugins0("before-hash");
			self.createHash();
			self.applyPlugins0("after-hash");

			if(shouldRecord)
				self.applyPlugins1("record-hash", self.records);

			self.applyPlugins0("before-module-assets");
			self.createModuleAssets();
			if(self.applyPluginsBailResult("should-generate-chunk-assets") !== false) ***REMOVED***
				self.applyPlugins0("before-chunk-assets");
				self.createChunkAssets();
			***REMOVED***
			self.applyPlugins1("additional-chunk-assets", self.chunks);
			self.summarizeDependencies();
			if(shouldRecord)
				self.applyPlugins2("record", self, self.records);

			self.applyPluginsAsync("additional-assets", err => ***REMOVED***
				if(err) ***REMOVED***
					return callback(err);
				***REMOVED***
				self.applyPluginsAsync("optimize-chunk-assets", self.chunks, err => ***REMOVED***
					if(err) ***REMOVED***
						return callback(err);
					***REMOVED***
					self.applyPlugins1("after-optimize-chunk-assets", self.chunks);
					self.applyPluginsAsync("optimize-assets", self.assets, err => ***REMOVED***
						if(err) ***REMOVED***
							return callback(err);
						***REMOVED***
						self.applyPlugins1("after-optimize-assets", self.assets);
						if(self.applyPluginsBailResult("need-additional-seal")) ***REMOVED***
							self.unseal();
							return self.seal(callback);
						***REMOVED***
						return self.applyPluginsAsync("after-seal", callback);
					***REMOVED***);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	sortModules(modules) ***REMOVED***
		modules.sort((a, b) => ***REMOVED***
			if(a.index < b.index) return -1;
			if(a.index > b.index) return 1;
			return 0;
		***REMOVED***);
	***REMOVED***

	reportDependencyErrorsAndWarnings(module, blocks) ***REMOVED***
		for(let indexBlock = 0; indexBlock < blocks.length; indexBlock++) ***REMOVED***
			const block = blocks[indexBlock];
			const dependencies = block.dependencies;

			for(let indexDep = 0; indexDep < dependencies.length; indexDep++) ***REMOVED***
				const d = dependencies[indexDep];

				const warnings = d.getWarnings();
				if(warnings) ***REMOVED***
					for(let indexWar = 0; indexWar < warnings.length; indexWar++) ***REMOVED***
						const w = warnings[indexWar];

						const warning = new ModuleDependencyWarning(module, w, d.loc);
						this.warnings.push(warning);
					***REMOVED***
				***REMOVED***
				const errors = d.getErrors();
				if(errors) ***REMOVED***
					for(let indexErr = 0; indexErr < errors.length; indexErr++) ***REMOVED***
						const e = errors[indexErr];

						const error = new ModuleDependencyError(module, e, d.loc);
						this.errors.push(error);
					***REMOVED***
				***REMOVED***
			***REMOVED***

			this.reportDependencyErrorsAndWarnings(module, block.blocks);
		***REMOVED***
	***REMOVED***

	addChunk(name, module, loc) ***REMOVED***
		if(name) ***REMOVED***
			if(Object.prototype.hasOwnProperty.call(this.namedChunks, name)) ***REMOVED***
				const chunk = this.namedChunks[name];
				if(module) ***REMOVED***
					chunk.addOrigin(module, loc);
				***REMOVED***
				return chunk;
			***REMOVED***
		***REMOVED***
		const chunk = new Chunk(name, module, loc);
		this.chunks.push(chunk);
		if(name) ***REMOVED***
			this.namedChunks[name] = chunk;
		***REMOVED***
		return chunk;
	***REMOVED***

	assignIndex(module) ***REMOVED***
		const _this = this;

		const queue = [() => ***REMOVED***
			assignIndexToModule(module);
		***REMOVED***];

		const iteratorAllDependencies = d => ***REMOVED***
			queue.push(() => assignIndexToDependency(d));
		***REMOVED***;

		function assignIndexToModule(module) ***REMOVED***
			// enter module
			if(typeof module.index !== "number") ***REMOVED***
				module.index = _this.nextFreeModuleIndex++;

				// leave module
				queue.push(() => module.index2 = _this.nextFreeModuleIndex2++);

				// enter it as block
				assignIndexToDependencyBlock(module);
			***REMOVED***
		***REMOVED***

		function assignIndexToDependency(dependency) ***REMOVED***
			if(dependency.module) ***REMOVED***
				queue.push(() => assignIndexToModule(dependency.module));
			***REMOVED***
		***REMOVED***

		function assignIndexToDependencyBlock(block) ***REMOVED***
			let allDependencies = [];

			function iteratorDependency(d) ***REMOVED***
				allDependencies.push(d);
			***REMOVED***

			function iteratorBlock(b) ***REMOVED***
				queue.push(() => assignIndexToDependencyBlock(b));
			***REMOVED***

			if(block.variables) ***REMOVED***
				iterationBlockVariable(block.variables, iteratorDependency);
			***REMOVED***

			if(block.dependencies) ***REMOVED***
				iterationOfArrayCallback(block.dependencies, iteratorDependency);
			***REMOVED***
			if(block.blocks) ***REMOVED***
				const blocks = block.blocks;
				let indexBlock = blocks.length;
				while(indexBlock--) ***REMOVED***
					iteratorBlock(blocks[indexBlock]);
				***REMOVED***
			***REMOVED***

			let indexAll = allDependencies.length;
			while(indexAll--) ***REMOVED***
				iteratorAllDependencies(allDependencies[indexAll]);
			***REMOVED***
		***REMOVED***

		while(queue.length) ***REMOVED***
			queue.pop()();
		***REMOVED***
	***REMOVED***

	assignDepth(module) ***REMOVED***
		function assignDepthToModule(module, depth) ***REMOVED***
			// enter module
			if(typeof module.depth === "number" && module.depth <= depth) return;
			module.depth = depth;

			// enter it as block
			assignDepthToDependencyBlock(module, depth + 1);
		***REMOVED***

		function assignDepthToDependency(dependency, depth) ***REMOVED***
			if(dependency.module) ***REMOVED***
				queue.push(() => assignDepthToModule(dependency.module, depth));
			***REMOVED***
		***REMOVED***

		function assignDepthToDependencyBlock(block, depth) ***REMOVED***
			function iteratorDependency(d) ***REMOVED***
				assignDepthToDependency(d, depth);
			***REMOVED***

			function iteratorBlock(b) ***REMOVED***
				assignDepthToDependencyBlock(b, depth);
			***REMOVED***

			if(block.variables) ***REMOVED***
				iterationBlockVariable(block.variables, iteratorDependency);
			***REMOVED***

			if(block.dependencies) ***REMOVED***
				iterationOfArrayCallback(block.dependencies, iteratorDependency);
			***REMOVED***

			if(block.blocks) ***REMOVED***
				iterationOfArrayCallback(block.blocks, iteratorBlock);
			***REMOVED***
		***REMOVED***

		const queue = [() => ***REMOVED***
			assignDepthToModule(module, 0);
		***REMOVED***];
		while(queue.length) ***REMOVED***
			queue.pop()();
		***REMOVED***
	***REMOVED***

	// This method creates the Chunk graph from the Module graph
	processDependenciesBlocksForChunks(inputChunks) ***REMOVED***
		// Process is splitting into two parts:
		// Part one traverse the module graph and builds a very basic chunks graph
		//   in chunkDependencies.
		// Part two traverse every possible way through the basic chunk graph and
		//   tracks the available modules. While traversing it connects chunks with
		//   eachother and Blocks with Chunks. It stops traversing when all modules
		//   for a chunk are already available. So it doesn't connect unneeded chunks.

		const chunkDependencies = new Map(); // Map<Chunk, Array<***REMOVED***Module, Chunk***REMOVED***>>
		const allCreatedChunks = new Set();

		// PART ONE

		const blockChunks = new Map();

		// Start with the provided modules/chunks
		const queue = inputChunks.map(chunk => (***REMOVED***
			block: chunk.entryModule,
			chunk: chunk
		***REMOVED***));

		let block, chunk;

		// For each async Block in graph
		const iteratorBlock = b => ***REMOVED***
			// 1. We create a chunk for this Block
			// but only once (blockChunks map)
			let c = blockChunks.get(b);
			if(c === undefined) ***REMOVED***
				c = this.namedChunks[b.chunkName];
				if(c && c.isInitial()) ***REMOVED***
					// TODO webpack 4: convert this to an error
					this.warnings.push(new AsyncDependencyToInitialChunkWarning(b.chunkName, b.module, b.loc));
					c = chunk;
				***REMOVED*** else ***REMOVED***
					c = this.addChunk(b.chunkName, b.module, b.loc);
					blockChunks.set(b, c);
					allCreatedChunks.add(c);
					// We initialize the chunks property
					// this is later filled with the chunk when needed
					b.chunks = [];
				***REMOVED***
			***REMOVED***

			// 2. We store the Block+Chunk mapping as dependency for the chunk
			let deps = chunkDependencies.get(chunk);
			if(!deps) chunkDependencies.set(chunk, deps = []);
			deps.push(***REMOVED***
				block: b,
				chunk: c
			***REMOVED***);

			// 3. We enqueue the DependenciesBlock for traversal
			queue.push(***REMOVED***
				block: b,
				chunk: c
			***REMOVED***);
		***REMOVED***;

		// For each Dependency in the graph
		const iteratorDependency = d => ***REMOVED***
			// We skip Dependencies without Module pointer
			if(!d.module) ***REMOVED***
				return;
			***REMOVED***
			// We skip weak Dependencies
			if(d.weak) ***REMOVED***
				return;
			***REMOVED***
			// We connect Module and Chunk when not already done
			if(chunk.addModule(d.module)) ***REMOVED***
				d.module.addChunk(chunk);

				// And enqueue the Module for traversal
				queue.push(***REMOVED***
					block: d.module,
					chunk
				***REMOVED***);
			***REMOVED***
		***REMOVED***;

		// Iterative traversal of the Module graph
		// Recursive would be simpler to write but could result in Stack Overflows
		while(queue.length) ***REMOVED***
			const queueItem = queue.pop();
			block = queueItem.block;
			chunk = queueItem.chunk;

			// Traverse all variables, Dependencies and Blocks
			if(block.variables) ***REMOVED***
				iterationBlockVariable(block.variables, iteratorDependency);
			***REMOVED***

			if(block.dependencies) ***REMOVED***
				iterationOfArrayCallback(block.dependencies, iteratorDependency);
			***REMOVED***

			if(block.blocks) ***REMOVED***
				iterationOfArrayCallback(block.blocks, iteratorBlock);
			***REMOVED***
		***REMOVED***

		// PART TWO

		let availableModules;
		let newAvailableModules;
		const queue2 = new Queue(inputChunks.map(chunk => (***REMOVED***
			chunk,
			availableModules: new Set()
		***REMOVED***)));

		// Helper function to check if all modules of a chunk are available
		const areModulesAvailable = (chunk, availableModules) => ***REMOVED***
			for(const module of chunk.modulesIterable) ***REMOVED***
				if(!availableModules.has(module))
					return false;
			***REMOVED***
			return true;
		***REMOVED***;

		// For each edge in the basic chunk graph
		const filterFn = dep => ***REMOVED***
			// Filter egdes that are not needed because all modules are already available
			// This also filters circular dependencies in the chunks graph
			const depChunk = dep.chunk;
			if(areModulesAvailable(depChunk, newAvailableModules))
				return false; // break all modules are already available
			return true;
		***REMOVED***;

		const minAvailableModulesMap = new Map();

		// Iterative traversing of the basic chunk graph
		while(queue2.length) ***REMOVED***
			const queueItem = queue2.dequeue();
			chunk = queueItem.chunk;
			availableModules = queueItem.availableModules;

			// 1. Get minimal available modules
			// It doesn't make sense to traverse a chunk again with more available modules.
			// This step calculates the minimal available modules and skips traversal when
			// the list didn't shrink.
			let minAvailableModules = minAvailableModulesMap.get(chunk);
			if(minAvailableModules === undefined) ***REMOVED***
				minAvailableModulesMap.set(chunk, new Set(availableModules));
			***REMOVED*** else ***REMOVED***
				let deletedModules = false;
				for(const m of minAvailableModules) ***REMOVED***
					if(!availableModules.has(m)) ***REMOVED***
						minAvailableModules.delete(m);
						deletedModules = true;
					***REMOVED***
				***REMOVED***
				if(!deletedModules)
					continue;
				availableModules = minAvailableModules;
			***REMOVED***

			// 2. Get the edges at this point of the graph
			const deps = chunkDependencies.get(chunk);
			if(!deps) continue;
			if(deps.length === 0) continue;

			// 3. Create a new Set of available modules at this points
			newAvailableModules = new Set(availableModules);
			for(const m of chunk.modulesIterable)
				newAvailableModules.add(m);

			// 4. Filter edges with available modules
			const filteredDeps = deps.filter(filterFn);

			// 5. Foreach remaining edge
			const nextChunks = new Set();
			for(let i = 0; i < filteredDeps.length; i++) ***REMOVED***
				const dep = filteredDeps[i];
				const depChunk = dep.chunk;
				const depBlock = dep.block;

				// 6. Connnect block with chunk
				if(depChunk.addBlock(depBlock)) ***REMOVED***
					depBlock.chunks.push(depChunk);
				***REMOVED***

				// 7. Connect chunk with parent
				if(chunk.addChunk(depChunk)) ***REMOVED***
					depChunk.addParent(chunk);
				***REMOVED***

				nextChunks.add(depChunk);
			***REMOVED***

			// 8. Enqueue further traversal
			for(const nextChunk of nextChunks) ***REMOVED***
				queue2.enqueue(***REMOVED***
					chunk: nextChunk,
					availableModules: newAvailableModules
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		// Remove all unconnected chunks
		for(const chunk of allCreatedChunks) ***REMOVED***
			if(chunk.parents.length === 0)
				chunk.remove("unconnected");
		***REMOVED***
	***REMOVED***

	removeChunkFromDependencies(block, chunk) ***REMOVED***
		const iteratorDependency = d => ***REMOVED***
			if(!d.module) ***REMOVED***
				return;
			***REMOVED***
			if(!d.module.hasReasonForChunk(chunk)) ***REMOVED***
				if(d.module.removeChunk(chunk)) ***REMOVED***
					this.removeChunkFromDependencies(d.module, chunk);
				***REMOVED***
			***REMOVED***
		***REMOVED***;

		const blocks = block.blocks;
		for(let indexBlock = 0; indexBlock < blocks.length; indexBlock++) ***REMOVED***
			const chunks = blocks[indexBlock].chunks;
			for(let indexChunk = 0; indexChunk < chunks.length; indexChunk++) ***REMOVED***
				const blockChunk = chunks[indexChunk];
				chunk.removeChunk(blockChunk);
				blockChunk.removeParent(chunk);
				this.removeChunkFromDependencies(chunks, blockChunk);
			***REMOVED***
		***REMOVED***

		if(block.dependencies) ***REMOVED***
			iterationOfArrayCallback(block.dependencies, iteratorDependency);
		***REMOVED***

		if(block.variables) ***REMOVED***
			iterationBlockVariable(block.variables, iteratorDependency);
		***REMOVED***
	***REMOVED***

	applyModuleIds() ***REMOVED***
		let unusedIds = [];
		let nextFreeModuleId = 0;
		let usedIds = [];
		// TODO consider Map when performance has improved https://gist.github.com/sokra/234c077e1299b7369461f1708519c392
		const usedIdMap = Object.create(null);
		if(this.usedModuleIds) ***REMOVED***
			Object.keys(this.usedModuleIds).forEach(key => ***REMOVED***
				const id = this.usedModuleIds[key];
				if(!usedIdMap[id]) ***REMOVED***
					usedIds.push(id);
					usedIdMap[id] = true;
				***REMOVED***
			***REMOVED***);
		***REMOVED***

		const modules1 = this.modules;
		for(let indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) ***REMOVED***
			const module1 = modules1[indexModule1];
			if(module1.id && !usedIdMap[module1.id]) ***REMOVED***
				usedIds.push(module1.id);
				usedIdMap[module1.id] = true;
			***REMOVED***
		***REMOVED***

		if(usedIds.length > 0) ***REMOVED***
			let usedIdMax = -1;
			for(let index = 0; index < usedIds.length; index++) ***REMOVED***
				const usedIdKey = usedIds[index];

				if(typeof usedIdKey !== "number") ***REMOVED***
					continue;
				***REMOVED***

				usedIdMax = Math.max(usedIdMax, usedIdKey);
			***REMOVED***

			let lengthFreeModules = nextFreeModuleId = usedIdMax + 1;

			while(lengthFreeModules--) ***REMOVED***
				if(!usedIdMap[lengthFreeModules]) ***REMOVED***
					unusedIds.push(lengthFreeModules);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		const modules2 = this.modules;
		for(let indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) ***REMOVED***
			const module2 = modules2[indexModule2];
			if(module2.id === null) ***REMOVED***
				if(unusedIds.length > 0)
					module2.id = unusedIds.pop();
				else
					module2.id = nextFreeModuleId++;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	applyChunkIds() ***REMOVED***
		const unusedIds = [];
		let nextFreeChunkId = 0;

		function getNextFreeChunkId(usedChunkIds) ***REMOVED***
			const keyChunks = Object.keys(usedChunkIds);
			let result = -1;

			for(let index = 0; index < keyChunks.length; index++) ***REMOVED***
				const usedIdKey = keyChunks[index];
				const usedIdValue = usedChunkIds[usedIdKey];

				if(typeof usedIdValue !== "number") ***REMOVED***
					continue;
				***REMOVED***

				result = Math.max(result, usedIdValue);
			***REMOVED***

			return result;
		***REMOVED***

		if(this.usedChunkIds) ***REMOVED***
			nextFreeChunkId = getNextFreeChunkId(this.usedChunkIds) + 1;
			let index = nextFreeChunkId;
			while(index--) ***REMOVED***
				if(this.usedChunkIds[index] !== index) ***REMOVED***
					unusedIds.push(index);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		const chunks = this.chunks;
		for(let indexChunk = 0; indexChunk < chunks.length; indexChunk++) ***REMOVED***
			const chunk = chunks[indexChunk];
			if(chunk.id === null) ***REMOVED***
				if(unusedIds.length > 0)
					chunk.id = unusedIds.pop();
				else
					chunk.id = nextFreeChunkId++;
			***REMOVED***
			if(!chunk.ids) ***REMOVED***
				chunk.ids = [chunk.id];
			***REMOVED***
		***REMOVED***
	***REMOVED***

	sortItemsWithModuleIds() ***REMOVED***
		this.modules.sort(byId);

		const modules = this.modules;
		for(let indexModule = 0; indexModule < modules.length; indexModule++) ***REMOVED***
			modules[indexModule].sortItems(false);
		***REMOVED***

		const chunks = this.chunks;
		for(let indexChunk = 0; indexChunk < chunks.length; indexChunk++) ***REMOVED***
			chunks[indexChunk].sortItems();
		***REMOVED***
	***REMOVED***

	sortItemsWithChunkIds() ***REMOVED***
		this.chunks.sort(byId);

		const modules = this.modules;
		for(let indexModule = 0; indexModule < modules.length; indexModule++) ***REMOVED***
			modules[indexModule].sortItems(true);
		***REMOVED***

		const chunks = this.chunks;
		for(let indexChunk = 0; indexChunk < chunks.length; indexChunk++) ***REMOVED***
			chunks[indexChunk].sortItems();
		***REMOVED***

		const byMessage = (a, b) => ***REMOVED***
			const ma = `$***REMOVED***a.message***REMOVED***`;
			const mb = `$***REMOVED***b.message***REMOVED***`;
			if(ma < mb) return -1;
			if(mb < ma) return 1;
			return 0;
		***REMOVED***;

		this.errors.sort(byMessage);
		this.warnings.sort(byMessage);
	***REMOVED***

	summarizeDependencies() ***REMOVED***
		function filterDups(array) ***REMOVED***
			const newArray = [];
			for(let i = 0; i < array.length; i++) ***REMOVED***
				if(i === 0 || array[i - 1] !== array[i])
					newArray.push(array[i]);
			***REMOVED***
			return newArray;
		***REMOVED***
		this.fileDependencies = (this.compilationDependencies || []).slice();
		this.contextDependencies = [];
		this.missingDependencies = [];

		const children = this.children;
		for(let indexChildren = 0; indexChildren < children.length; indexChildren++) ***REMOVED***
			const child = children[indexChildren];

			this.fileDependencies = this.fileDependencies.concat(child.fileDependencies);
			this.contextDependencies = this.contextDependencies.concat(child.contextDependencies);
			this.missingDependencies = this.missingDependencies.concat(child.missingDependencies);
		***REMOVED***

		const modules = this.modules;
		for(let indexModule = 0; indexModule < modules.length; indexModule++) ***REMOVED***
			const module = modules[indexModule];

			if(module.fileDependencies) ***REMOVED***
				const fileDependencies = module.fileDependencies;
				for(let indexFileDep = 0; indexFileDep < fileDependencies.length; indexFileDep++) ***REMOVED***
					this.fileDependencies.push(fileDependencies[indexFileDep]);
				***REMOVED***
			***REMOVED***
			if(module.contextDependencies) ***REMOVED***
				const contextDependencies = module.contextDependencies;
				for(let indexContextDep = 0; indexContextDep < contextDependencies.length; indexContextDep++) ***REMOVED***
					this.contextDependencies.push(contextDependencies[indexContextDep]);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		this.errors.forEach(error => ***REMOVED***
			if(Array.isArray(error.missing)) ***REMOVED***
				error.missing.forEach(item => this.missingDependencies.push(item));
			***REMOVED***
		***REMOVED***);
		this.fileDependencies.sort();
		this.fileDependencies = filterDups(this.fileDependencies);
		this.contextDependencies.sort();
		this.contextDependencies = filterDups(this.contextDependencies);
		this.missingDependencies.sort();
		this.missingDependencies = filterDups(this.missingDependencies);
	***REMOVED***

	createHash() ***REMOVED***
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = crypto.createHash(hashFunction);
		if(outputOptions.hashSalt)
			hash.update(outputOptions.hashSalt);
		this.mainTemplate.updateHash(hash);
		this.chunkTemplate.updateHash(hash);
		this.moduleTemplate.updateHash(hash);
		this.children.forEach(function(child) ***REMOVED***
			hash.update(child.hash);
		***REMOVED***);
		this.warnings.forEach(function(warning) ***REMOVED***
			hash.update(`$***REMOVED***warning.message***REMOVED***`);
		***REMOVED***);
		this.errors.forEach(function(error) ***REMOVED***
			hash.update(`$***REMOVED***error.message***REMOVED***`);
		***REMOVED***);
		// clone needed as sort below is inplace mutation
		const chunks = this.chunks.slice();
		/**
		 * sort here will bring all "falsy" values to the beginning
		 * this is needed as the "hasRuntime()" chunks are dependent on the
		 * hashes of the non-runtime chunks.
		 */
		chunks.sort((a, b) => ***REMOVED***
			const aEntry = a.hasRuntime();
			const bEntry = b.hasRuntime();
			if(aEntry && !bEntry) return 1;
			if(!aEntry && bEntry) return -1;
			return 0;
		***REMOVED***);
		for(let i = 0; i < chunks.length; i++) ***REMOVED***
			const chunk = chunks[i];
			const chunkHash = crypto.createHash(hashFunction);
			if(outputOptions.hashSalt)
				chunkHash.update(outputOptions.hashSalt);
			chunk.updateHash(chunkHash);
			if(chunk.hasRuntime()) ***REMOVED***
				this.mainTemplate.updateHashForChunk(chunkHash, chunk);
			***REMOVED*** else ***REMOVED***
				this.chunkTemplate.updateHashForChunk(chunkHash, chunk);
			***REMOVED***
			this.applyPlugins2("chunk-hash", chunk, chunkHash);
			chunk.hash = chunkHash.digest(hashDigest);
			hash.update(chunk.hash);
			chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
		***REMOVED***
		this.fullHash = hash.digest(hashDigest);
		this.hash = this.fullHash.substr(0, hashDigestLength);
	***REMOVED***

	modifyHash(update) ***REMOVED***
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = crypto.createHash(hashFunction);
		hash.update(this.fullHash);
		hash.update(update);
		this.fullHash = hash.digest(hashDigest);
		this.hash = this.fullHash.substr(0, hashDigestLength);
	***REMOVED***

	createModuleAssets() ***REMOVED***
		for(let i = 0; i < this.modules.length; i++) ***REMOVED***
			const module = this.modules[i];
			if(module.assets) ***REMOVED***
				Object.keys(module.assets).forEach((assetName) => ***REMOVED***
					const fileName = this.getPath(assetName);
					this.assets[fileName] = module.assets[assetName];
					this.applyPlugins2("module-asset", module, fileName);
				***REMOVED***);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	createChunkAssets() ***REMOVED***
		const outputOptions = this.outputOptions;
		const filename = outputOptions.filename;
		const chunkFilename = outputOptions.chunkFilename;
		for(let i = 0; i < this.chunks.length; i++) ***REMOVED***
			const chunk = this.chunks[i];
			chunk.files = [];
			const chunkHash = chunk.hash;
			let source;
			let file;
			const filenameTemplate = chunk.filenameTemplate ? chunk.filenameTemplate :
				chunk.isInitial() ? filename :
				chunkFilename;
			try ***REMOVED***
				const useChunkHash = !chunk.hasRuntime() || (this.mainTemplate.useChunkHash && this.mainTemplate.useChunkHash(chunk));
				const usedHash = useChunkHash ? chunkHash : this.fullHash;
				const cacheName = "c" + chunk.id;
				if(this.cache && this.cache[cacheName] && this.cache[cacheName].hash === usedHash) ***REMOVED***
					source = this.cache[cacheName].source;
				***REMOVED*** else ***REMOVED***
					if(chunk.hasRuntime()) ***REMOVED***
						source = this.mainTemplate.render(this.hash, chunk, this.moduleTemplate, this.dependencyTemplates);
					***REMOVED*** else ***REMOVED***
						source = this.chunkTemplate.render(chunk, this.moduleTemplate, this.dependencyTemplates);
					***REMOVED***
					if(this.cache) ***REMOVED***
						this.cache[cacheName] = ***REMOVED***
							hash: usedHash,
							source: source = (source instanceof CachedSource ? source : new CachedSource(source))
						***REMOVED***;
					***REMOVED***
				***REMOVED***
				file = this.getPath(filenameTemplate, ***REMOVED***
					noChunkHash: !useChunkHash,
					chunk
				***REMOVED***);
				if(this.assets[file])
					throw new Error(`Conflict: Multiple assets emit to the same filename $***REMOVED***file***REMOVED***`);
				this.assets[file] = source;
				chunk.files.push(file);
				this.applyPlugins2("chunk-asset", chunk, file);
			***REMOVED*** catch(err) ***REMOVED***
				this.errors.push(new ChunkRenderError(chunk, file || filenameTemplate, err));
			***REMOVED***
		***REMOVED***
	***REMOVED***

	getPath(filename, data) ***REMOVED***
		data = data || ***REMOVED******REMOVED***;
		data.hash = data.hash || this.hash;
		return this.mainTemplate.applyPluginsWaterfall("asset-path", filename, data);
	***REMOVED***

	createChildCompiler(name, outputOptions, plugins) ***REMOVED***
		const idx = (this.childrenCounters[name] || 0);
		this.childrenCounters[name] = idx + 1;
		return this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);
	***REMOVED***

	checkConstraints() ***REMOVED***
		const usedIds = ***REMOVED******REMOVED***;

		const modules = this.modules;
		for(let indexModule = 0; indexModule < modules.length; indexModule++) ***REMOVED***
			const moduleId = modules[indexModule].id;

			if(usedIds[moduleId])
				throw new Error(`checkConstraints: duplicate module id $***REMOVED***moduleId***REMOVED***`);
		***REMOVED***

		const chunks = this.chunks;
		for(let indexChunk = 0; indexChunk < chunks.length; indexChunk++) ***REMOVED***
			const chunk = chunks[indexChunk];

			if(chunks.indexOf(chunk) !== indexChunk)
				throw new Error(`checkConstraints: duplicate chunk in compilation $***REMOVED***chunk.debugId***REMOVED***`);
			chunk.checkConstraints();
		***REMOVED***
	***REMOVED***
***REMOVED***

module.exports = Compilation;
