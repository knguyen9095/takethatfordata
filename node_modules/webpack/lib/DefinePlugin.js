/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const ConstDependency = require("./dependencies/ConstDependency");
const BasicEvaluatedExpression = require("./BasicEvaluatedExpression");
const ParserHelpers = require("./ParserHelpers");
const NullFactory = require("./NullFactory");

class DefinePlugin ***REMOVED***
	constructor(definitions) ***REMOVED***
		this.definitions = definitions;
	***REMOVED***

	apply(compiler) ***REMOVED***
		const definitions = this.definitions;
		compiler.plugin("compilation", (compilation, params) => ***REMOVED***
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

			params.normalModuleFactory.plugin("parser", (parser) => ***REMOVED***
				(function walkDefinitions(definitions, prefix) ***REMOVED***
					Object.keys(definitions).forEach((key) => ***REMOVED***
						const code = definitions[key];
						if(code && typeof code === "object" && !(code instanceof RegExp)) ***REMOVED***
							walkDefinitions(code, prefix + key + ".");
							applyObjectDefine(prefix + key, code);
							return;
						***REMOVED***
						applyDefineKey(prefix, key);
						applyDefine(prefix + key, code);
					***REMOVED***);
				***REMOVED***(definitions, ""));

				function stringifyObj(obj) ***REMOVED***
					return "Object(***REMOVED***" + Object.keys(obj).map((key) => ***REMOVED***
						const code = obj[key];
						return JSON.stringify(key) + ":" + toCode(code);
					***REMOVED***).join(",") + "***REMOVED***)";
				***REMOVED***

				function toCode(code) ***REMOVED***
					if(code === null) return "null";
					else if(code === undefined) return "undefined";
					else if(code instanceof RegExp && code.toString) return code.toString();
					else if(typeof code === "function" && code.toString) return "(" + code.toString() + ")";
					else if(typeof code === "object") return stringifyObj(code);
					else return code + "";
				***REMOVED***

				function applyDefineKey(prefix, key) ***REMOVED***
					const splittedKey = key.split(".");
					splittedKey.slice(1).forEach((_, i) => ***REMOVED***
						const fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
						parser.plugin("can-rename " + fullKey, ParserHelpers.approve);
					***REMOVED***);
				***REMOVED***

				function applyDefine(key, code) ***REMOVED***
					const isTypeof = /^typeof\s+/.test(key);
					if(isTypeof) key = key.replace(/^typeof\s+/, "");
					let recurse = false;
					let recurseTypeof = false;
					code = toCode(code);
					if(!isTypeof) ***REMOVED***
						parser.plugin("can-rename " + key, ParserHelpers.approve);
						parser.plugin("evaluate Identifier " + key, (expr) => ***REMOVED***
							/**
							 * this is needed in case there is a recursion in the DefinePlugin
							 * to prevent an endless recursion
							 * e.g.: new DefinePlugin(***REMOVED***
							 * "a": "b",
							 * "b": "a"
							 * ***REMOVED***);
							 */
							if(recurse) return;
							recurse = true;
							const res = parser.evaluate(code);
							recurse = false;
							res.setRange(expr.range);
							return res;
						***REMOVED***);
						parser.plugin("expression " + key, ParserHelpers.toConstantDependency(code));
					***REMOVED***
					const typeofCode = isTypeof ? code : "typeof (" + code + ")";
					parser.plugin("evaluate typeof " + key, (expr) => ***REMOVED***
						/**
						 * this is needed in case there is a recursion in the DefinePlugin
						 * to prevent an endless recursion
						 * e.g.: new DefinePlugin(***REMOVED***
						 * "typeof a": "tyepof b",
						 * "typeof b": "typeof a"
						 * ***REMOVED***);
						 */
						if(recurseTypeof) return;
						recurseTypeof = true;
						const res = parser.evaluate(typeofCode);
						recurseTypeof = false;
						res.setRange(expr.range);
						return res;
					***REMOVED***);
					parser.plugin("typeof " + key, (expr) => ***REMOVED***
						const res = parser.evaluate(typeofCode);
						if(!res.isString()) return;
						return ParserHelpers.toConstantDependency(JSON.stringify(res.string)).bind(parser)(expr);
					***REMOVED***);
				***REMOVED***

				function applyObjectDefine(key, obj) ***REMOVED***
					const code = stringifyObj(obj);
					parser.plugin("can-rename " + key, ParserHelpers.approve);
					parser.plugin("evaluate Identifier " + key, (expr) => new BasicEvaluatedExpression().setTruthy().setRange(expr.range));
					parser.plugin("evaluate typeof " + key, ParserHelpers.evaluateToString("object"));
					parser.plugin("expression " + key, ParserHelpers.toConstantDependency(code));
					parser.plugin("typeof " + key, ParserHelpers.toConstantDependency(JSON.stringify("object")));
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***
module.exports = DefinePlugin;
