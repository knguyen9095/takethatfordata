/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sean Larkin @thelarkinn
*/
"use strict";
const EntrypointsOverSizeLimitWarning = require("./EntrypointsOverSizeLimitWarning");
const AssetsOverSizeLimitWarning = require("./AssetsOverSizeLimitWarning");
const NoAsyncChunksWarning = require("./NoAsyncChunksWarning");

module.exports = class SizeLimitsPlugin ***REMOVED***
	constructor(options) ***REMOVED***
		this.hints = options.hints;
		this.maxAssetSize = options.maxAssetSize;
		this.maxEntrypointSize = options.maxEntrypointSize;
		this.assetFilter = options.assetFilter;
	***REMOVED***
	apply(compiler) ***REMOVED***
		const entrypointSizeLimit = this.maxEntrypointSize;
		const assetSizeLimit = this.maxAssetSize;
		const hints = this.hints;
		const assetFilter = this.assetFilter || (asset => !(/\.map$/.test(asset)));

		compiler.plugin("after-emit", (compilation, callback) => ***REMOVED***
			const warnings = [];

			const getEntrypointSize = entrypoint =>
				entrypoint.getFiles()
				.filter(assetFilter)
				.map(file => compilation.assets[file])
				.filter(Boolean)
				.map(asset => asset.size())
				.reduce((currentSize, nextSize) => currentSize + nextSize, 0);

			const assetsOverSizeLimit = [];
			Object.keys(compilation.assets)
				.filter(assetFilter)
				.forEach(assetName => ***REMOVED***
					const asset = compilation.assets[assetName];
					const size = asset.size();

					if(size > assetSizeLimit) ***REMOVED***
						assetsOverSizeLimit.push(***REMOVED***
							name: assetName,
							size: size,
						***REMOVED***);
						asset.isOverSizeLimit = true;
					***REMOVED***
				***REMOVED***);

			const entrypointsOverLimit = [];
			Object.keys(compilation.entrypoints)
				.forEach(key => ***REMOVED***
					const entry = compilation.entrypoints[key];
					const size = getEntrypointSize(entry, compilation);

					if(size > entrypointSizeLimit) ***REMOVED***
						entrypointsOverLimit.push(***REMOVED***
							name: key,
							size: size,
							files: entry.getFiles().filter(assetFilter)
						***REMOVED***);
						entry.isOverSizeLimit = true;
					***REMOVED***
				***REMOVED***);

			if(hints) ***REMOVED***
				// 1. Individual Chunk: Size < 250kb
				// 2. Collective Initial Chunks [entrypoint] (Each Set?): Size < 250kb
				// 3. No Async Chunks
				// if !1, then 2, if !2 return
				if(assetsOverSizeLimit.length > 0) ***REMOVED***
					warnings.push(
						new AssetsOverSizeLimitWarning(
							assetsOverSizeLimit,
							assetSizeLimit));
				***REMOVED***
				if(entrypointsOverLimit.length > 0) ***REMOVED***
					warnings.push(
						new EntrypointsOverSizeLimitWarning(
							entrypointsOverLimit,
							entrypointSizeLimit));
				***REMOVED***

				if(warnings.length > 0) ***REMOVED***
					const hasAsyncChunks = compilation.chunks.filter(chunk => !chunk.isInitial()).length > 0;

					if(!hasAsyncChunks) ***REMOVED***
						warnings.push(new NoAsyncChunksWarning());
					***REMOVED***

					if(hints === "error") ***REMOVED***
						Array.prototype.push.apply(compilation.errors, warnings);
					***REMOVED*** else ***REMOVED***
						Array.prototype.push.apply(compilation.warnings, warnings);
					***REMOVED***
				***REMOVED***
			***REMOVED***

			callback();
		***REMOVED***);
	***REMOVED***
***REMOVED***;
