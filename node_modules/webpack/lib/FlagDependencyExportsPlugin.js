/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

class FlagDependencyExportsPlugin ***REMOVED***

	apply(compiler) ***REMOVED***
		compiler.plugin("compilation", (compilation) => ***REMOVED***
			compilation.plugin("finish-modules", (modules) => ***REMOVED***
				const dependencies = Object.create(null);

				let module;
				let moduleWithExports;
				let moduleProvidedExports;
				const queue = modules.filter((m) => !m.providedExports);
				for(let i = 0; i < queue.length; i++) ***REMOVED***
					module = queue[i];

					if(module.providedExports !== true) ***REMOVED***
						moduleWithExports = module.meta && module.meta.harmonyModule;
						moduleProvidedExports = Array.isArray(module.providedExports) ? new Set(module.providedExports) : new Set();
						processDependenciesBlock(module);
						if(!moduleWithExports) ***REMOVED***
							module.providedExports = true;
							notifyDependencies();
						***REMOVED*** else if(module.providedExports !== true) ***REMOVED***
							module.providedExports = Array.from(moduleProvidedExports);
						***REMOVED***
					***REMOVED***
				***REMOVED***

				function processDependenciesBlock(depBlock) ***REMOVED***
					depBlock.dependencies.forEach((dep) => processDependency(dep));
					depBlock.variables.forEach((variable) => ***REMOVED***
						variable.dependencies.forEach((dep) => processDependency(dep));
					***REMOVED***);
					depBlock.blocks.forEach(processDependenciesBlock);
				***REMOVED***

				function processDependency(dep) ***REMOVED***
					const exportDesc = dep.getExports && dep.getExports();
					if(!exportDesc) return;
					moduleWithExports = true;
					const exports = exportDesc.exports;
					const exportDeps = exportDesc.dependencies;
					if(exportDeps) ***REMOVED***
						exportDeps.forEach((dep) => ***REMOVED***
							const depIdent = dep.identifier();
							// if this was not yet initialized
							// initialize it as an array containing the module and stop
							const array = dependencies[depIdent];
							if(!array) ***REMOVED***
								dependencies[depIdent] = [module];
								return;
							***REMOVED***

							// check if this module is known
							// if not, add it to the dependencies for this identifier
							if(array.indexOf(module) < 0)
								array.push(module);
						***REMOVED***);
					***REMOVED***
					let changed = false;
					if(module.providedExports !== true) ***REMOVED***
						if(exports === true) ***REMOVED***
							module.providedExports = true;
							changed = true;
						***REMOVED*** else if(Array.isArray(exports)) ***REMOVED***
							changed = addToSet(moduleProvidedExports, exports);
						***REMOVED***
					***REMOVED***
					if(changed) ***REMOVED***
						notifyDependencies();
					***REMOVED***
				***REMOVED***

				function notifyDependencies() ***REMOVED***
					const deps = dependencies[module.identifier()];
					if(deps) ***REMOVED***
						deps.forEach((dep) => queue.push(dep));
					***REMOVED***
				***REMOVED***
			***REMOVED***);

			function addToSet(a, b) ***REMOVED***
				let changed = false;
				b.forEach((item) => ***REMOVED***
					if(!a.has(item)) ***REMOVED***
						a.add(item);
						changed = true;
					***REMOVED***
				***REMOVED***);
				return changed;
			***REMOVED***
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = FlagDependencyExportsPlugin;
