/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*
<rules>: <rule>
<rules>: [<rule>]
<rule>: ***REMOVED***
	resource: ***REMOVED***
		test: <condition>,
		include: <condition>,
		exclude: <condition>,
	***REMOVED***,
	resource: <condition>, -> resource.test
	test: <condition>, -> resource.test
	include: <condition>, -> resource.include
	exclude: <condition>, -> resource.exclude
	resourceQuery: <condition>,
	compiler: <condition>,
	issuer: <condition>,
	use: "loader", -> use[0].loader
	loader: <>, -> use[0].loader
	loaders: <>, -> use
	options: ***REMOVED******REMOVED***, -> use[0].options,
	query: ***REMOVED******REMOVED***, -> options
	parser: ***REMOVED******REMOVED***,
	use: [
		"loader" -> use[x].loader
	],
	use: [
		***REMOVED***
			loader: "loader",
			options: ***REMOVED******REMOVED***
		***REMOVED***
	],
	rules: [
		<rule>
	],
	oneOf: [
		<rule>
	]
***REMOVED***

<condition>: /regExp/
<condition>: function(arg) ***REMOVED******REMOVED***
<condition>: "starting"
<condition>: [<condition>] // or
<condition>: ***REMOVED*** and: [<condition>] ***REMOVED***
<condition>: ***REMOVED*** or: [<condition>] ***REMOVED***
<condition>: ***REMOVED*** not: [<condition>] ***REMOVED***
<condition>: ***REMOVED*** test: <condition>, include: <condition>, exclude: <condition> ***REMOVED***


normalized:

***REMOVED***
	resource: function(),
	resourceQuery: function(),
	compiler: function(),
	issuer: function(),
	use: [
		***REMOVED***
			loader: string,
			options: string,
			<any>: <any>
		***REMOVED***
	],
	rules: [<rule>],
	oneOf: [<rule>],
	<any>: <any>,
***REMOVED***

*/

"use strict";

module.exports = class RuleSet ***REMOVED***
	constructor(rules) ***REMOVED***
		this.references = Object.create(null);
		this.rules = RuleSet.normalizeRules(rules, this.references, "ref-");
	***REMOVED***

	static normalizeRules(rules, refs, ident) ***REMOVED***
		if(Array.isArray(rules)) ***REMOVED***
			return rules.map((rule, idx) => ***REMOVED***
				return RuleSet.normalizeRule(rule, refs, `$***REMOVED***ident***REMOVED***-$***REMOVED***idx***REMOVED***`);
			***REMOVED***);
		***REMOVED*** else if(rules) ***REMOVED***
			return [RuleSet.normalizeRule(rules, refs, ident)];
		***REMOVED*** else ***REMOVED***
			return [];
		***REMOVED***
	***REMOVED***

	static normalizeRule(rule, refs, ident) ***REMOVED***
		if(typeof rule === "string")
			return ***REMOVED***
				use: [***REMOVED***
					loader: rule
				***REMOVED***]
			***REMOVED***;
		if(!rule)
			throw new Error("Unexcepted null when object was expected as rule");
		if(typeof rule !== "object")
			throw new Error("Unexcepted " + typeof rule + " when object was expected as rule (" + rule + ")");

		const newRule = ***REMOVED******REMOVED***;
		let useSource;
		let resourceSource;
		let condition;

		if(rule.test || rule.include || rule.exclude) ***REMOVED***
			checkResourceSource("test + include + exclude");
			condition = ***REMOVED***
				test: rule.test,
				include: rule.include,
				exclude: rule.exclude
			***REMOVED***;
			try ***REMOVED***
				newRule.resource = RuleSet.normalizeCondition(condition);
			***REMOVED*** catch(error) ***REMOVED***
				throw new Error(RuleSet.buildErrorMessage(condition, error));
			***REMOVED***
		***REMOVED***

		if(rule.resource) ***REMOVED***
			checkResourceSource("resource");
			try ***REMOVED***
				newRule.resource = RuleSet.normalizeCondition(rule.resource);
			***REMOVED*** catch(error) ***REMOVED***
				throw new Error(RuleSet.buildErrorMessage(rule.resource, error));
			***REMOVED***
		***REMOVED***

		if(rule.resourceQuery) ***REMOVED***
			try ***REMOVED***
				newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);
			***REMOVED*** catch(error) ***REMOVED***
				throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));
			***REMOVED***
		***REMOVED***

		if(rule.compiler) ***REMOVED***
			try ***REMOVED***
				newRule.compiler = RuleSet.normalizeCondition(rule.compiler);
			***REMOVED*** catch(error) ***REMOVED***
				throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));
			***REMOVED***
		***REMOVED***

		if(rule.issuer) ***REMOVED***
			try ***REMOVED***
				newRule.issuer = RuleSet.normalizeCondition(rule.issuer);
			***REMOVED*** catch(error) ***REMOVED***
				throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));
			***REMOVED***
		***REMOVED***

		if(rule.loader && rule.loaders)
			throw new Error(RuleSet.buildErrorMessage(rule, new Error("Provided loader and loaders for rule (use only one of them)")));

		const loader = rule.loaders || rule.loader;
		if(typeof loader === "string" && !rule.options && !rule.query) ***REMOVED***
			checkUseSource("loader");
			newRule.use = RuleSet.normalizeUse(loader.split("!"), ident);
		***REMOVED*** else if(typeof loader === "string" && (rule.options || rule.query)) ***REMOVED***
			checkUseSource("loader + options/query");
			newRule.use = RuleSet.normalizeUse(***REMOVED***
				loader: loader,
				options: rule.options,
				query: rule.query
			***REMOVED***, ident);
		***REMOVED*** else if(loader && (rule.options || rule.query)) ***REMOVED***
			throw new Error(RuleSet.buildErrorMessage(rule, new Error("options/query cannot be used with loaders (use options for each array item)")));
		***REMOVED*** else if(loader) ***REMOVED***
			checkUseSource("loaders");
			newRule.use = RuleSet.normalizeUse(loader, ident);
		***REMOVED*** else if(rule.options || rule.query) ***REMOVED***
			throw new Error(RuleSet.buildErrorMessage(rule, new Error("options/query provided without loader (use loader + options)")));
		***REMOVED***

		if(rule.use) ***REMOVED***
			checkUseSource("use");
			newRule.use = RuleSet.normalizeUse(rule.use, ident);
		***REMOVED***

		if(rule.rules)
			newRule.rules = RuleSet.normalizeRules(rule.rules, refs, `$***REMOVED***ident***REMOVED***-rules`);

		if(rule.oneOf)
			newRule.oneOf = RuleSet.normalizeRules(rule.oneOf, refs, `$***REMOVED***ident***REMOVED***-oneOf`);

		const keys = Object.keys(rule).filter((key) => ***REMOVED***
			return ["resource", "resourceQuery", "compiler", "test", "include", "exclude", "issuer", "loader", "options", "query", "loaders", "use", "rules", "oneOf"].indexOf(key) < 0;
		***REMOVED***);
		keys.forEach((key) => ***REMOVED***
			newRule[key] = rule[key];
		***REMOVED***);

		function checkUseSource(newSource) ***REMOVED***
			if(useSource && useSource !== newSource)
				throw new Error(RuleSet.buildErrorMessage(rule, new Error("Rule can only have one result source (provided " + newSource + " and " + useSource + ")")));
			useSource = newSource;
		***REMOVED***

		function checkResourceSource(newSource) ***REMOVED***
			if(resourceSource && resourceSource !== newSource)
				throw new Error(RuleSet.buildErrorMessage(rule, new Error("Rule can only have one resource source (provided " + newSource + " and " + resourceSource + ")")));
			resourceSource = newSource;
		***REMOVED***

		if(Array.isArray(newRule.use)) ***REMOVED***
			newRule.use.forEach((item) => ***REMOVED***
				if(item.ident) ***REMOVED***
					refs[item.ident] = item.options;
				***REMOVED***
			***REMOVED***);
		***REMOVED***

		return newRule;
	***REMOVED***

	static buildErrorMessage(condition, error) ***REMOVED***
		const conditionAsText = JSON.stringify(condition, (key, value) => ***REMOVED***
			return value === undefined ? "undefined" : value;
		***REMOVED***, 2);
		return error.message + " in " + conditionAsText;
	***REMOVED***

	static normalizeUse(use, ident) ***REMOVED***
		if(Array.isArray(use)) ***REMOVED***
			return use
				.map((item, idx) => RuleSet.normalizeUse(item, `$***REMOVED***ident***REMOVED***-$***REMOVED***idx***REMOVED***`))
				.reduce((arr, items) => arr.concat(items), []);
		***REMOVED***
		return [RuleSet.normalizeUseItem(use, ident)];
	***REMOVED***

	static normalizeUseItemFunction(use, data) ***REMOVED***
		const result = use(data);
		if(typeof result === "string") ***REMOVED***
			return RuleSet.normalizeUseItem(result);
		***REMOVED***
		return result;
	***REMOVED***

	static normalizeUseItemString(useItemString) ***REMOVED***
		const idx = useItemString.indexOf("?");
		if(idx >= 0) ***REMOVED***
			return ***REMOVED***
				loader: useItemString.substr(0, idx),
				options: useItemString.substr(idx + 1)
			***REMOVED***;
		***REMOVED***
		return ***REMOVED***
			loader: useItemString
		***REMOVED***;
	***REMOVED***

	static normalizeUseItem(item, ident) ***REMOVED***
		if(typeof item === "function")
			return item;

		if(typeof item === "string") ***REMOVED***
			return RuleSet.normalizeUseItemString(item);
		***REMOVED***

		const newItem = ***REMOVED******REMOVED***;

		if(item.options && item.query)
			throw new Error("Provided options and query in use");

		if(!item.loader)
			throw new Error("No loader specified");

		newItem.options = item.options || item.query;

		if(typeof newItem.options === "object" && newItem.options) ***REMOVED***
			if(newItem.options.ident)
				newItem.ident = newItem.options.ident;
			else
				newItem.ident = ident;
		***REMOVED***

		const keys = Object.keys(item).filter(function(key) ***REMOVED***
			return ["options", "query"].indexOf(key) < 0;
		***REMOVED***);

		keys.forEach(function(key) ***REMOVED***
			newItem[key] = item[key];
		***REMOVED***);

		return newItem;
	***REMOVED***

	static normalizeCondition(condition) ***REMOVED***
		if(!condition)
			throw new Error("Expected condition but got falsy value");
		if(typeof condition === "string") ***REMOVED***
			return str => str.indexOf(condition) === 0;
		***REMOVED***
		if(typeof condition === "function") ***REMOVED***
			return condition;
		***REMOVED***
		if(condition instanceof RegExp) ***REMOVED***
			return condition.test.bind(condition);
		***REMOVED***
		if(Array.isArray(condition)) ***REMOVED***
			const items = condition.map(c => RuleSet.normalizeCondition(c));
			return orMatcher(items);
		***REMOVED***
		if(typeof condition !== "object")
			throw Error("Unexcepted " + typeof condition + " when condition was expected (" + condition + ")");

		const matchers = [];
		Object.keys(condition).forEach(key => ***REMOVED***
			const value = condition[key];
			switch(key) ***REMOVED***
				case "or":
				case "include":
				case "test":
					if(value)
						matchers.push(RuleSet.normalizeCondition(value));
					break;
				case "and":
					if(value) ***REMOVED***
						const items = value.map(c => RuleSet.normalizeCondition(c));
						matchers.push(andMatcher(items));
					***REMOVED***
					break;
				case "not":
				case "exclude":
					if(value) ***REMOVED***
						const matcher = RuleSet.normalizeCondition(value);
						matchers.push(notMatcher(matcher));
					***REMOVED***
					break;
				default:
					throw new Error("Unexcepted property " + key + " in condition");
			***REMOVED***
		***REMOVED***);
		if(matchers.length === 0)
			throw new Error("Excepted condition but got " + condition);
		if(matchers.length === 1)
			return matchers[0];
		return andMatcher(matchers);
	***REMOVED***

	exec(data) ***REMOVED***
		const result = [];
		this._run(data, ***REMOVED***
			rules: this.rules
		***REMOVED***, result);
		return result;
	***REMOVED***

	_run(data, rule, result) ***REMOVED***
		// test conditions
		if(rule.resource && !data.resource)
			return false;
		if(rule.resourceQuery && !data.resourceQuery)
			return false;
		if(rule.compiler && !data.compiler)
			return false;
		if(rule.issuer && !data.issuer)
			return false;
		if(rule.resource && !rule.resource(data.resource))
			return false;
		if(data.issuer && rule.issuer && !rule.issuer(data.issuer))
			return false;
		if(data.resourceQuery && rule.resourceQuery && !rule.resourceQuery(data.resourceQuery))
			return false;
		if(data.compiler && rule.compiler && !rule.compiler(data.compiler))
			return false;

		// apply
		const keys = Object.keys(rule).filter((key) => ***REMOVED***
			return ["resource", "resourceQuery", "compiler", "issuer", "rules", "oneOf", "use", "enforce"].indexOf(key) < 0;
		***REMOVED***);
		keys.forEach((key) => ***REMOVED***
			result.push(***REMOVED***
				type: key,
				value: rule[key]
			***REMOVED***);
		***REMOVED***);

		if(rule.use) ***REMOVED***
			rule.use.forEach((use) => ***REMOVED***
				result.push(***REMOVED***
					type: "use",
					value: typeof use === "function" ? RuleSet.normalizeUseItemFunction(use, data) : use,
					enforce: rule.enforce
				***REMOVED***);
			***REMOVED***);
		***REMOVED***

		if(rule.rules) ***REMOVED***
			for(let i = 0; i < rule.rules.length; i++) ***REMOVED***
				this._run(data, rule.rules[i], result);
			***REMOVED***
		***REMOVED***

		if(rule.oneOf) ***REMOVED***
			for(let i = 0; i < rule.oneOf.length; i++) ***REMOVED***
				if(this._run(data, rule.oneOf[i], result))
					break;
			***REMOVED***
		***REMOVED***

		return true;
	***REMOVED***

	findOptionsByIdent(ident) ***REMOVED***
		const options = this.references[ident];
		if(!options) throw new Error("Can't find options with ident '" + ident + "'");
		return options;
	***REMOVED***
***REMOVED***;

function notMatcher(matcher) ***REMOVED***
	return function(str) ***REMOVED***
		return !matcher(str);
	***REMOVED***;
***REMOVED***

function orMatcher(items) ***REMOVED***
	return function(str) ***REMOVED***
		for(let i = 0; i < items.length; i++) ***REMOVED***
			if(items[i](str))
				return true;
		***REMOVED***
		return false;
	***REMOVED***;
***REMOVED***

function andMatcher(items) ***REMOVED***
	return function(str) ***REMOVED***
		for(let i = 0; i < items.length; i++) ***REMOVED***
			if(!items[i](str))
				return false;
		***REMOVED***
		return true;
	***REMOVED***;
***REMOVED***
