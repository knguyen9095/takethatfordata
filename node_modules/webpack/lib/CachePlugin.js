/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const asyncLib = require("async");

class CachePlugin ***REMOVED***
	constructor(cache) ***REMOVED***
		this.cache = cache || ***REMOVED******REMOVED***;
		this.FS_ACCURENCY = 2000;
	***REMOVED***

	apply(compiler) ***REMOVED***
		if(Array.isArray(compiler.compilers)) ***REMOVED***
			compiler.compilers.forEach((c, idx) => ***REMOVED***
				c.apply(new CachePlugin(this.cache[idx] = this.cache[idx] || ***REMOVED******REMOVED***));
			***REMOVED***);
		***REMOVED*** else ***REMOVED***
			const registerCacheToCompiler = (compiler, cache) => ***REMOVED***
				compiler.plugin("this-compilation", compilation => ***REMOVED***
					// TODO remove notCacheable for webpack 4
					if(!compilation.notCacheable) ***REMOVED***
						compilation.cache = cache;
						compilation.plugin("child-compiler", (childCompiler, compilerName, compilerIndex) => ***REMOVED***
							if(cache) ***REMOVED***
								let childCache;
								if(!cache.children) cache.children = ***REMOVED******REMOVED***;
								if(!cache.children[compilerName]) cache.children[compilerName] = [];
								if(cache.children[compilerName][compilerIndex])
									childCache = cache.children[compilerName][compilerIndex];
								else
									cache.children[compilerName].push(childCache = ***REMOVED******REMOVED***);
								registerCacheToCompiler(childCompiler, childCache);
							***REMOVED***
						***REMOVED***);
					***REMOVED*** else if(this.watching) ***REMOVED***
						compilation.warnings.push(
							new Error(`CachePlugin - Cache cannot be used because of: $***REMOVED***compilation.notCacheable***REMOVED***`)
						);
					***REMOVED***
				***REMOVED***);
			***REMOVED***;
			registerCacheToCompiler(compiler, this.cache);
			compiler.plugin("watch-run", (compiler, callback) => ***REMOVED***
				this.watching = true;
				callback();
			***REMOVED***);
			compiler.plugin("run", (compiler, callback) => ***REMOVED***
				if(!compiler._lastCompilationFileDependencies) return callback();
				const fs = compiler.inputFileSystem;
				const fileTs = compiler.fileTimestamps = ***REMOVED******REMOVED***;
				asyncLib.forEach(compiler._lastCompilationFileDependencies, (file, callback) => ***REMOVED***
					fs.stat(file, (err, stat) => ***REMOVED***
						if(err) ***REMOVED***
							if(err.code === "ENOENT") return callback();
							return callback(err);
						***REMOVED***

						if(stat.mtime)
							this.applyMtime(+stat.mtime);

						fileTs[file] = +stat.mtime || Infinity;
						callback();
					***REMOVED***);
				***REMOVED***, err => ***REMOVED***
					if(err) return callback(err);
					Object.keys(fileTs).forEach(key => ***REMOVED***
						fileTs[key] += this.FS_ACCURENCY;
					***REMOVED***);
					callback();
				***REMOVED***);
			***REMOVED***);
			compiler.plugin("after-compile", function(compilation, callback) ***REMOVED***
				compilation.compiler._lastCompilationFileDependencies = compilation.fileDependencies;
				compilation.compiler._lastCompilationContextDependencies = compilation.contextDependencies;
				callback();
			***REMOVED***);
		***REMOVED***
	***REMOVED***

	/* istanbul ignore next */
	applyMtime(mtime) ***REMOVED***
		if(this.FS_ACCURENCY > 1 && mtime % 2 !== 0)
			this.FS_ACCURENCY = 1;
		else if(this.FS_ACCURENCY > 10 && mtime % 20 !== 0)
			this.FS_ACCURENCY = 10;
		else if(this.FS_ACCURENCY > 100 && mtime % 200 !== 0)
			this.FS_ACCURENCY = 100;
		else if(this.FS_ACCURENCY > 1000 && mtime % 2000 !== 0)
			this.FS_ACCURENCY = 1000;
	***REMOVED***
***REMOVED***
module.exports = CachePlugin;
