/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Gajus Kuizinas @gajus
*/
"use strict";

const WebpackError = require("./WebpackError");
const webpackOptionsSchema = require("../schemas/webpackOptionsSchema.json");

const getSchemaPart = (path, parents, additionalPath) => ***REMOVED***
	parents = parents || 0;
	path = path.split("/");
	path = path.slice(0, path.length - parents);
	if(additionalPath) ***REMOVED***
		additionalPath = additionalPath.split("/");
		path = path.concat(additionalPath);
	***REMOVED***
	let schemaPart = webpackOptionsSchema;
	for(let i = 1; i < path.length; i++) ***REMOVED***
		const inner = schemaPart[path[i]];
		if(inner)
			schemaPart = inner;
	***REMOVED***
	return schemaPart;
***REMOVED***;

const getSchemaPartText = (schemaPart, additionalPath) => ***REMOVED***
	if(additionalPath) ***REMOVED***
		for(let i = 0; i < additionalPath.length; i++) ***REMOVED***
			const inner = schemaPart[additionalPath[i]];
			if(inner)
				schemaPart = inner;
		***REMOVED***
	***REMOVED***
	while(schemaPart.$ref) schemaPart = getSchemaPart(schemaPart.$ref);
	let schemaText = WebpackOptionsValidationError.formatSchema(schemaPart);
	if(schemaPart.description)
		schemaText += `\n-> $***REMOVED***schemaPart.description***REMOVED***`;
	return schemaText;
***REMOVED***;

const getSchemaPartDescription = schemaPart => ***REMOVED***
	while(schemaPart.$ref) schemaPart = getSchemaPart(schemaPart.$ref);
	if(schemaPart.description)
		return `\n-> $***REMOVED***schemaPart.description***REMOVED***`;
	return "";
***REMOVED***;

const filterChildren = children => ***REMOVED***
	return children.filter(err => err.keyword !== "anyOf" && err.keyword !== "allOf" && err.keyword !== "oneOf");
***REMOVED***;

const indent = (str, prefix, firstLine) => ***REMOVED***
	if(firstLine) ***REMOVED***
		return prefix + str.replace(/\n(?!$)/g, "\n" + prefix);
	***REMOVED*** else ***REMOVED***
		return str.replace(/\n(?!$)/g, `\n$***REMOVED***prefix***REMOVED***`);
	***REMOVED***
***REMOVED***;

class WebpackOptionsValidationError extends WebpackError ***REMOVED***
	constructor(validationErrors) ***REMOVED***
		super();

		this.name = "WebpackOptionsValidationError";
		this.message = "Invalid configuration object. " +
			"Webpack has been initialised using a configuration object that does not match the API schema.\n" +
			validationErrors.map(err => " - " + indent(WebpackOptionsValidationError.formatValidationError(err), "   ", false)).join("\n");
		this.validationErrors = validationErrors;

		Error.captureStackTrace(this, this.constructor);
	***REMOVED***

	static formatSchema(schema, prevSchemas) ***REMOVED***
		prevSchemas = prevSchemas || [];

		const formatInnerSchema = (innerSchema, addSelf) => ***REMOVED***
			if(!addSelf) return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas);
			if(prevSchemas.indexOf(innerSchema) >= 0) return "(recursive)";
			return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas.concat(schema));
		***REMOVED***;

		if(schema.type === "string") ***REMOVED***
			if(schema.minLength === 1)
				return "non-empty string";
			else if(schema.minLength > 1)
				return `string (min length $***REMOVED***schema.minLength***REMOVED***)`;
			return "string";
		***REMOVED*** else if(schema.type === "boolean") ***REMOVED***
			return "boolean";
		***REMOVED*** else if(schema.type === "number") ***REMOVED***
			return "number";
		***REMOVED*** else if(schema.type === "object") ***REMOVED***
			if(schema.properties) ***REMOVED***
				const required = schema.required || [];
				return `object ***REMOVED*** $***REMOVED***Object.keys(schema.properties).map(property => ***REMOVED***
					if(required.indexOf(property) < 0) return property + "?";
					return property;
				***REMOVED***).concat(schema.additionalProperties ? ["..."] : []).join(", ")***REMOVED*** ***REMOVED***`;
			***REMOVED***
			if(schema.additionalProperties) ***REMOVED***
				return `object ***REMOVED*** <key>: $***REMOVED***formatInnerSchema(schema.additionalProperties)***REMOVED*** ***REMOVED***`;
			***REMOVED***
			return "object";
		***REMOVED*** else if(schema.type === "array") ***REMOVED***
			return `[$***REMOVED***formatInnerSchema(schema.items)***REMOVED***]`;
		***REMOVED***

		switch(schema.instanceof) ***REMOVED***
			case "Function":
				return "function";
			case "RegExp":
				return "RegExp";
		***REMOVED***
		if(schema.$ref) return formatInnerSchema(getSchemaPart(schema.$ref), true);
		if(schema.allOf) return schema.allOf.map(formatInnerSchema).join(" & ");
		if(schema.oneOf) return schema.oneOf.map(formatInnerSchema).join(" | ");
		if(schema.anyOf) return schema.anyOf.map(formatInnerSchema).join(" | ");
		if(schema.enum) return schema.enum.map(item => JSON.stringify(item)).join(" | ");
		return JSON.stringify(schema, 0, 2);
	***REMOVED***

	static formatValidationError(err) ***REMOVED***
		const dataPath = `configuration$***REMOVED***err.dataPath***REMOVED***`;
		if(err.keyword === "additionalProperties") ***REMOVED***
			const baseMessage = `$***REMOVED***dataPath***REMOVED*** has an unknown property '$***REMOVED***err.params.additionalProperty***REMOVED***'. These properties are valid:\n$***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***`;
			if(!err.dataPath) ***REMOVED***
				switch(err.params.additionalProperty) ***REMOVED***
					case "debug":
						return `$***REMOVED***baseMessage***REMOVED***\n` +
							"The 'debug' property was removed in webpack 2.\n" +
							"Loaders should be updated to allow passing this option via loader options in module.rules.\n" +
							"Until loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\n" +
							"plugins: [\n" +
							"  new webpack.LoaderOptionsPlugin(***REMOVED***\n" +
							"    debug: true\n" +
							"  ***REMOVED***)\n" +
							"]";
				***REMOVED***
				return baseMessage + "\n" +
					"For typos: please correct them.\n" +
					"For loader options: webpack 2 no longer allows custom properties in configuration.\n" +
					"  Loaders should be updated to allow passing options via loader options in module.rules.\n" +
					"  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\n" +
					"  plugins: [\n" +
					"    new webpack.LoaderOptionsPlugin(***REMOVED***\n" +
					"      // test: /\\.xxx$/, // may apply this only for some modules\n" +
					"      options: ***REMOVED***\n" +
					`        $***REMOVED***err.params.additionalProperty***REMOVED***: ...\n` +
					"      ***REMOVED***\n" +
					"    ***REMOVED***)\n" +
					"  ]";
			***REMOVED***
			return baseMessage;
		***REMOVED*** else if(err.keyword === "oneOf" || err.keyword === "anyOf") ***REMOVED***
			if(err.children && err.children.length > 0) ***REMOVED***
				if(err.schema.length === 1) ***REMOVED***
					const lastChild = err.children[err.children.length - 1];
					const remainingChildren = err.children.slice(0, err.children.length - 1);
					return WebpackOptionsValidationError.formatValidationError(Object.assign(***REMOVED******REMOVED***, lastChild, ***REMOVED***
						children: remainingChildren,
						parentSchema: Object.assign(***REMOVED******REMOVED***, err.parentSchema, lastChild.parentSchema)
					***REMOVED***));
				***REMOVED***
				return `$***REMOVED***dataPath***REMOVED*** should be one of these:\n$***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***\n` +
					`Details:\n$***REMOVED***filterChildren(err.children).map(err => " * " + indent(WebpackOptionsValidationError.formatValidationError(err), "   ", false)).join("\n")***REMOVED***`;
			***REMOVED***
			return `$***REMOVED***dataPath***REMOVED*** should be one of these:\n$***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***`;

		***REMOVED*** else if(err.keyword === "enum") ***REMOVED***
			if(err.parentSchema && err.parentSchema.enum && err.parentSchema.enum.length === 1) ***REMOVED***
				return `$***REMOVED***dataPath***REMOVED*** should be $***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***`;
			***REMOVED***
			return `$***REMOVED***dataPath***REMOVED*** should be one of these:\n$***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***`;
		***REMOVED*** else if(err.keyword === "allOf") ***REMOVED***
			return `$***REMOVED***dataPath***REMOVED*** should be:\n$***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***`;
		***REMOVED*** else if(err.keyword === "type") ***REMOVED***
			switch(err.params.type) ***REMOVED***
				case "object":
					return `$***REMOVED***dataPath***REMOVED*** should be an object.$***REMOVED***getSchemaPartDescription(err.parentSchema)***REMOVED***`;
				case "string":
					return `$***REMOVED***dataPath***REMOVED*** should be a string.$***REMOVED***getSchemaPartDescription(err.parentSchema)***REMOVED***`;
				case "boolean":
					return `$***REMOVED***dataPath***REMOVED*** should be a boolean.$***REMOVED***getSchemaPartDescription(err.parentSchema)***REMOVED***`;
				case "number":
					return `$***REMOVED***dataPath***REMOVED*** should be a number.$***REMOVED***getSchemaPartDescription(err.parentSchema)***REMOVED***`;
				case "array":
					return `$***REMOVED***dataPath***REMOVED*** should be an array:\n$***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***`;
			***REMOVED***
			return `$***REMOVED***dataPath***REMOVED*** should be $***REMOVED***err.params.type***REMOVED***:\n$***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***`;
		***REMOVED*** else if(err.keyword === "instanceof") ***REMOVED***
			return `$***REMOVED***dataPath***REMOVED*** should be an instance of $***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***`;
		***REMOVED*** else if(err.keyword === "required") ***REMOVED***
			const missingProperty = err.params.missingProperty.replace(/^\./, "");
			return `$***REMOVED***dataPath***REMOVED*** misses the property '$***REMOVED***missingProperty***REMOVED***'.\n$***REMOVED***getSchemaPartText(err.parentSchema, ["properties", missingProperty])***REMOVED***`;
		***REMOVED*** else if(err.keyword === "minimum") ***REMOVED***
			return `$***REMOVED***dataPath***REMOVED*** $***REMOVED***err.message***REMOVED***.$***REMOVED***getSchemaPartDescription(err.parentSchema)***REMOVED***`;
		***REMOVED*** else if(err.keyword === "uniqueItems") ***REMOVED***
			return `$***REMOVED***dataPath***REMOVED*** should not contain the item '$***REMOVED***err.data[err.params.i]***REMOVED***' twice.$***REMOVED***getSchemaPartDescription(err.parentSchema)***REMOVED***`;
		***REMOVED*** else if(err.keyword === "minLength" || err.keyword === "minItems" || err.keyword === "minProperties") ***REMOVED***
			if(err.params.limit === 1)
				return `$***REMOVED***dataPath***REMOVED*** should not be empty.$***REMOVED***getSchemaPartDescription(err.parentSchema)***REMOVED***`;
			else
				return `$***REMOVED***dataPath***REMOVED*** $***REMOVED***err.message***REMOVED***$***REMOVED***getSchemaPartDescription(err.parentSchema)***REMOVED***`;
		***REMOVED*** else if(err.keyword === "absolutePath") ***REMOVED***
			const baseMessage = `$***REMOVED***dataPath***REMOVED***: $***REMOVED***err.message***REMOVED***$***REMOVED***getSchemaPartDescription(err.parentSchema)***REMOVED***`;
			if(dataPath === "configuration.output.filename") ***REMOVED***
				return `$***REMOVED***baseMessage***REMOVED***\n` +
					"Please use output.path to specify absolute path and output.filename for the file name.";
			***REMOVED***
			return baseMessage;
		***REMOVED*** else ***REMOVED***
			// eslint-disable-line no-fallthrough
			return `$***REMOVED***dataPath***REMOVED*** $***REMOVED***err.message***REMOVED*** ($***REMOVED***JSON.stringify(err, 0, 2)***REMOVED***).\n$***REMOVED***getSchemaPartText(err.parentSchema)***REMOVED***`;
		***REMOVED***
	***REMOVED***
***REMOVED***

module.exports = WebpackOptionsValidationError;
