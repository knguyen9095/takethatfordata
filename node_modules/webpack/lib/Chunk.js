/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const util = require("util");
const compareLocations = require("./compareLocations");
const SortableSet = require("./util/SortableSet");
let debugId = 1000;

const sortById = (a, b) => ***REMOVED***
	if(a.id < b.id) return -1;
	if(b.id < a.id) return 1;
	return 0;
***REMOVED***;

const sortByIdentifier = (a, b) => ***REMOVED***
	if(a.identifier() > b.identifier()) return 1;
	if(a.identifier() < b.identifier()) return -1;
	return 0;
***REMOVED***;

class Chunk ***REMOVED***

	constructor(name, module, loc) ***REMOVED***
		this.id = null;
		this.ids = null;
		this.debugId = debugId++;
		this.name = name;
		this._modules = new SortableSet(undefined, sortByIdentifier);
		this.entrypoints = [];
		this.chunks = [];
		this.parents = [];
		this.blocks = [];
		this.origins = [];
		this.files = [];
		this.rendered = false;
		if(module) ***REMOVED***
			this.origins.push(***REMOVED***
				module,
				loc,
				name
			***REMOVED***);
		***REMOVED***
	***REMOVED***

	get entry() ***REMOVED***
		throw new Error("Chunk.entry was removed. Use hasRuntime()");
	***REMOVED***

	set entry(data) ***REMOVED***
		throw new Error("Chunk.entry was removed. Use hasRuntime()");
	***REMOVED***

	get initial() ***REMOVED***
		throw new Error("Chunk.initial was removed. Use isInitial()");
	***REMOVED***

	set initial(data) ***REMOVED***
		throw new Error("Chunk.initial was removed. Use isInitial()");
	***REMOVED***

	hasRuntime() ***REMOVED***
		if(this.entrypoints.length === 0) return false;
		return this.entrypoints[0].chunks[0] === this;
	***REMOVED***

	isInitial() ***REMOVED***
		return this.entrypoints.length > 0;
	***REMOVED***

	hasEntryModule() ***REMOVED***
		return !!this.entryModule;
	***REMOVED***

	addToCollection(collection, item) ***REMOVED***
		if(item === this) ***REMOVED***
			return false;
		***REMOVED***

		if(collection.indexOf(item) > -1) ***REMOVED***
			return false;
		***REMOVED***

		collection.push(item);
		return true;
	***REMOVED***

	addChunk(chunk) ***REMOVED***
		return this.addToCollection(this.chunks, chunk);
	***REMOVED***

	addParent(parentChunk) ***REMOVED***
		return this.addToCollection(this.parents, parentChunk);
	***REMOVED***

	addModule(module) ***REMOVED***
		if(!this._modules.has(module)) ***REMOVED***
			this._modules.add(module);
			return true;
		***REMOVED***
		return false;
	***REMOVED***

	addBlock(block) ***REMOVED***
		return this.addToCollection(this.blocks, block);
	***REMOVED***

	removeModule(module) ***REMOVED***
		if(this._modules.delete(module)) ***REMOVED***
			module.removeChunk(this);
			return true;
		***REMOVED***
		return false;
	***REMOVED***

	removeChunk(chunk) ***REMOVED***
		const idx = this.chunks.indexOf(chunk);
		if(idx >= 0) ***REMOVED***
			this.chunks.splice(idx, 1);
			chunk.removeParent(this);
			return true;
		***REMOVED***
		return false;
	***REMOVED***

	removeParent(chunk) ***REMOVED***
		const idx = this.parents.indexOf(chunk);
		if(idx >= 0) ***REMOVED***
			this.parents.splice(idx, 1);
			chunk.removeChunk(this);
			return true;
		***REMOVED***
		return false;
	***REMOVED***

	addOrigin(module, loc) ***REMOVED***
		this.origins.push(***REMOVED***
			module,
			loc,
			name: this.name
		***REMOVED***);
	***REMOVED***

	setModules(modules) ***REMOVED***
		this._modules = new SortableSet(modules, sortByIdentifier);
	***REMOVED***

	getNumberOfModules() ***REMOVED***
		return this._modules.size;
	***REMOVED***

	get modulesIterable() ***REMOVED***
		return this._modules;
	***REMOVED***

	forEachModule(fn) ***REMOVED***
		this._modules.forEach(fn);
	***REMOVED***

	mapModules(fn) ***REMOVED***
		return Array.from(this._modules, fn);
	***REMOVED***

	compareTo(otherChunk) ***REMOVED***
		this._modules.sort();
		otherChunk._modules.sort();
		if(this._modules.size > otherChunk._modules.size) return -1;
		if(this._modules.size < otherChunk._modules.size) return 1;
		const a = this._modules[Symbol.iterator]();
		const b = otherChunk._modules[Symbol.iterator]();
		while(true) ***REMOVED*** // eslint-disable-line
			const aItem = a.next();
			const bItem = b.next();
			if(aItem.done) return 0;
			const aModuleIdentifier = aItem.value.identifier();
			const bModuleIdentifier = bItem.value.identifier();
			if(aModuleIdentifier > bModuleIdentifier) return -1;
			if(aModuleIdentifier < bModuleIdentifier) return 1;
		***REMOVED***
	***REMOVED***

	containsModule(module) ***REMOVED***
		return this._modules.has(module);
	***REMOVED***

	getModules() ***REMOVED***
		return Array.from(this._modules);
	***REMOVED***

	getModulesIdent() ***REMOVED***
		this._modules.sort();
		let str = "";
		this._modules.forEach(m => ***REMOVED***
			str += m.identifier() + "#";
		***REMOVED***);
		return str;
	***REMOVED***

	remove(reason) ***REMOVED***
		// cleanup modules
		// Array.from is used here to create a clone, because removeChunk modifies this._modules
		Array.from(this._modules).forEach(module => ***REMOVED***
			module.removeChunk(this);
		***REMOVED***);

		// cleanup parents
		this.parents.forEach(parentChunk => ***REMOVED***
			// remove this chunk from its parents
			const idx = parentChunk.chunks.indexOf(this);
			if(idx >= 0) ***REMOVED***
				parentChunk.chunks.splice(idx, 1);
			***REMOVED***

			// cleanup "sub chunks"
			this.chunks.forEach(chunk => ***REMOVED***
				/**
				 * remove this chunk as "intermediary" and connect
				 * it "sub chunks" and parents directly
				 */
				// add parent to each "sub chunk"
				chunk.addParent(parentChunk);
				// add "sub chunk" to parent
				parentChunk.addChunk(chunk);
			***REMOVED***);
		***REMOVED***);

		/**
		 * we need to iterate again over the chunks
		 * to remove this from the chunks parents.
		 * This can not be done in the above loop
		 * as it is not garuanteed that `this.parents` contains anything.
		 */
		this.chunks.forEach(chunk => ***REMOVED***
			// remove this as parent of every "sub chunk"
			const idx = chunk.parents.indexOf(this);
			if(idx >= 0) ***REMOVED***
				chunk.parents.splice(idx, 1);
			***REMOVED***
		***REMOVED***);

		// cleanup blocks
		this.blocks.forEach(block => ***REMOVED***
			const idx = block.chunks.indexOf(this);
			if(idx >= 0) ***REMOVED***
				block.chunks.splice(idx, 1);
				if(block.chunks.length === 0) ***REMOVED***
					block.chunks = null;
					block.chunkReason = reason;
				***REMOVED***
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	moveModule(module, otherChunk) ***REMOVED***
		module.removeChunk(this);
		module.addChunk(otherChunk);
		otherChunk.addModule(module);
		module.rewriteChunkInReasons(this, [otherChunk]);
	***REMOVED***

	replaceChunk(oldChunk, newChunk) ***REMOVED***
		const idx = this.chunks.indexOf(oldChunk);
		if(idx >= 0) ***REMOVED***
			this.chunks.splice(idx, 1);
		***REMOVED***
		if(this !== newChunk && newChunk.addParent(this)) ***REMOVED***
			this.addChunk(newChunk);
		***REMOVED***
	***REMOVED***

	replaceParentChunk(oldParentChunk, newParentChunk) ***REMOVED***
		const idx = this.parents.indexOf(oldParentChunk);
		if(idx >= 0) ***REMOVED***
			this.parents.splice(idx, 1);
		***REMOVED***
		if(this !== newParentChunk && newParentChunk.addChunk(this)) ***REMOVED***
			this.addParent(newParentChunk);
		***REMOVED***
	***REMOVED***

	integrate(otherChunk, reason) ***REMOVED***
		if(!this.canBeIntegrated(otherChunk)) ***REMOVED***
			return false;
		***REMOVED***

		// Array.from is used here to create a clone, because moveModule modifies otherChunk._modules
		const otherChunkModules = Array.from(otherChunk._modules);
		otherChunkModules.forEach(module => otherChunk.moveModule(module, this));
		otherChunk._modules.clear();

		otherChunk.parents.forEach(parentChunk => parentChunk.replaceChunk(otherChunk, this));
		otherChunk.parents.length = 0;

		otherChunk.chunks.forEach(chunk => chunk.replaceParentChunk(otherChunk, this));
		otherChunk.chunks.length = 0;

		otherChunk.blocks.forEach(b => ***REMOVED***
			b.chunks = b.chunks ? b.chunks.map(c => ***REMOVED***
				return c === otherChunk ? this : c;
			***REMOVED***) : [this];
			b.chunkReason = reason;
			this.addBlock(b);
		***REMOVED***);
		otherChunk.blocks.length = 0;

		otherChunk.origins.forEach(origin => ***REMOVED***
			this.origins.push(origin);
		***REMOVED***);
		this.blocks.forEach(b => ***REMOVED***
			b.chunkReason = reason;
		***REMOVED***);
		this.origins.forEach(origin => ***REMOVED***
			if(!origin.reasons) ***REMOVED***
				origin.reasons = [reason];
			***REMOVED*** else if(origin.reasons[0] !== reason) ***REMOVED***
				origin.reasons.unshift(reason);
			***REMOVED***
		***REMOVED***);
		this.chunks = this.chunks.filter(chunk => ***REMOVED***
			return chunk !== otherChunk && chunk !== this;
		***REMOVED***);
		this.parents = this.parents.filter(parentChunk => ***REMOVED***
			return parentChunk !== otherChunk && parentChunk !== this;
		***REMOVED***);
		return true;
	***REMOVED***

	split(newChunk) ***REMOVED***
		this.blocks.forEach(block => ***REMOVED***
			newChunk.blocks.push(block);
			block.chunks.push(newChunk);
		***REMOVED***);
		this.chunks.forEach(chunk => ***REMOVED***
			newChunk.chunks.push(chunk);
			chunk.parents.push(newChunk);
		***REMOVED***);
		this.parents.forEach(parentChunk => ***REMOVED***
			parentChunk.chunks.push(newChunk);
			newChunk.parents.push(parentChunk);
		***REMOVED***);
		this.entrypoints.forEach(entrypoint => ***REMOVED***
			entrypoint.insertChunk(newChunk, this);
		***REMOVED***);
	***REMOVED***

	isEmpty() ***REMOVED***
		return this._modules.size === 0;
	***REMOVED***

	updateHash(hash) ***REMOVED***
		hash.update(`$***REMOVED***this.id***REMOVED*** `);
		hash.update(this.ids ? this.ids.join(",") : "");
		hash.update(`$***REMOVED***this.name || ""***REMOVED*** `);
		this._modules.forEach(m => m.updateHash(hash));
	***REMOVED***

	canBeIntegrated(otherChunk) ***REMOVED***
		if(otherChunk.isInitial()) ***REMOVED***
			return false;
		***REMOVED***
		if(this.isInitial()) ***REMOVED***
			if(otherChunk.parents.length !== 1 || otherChunk.parents[0] !== this) ***REMOVED***
				return false;
			***REMOVED***
		***REMOVED***
		return true;
	***REMOVED***

	addMultiplierAndOverhead(size, options) ***REMOVED***
		const overhead = typeof options.chunkOverhead === "number" ? options.chunkOverhead : 10000;
		const multiplicator = this.isInitial() ? (options.entryChunkMultiplicator || 10) : 1;

		return size * multiplicator + overhead;
	***REMOVED***

	modulesSize() ***REMOVED***
		let count = 0;
		for(const module of this._modules) ***REMOVED***
			count += module.size();
		***REMOVED***
		return count;
	***REMOVED***

	size(options) ***REMOVED***
		return this.addMultiplierAndOverhead(this.modulesSize(), options);
	***REMOVED***

	integratedSize(otherChunk, options) ***REMOVED***
		// Chunk if it's possible to integrate this chunk
		if(!this.canBeIntegrated(otherChunk)) ***REMOVED***
			return false;
		***REMOVED***

		let integratedModulesSize = this.modulesSize();
		// only count modules that do not exist in this chunk!
		for(const otherModule of otherChunk._modules) ***REMOVED***
			if(!this._modules.has(otherModule)) ***REMOVED***
				integratedModulesSize += otherModule.size();
			***REMOVED***
		***REMOVED***

		return this.addMultiplierAndOverhead(integratedModulesSize, options);
	***REMOVED***

	getChunkMaps(includeEntries, realHash) ***REMOVED***
		const chunksProcessed = [];
		const chunkHashMap = ***REMOVED******REMOVED***;
		const chunkNameMap = ***REMOVED******REMOVED***;
		(function addChunk(chunk) ***REMOVED***
			if(chunksProcessed.indexOf(chunk) >= 0) return;
			chunksProcessed.push(chunk);
			if(!chunk.hasRuntime() || includeEntries) ***REMOVED***
				chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;
				if(chunk.name)
					chunkNameMap[chunk.id] = chunk.name;
			***REMOVED***
			chunk.chunks.forEach(addChunk);
		***REMOVED***(this));
		return ***REMOVED***
			hash: chunkHashMap,
			name: chunkNameMap
		***REMOVED***;
	***REMOVED***

	sortModules(sortByFn) ***REMOVED***
		this._modules.sortWith(sortByFn || sortById);
	***REMOVED***

	sortItems() ***REMOVED***
		this.sortModules();
		this.origins.sort((a, b) => ***REMOVED***
			const aIdent = a.module.identifier();
			const bIdent = b.module.identifier();
			if(aIdent < bIdent) return -1;
			if(aIdent > bIdent) return 1;
			return compareLocations(a.loc, b.loc);
		***REMOVED***);
		this.origins.forEach(origin => ***REMOVED***
			if(origin.reasons)
				origin.reasons.sort();
		***REMOVED***);
		this.parents.sort(sortById);
		this.chunks.sort(sortById);
	***REMOVED***

	toString() ***REMOVED***
		return `Chunk[$***REMOVED***Array.from(this._modules).join()***REMOVED***]`;
	***REMOVED***

	checkConstraints() ***REMOVED***
		const chunk = this;
		chunk.chunks.forEach((child, idx) => ***REMOVED***
			if(chunk.chunks.indexOf(child) !== idx)
				throw new Error(`checkConstraints: duplicate child in chunk $***REMOVED***chunk.debugId***REMOVED*** $***REMOVED***child.debugId***REMOVED***`);
			if(child.parents.indexOf(chunk) < 0)
				throw new Error(`checkConstraints: child missing parent $***REMOVED***chunk.debugId***REMOVED*** -> $***REMOVED***child.debugId***REMOVED***`);
		***REMOVED***);
		chunk.parents.forEach((parentChunk, idx) => ***REMOVED***
			if(chunk.parents.indexOf(parentChunk) !== idx)
				throw new Error(`checkConstraints: duplicate parent in chunk $***REMOVED***chunk.debugId***REMOVED*** $***REMOVED***parentChunk.debugId***REMOVED***`);
			if(parentChunk.chunks.indexOf(chunk) < 0)
				throw new Error(`checkConstraints: parent missing child $***REMOVED***parentChunk.debugId***REMOVED*** <- $***REMOVED***chunk.debugId***REMOVED***`);
		***REMOVED***);
	***REMOVED***
***REMOVED***

Object.defineProperty(Chunk.prototype, "modules", ***REMOVED***
	configurable: false,
	get: util.deprecate(function() ***REMOVED***
		return Array.from(this._modules);
	***REMOVED***, "Chunk.modules is deprecated. Use Chunk.getNumberOfModules/mapModules/forEachModule/containsModule instead."),
	set: util.deprecate(function(value) ***REMOVED***
		this.setModules(value);
	***REMOVED***, "Chunk.modules is deprecated. Use Chunk.addModule/removeModule instead.")
***REMOVED***);

module.exports = Chunk;
