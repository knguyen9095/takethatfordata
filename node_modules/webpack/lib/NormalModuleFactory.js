/*
 MIT License http://www.opensource.org/licenses/mit-license.php
 Author Tobias Koppers @sokra
 */
"use strict";

const asyncLib = require("async");
const Tapable = require("tapable");
const NormalModule = require("./NormalModule");
const RawModule = require("./RawModule");
const Parser = require("./Parser");
const RuleSet = require("./RuleSet");

function loaderToIdent(data) ***REMOVED***
	if(!data.options)
		return data.loader;
	if(typeof data.options === "string")
		return data.loader + "?" + data.options;
	if(typeof data.options !== "object")
		throw new Error("loader options must be string or object");
	if(data.ident)
		return data.loader + "??" + data.ident;
	return data.loader + "?" + JSON.stringify(data.options);
***REMOVED***

function identToLoaderRequest(resultString) ***REMOVED***
	const idx = resultString.indexOf("?");
	let options;

	if(idx >= 0) ***REMOVED***
		options = resultString.substr(idx + 1);
		resultString = resultString.substr(0, idx);

		return ***REMOVED***
			loader: resultString,
			options
		***REMOVED***;
	***REMOVED*** else ***REMOVED***
		return ***REMOVED***
			loader: resultString
		***REMOVED***;
	***REMOVED***
***REMOVED***

class NormalModuleFactory extends Tapable ***REMOVED***
	constructor(context, resolvers, options) ***REMOVED***
		super();
		this.resolvers = resolvers;
		this.ruleSet = new RuleSet(options.rules || options.loaders);
		this.cachePredicate = typeof options.unsafeCache === "function" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);
		this.context = context || "";
		this.parserCache = ***REMOVED******REMOVED***;
		this.plugin("factory", () => (result, callback) => ***REMOVED***
			let resolver = this.applyPluginsWaterfall0("resolver", null);

			// Ignored
			if(!resolver) return callback();

			resolver(result, (err, data) => ***REMOVED***
				if(err) return callback(err);

				// Ignored
				if(!data) return callback();

				// direct module
				if(typeof data.source === "function")
					return callback(null, data);

				this.applyPluginsAsyncWaterfall("after-resolve", data, (err, result) => ***REMOVED***
					if(err) return callback(err);

					// Ignored
					if(!result) return callback();

					let createdModule = this.applyPluginsBailResult("create-module", result);
					if(!createdModule) ***REMOVED***

						if(!result.request) ***REMOVED***
							return callback(new Error("Empty dependency (no request)"));
						***REMOVED***

						createdModule = new NormalModule(
							result.request,
							result.userRequest,
							result.rawRequest,
							result.loaders,
							result.resource,
							result.parser
						);
					***REMOVED***

					createdModule = this.applyPluginsWaterfall0("module", createdModule);

					return callback(null, createdModule);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
		this.plugin("resolver", () => (data, callback) => ***REMOVED***
			const contextInfo = data.contextInfo;
			const context = data.context;
			const request = data.request;

			const noAutoLoaders = /^-?!/.test(request);
			const noPrePostAutoLoaders = /^!!/.test(request);
			const noPostAutoLoaders = /^-!/.test(request);
			let elements = request.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
			let resource = elements.pop();
			elements = elements.map(identToLoaderRequest);

			asyncLib.parallel([
				callback => this.resolveRequestArray(contextInfo, context, elements, this.resolvers.loader, callback),
				callback => ***REMOVED***
					if(resource === "" || resource[0] === "?")
						return callback(null, ***REMOVED***
							resource
						***REMOVED***);

					this.resolvers.normal.resolve(contextInfo, context, resource, (err, resource, resourceResolveData) => ***REMOVED***
						if(err) return callback(err);
						callback(null, ***REMOVED***
							resourceResolveData,
							resource
						***REMOVED***);
					***REMOVED***);
				***REMOVED***
			], (err, results) => ***REMOVED***
				if(err) return callback(err);
				let loaders = results[0];
				const resourceResolveData = results[1].resourceResolveData;
				resource = results[1].resource;

				// translate option idents
				try ***REMOVED***
					loaders.forEach(item => ***REMOVED***
						if(typeof item.options === "string" && /^\?/.test(item.options)) ***REMOVED***
							item.options = this.ruleSet.findOptionsByIdent(item.options.substr(1));
						***REMOVED***
					***REMOVED***);
				***REMOVED*** catch(e) ***REMOVED***
					return callback(e);
				***REMOVED***

				if(resource === false) ***REMOVED***
					// ignored
					return callback(null,
						new RawModule(
							"/* (ignored) */",
							`ignored $***REMOVED***context***REMOVED*** $***REMOVED***request***REMOVED***`,
							`$***REMOVED***request***REMOVED*** (ignored)`
						)
					);
				***REMOVED***

				const userRequest = loaders.map(loaderToIdent).concat([resource]).join("!");

				let resourcePath = resource;
				let resourceQuery = "";
				const queryIndex = resourcePath.indexOf("?");
				if(queryIndex >= 0) ***REMOVED***
					resourceQuery = resourcePath.substr(queryIndex);
					resourcePath = resourcePath.substr(0, queryIndex);
				***REMOVED***

				const result = this.ruleSet.exec(***REMOVED***
					resource: resourcePath,
					resourceQuery,
					issuer: contextInfo.issuer,
					compiler: contextInfo.compiler
				***REMOVED***);
				const settings = ***REMOVED******REMOVED***;
				const useLoadersPost = [];
				const useLoaders = [];
				const useLoadersPre = [];
				result.forEach(r => ***REMOVED***
					if(r.type === "use") ***REMOVED***
						if(r.enforce === "post" && !noPostAutoLoaders && !noPrePostAutoLoaders)
							useLoadersPost.push(r.value);
						else if(r.enforce === "pre" && !noPrePostAutoLoaders)
							useLoadersPre.push(r.value);
						else if(!r.enforce && !noAutoLoaders && !noPrePostAutoLoaders)
							useLoaders.push(r.value);
					***REMOVED*** else ***REMOVED***
						settings[r.type] = r.value;
					***REMOVED***
				***REMOVED***);
				asyncLib.parallel([
					this.resolveRequestArray.bind(this, contextInfo, this.context, useLoadersPost, this.resolvers.loader),
					this.resolveRequestArray.bind(this, contextInfo, this.context, useLoaders, this.resolvers.loader),
					this.resolveRequestArray.bind(this, contextInfo, this.context, useLoadersPre, this.resolvers.loader)
				], (err, results) => ***REMOVED***
					if(err) return callback(err);
					loaders = results[0].concat(loaders, results[1], results[2]);
					process.nextTick(() => ***REMOVED***
						callback(null, ***REMOVED***
							context: context,
							request: loaders.map(loaderToIdent).concat([resource]).join("!"),
							dependencies: data.dependencies,
							userRequest,
							rawRequest: request,
							loaders,
							resource,
							resourceResolveData,
							parser: this.getParser(settings.parser)
						***REMOVED***);
					***REMOVED***);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	create(data, callback) ***REMOVED***
		const dependencies = data.dependencies;
		const cacheEntry = dependencies[0].__NormalModuleFactoryCache;
		if(cacheEntry) return callback(null, cacheEntry);
		const context = data.context || this.context;
		const request = dependencies[0].request;
		const contextInfo = data.contextInfo || ***REMOVED******REMOVED***;
		this.applyPluginsAsyncWaterfall("before-resolve", ***REMOVED***
			contextInfo,
			context,
			request,
			dependencies
		***REMOVED***, (err, result) => ***REMOVED***
			if(err) return callback(err);

			// Ignored
			if(!result) return callback();

			const factory = this.applyPluginsWaterfall0("factory", null);

			// Ignored
			if(!factory) return callback();

			factory(result, (err, module) => ***REMOVED***
				if(err) return callback(err);

				if(module && this.cachePredicate(module)) ***REMOVED***
					dependencies.forEach(d => d.__NormalModuleFactoryCache = module);
				***REMOVED***

				callback(null, module);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	resolveRequestArray(contextInfo, context, array, resolver, callback) ***REMOVED***
		if(array.length === 0) return callback(null, []);
		asyncLib.map(array, (item, callback) => ***REMOVED***
			resolver.resolve(contextInfo, context, item.loader, (err, result) => ***REMOVED***
				if(err && /^[^/]*$/.test(item.loader) && !/-loader$/.test(item.loader)) ***REMOVED***
					return resolver.resolve(contextInfo, context, item.loader + "-loader", err2 => ***REMOVED***
						if(!err2) ***REMOVED***
							err.message = err.message + "\n" +
								"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n" +
								`                 You need to specify '$***REMOVED***item.loader***REMOVED***-loader' instead of '$***REMOVED***item.loader***REMOVED***',\n` +
								"                 see https://webpack.js.org/guides/migrating/#automatic-loader-module-name-extension-removed";
						***REMOVED***
						callback(err);
					***REMOVED***);
				***REMOVED***
				if(err) return callback(err);

				const optionsOnly = item.options ? ***REMOVED***
					options: item.options
				***REMOVED*** : undefined;
				return callback(null, Object.assign(***REMOVED******REMOVED***, item, identToLoaderRequest(result), optionsOnly));
			***REMOVED***);
		***REMOVED***, callback);
	***REMOVED***

	getParser(parserOptions) ***REMOVED***
		let ident = "null";
		if(parserOptions) ***REMOVED***
			if(parserOptions.ident)
				ident = parserOptions.ident;
			else
				ident = JSON.stringify(parserOptions);
		***REMOVED***
		const parser = this.parserCache[ident];
		if(parser)
			return parser;
		return this.parserCache[ident] = this.createParser(parserOptions);
	***REMOVED***

	createParser(parserOptions) ***REMOVED***
		const parser = new Parser();
		this.applyPlugins2("parser", parser, parserOptions || ***REMOVED******REMOVED***);
		return parser;
	***REMOVED***
***REMOVED***

module.exports = NormalModuleFactory;
