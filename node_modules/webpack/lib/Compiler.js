/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const path = require("path");
const Tapable = require("tapable");
const util = require("util");

const Compilation = require("./Compilation");
const Stats = require("./Stats");
const NormalModuleFactory = require("./NormalModuleFactory");
const ContextModuleFactory = require("./ContextModuleFactory");

const makePathsRelative = require("./util/identifier").makePathsRelative;

class Watching ***REMOVED***
	constructor(compiler, watchOptions, handler) ***REMOVED***
		this.startTime = null;
		this.invalid = false;
		this.handler = handler;
		this.callbacks = [];
		this.closed = false;
		if(typeof watchOptions === "number") ***REMOVED***
			this.watchOptions = ***REMOVED***
				aggregateTimeout: watchOptions
			***REMOVED***;
		***REMOVED*** else if(watchOptions && typeof watchOptions === "object") ***REMOVED***
			this.watchOptions = Object.assign(***REMOVED******REMOVED***, watchOptions);
		***REMOVED*** else ***REMOVED***
			this.watchOptions = ***REMOVED******REMOVED***;
		***REMOVED***
		this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;
		this.compiler = compiler;
		this.running = true;
		this.compiler.readRecords(err => ***REMOVED***
			if(err) return this._done(err);

			this._go();
		***REMOVED***);
	***REMOVED***

	_go() ***REMOVED***
		this.startTime = Date.now();
		this.running = true;
		this.invalid = false;
		this.compiler.applyPluginsAsync("watch-run", this, err => ***REMOVED***
			if(err) return this._done(err);
			const onCompiled = (err, compilation) => ***REMOVED***
				if(err) return this._done(err);
				if(this.invalid) return this._done();

				if(this.compiler.applyPluginsBailResult("should-emit", compilation) === false) ***REMOVED***
					return this._done(null, compilation);
				***REMOVED***

				this.compiler.emitAssets(compilation, err => ***REMOVED***
					if(err) return this._done(err);
					if(this.invalid) return this._done();

					this.compiler.emitRecords(err => ***REMOVED***
						if(err) return this._done(err);

						if(compilation.applyPluginsBailResult("need-additional-pass")) ***REMOVED***
							compilation.needAdditionalPass = true;

							const stats = new Stats(compilation);
							stats.startTime = this.startTime;
							stats.endTime = Date.now();
							this.compiler.applyPlugins("done", stats);

							this.compiler.applyPluginsAsync("additional-pass", err => ***REMOVED***
								if(err) return this._done(err);
								this.compiler.compile(onCompiled);
							***REMOVED***);
							return;
						***REMOVED***
						return this._done(null, compilation);
					***REMOVED***);
				***REMOVED***);
			***REMOVED***;
			this.compiler.compile(onCompiled);
		***REMOVED***);
	***REMOVED***

	_getStats(compilation) ***REMOVED***
		const stats = new Stats(compilation);
		stats.startTime = this.startTime;
		stats.endTime = Date.now();
		return stats;
	***REMOVED***

	_done(err, compilation) ***REMOVED***
		this.running = false;
		if(this.invalid) return this._go();

		const stats = compilation ? this._getStats(compilation) : null;
		if(err) ***REMOVED***
			this.compiler.applyPlugins("failed", err);
			this.handler(err, stats);
			return;
		***REMOVED***

		this.compiler.applyPlugins("done", stats);
		this.handler(null, stats);
		if(!this.closed) ***REMOVED***
			this.watch(compilation.fileDependencies, compilation.contextDependencies, compilation.missingDependencies);
		***REMOVED***
		this.callbacks.forEach(cb => cb());
		this.callbacks.length = 0;
	***REMOVED***

	watch(files, dirs, missing) ***REMOVED***
		this.pausedWatcher = null;
		this.watcher = this.compiler.watchFileSystem.watch(files, dirs, missing, this.startTime, this.watchOptions, (err, filesModified, contextModified, missingModified, fileTimestamps, contextTimestamps) => ***REMOVED***
			this.pausedWatcher = this.watcher;
			this.watcher = null;
			if(err) return this.handler(err);

			this.compiler.fileTimestamps = fileTimestamps;
			this.compiler.contextTimestamps = contextTimestamps;
			this.invalidate();
		***REMOVED***, (fileName, changeTime) => ***REMOVED***
			this.compiler.applyPlugins("invalid", fileName, changeTime);
		***REMOVED***);
	***REMOVED***

	invalidate(callback) ***REMOVED***
		if(callback) ***REMOVED***
			this.callbacks.push(callback);
		***REMOVED***
		if(this.watcher) ***REMOVED***
			this.pausedWatcher = this.watcher;
			this.watcher.pause();
			this.watcher = null;
		***REMOVED***
		if(this.running) ***REMOVED***
			this.invalid = true;
			return false;
		***REMOVED*** else ***REMOVED***
			this._go();
		***REMOVED***
	***REMOVED***

	close(callback) ***REMOVED***
		if(callback === undefined) callback = function() ***REMOVED******REMOVED***;

		this.closed = true;
		if(this.watcher) ***REMOVED***
			this.watcher.close();
			this.watcher = null;
		***REMOVED***
		if(this.pausedWatcher) ***REMOVED***
			this.pausedWatcher.close();
			this.pausedWatcher = null;
		***REMOVED***
		if(this.running) ***REMOVED***
			this.invalid = true;
			this._done = () => ***REMOVED***
				this.compiler.applyPlugins("watch-close");
				callback();
			***REMOVED***;
		***REMOVED*** else ***REMOVED***
			this.compiler.applyPlugins("watch-close");
			callback();
		***REMOVED***
	***REMOVED***
***REMOVED***

class Compiler extends Tapable ***REMOVED***
	constructor() ***REMOVED***
		super();
		this.outputPath = "";
		this.outputFileSystem = null;
		this.inputFileSystem = null;

		this.recordsInputPath = null;
		this.recordsOutputPath = null;
		this.records = ***REMOVED******REMOVED***;

		this.fileTimestamps = ***REMOVED******REMOVED***;
		this.contextTimestamps = ***REMOVED******REMOVED***;

		this.resolvers = ***REMOVED***
			normal: null,
			loader: null,
			context: null
		***REMOVED***;
		this.parser = ***REMOVED***
			plugin: util.deprecate(
				(hook, fn) => ***REMOVED***
					this.plugin("compilation", (compilation, data) => ***REMOVED***
						data.normalModuleFactory.plugin("parser", parser => ***REMOVED***
							parser.plugin(hook, fn);
						***REMOVED***);
					***REMOVED***);
				***REMOVED***,
				"webpack: Using compiler.parser is deprecated.\n" +
				"Use compiler.plugin(\"compilation\", function(compilation, data) ***REMOVED***\n  data.normalModuleFactory.plugin(\"parser\", function(parser, options) ***REMOVED*** parser.plugin(/* ... */); ***REMOVED***);\n***REMOVED***); instead. "
			),
			apply: util.deprecate(
				() => ***REMOVED***
					const args = arguments;
					this.plugin("compilation", (compilation, data) => ***REMOVED***
						data.normalModuleFactory.plugin("parser", parser => ***REMOVED***
							parser.apply.apply(parser, args);
						***REMOVED***);
					***REMOVED***);
				***REMOVED***,
				"webpack: Using compiler.parser is deprecated.\n" +
				"Use compiler.plugin(\"compilation\", function(compilation, data) ***REMOVED***\n  data.normalModuleFactory.plugin(\"parser\", function(parser, options) ***REMOVED*** parser.apply(/* ... */); ***REMOVED***);\n***REMOVED***); instead. "
			)
		***REMOVED***;

		this.options = ***REMOVED******REMOVED***;
	***REMOVED***

	watch(watchOptions, handler) ***REMOVED***
		this.fileTimestamps = ***REMOVED******REMOVED***;
		this.contextTimestamps = ***REMOVED******REMOVED***;
		const watching = new Watching(this, watchOptions, handler);
		return watching;
	***REMOVED***

	run(callback) ***REMOVED***
		const startTime = Date.now();

		const onCompiled = (err, compilation) => ***REMOVED***
			if(err) return callback(err);

			if(this.applyPluginsBailResult("should-emit", compilation) === false) ***REMOVED***
				const stats = new Stats(compilation);
				stats.startTime = startTime;
				stats.endTime = Date.now();
				this.applyPlugins("done", stats);
				return callback(null, stats);
			***REMOVED***

			this.emitAssets(compilation, err => ***REMOVED***
				if(err) return callback(err);

				if(compilation.applyPluginsBailResult("need-additional-pass")) ***REMOVED***
					compilation.needAdditionalPass = true;

					const stats = new Stats(compilation);
					stats.startTime = startTime;
					stats.endTime = Date.now();
					this.applyPlugins("done", stats);

					this.applyPluginsAsync("additional-pass", err => ***REMOVED***
						if(err) return callback(err);
						this.compile(onCompiled);
					***REMOVED***);
					return;
				***REMOVED***

				this.emitRecords(err => ***REMOVED***
					if(err) return callback(err);

					const stats = new Stats(compilation);
					stats.startTime = startTime;
					stats.endTime = Date.now();
					this.applyPlugins("done", stats);
					return callback(null, stats);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***;

		this.applyPluginsAsync("before-run", this, err => ***REMOVED***
			if(err) return callback(err);

			this.applyPluginsAsync("run", this, err => ***REMOVED***
				if(err) return callback(err);

				this.readRecords(err => ***REMOVED***
					if(err) return callback(err);

					this.compile(onCompiled);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	runAsChild(callback) ***REMOVED***
		this.compile((err, compilation) => ***REMOVED***
			if(err) return callback(err);

			this.parentCompilation.children.push(compilation);
			Object.keys(compilation.assets).forEach(name => ***REMOVED***
				this.parentCompilation.assets[name] = compilation.assets[name];
			***REMOVED***);

			const entries = Object.keys(compilation.entrypoints).map(name => ***REMOVED***
				return compilation.entrypoints[name].chunks;
			***REMOVED***).reduce((array, chunks) => ***REMOVED***
				return array.concat(chunks);
			***REMOVED***, []);

			return callback(null, entries, compilation);
		***REMOVED***);
	***REMOVED***

	purgeInputFileSystem() ***REMOVED***
		if(this.inputFileSystem && this.inputFileSystem.purge)
			this.inputFileSystem.purge();
	***REMOVED***

	emitAssets(compilation, callback) ***REMOVED***
		let outputPath;

		const emitFiles = (err) => ***REMOVED***
			if(err) return callback(err);

			require("async").forEach(Object.keys(compilation.assets), (file, callback) => ***REMOVED***

				let targetFile = file;
				const queryStringIdx = targetFile.indexOf("?");
				if(queryStringIdx >= 0) ***REMOVED***
					targetFile = targetFile.substr(0, queryStringIdx);
				***REMOVED***

				const writeOut = (err) => ***REMOVED***
					if(err) return callback(err);
					const targetPath = this.outputFileSystem.join(outputPath, targetFile);
					const source = compilation.assets[file];
					if(source.existsAt === targetPath) ***REMOVED***
						source.emitted = false;
						return callback();
					***REMOVED***
					let content = source.source();

					if(!Buffer.isBuffer(content)) ***REMOVED***
						content = new Buffer(content, "utf8"); // eslint-disable-line
					***REMOVED***

					source.existsAt = targetPath;
					source.emitted = true;
					this.outputFileSystem.writeFile(targetPath, content, callback);
				***REMOVED***;

				if(targetFile.match(/\/|\\/)) ***REMOVED***
					const dir = path.dirname(targetFile);
					this.outputFileSystem.mkdirp(this.outputFileSystem.join(outputPath, dir), writeOut);
				***REMOVED*** else writeOut();

			***REMOVED***, err => ***REMOVED***
				if(err) return callback(err);

				afterEmit.call(this);
			***REMOVED***);
		***REMOVED***;

		this.applyPluginsAsync("emit", compilation, err => ***REMOVED***
			if(err) return callback(err);
			outputPath = compilation.getPath(this.outputPath);
			this.outputFileSystem.mkdirp(outputPath, emitFiles);
		***REMOVED***);

		function afterEmit() ***REMOVED***
			this.applyPluginsAsyncSeries1("after-emit", compilation, err => ***REMOVED***
				if(err) return callback(err);

				return callback();
			***REMOVED***);
		***REMOVED***

	***REMOVED***

	emitRecords(callback) ***REMOVED***
		if(!this.recordsOutputPath) return callback();
		const idx1 = this.recordsOutputPath.lastIndexOf("/");
		const idx2 = this.recordsOutputPath.lastIndexOf("\\");
		let recordsOutputPathDirectory = null;
		if(idx1 > idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);
		if(idx1 < idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);
		if(!recordsOutputPathDirectory) return writeFile.call(this);
		this.outputFileSystem.mkdirp(recordsOutputPathDirectory, err => ***REMOVED***
			if(err) return callback(err);
			writeFile.call(this);
		***REMOVED***);

		function writeFile() ***REMOVED***
			this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, undefined, 2), callback);
		***REMOVED***
	***REMOVED***

	readRecords(callback) ***REMOVED***
		if(!this.recordsInputPath) ***REMOVED***
			this.records = ***REMOVED******REMOVED***;
			return callback();
		***REMOVED***
		this.inputFileSystem.stat(this.recordsInputPath, err => ***REMOVED***
			// It doesn't exist
			// We can ignore this.
			if(err) return callback();

			this.inputFileSystem.readFile(this.recordsInputPath, (err, content) => ***REMOVED***
				if(err) return callback(err);

				try ***REMOVED***
					this.records = JSON.parse(content.toString("utf-8"));
				***REMOVED*** catch(e) ***REMOVED***
					e.message = "Cannot parse records: " + e.message;
					return callback(e);
				***REMOVED***

				return callback();
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) ***REMOVED***
		const childCompiler = new Compiler();
		if(Array.isArray(plugins)) ***REMOVED***
			plugins.forEach(plugin => childCompiler.apply(plugin));
		***REMOVED***
		for(const name in this._plugins) ***REMOVED***
			if(["make", "compile", "emit", "after-emit", "invalid", "done", "this-compilation"].indexOf(name) < 0)
				childCompiler._plugins[name] = this._plugins[name].slice();
		***REMOVED***
		childCompiler.name = compilerName;
		childCompiler.outputPath = this.outputPath;
		childCompiler.inputFileSystem = this.inputFileSystem;
		childCompiler.outputFileSystem = null;
		childCompiler.resolvers = this.resolvers;
		childCompiler.fileTimestamps = this.fileTimestamps;
		childCompiler.contextTimestamps = this.contextTimestamps;

		const relativeCompilerName = makePathsRelative(this.context, compilerName);
		if(!this.records[relativeCompilerName]) this.records[relativeCompilerName] = [];
		if(this.records[relativeCompilerName][compilerIndex])
			childCompiler.records = this.records[relativeCompilerName][compilerIndex];
		else
			this.records[relativeCompilerName].push(childCompiler.records = ***REMOVED******REMOVED***);

		childCompiler.options = Object.create(this.options);
		childCompiler.options.output = Object.create(childCompiler.options.output);
		for(const name in outputOptions) ***REMOVED***
			childCompiler.options.output[name] = outputOptions[name];
		***REMOVED***
		childCompiler.parentCompilation = compilation;

		compilation.applyPlugins("child-compiler", childCompiler, compilerName, compilerIndex);

		return childCompiler;
	***REMOVED***

	isChild() ***REMOVED***
		return !!this.parentCompilation;
	***REMOVED***

	createCompilation() ***REMOVED***
		return new Compilation(this);
	***REMOVED***

	newCompilation(params) ***REMOVED***
		const compilation = this.createCompilation();
		compilation.fileTimestamps = this.fileTimestamps;
		compilation.contextTimestamps = this.contextTimestamps;
		compilation.name = this.name;
		compilation.records = this.records;
		compilation.compilationDependencies = params.compilationDependencies;
		this.applyPlugins("this-compilation", compilation, params);
		this.applyPlugins("compilation", compilation, params);
		return compilation;
	***REMOVED***

	createNormalModuleFactory() ***REMOVED***
		const normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolvers, this.options.module || ***REMOVED******REMOVED***);
		this.applyPlugins("normal-module-factory", normalModuleFactory);
		return normalModuleFactory;
	***REMOVED***

	createContextModuleFactory() ***REMOVED***
		const contextModuleFactory = new ContextModuleFactory(this.resolvers, this.inputFileSystem);
		this.applyPlugins("context-module-factory", contextModuleFactory);
		return contextModuleFactory;
	***REMOVED***

	newCompilationParams() ***REMOVED***
		const params = ***REMOVED***
			normalModuleFactory: this.createNormalModuleFactory(),
			contextModuleFactory: this.createContextModuleFactory(),
			compilationDependencies: []
		***REMOVED***;
		return params;
	***REMOVED***

	compile(callback) ***REMOVED***
		const params = this.newCompilationParams();
		this.applyPluginsAsync("before-compile", params, err => ***REMOVED***
			if(err) return callback(err);

			this.applyPlugins("compile", params);

			const compilation = this.newCompilation(params);

			this.applyPluginsParallel("make", compilation, err => ***REMOVED***
				if(err) return callback(err);

				compilation.finish();

				compilation.seal(err => ***REMOVED***
					if(err) return callback(err);

					this.applyPluginsAsync("after-compile", compilation, err => ***REMOVED***
						if(err) return callback(err);

						return callback(null, compilation);
					***REMOVED***);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***

Compiler.Watching = Watching;
module.exports = Compiler;
