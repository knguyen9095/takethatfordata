/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const CommonJsRequireDependency = require("./CommonJsRequireDependency");
const CommonJsRequireContextDependency = require("./CommonJsRequireContextDependency");
const RequireHeaderDependency = require("./RequireHeaderDependency");
const LocalModuleDependency = require("./LocalModuleDependency");
const ContextDependencyHelpers = require("./ContextDependencyHelpers");
const LocalModulesHelpers = require("./LocalModulesHelpers");
const ParserHelpers = require("../ParserHelpers");

class CommonJsRequireDependencyParserPlugin ***REMOVED***
	constructor(options) ***REMOVED***
		this.options = options;
	***REMOVED***

	apply(parser) ***REMOVED***
		const options = this.options;
		parser.plugin("expression require.cache", ParserHelpers.toConstantDependency("__webpack_require__.c"));
		parser.plugin("expression require", (expr) => ***REMOVED***
			const dep = new CommonJsRequireContextDependency(options.unknownContextRequest, options.unknownContextRecursive, options.unknownContextRegExp, expr.range);
			dep.critical = options.unknownContextCritical && "require function is used in a way in which dependencies cannot be statically extracted";
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		***REMOVED***);
		parser.plugin("call require", (expr) => ***REMOVED***
			if(expr.arguments.length !== 1) return;
			let localModule;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if(param.isConditional()) ***REMOVED***
				let isExpression = false;
				const prevLength = parser.state.current.dependencies.length;
				const dep = new RequireHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				param.options.forEach(function(param) ***REMOVED***
					const result = parser.applyPluginsBailResult("call require:commonjs:item", expr, param);
					if(result === undefined) ***REMOVED***
						isExpression = true;
					***REMOVED***
				***REMOVED***);
				if(isExpression) ***REMOVED***
					parser.state.current.dependencies.length = prevLength;
				***REMOVED*** else ***REMOVED***
					return true;
				***REMOVED***
			***REMOVED***
			if(param.isString() && (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string))) ***REMOVED***
				const dep = new LocalModuleDependency(localModule, expr.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			***REMOVED*** else ***REMOVED***
				const result = parser.applyPluginsBailResult("call require:commonjs:item", expr, param);
				if(result === undefined) ***REMOVED***
					parser.applyPluginsBailResult("call require:commonjs:context", expr, param);
				***REMOVED*** else ***REMOVED***
					const dep = new RequireHeaderDependency(expr.callee.range);
					dep.loc = expr.loc;
					parser.state.current.addDependency(dep);
				***REMOVED***
				return true;
			***REMOVED***
		***REMOVED***);
		parser.plugin("call require:commonjs:item", (expr, param) => ***REMOVED***
			if(param.isString()) ***REMOVED***
				const dep = new CommonJsRequireDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			***REMOVED***
		***REMOVED***);
		parser.plugin("call require:commonjs:context", (expr, param) => ***REMOVED***
			const dep = ContextDependencyHelpers.create(CommonJsRequireContextDependency, expr.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		***REMOVED***);
	***REMOVED***
***REMOVED***
module.exports = CommonJsRequireDependencyParserPlugin;
