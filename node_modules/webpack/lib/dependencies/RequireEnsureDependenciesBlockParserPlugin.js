/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const RequireEnsureDependenciesBlock = require("./RequireEnsureDependenciesBlock");
const RequireEnsureItemDependency = require("./RequireEnsureItemDependency");
const getFunctionExpression = require("./getFunctionExpression");

module.exports = class RequireEnsureDependenciesBlockParserPlugin ***REMOVED***
	apply(parser) ***REMOVED***
		parser.plugin("call require.ensure", expr => ***REMOVED***
			let chunkName = null;
			let chunkNameRange = null;
			let errorExpressionArg = null;
			let errorExpression = null;
			switch(expr.arguments.length) ***REMOVED***
				case 4:
					***REMOVED***
						const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);
						if(!chunkNameExpr.isString()) return;
						chunkNameRange = chunkNameExpr.range;
						chunkName = chunkNameExpr.string;
					***REMOVED***
					// falls through
				case 3:
					***REMOVED***
						errorExpressionArg = expr.arguments[2];
						errorExpression = getFunctionExpression(errorExpressionArg);

						if(!errorExpression && !chunkName) ***REMOVED***
							const chunkNameExpr = parser.evaluateExpression(expr.arguments[2]);
							if(!chunkNameExpr.isString()) return;
							chunkNameRange = chunkNameExpr.range;
							chunkName = chunkNameExpr.string;
						***REMOVED***
					***REMOVED***
					// falls through
				case 2:
					***REMOVED***
						const dependenciesExpr = parser.evaluateExpression(expr.arguments[0]);
						const dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [dependenciesExpr];
						const successExpressionArg = expr.arguments[1];
						const successExpression = getFunctionExpression(successExpressionArg);

						if(successExpression) ***REMOVED***
							parser.walkExpressions(successExpression.expressions);
						***REMOVED***
						if(errorExpression) ***REMOVED***
							parser.walkExpressions(errorExpression.expressions);
						***REMOVED***

						const dep = new RequireEnsureDependenciesBlock(expr,
							successExpression ? successExpression.fn : successExpressionArg,
							errorExpression ? errorExpression.fn : errorExpressionArg,
							chunkName, chunkNameRange, parser.state.module, expr.loc);
						const old = parser.state.current;
						parser.state.current = dep;
						try ***REMOVED***
							let failed = false;
							parser.inScope([], () => ***REMOVED***
								dependenciesItems.forEach(ee => ***REMOVED***
									if(ee.isString()) ***REMOVED***
										const edep = new RequireEnsureItemDependency(ee.string, ee.range);
										edep.loc = dep.loc;
										dep.addDependency(edep);
									***REMOVED*** else ***REMOVED***
										failed = true;
									***REMOVED***
								***REMOVED***);
							***REMOVED***);
							if(failed) ***REMOVED***
								return;
							***REMOVED***
							if(successExpression) ***REMOVED***
								if(successExpression.fn.body.type === "BlockStatement")
									parser.walkStatement(successExpression.fn.body);
								else
									parser.walkExpression(successExpression.fn.body);
							***REMOVED***
							old.addBlock(dep);
						***REMOVED*** finally ***REMOVED***
							parser.state.current = old;
						***REMOVED***
						if(!successExpression) ***REMOVED***
							parser.walkExpression(successExpressionArg);
						***REMOVED***
						if(errorExpression) ***REMOVED***
							if(errorExpression.fn.body.type === "BlockStatement")
								parser.walkStatement(errorExpression.fn.body);
							else
								parser.walkExpression(errorExpression.fn.body);
						***REMOVED*** else if(errorExpressionArg) ***REMOVED***
							parser.walkExpression(errorExpressionArg);
						***REMOVED***
						return true;
					***REMOVED***
			***REMOVED***
		***REMOVED***);
	***REMOVED***
***REMOVED***;
