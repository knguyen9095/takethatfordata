/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const AMDRequireItemDependency = require("./AMDRequireItemDependency");
const AMDRequireContextDependency = require("./AMDRequireContextDependency");
const ConstDependency = require("./ConstDependency");
const AMDDefineDependency = require("./AMDDefineDependency");
const AMDRequireArrayDependency = require("./AMDRequireArrayDependency");
const LocalModuleDependency = require("./LocalModuleDependency");
const ContextDependencyHelpers = require("./ContextDependencyHelpers");
const LocalModulesHelpers = require("./LocalModulesHelpers");

function isBoundFunctionExpression(expr) ***REMOVED***
	if(expr.type !== "CallExpression") return false;
	if(expr.callee.type !== "MemberExpression") return false;
	if(expr.callee.computed) return false;
	if(expr.callee.object.type !== "FunctionExpression") return false;
	if(expr.callee.property.type !== "Identifier") return false;
	if(expr.callee.property.name !== "bind") return false;
	return true;
***REMOVED***

function isUnboundFunctionExpression(expr) ***REMOVED***
	if(expr.type === "FunctionExpression") return true;
	if(expr.type === "ArrowFunctionExpression") return true;
	return false;
***REMOVED***

function isCallable(expr) ***REMOVED***
	if(isUnboundFunctionExpression(expr)) return true;
	if(isBoundFunctionExpression(expr)) return true;
	return false;
***REMOVED***

class AMDDefineDependencyParserPlugin ***REMOVED***
	constructor(options) ***REMOVED***
		this.options = options;
	***REMOVED***

	newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) ***REMOVED***
		return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);
	***REMOVED***

	apply(parser) ***REMOVED***
		const options = this.options;
		parser.plugin("call define", (expr) => ***REMOVED***
			let array, fn, obj, namedModule;
			switch(expr.arguments.length) ***REMOVED***
				case 1:
					if(isCallable(expr.arguments[0])) ***REMOVED***
						// define(f() ***REMOVED***...***REMOVED***)
						fn = expr.arguments[0];
					***REMOVED*** else if(expr.arguments[0].type === "ObjectExpression") ***REMOVED***
						// define(***REMOVED***...***REMOVED***)
						obj = expr.arguments[0];
					***REMOVED*** else ***REMOVED***
						// define(expr)
						// unclear if function or object
						obj = fn = expr.arguments[0];
					***REMOVED***
					break;
				case 2:
					if(expr.arguments[0].type === "Literal") ***REMOVED***
						namedModule = expr.arguments[0].value;
						// define("...", ...)
						if(isCallable(expr.arguments[1])) ***REMOVED***
							// define("...", f() ***REMOVED***...***REMOVED***)
							fn = expr.arguments[1];
						***REMOVED*** else if(expr.arguments[1].type === "ObjectExpression") ***REMOVED***
							// define("...", ***REMOVED***...***REMOVED***)
							obj = expr.arguments[1];
						***REMOVED*** else ***REMOVED***
							// define("...", expr)
							// unclear if function or object
							obj = fn = expr.arguments[1];
						***REMOVED***
					***REMOVED*** else ***REMOVED***
						array = expr.arguments[0];
						if(isCallable(expr.arguments[1])) ***REMOVED***
							// define([...], f() ***REMOVED******REMOVED***)
							fn = expr.arguments[1];
						***REMOVED*** else if(expr.arguments[1].type === "ObjectExpression") ***REMOVED***
							// define([...], ***REMOVED***...***REMOVED***)
							obj = expr.arguments[1];
						***REMOVED*** else ***REMOVED***
							// define([...], expr)
							// unclear if function or object
							obj = fn = expr.arguments[1];
						***REMOVED***
					***REMOVED***
					break;
				case 3:
					// define("...", [...], f() ***REMOVED***...***REMOVED***)
					namedModule = expr.arguments[0].value;
					array = expr.arguments[1];
					if(isCallable(expr.arguments[2])) ***REMOVED***
						// define("...", [...], f() ***REMOVED******REMOVED***)
						fn = expr.arguments[2];
					***REMOVED*** else if(expr.arguments[2].type === "ObjectExpression") ***REMOVED***
						// define("...", [...], ***REMOVED***...***REMOVED***)
						obj = expr.arguments[2];
					***REMOVED*** else ***REMOVED***
						// define("...", [...], expr)
						// unclear if function or object
						obj = fn = expr.arguments[2];
					***REMOVED***
					break;
				default:
					return;
			***REMOVED***
			let fnParams = null;
			let fnParamsOffset = 0;
			if(fn) ***REMOVED***
				if(isUnboundFunctionExpression(fn)) fnParams = fn.params;
				else if(isBoundFunctionExpression(fn)) ***REMOVED***
					fnParams = fn.callee.object.params;
					fnParamsOffset = fn.arguments.length - 1;
					if(fnParamsOffset < 0) fnParamsOffset = 0;
				***REMOVED***
			***REMOVED***
			let fnRenames = Object.create(parser.scope.renames);
			let identifiers;
			if(array) ***REMOVED***
				identifiers = ***REMOVED******REMOVED***;
				const param = parser.evaluateExpression(array);
				const result = parser.applyPluginsBailResult("call define:amd:array", expr, param, identifiers, namedModule);
				if(!result) return;
				if(fnParams) fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => ***REMOVED***
					if(identifiers[idx]) ***REMOVED***
						fnRenames["$" + param.name] = identifiers[idx];
						return false;
					***REMOVED***
					return true;
				***REMOVED***);
			***REMOVED*** else ***REMOVED***
				identifiers = ["require", "exports", "module"];
				if(fnParams) fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => ***REMOVED***
					if(identifiers[idx]) ***REMOVED***
						fnRenames["$" + param.name] = identifiers[idx];
						return false;
					***REMOVED***
					return true;
				***REMOVED***);
			***REMOVED***
			let inTry;
			if(fn && isUnboundFunctionExpression(fn)) ***REMOVED***
				inTry = parser.scope.inTry;
				parser.inScope(fnParams, () => ***REMOVED***
					parser.scope.renames = fnRenames;
					parser.scope.inTry = inTry;
					if(fn.body.type === "BlockStatement")
						parser.walkStatement(fn.body);
					else
						parser.walkExpression(fn.body);
				***REMOVED***);
			***REMOVED*** else if(fn && isBoundFunctionExpression(fn)) ***REMOVED***
				inTry = parser.scope.inTry;
				parser.inScope(fn.callee.object.params.filter((i) => ["require", "module", "exports"].indexOf(i.name) < 0), () => ***REMOVED***
					parser.scope.renames = fnRenames;
					parser.scope.inTry = inTry;
					if(fn.callee.object.body.type === "BlockStatement")
						parser.walkStatement(fn.callee.object.body);
					else
						parser.walkExpression(fn.callee.object.body);
				***REMOVED***);
				if(fn.arguments)
					parser.walkExpressions(fn.arguments);
			***REMOVED*** else if(fn || obj) ***REMOVED***
				parser.walkExpression(fn || obj);
			***REMOVED***

			const dep = this.newDefineDependency(
				expr.range,
				array ? array.range : null,
				fn ? fn.range : null,
				obj ? obj.range : null,
				namedModule ? namedModule : null
			);
			dep.loc = expr.loc;
			if(namedModule) ***REMOVED***
				dep.localModule = LocalModulesHelpers.addLocalModule(parser.state, namedModule);
			***REMOVED***
			parser.state.current.addDependency(dep);
			return true;
		***REMOVED***);
		parser.plugin("call define:amd:array", (expr, param, identifiers, namedModule) => ***REMOVED***
			if(param.isArray()) ***REMOVED***
				param.items.forEach((param, idx) => ***REMOVED***
					if(param.isString() && ["require", "module", "exports"].indexOf(param.string) >= 0)
						identifiers[idx] = param.string;
					const result = parser.applyPluginsBailResult("call define:amd:item", expr, param, namedModule);
					if(result === undefined) ***REMOVED***
						parser.applyPluginsBailResult("call define:amd:context", expr, param);
					***REMOVED***
				***REMOVED***);
				return true;
			***REMOVED*** else if(param.isConstArray()) ***REMOVED***
				const deps = [];
				param.array.forEach((request, idx) => ***REMOVED***
					let dep;
					let localModule;
					if(request === "require") ***REMOVED***
						identifiers[idx] = request;
						dep = "__webpack_require__";
					***REMOVED*** else if(["exports", "module"].indexOf(request) >= 0) ***REMOVED***
						identifiers[idx] = request;
						dep = request;
					***REMOVED*** else if(localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) ***REMOVED*** // eslint-disable-line no-cond-assign
						dep = new LocalModuleDependency(localModule);
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
					***REMOVED*** else ***REMOVED***
						dep = new AMDRequireItemDependency(request);
						dep.loc = expr.loc;
						dep.optional = !!parser.scope.inTry;
						parser.state.current.addDependency(dep);
					***REMOVED***
					deps.push(dep);
				***REMOVED***);
				const dep = new AMDRequireArrayDependency(deps, param.range);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			***REMOVED***
		***REMOVED***);
		parser.plugin("call define:amd:item", (expr, param, namedModule) => ***REMOVED***
			if(param.isConditional()) ***REMOVED***
				param.options.forEach((param) => ***REMOVED***
					const result = parser.applyPluginsBailResult("call define:amd:item", expr, param);
					if(result === undefined) ***REMOVED***
						parser.applyPluginsBailResult("call define:amd:context", expr, param);
					***REMOVED***
				***REMOVED***);
				return true;
			***REMOVED*** else if(param.isString()) ***REMOVED***
				let dep, localModule;
				if(param.string === "require") ***REMOVED***
					dep = new ConstDependency("__webpack_require__", param.range);
				***REMOVED*** else if(["require", "exports", "module"].indexOf(param.string) >= 0) ***REMOVED***
					dep = new ConstDependency(param.string, param.range);
				***REMOVED*** else if(localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string, namedModule)) ***REMOVED*** // eslint-disable-line no-cond-assign
					dep = new LocalModuleDependency(localModule, param.range);
				***REMOVED*** else ***REMOVED***
					dep = new AMDRequireItemDependency(param.string, param.range);
				***REMOVED***
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			***REMOVED***
		***REMOVED***);
		parser.plugin("call define:amd:context", (expr, param) => ***REMOVED***
			const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		***REMOVED***);
	***REMOVED***
***REMOVED***
module.exports = AMDDefineDependencyParserPlugin;
