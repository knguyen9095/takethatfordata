/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const AMDRequireItemDependency = require("./AMDRequireItemDependency");
const AMDRequireArrayDependency = require("./AMDRequireArrayDependency");
const AMDRequireContextDependency = require("./AMDRequireContextDependency");
const AMDRequireDependenciesBlock = require("./AMDRequireDependenciesBlock");
const UnsupportedDependency = require("./UnsupportedDependency");
const LocalModuleDependency = require("./LocalModuleDependency");
const ContextDependencyHelpers = require("./ContextDependencyHelpers");
const LocalModulesHelpers = require("./LocalModulesHelpers");
const ConstDependency = require("./ConstDependency");
const getFunctionExpression = require("./getFunctionExpression");
const UnsupportedFeatureWarning = require("../UnsupportedFeatureWarning");

class AMDRequireDependenciesBlockParserPlugin ***REMOVED***
	constructor(options) ***REMOVED***
		this.options = options;
	***REMOVED***

	processFunctionArgument(parser, expression) ***REMOVED***
		let bindThis = true;
		const fnData = getFunctionExpression(expression);
		if(fnData) ***REMOVED***
			parser.inScope(fnData.fn.params.filter((i) => ***REMOVED***
				return ["require", "module", "exports"].indexOf(i.name) < 0;
			***REMOVED***), () => ***REMOVED***
				if(fnData.fn.body.type === "BlockStatement")
					parser.walkStatement(fnData.fn.body);
				else
					parser.walkExpression(fnData.fn.body);
			***REMOVED***);
			parser.walkExpressions(fnData.expressions);
			if(fnData.needThis === false) ***REMOVED***
				bindThis = false;
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			parser.walkExpression(expression);
		***REMOVED***
		return bindThis;
	***REMOVED***

	apply(parser) ***REMOVED***
		const options = this.options;
		parser.plugin("call require", (expr) => ***REMOVED***
			let param;
			let dep;
			let result;

			const old = parser.state.current;

			if(expr.arguments.length >= 1) ***REMOVED***
				param = parser.evaluateExpression(expr.arguments[0]);
				dep = new AMDRequireDependenciesBlock(
					expr,
					param.range,
					(expr.arguments.length > 1) ? expr.arguments[1].range : null,
					(expr.arguments.length > 2) ? expr.arguments[2].range : null,
					parser.state.module,
					expr.loc
				);
				parser.state.current = dep;
			***REMOVED***

			if(expr.arguments.length === 1) ***REMOVED***
				parser.inScope([], () => ***REMOVED***
					result = parser.applyPluginsBailResult("call require:amd:array", expr, param);
				***REMOVED***);
				parser.state.current = old;
				if(!result) return;
				parser.state.current.addBlock(dep);
				return true;
			***REMOVED***

			if(expr.arguments.length === 2 || expr.arguments.length === 3) ***REMOVED***
				try ***REMOVED***
					parser.inScope([], () => ***REMOVED***
						result = parser.applyPluginsBailResult("call require:amd:array", expr, param);
					***REMOVED***);
					if(!result) ***REMOVED***
						dep = new UnsupportedDependency("unsupported", expr.range);
						old.addDependency(dep);
						if(parser.state.module)
							parser.state.module.errors.push(new UnsupportedFeatureWarning(parser.state.module, "Cannot statically analyse 'require(..., ...)' in line " + expr.loc.start.line));
						dep = null;
						return true;
					***REMOVED***
					dep.functionBindThis = this.processFunctionArgument(parser, expr.arguments[1]);
					if(expr.arguments.length === 3) ***REMOVED***
						dep.errorCallbackBindThis = this.processFunctionArgument(parser, expr.arguments[2]);
					***REMOVED***
				***REMOVED*** finally ***REMOVED***
					parser.state.current = old;
					if(dep)
						parser.state.current.addBlock(dep);
				***REMOVED***
				return true;
			***REMOVED***
		***REMOVED***);
		parser.plugin("call require:amd:array", (expr, param) => ***REMOVED***
			if(param.isArray()) ***REMOVED***
				param.items.forEach((param) => ***REMOVED***
					const result = parser.applyPluginsBailResult("call require:amd:item", expr, param);
					if(result === undefined) ***REMOVED***
						parser.applyPluginsBailResult("call require:amd:context", expr, param);
					***REMOVED***
				***REMOVED***);
				return true;
			***REMOVED*** else if(param.isConstArray()) ***REMOVED***
				const deps = [];
				param.array.forEach((request) => ***REMOVED***
					let dep, localModule;
					if(request === "require") ***REMOVED***
						dep = "__webpack_require__";
					***REMOVED*** else if(["exports", "module"].indexOf(request) >= 0) ***REMOVED***
						dep = request;
					***REMOVED*** else if(localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) ***REMOVED*** // eslint-disable-line no-cond-assign
						dep = new LocalModuleDependency(localModule);
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
					***REMOVED*** else ***REMOVED***
						dep = new AMDRequireItemDependency(request);
						dep.loc = expr.loc;
						dep.optional = !!parser.scope.inTry;
						parser.state.current.addDependency(dep);
					***REMOVED***
					deps.push(dep);
				***REMOVED***);
				const dep = new AMDRequireArrayDependency(deps, param.range);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			***REMOVED***
		***REMOVED***);
		parser.plugin("call require:amd:item", (expr, param) => ***REMOVED***
			if(param.isConditional()) ***REMOVED***
				param.options.forEach((param) => ***REMOVED***
					const result = parser.applyPluginsBailResult("call require:amd:item", expr, param);
					if(result === undefined) ***REMOVED***
						parser.applyPluginsBailResult("call require:amd:context", expr, param);
					***REMOVED***
				***REMOVED***);
				return true;
			***REMOVED*** else if(param.isString()) ***REMOVED***
				let dep, localModule;
				if(param.string === "require") ***REMOVED***
					dep = new ConstDependency("__webpack_require__", param.string);
				***REMOVED*** else if(param.string === "module") ***REMOVED***
					dep = new ConstDependency(parser.state.module.moduleArgument || "module", param.range);
				***REMOVED*** else if(param.string === "exports") ***REMOVED***
					dep = new ConstDependency(parser.state.module.exportsArgument || "exports", param.range);
				***REMOVED*** else if(localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string)) ***REMOVED*** // eslint-disable-line no-cond-assign
					dep = new LocalModuleDependency(localModule, param.range);
				***REMOVED*** else ***REMOVED***
					dep = new AMDRequireItemDependency(param.string, param.range);
				***REMOVED***
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			***REMOVED***
		***REMOVED***);
		parser.plugin("call require:amd:context", (expr, param) => ***REMOVED***
			const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		***REMOVED***);
	***REMOVED***
***REMOVED***
module.exports = AMDRequireDependenciesBlockParserPlugin;
