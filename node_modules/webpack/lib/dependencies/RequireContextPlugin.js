/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const RequireContextDependency = require("./RequireContextDependency");
const ContextElementDependency = require("./ContextElementDependency");

const RequireContextDependencyParserPlugin = require("./RequireContextDependencyParserPlugin");

class RequireContextPlugin ***REMOVED***
	constructor(modulesDirectories, extensions, mainFiles) ***REMOVED***
		if(!Array.isArray(modulesDirectories))
			throw new Error("modulesDirectories must be an array");
		if(!Array.isArray(extensions))
			throw new Error("extensions must be an array");
		this.modulesDirectories = modulesDirectories;
		this.extensions = extensions;
		this.mainFiles = mainFiles;
	***REMOVED***

	apply(compiler) ***REMOVED***
		compiler.plugin("compilation", (compilation, params) => ***REMOVED***
			const contextModuleFactory = params.contextModuleFactory;
			const normalModuleFactory = params.normalModuleFactory;

			compilation.dependencyFactories.set(RequireContextDependency, contextModuleFactory);
			compilation.dependencyTemplates.set(RequireContextDependency, new RequireContextDependency.Template());

			compilation.dependencyFactories.set(ContextElementDependency, normalModuleFactory);

			params.normalModuleFactory.plugin("parser", (parser, parserOptions) => ***REMOVED***

				if(typeof parserOptions.requireContext !== "undefined" && !parserOptions.requireContext)
					return;

				parser.apply(new RequireContextDependencyParserPlugin());
			***REMOVED***);

			params.contextModuleFactory.plugin("alternatives", (items, callback) => ***REMOVED***
				if(items.length === 0) return callback(null, items);

				callback(null, items.map((obj) => ***REMOVED***
					return this.extensions.filter((ext) => ***REMOVED***
						const l = obj.request.length;
						return l > ext.length && obj.request.substr(l - ext.length, l) === ext;
					***REMOVED***).map((ext) => ***REMOVED***
						const l = obj.request.length;
						return ***REMOVED***
							context: obj.context,
							request: obj.request.substr(0, l - ext.length)
						***REMOVED***;
					***REMOVED***).concat(obj);
				***REMOVED***).reduce((a, b) => a.concat(b), []));
			***REMOVED***);

			params.contextModuleFactory.plugin("alternatives", (items, callback) => ***REMOVED***
				if(items.length === 0) return callback(null, items);

				callback(null, items.map((obj) => ***REMOVED***
					return this.mainFiles.filter((mainFile) => ***REMOVED***
						const l = obj.request.length;
						return l > mainFile.length + 1 && obj.request.substr(l - mainFile.length - 1, l) === "/" + mainFile;
					***REMOVED***).map((mainFile) => ***REMOVED***
						const l = obj.request.length;
						return [***REMOVED***
							context: obj.context,
							request: obj.request.substr(0, l - mainFile.length)
						***REMOVED***, ***REMOVED***
							context: obj.context,
							request: obj.request.substr(0, l - mainFile.length - 1)
						***REMOVED***];
					***REMOVED***).reduce((a, b) => a.concat(b), []).concat(obj);
				***REMOVED***).reduce((a, b) => a.concat(b), []));
			***REMOVED***);

			params.contextModuleFactory.plugin("alternatives", (items, callback) => ***REMOVED***
				if(items.length === 0) return callback(null, items);

				callback(null, items.map((obj) => ***REMOVED***
					for(let i = 0; i < this.modulesDirectories.length; i++) ***REMOVED***
						const dir = this.modulesDirectories[i];
						const idx = obj.request.indexOf("./" + dir + "/");
						if(idx === 0) ***REMOVED***
							obj.request = obj.request.slice(dir.length + 3);
							break;
						***REMOVED***
					***REMOVED***
					return obj;
				***REMOVED***));
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***
module.exports = RequireContextPlugin;
