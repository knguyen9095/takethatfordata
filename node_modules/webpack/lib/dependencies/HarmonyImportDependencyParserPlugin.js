/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const HarmonyImportDependency = require("./HarmonyImportDependency");
const HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");
const HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");
const HarmonyAcceptDependency = require("./HarmonyAcceptDependency");
const HarmonyModulesHelpers = require("./HarmonyModulesHelpers");

module.exports = class HarmonyImportDependencyParserPlugin ***REMOVED***
	constructor(moduleOptions) ***REMOVED***
		this.strictExportPresence = moduleOptions.strictExportPresence;
		this.strictThisContextOnImports = moduleOptions.strictThisContextOnImports;
	***REMOVED***

	apply(parser) ***REMOVED***
		parser.plugin("import", (statement, source) => ***REMOVED***
			const dep = new HarmonyImportDependency(source, HarmonyModulesHelpers.getNewModuleVar(parser.state, source), statement.range);
			dep.loc = statement.loc;
			parser.state.current.addDependency(dep);
			parser.state.lastHarmonyImport = dep;
			return true;
		***REMOVED***);
		parser.plugin("import specifier", (statement, source, id, name) => ***REMOVED***
			parser.scope.definitions.length--;
			parser.scope.renames[`$$***REMOVED***name***REMOVED***`] = "imported var";
			if(!parser.state.harmonySpecifier) parser.state.harmonySpecifier = ***REMOVED******REMOVED***;
			parser.state.harmonySpecifier[`$$***REMOVED***name***REMOVED***`] = [parser.state.lastHarmonyImport, HarmonyModulesHelpers.getModuleVar(parser.state, source), id];
			return true;
		***REMOVED***);
		parser.plugin("expression imported var", (expr) => ***REMOVED***
			const name = expr.name;
			const settings = parser.state.harmonySpecifier[`$$***REMOVED***name***REMOVED***`];
			const dep = new HarmonyImportSpecifierDependency(settings[0], settings[1], settings[2], name, expr.range, this.strictExportPresence);
			dep.shorthand = parser.scope.inShorthand;
			dep.directImport = true;
			dep.loc = expr.loc;
			parser.state.current.addDependency(dep);
			return true;
		***REMOVED***);
		parser.plugin("expression imported var.*", (expr) => ***REMOVED***
			const name = expr.object.name;
			const settings = parser.state.harmonySpecifier[`$$***REMOVED***name***REMOVED***`];
			if(settings[2] !== null)
				return false;
			const dep = new HarmonyImportSpecifierDependency(settings[0], settings[1], expr.property.name || expr.property.value, name, expr.range, this.strictExportPresence);
			dep.shorthand = parser.scope.inShorthand;
			dep.directImport = false;
			dep.loc = expr.loc;
			parser.state.current.addDependency(dep);
			return true;
		***REMOVED***);
		if(this.strictThisContextOnImports) ***REMOVED***
			// only in case when we strictly follow the spec we need a special case here
			parser.plugin("call imported var.*", (expr) => ***REMOVED***
				if(expr.callee.type !== "MemberExpression") return;
				if(expr.callee.object.type !== "Identifier") return;
				const name = expr.callee.object.name;
				const settings = parser.state.harmonySpecifier[`$$***REMOVED***name***REMOVED***`];
				if(settings[2] !== null)
					return false;
				const dep = new HarmonyImportSpecifierDependency(settings[0], settings[1], expr.callee.property.name || expr.callee.property.value, name, expr.callee.range, this.strictExportPresence);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = false;
				dep.namespaceObjectAsContext = true;
				dep.loc = expr.callee.loc;
				parser.state.current.addDependency(dep);
				if(expr.arguments)
					parser.walkExpressions(expr.arguments);
				return true;
			***REMOVED***);
		***REMOVED***
		parser.plugin("call imported var", (expr) => ***REMOVED***
			const args = expr.arguments;
			const fullExpr = expr;
			expr = expr.callee;
			if(expr.type !== "Identifier") return;
			const name = expr.name;
			const settings = parser.state.harmonySpecifier[`$$***REMOVED***name***REMOVED***`];
			const dep = new HarmonyImportSpecifierDependency(settings[0], settings[1], settings[2], name, expr.range, this.strictExportPresence);
			dep.directImport = true;
			dep.callArgs = args;
			dep.call = fullExpr;
			dep.loc = expr.loc;
			parser.state.current.addDependency(dep);
			if(args)
				parser.walkExpressions(args);
			return true;
		***REMOVED***);
		parser.plugin("hot accept callback", (expr, requests) => ***REMOVED***
			const dependencies = requests
				.filter(request => HarmonyModulesHelpers.checkModuleVar(parser.state, request))
				.map(request => ***REMOVED***
					const dep = new HarmonyAcceptImportDependency(request, HarmonyModulesHelpers.getModuleVar(parser.state, request), expr.range);
					dep.loc = expr.loc;
					parser.state.current.addDependency(dep);
					return dep;
				***REMOVED***);
			if(dependencies.length > 0) ***REMOVED***
				const dep = new HarmonyAcceptDependency(expr.range, dependencies, true);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
			***REMOVED***
		***REMOVED***);
		parser.plugin("hot accept without callback", (expr, requests) => ***REMOVED***
			const dependencies = requests
				.filter(request => HarmonyModulesHelpers.checkModuleVar(parser.state, request))
				.map(request => ***REMOVED***
					const dep = new HarmonyAcceptImportDependency(request, HarmonyModulesHelpers.getModuleVar(parser.state, request), expr.range);
					dep.loc = expr.loc;
					parser.state.current.addDependency(dep);
					return dep;
				***REMOVED***);
			if(dependencies.length > 0) ***REMOVED***
				const dep = new HarmonyAcceptDependency(expr.range, dependencies, false);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
			***REMOVED***
		***REMOVED***);
	***REMOVED***
***REMOVED***;
