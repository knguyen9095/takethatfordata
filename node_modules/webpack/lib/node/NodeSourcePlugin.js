/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";
const AliasPlugin = require("enhanced-resolve/lib/AliasPlugin");
const ParserHelpers = require("../ParserHelpers");
const nodeLibsBrowser = require("node-libs-browser");

module.exports = class NodeSourcePlugin ***REMOVED***
	constructor(options) ***REMOVED***
		this.options = options;
	***REMOVED***
	apply(compiler) ***REMOVED***
		const options = this.options;
		if(options === false) // allow single kill switch to turn off this plugin
			return;

		function getPathToModule(module, type) ***REMOVED***
			if(type === true || (type === undefined && nodeLibsBrowser[module])) ***REMOVED***
				if(!nodeLibsBrowser[module]) throw new Error(`No browser version for node.js core module $***REMOVED***module***REMOVED*** available`);
				return nodeLibsBrowser[module];
			***REMOVED*** else if(type === "mock") ***REMOVED***
				return require.resolve(`node-libs-browser/mock/$***REMOVED***module***REMOVED***`);
			***REMOVED*** else if(type === "empty") ***REMOVED***
				return require.resolve("node-libs-browser/mock/empty");
			***REMOVED*** else return module;
		***REMOVED***

		function addExpression(parser, name, module, type, suffix) ***REMOVED***
			suffix = suffix || "";
			parser.plugin(`expression $***REMOVED***name***REMOVED***`, function() ***REMOVED***
				if(this.state.module && this.state.module.resource === getPathToModule(module, type)) return;
				const mockModule = ParserHelpers.requireFileAsExpression(this.state.module.context, getPathToModule(module, type));
				return ParserHelpers.addParsedVariableToModule(this, name, mockModule + suffix);
			***REMOVED***);
		***REMOVED***

		compiler.plugin("compilation", function(compilation, params) ***REMOVED***
			params.normalModuleFactory.plugin("parser", function(parser, parserOptions) ***REMOVED***

				if(parserOptions.node === false)
					return;

				let localOptions = options;
				if(parserOptions.node)
					localOptions = Object.assign(***REMOVED******REMOVED***, localOptions, parserOptions.node);

				if(localOptions.global) ***REMOVED***
					parser.plugin("expression global", function() ***REMOVED***
						const retrieveGlobalModule = ParserHelpers.requireFileAsExpression(this.state.module.context, require.resolve("../../buildin/global.js"));
						return ParserHelpers.addParsedVariableToModule(this, "global", retrieveGlobalModule);
					***REMOVED***);
				***REMOVED***
				if(localOptions.process) ***REMOVED***
					const processType = localOptions.process;
					addExpression(parser, "process", "process", processType);
				***REMOVED***
				if(localOptions.console) ***REMOVED***
					const consoleType = localOptions.console;
					addExpression(parser, "console", "console", consoleType);
				***REMOVED***
				const bufferType = localOptions.Buffer;
				if(bufferType) ***REMOVED***
					addExpression(parser, "Buffer", "buffer", bufferType, ".Buffer");
				***REMOVED***
				if(localOptions.setImmediate) ***REMOVED***
					const setImmediateType = localOptions.setImmediate;
					addExpression(parser, "setImmediate", "timers", setImmediateType, ".setImmediate");
					addExpression(parser, "clearImmediate", "timers", setImmediateType, ".clearImmediate");
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
		compiler.plugin("after-resolvers", (compiler) => ***REMOVED***
			Object.keys(nodeLibsBrowser).forEach((lib) => ***REMOVED***
				if(options[lib] !== false) ***REMOVED***
					compiler.resolvers.normal.apply(
						new AliasPlugin("described-resolve", ***REMOVED***
							name: lib,
							onlyModule: true,
							alias: getPathToModule(lib, options[lib])
						***REMOVED***, "resolve")
					);
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***;
