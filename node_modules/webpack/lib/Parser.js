/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API

const acorn = require("acorn-dynamic-import").default;
const Tapable = require("tapable");
const json5 = require("json5");
const BasicEvaluatedExpression = require("./BasicEvaluatedExpression");

function joinRanges(startRange, endRange) ***REMOVED***
	if(!endRange) return startRange;
	if(!startRange) return endRange;
	return [startRange[0], endRange[1]];
***REMOVED***

const ECMA_VERSION = 2017;

const POSSIBLE_AST_OPTIONS = [***REMOVED***
	ranges: true,
	locations: true,
	ecmaVersion: ECMA_VERSION,
	sourceType: "module",
	plugins: ***REMOVED***
		dynamicImport: true
	***REMOVED***
***REMOVED***, ***REMOVED***
	ranges: true,
	locations: true,
	ecmaVersion: ECMA_VERSION,
	sourceType: "script",
	plugins: ***REMOVED***
		dynamicImport: true
	***REMOVED***
***REMOVED***];

class Parser extends Tapable ***REMOVED***
	constructor(options) ***REMOVED***
		super();
		this.options = options;
		this.scope = undefined;
		this.state = undefined;
		this.comments = undefined;
		this.initializeEvaluating();
	***REMOVED***

	initializeEvaluating() ***REMOVED***
		this.plugin("evaluate Literal", expr => ***REMOVED***
			switch(typeof expr.value) ***REMOVED***
				case "number":
					return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);
			***REMOVED***
			if(expr.value === null)
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			if(expr.value instanceof RegExp)
				return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);
		***REMOVED***);
		this.plugin("evaluate LogicalExpression", function(expr) ***REMOVED***
			let left;
			let leftAsBool;
			let right;
			if(expr.operator === "&&") ***REMOVED***
				left = this.evaluateExpression(expr.left);
				leftAsBool = left && left.asBool();
				if(leftAsBool === false) return left.setRange(expr.range);
				if(leftAsBool !== true) return;
				right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			***REMOVED*** else if(expr.operator === "||") ***REMOVED***
				left = this.evaluateExpression(expr.left);
				leftAsBool = left && left.asBool();
				if(leftAsBool === true) return left.setRange(expr.range);
				if(leftAsBool !== false) return;
				right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			***REMOVED***
		***REMOVED***);
		this.plugin("evaluate BinaryExpression", function(expr) ***REMOVED***
			let left;
			let right;
			let res;
			if(expr.operator === "+") ***REMOVED***
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				res = new BasicEvaluatedExpression();
				if(left.isString()) ***REMOVED***
					if(right.isString()) ***REMOVED***
						res.setString(left.string + right.string);
					***REMOVED*** else if(right.isNumber()) ***REMOVED***
						res.setString(left.string + right.number);
					***REMOVED*** else if(right.isWrapped() && right.prefix && right.prefix.isString()) ***REMOVED***
						res.setWrapped(
							new BasicEvaluatedExpression()
							.setString(left.string + right.prefix.string)
							.setRange(joinRanges(left.range, right.prefix.range)),
							right.postfix);
					***REMOVED*** else if(right.isWrapped()) ***REMOVED***
						res.setWrapped(
							new BasicEvaluatedExpression()
							.setString(left.string)
							.setRange(left.range),
							right.postfix);
					***REMOVED*** else ***REMOVED***
						res.setWrapped(left, null);
					***REMOVED***
				***REMOVED*** else if(left.isNumber()) ***REMOVED***
					if(right.isString()) ***REMOVED***
						res.setString(left.number + right.string);
					***REMOVED*** else if(right.isNumber()) ***REMOVED***
						res.setNumber(left.number + right.number);
					***REMOVED***
				***REMOVED*** else if(left.isWrapped()) ***REMOVED***
					if(left.postfix && left.postfix.isString() && right.isString()) ***REMOVED***
						res.setWrapped(left.prefix,
							new BasicEvaluatedExpression()
							.setString(left.postfix.string + right.string)
							.setRange(joinRanges(left.postfix.range, right.range))
						);
					***REMOVED*** else if(left.postfix && left.postfix.isString() && right.isNumber()) ***REMOVED***
						res.setWrapped(left.prefix,
							new BasicEvaluatedExpression()
							.setString(left.postfix.string + right.number)
							.setRange(joinRanges(left.postfix.range, right.range))
						);
					***REMOVED*** else if(right.isString()) ***REMOVED***
						res.setWrapped(left.prefix, right);
					***REMOVED*** else if(right.isNumber()) ***REMOVED***
						res.setWrapped(left.prefix,
							new BasicEvaluatedExpression()
							.setString(right.number + "")
							.setRange(right.range));
					***REMOVED*** else ***REMOVED***
						res.setWrapped(left.prefix, new BasicEvaluatedExpression());
					***REMOVED***
				***REMOVED*** else ***REMOVED***
					if(right.isString()) ***REMOVED***
						res.setWrapped(null, right);
					***REMOVED***
				***REMOVED***
				res.setRange(expr.range);
				return res;
			***REMOVED*** else if(expr.operator === "-") ***REMOVED***
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				if(!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number - right.number);
				res.setRange(expr.range);
				return res;
			***REMOVED*** else if(expr.operator === "*") ***REMOVED***
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				if(!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number * right.number);
				res.setRange(expr.range);
				return res;
			***REMOVED*** else if(expr.operator === "/") ***REMOVED***
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				if(!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number / right.number);
				res.setRange(expr.range);
				return res;
			***REMOVED*** else if(expr.operator === "==" || expr.operator === "===") ***REMOVED***
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if(left.isString() && right.isString()) ***REMOVED***
					return res.setBoolean(left.string === right.string);
				***REMOVED*** else if(left.isNumber() && right.isNumber()) ***REMOVED***
					return res.setBoolean(left.number === right.number);
				***REMOVED*** else if(left.isBoolean() && right.isBoolean()) ***REMOVED***
					return res.setBoolean(left.bool === right.bool);
				***REMOVED***
			***REMOVED*** else if(expr.operator === "!=" || expr.operator === "!==") ***REMOVED***
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if(left.isString() && right.isString()) ***REMOVED***
					return res.setBoolean(left.string !== right.string);
				***REMOVED*** else if(left.isNumber() && right.isNumber()) ***REMOVED***
					return res.setBoolean(left.number !== right.number);
				***REMOVED*** else if(left.isBoolean() && right.isBoolean()) ***REMOVED***
					return res.setBoolean(left.bool !== right.bool);
				***REMOVED***
			***REMOVED***
		***REMOVED***);
		this.plugin("evaluate UnaryExpression", function(expr) ***REMOVED***
			if(expr.operator === "typeof") ***REMOVED***
				let res;
				let name;
				if(expr.argument.type === "Identifier") ***REMOVED***
					name = this.scope.renames["$" + expr.argument.name] || expr.argument.name;
					if(this.scope.definitions.indexOf(name) === -1) ***REMOVED***
						res = this.applyPluginsBailResult1("evaluate typeof " + name, expr);
						if(res !== undefined) return res;
					***REMOVED***
				***REMOVED***
				if(expr.argument.type === "MemberExpression") ***REMOVED***
					const exprName = this.getNameForExpression(expr.argument);
					if(exprName && exprName.free) ***REMOVED***
						res = this.applyPluginsBailResult1("evaluate typeof " + exprName.name, expr);
						if(res !== undefined) return res;
					***REMOVED***
				***REMOVED***
				if(expr.argument.type === "FunctionExpression") ***REMOVED***
					return new BasicEvaluatedExpression().setString("function").setRange(expr.range);
				***REMOVED***
				const arg = this.evaluateExpression(expr.argument);
				if(arg.isString() || arg.isWrapped()) return new BasicEvaluatedExpression().setString("string").setRange(expr.range);
				else if(arg.isNumber()) return new BasicEvaluatedExpression().setString("number").setRange(expr.range);
				else if(arg.isBoolean()) return new BasicEvaluatedExpression().setString("boolean").setRange(expr.range);
				else if(arg.isArray() || arg.isConstArray() || arg.isRegExp()) return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
			***REMOVED*** else if(expr.operator === "!") ***REMOVED***
				const argument = this.evaluateExpression(expr.argument);
				if(!argument) return;
				if(argument.isBoolean()) ***REMOVED***
					return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);
				***REMOVED*** else if(argument.isTruthy()) ***REMOVED***
					return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);
				***REMOVED*** else if(argument.isFalsy()) ***REMOVED***
					return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);
				***REMOVED*** else if(argument.isString()) ***REMOVED***
					return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);
				***REMOVED*** else if(argument.isNumber()) ***REMOVED***
					return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);
				***REMOVED***
			***REMOVED***
		***REMOVED***);
		this.plugin("evaluate typeof undefined", function(expr) ***REMOVED***
			return new BasicEvaluatedExpression().setString("undefined").setRange(expr.range);
		***REMOVED***);
		this.plugin("evaluate Identifier", function(expr) ***REMOVED***
			const name = this.scope.renames["$" + expr.name] || expr.name;
			if(this.scope.definitions.indexOf(expr.name) === -1) ***REMOVED***
				const result = this.applyPluginsBailResult1("evaluate Identifier " + name, expr);
				if(result) return result;
				return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);
			***REMOVED*** else ***REMOVED***
				return this.applyPluginsBailResult1("evaluate defined Identifier " + name, expr);
			***REMOVED***
		***REMOVED***);
		this.plugin("evaluate ThisExpression", function(expr) ***REMOVED***
			const name = this.scope.renames.$this;
			if(name) ***REMOVED***
				const result = this.applyPluginsBailResult1("evaluate Identifier " + name, expr);
				if(result) return result;
				return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);
			***REMOVED***
		***REMOVED***);
		this.plugin("evaluate MemberExpression", function(expression) ***REMOVED***
			let exprName = this.getNameForExpression(expression);
			if(exprName) ***REMOVED***
				if(exprName.free) ***REMOVED***
					const result = this.applyPluginsBailResult1("evaluate Identifier " + exprName.name, expression);
					if(result) return result;
					return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);
				***REMOVED*** else ***REMOVED***
					return this.applyPluginsBailResult1("evaluate defined Identifier " + exprName.name, expression);
				***REMOVED***
			***REMOVED***
		***REMOVED***);
		this.plugin("evaluate CallExpression", function(expr) ***REMOVED***
			if(expr.callee.type !== "MemberExpression") return;
			if(expr.callee.property.type !== (expr.callee.computed ? "Literal" : "Identifier")) return;
			const param = this.evaluateExpression(expr.callee.object);
			if(!param) return;
			const property = expr.callee.property.name || expr.callee.property.value;
			return this.applyPluginsBailResult("evaluate CallExpression ." + property, expr, param);
		***REMOVED***);
		this.plugin("evaluate CallExpression .replace", function(expr, param) ***REMOVED***
			if(!param.isString()) return;
			if(expr.arguments.length !== 2) return;
			let arg1 = this.evaluateExpression(expr.arguments[0]);
			let arg2 = this.evaluateExpression(expr.arguments[1]);
			if(!arg1.isString() && !arg1.isRegExp()) return;
			arg1 = arg1.regExp || arg1.string;
			if(!arg2.isString()) return;
			arg2 = arg2.string;
			return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);
		***REMOVED***);
		["substr", "substring"].forEach(fn => ***REMOVED***
			this.plugin("evaluate CallExpression ." + fn, function(expr, param) ***REMOVED***
				if(!param.isString()) return;
				let arg1;
				let result, str = param.string;
				switch(expr.arguments.length) ***REMOVED***
					case 1:
						arg1 = this.evaluateExpression(expr.arguments[0]);
						if(!arg1.isNumber()) return;
						result = str[fn](arg1.number);
						break;
					case 2:
						***REMOVED***
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if(!arg1.isNumber()) return;
							if(!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						***REMOVED***
					default:
						return;
				***REMOVED***
				return new BasicEvaluatedExpression().setString(result).setRange(expr.range);
			***REMOVED***);
		***REMOVED***);

		/**
		 * @param ***REMOVED***string***REMOVED*** kind "cooked" | "raw"
		 * @param ***REMOVED***any[]***REMOVED*** quasis quasis
		 * @param ***REMOVED***any[]***REMOVED*** expressions expressions
		 * @return ***REMOVED***BasicEvaluatedExpression[]***REMOVED*** Simplified template
		 */
		function getSimplifiedTemplateResult(kind, quasis, expressions) ***REMOVED***
			const parts = [];

			for(let i = 0; i < quasis.length; i++) ***REMOVED***
				parts.push(new BasicEvaluatedExpression().setString(quasis[i].value[kind]).setRange(quasis[i].range));

				if(i > 0) ***REMOVED***
					const prevExpr = parts[parts.length - 2],
						lastExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(expressions[i - 1]);
					if(!(expr.isString() || expr.isNumber())) continue;

					prevExpr.setString(prevExpr.string + (expr.isString() ? expr.string : expr.number) + lastExpr.string);
					prevExpr.setRange([prevExpr.range[0], lastExpr.range[1]]);
					parts.pop();
				***REMOVED***
			***REMOVED***
			return parts;
		***REMOVED***

		this.plugin("evaluate TemplateLiteral", function(node) ***REMOVED***
			const parts = getSimplifiedTemplateResult.call(this, "cooked", node.quasis, node.expressions);
			if(parts.length === 1) ***REMOVED***
				return parts[0].setRange(node.range);
			***REMOVED***
			return new BasicEvaluatedExpression().setTemplateString(parts).setRange(node.range);
		***REMOVED***);
		this.plugin("evaluate TaggedTemplateExpression", function(node) ***REMOVED***
			if(this.evaluateExpression(node.tag).identifier !== "String.raw") return;
			const parts = getSimplifiedTemplateResult.call(this, "raw", node.quasi.quasis, node.quasi.expressions);
			return new BasicEvaluatedExpression().setTemplateString(parts).setRange(node.range);
		***REMOVED***);

		this.plugin("evaluate CallExpression .concat", function(expr, param) ***REMOVED***
			if(!param.isString() && !param.isWrapped()) return;

			let stringSuffix = null;
			let hasUnknownParams = false;
			for(let i = expr.arguments.length - 1; i >= 0; i--) ***REMOVED***
				const argExpr = this.evaluateExpression(expr.arguments[i]);
				if(!argExpr.isString() && !argExpr.isNumber()) ***REMOVED***
					hasUnknownParams = true;
					break;
				***REMOVED***

				const value = argExpr.isString() ? argExpr.string : "" + argExpr.number;

				const newString = value + (stringSuffix ? stringSuffix.string : "");
				const newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];
				stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);
			***REMOVED***

			if(hasUnknownParams) ***REMOVED***
				const prefix = param.isString() ? param : param.prefix;
				return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);
			***REMOVED*** else if(param.isWrapped()) ***REMOVED***
				const postfix = stringSuffix || param.postfix;
				return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);
			***REMOVED*** else ***REMOVED***
				const newString = param.string + (stringSuffix ? stringSuffix.string : "");
				return new BasicEvaluatedExpression().setString(newString).setRange(expr.range);
			***REMOVED***
		***REMOVED***);
		this.plugin("evaluate CallExpression .split", function(expr, param) ***REMOVED***
			if(!param.isString()) return;
			if(expr.arguments.length !== 1) return;
			let result;
			const arg = this.evaluateExpression(expr.arguments[0]);
			if(arg.isString()) ***REMOVED***
				result = param.string.split(arg.string);
			***REMOVED*** else if(arg.isRegExp()) ***REMOVED***
				result = param.string.split(arg.regExp);
			***REMOVED*** else return;
			return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);
		***REMOVED***);
		this.plugin("evaluate ConditionalExpression", function(expr) ***REMOVED***
			const condition = this.evaluateExpression(expr.test);
			const conditionValue = condition.asBool();
			let res;
			if(conditionValue === undefined) ***REMOVED***
				const consequent = this.evaluateExpression(expr.consequent);
				const alternate = this.evaluateExpression(expr.alternate);
				if(!consequent || !alternate) return;
				res = new BasicEvaluatedExpression();
				if(consequent.isConditional())
					res.setOptions(consequent.options);
				else
					res.setOptions([consequent]);
				if(alternate.isConditional())
					res.addOptions(alternate.options);
				else
					res.addOptions([alternate]);
			***REMOVED*** else ***REMOVED***
				res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);
			***REMOVED***
			res.setRange(expr.range);
			return res;
		***REMOVED***);
		this.plugin("evaluate ArrayExpression", function(expr) ***REMOVED***
			const items = expr.elements.map(function(element) ***REMOVED***
				return element !== null && this.evaluateExpression(element);
			***REMOVED***, this);
			if(!items.every(Boolean)) return;
			return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);
		***REMOVED***);
	***REMOVED***

	getRenameIdentifier(expr) ***REMOVED***
		const result = this.evaluateExpression(expr);
		if(!result) return;
		if(result.isIdentifier()) return result.identifier;
		return;
	***REMOVED***

	walkClass(classy) ***REMOVED***
		if(classy.superClass)
			this.walkExpression(classy.superClass);
		if(classy.body && classy.body.type === "ClassBody") ***REMOVED***
			classy.body.body.forEach(methodDefinition => ***REMOVED***
				if(methodDefinition.type === "MethodDefinition")
					this.walkMethodDefinition(methodDefinition);
			***REMOVED***);
		***REMOVED***
	***REMOVED***

	walkMethodDefinition(methodDefinition) ***REMOVED***
		if(methodDefinition.computed && methodDefinition.key)
			this.walkExpression(methodDefinition.key);
		if(methodDefinition.value)
			this.walkExpression(methodDefinition.value);
	***REMOVED***

	// Prewalking iterates the scope for variable declarations
	prewalkStatements(statements) ***REMOVED***
		for(let index = 0, len = statements.length; index < len; index++) ***REMOVED***
			const statement = statements[index];
			this.prewalkStatement(statement);
		***REMOVED***
	***REMOVED***

	// Walking iterates the statements and expressions and processes them
	walkStatements(statements) ***REMOVED***
		for(let index = 0, len = statements.length; index < len; index++) ***REMOVED***
			const statement = statements[index];
			this.walkStatement(statement);
		***REMOVED***
	***REMOVED***

	prewalkStatement(statement) ***REMOVED***
		const handler = this["prewalk" + statement.type];
		if(handler)
			handler.call(this, statement);
	***REMOVED***

	walkStatement(statement) ***REMOVED***
		if(this.applyPluginsBailResult1("statement", statement) !== undefined) return;
		const handler = this["walk" + statement.type];
		if(handler)
			handler.call(this, statement);
	***REMOVED***

	// Real Statements
	prewalkBlockStatement(statement) ***REMOVED***
		this.prewalkStatements(statement.body);
	***REMOVED***

	walkBlockStatement(statement) ***REMOVED***
		this.walkStatements(statement.body);
	***REMOVED***

	walkExpressionStatement(statement) ***REMOVED***
		this.walkExpression(statement.expression);
	***REMOVED***

	prewalkIfStatement(statement) ***REMOVED***
		this.prewalkStatement(statement.consequent);
		if(statement.alternate)
			this.prewalkStatement(statement.alternate);
	***REMOVED***

	walkIfStatement(statement) ***REMOVED***
		const result = this.applyPluginsBailResult1("statement if", statement);
		if(result === undefined) ***REMOVED***
			this.walkExpression(statement.test);
			this.walkStatement(statement.consequent);
			if(statement.alternate)
				this.walkStatement(statement.alternate);
		***REMOVED*** else ***REMOVED***
			if(result)
				this.walkStatement(statement.consequent);
			else if(statement.alternate)
				this.walkStatement(statement.alternate);
		***REMOVED***
	***REMOVED***

	prewalkLabeledStatement(statement) ***REMOVED***
		this.prewalkStatement(statement.body);
	***REMOVED***

	walkLabeledStatement(statement) ***REMOVED***
		const result = this.applyPluginsBailResult1("label " + statement.label.name, statement);
		if(result !== true)
			this.walkStatement(statement.body);
	***REMOVED***

	prewalkWithStatement(statement) ***REMOVED***
		this.prewalkStatement(statement.body);
	***REMOVED***

	walkWithStatement(statement) ***REMOVED***
		this.walkExpression(statement.object);
		this.walkStatement(statement.body);
	***REMOVED***

	prewalkSwitchStatement(statement) ***REMOVED***
		this.prewalkSwitchCases(statement.cases);
	***REMOVED***

	walkSwitchStatement(statement) ***REMOVED***
		this.walkExpression(statement.discriminant);
		this.walkSwitchCases(statement.cases);
	***REMOVED***

	walkTerminatingStatement(statement) ***REMOVED***
		if(statement.argument)
			this.walkExpression(statement.argument);
	***REMOVED***

	walkReturnStatement(statement) ***REMOVED***
		this.walkTerminatingStatement(statement);
	***REMOVED***

	walkThrowStatement(statement) ***REMOVED***
		this.walkTerminatingStatement(statement);
	***REMOVED***

	prewalkTryStatement(statement) ***REMOVED***
		this.prewalkStatement(statement.block);
	***REMOVED***

	walkTryStatement(statement) ***REMOVED***
		if(this.scope.inTry) ***REMOVED***
			this.walkStatement(statement.block);
		***REMOVED*** else ***REMOVED***
			this.scope.inTry = true;
			this.walkStatement(statement.block);
			this.scope.inTry = false;
		***REMOVED***
		if(statement.handler)
			this.walkCatchClause(statement.handler);
		if(statement.finalizer)
			this.walkStatement(statement.finalizer);
	***REMOVED***

	prewalkWhileStatement(statement) ***REMOVED***
		this.prewalkStatement(statement.body);
	***REMOVED***

	walkWhileStatement(statement) ***REMOVED***
		this.walkExpression(statement.test);
		this.walkStatement(statement.body);
	***REMOVED***

	prewalkDoWhileStatement(statement) ***REMOVED***
		this.prewalkStatement(statement.body);
	***REMOVED***

	walkDoWhileStatement(statement) ***REMOVED***
		this.walkStatement(statement.body);
		this.walkExpression(statement.test);
	***REMOVED***

	prewalkForStatement(statement) ***REMOVED***
		if(statement.init) ***REMOVED***
			if(statement.init.type === "VariableDeclaration")
				this.prewalkStatement(statement.init);
		***REMOVED***
		this.prewalkStatement(statement.body);
	***REMOVED***

	walkForStatement(statement) ***REMOVED***
		if(statement.init) ***REMOVED***
			if(statement.init.type === "VariableDeclaration")
				this.walkStatement(statement.init);
			else
				this.walkExpression(statement.init);
		***REMOVED***
		if(statement.test)
			this.walkExpression(statement.test);
		if(statement.update)
			this.walkExpression(statement.update);
		this.walkStatement(statement.body);
	***REMOVED***

	prewalkForInStatement(statement) ***REMOVED***
		if(statement.left.type === "VariableDeclaration")
			this.prewalkStatement(statement.left);
		this.prewalkStatement(statement.body);
	***REMOVED***

	walkForInStatement(statement) ***REMOVED***
		if(statement.left.type === "VariableDeclaration")
			this.walkStatement(statement.left);
		else
			this.walkExpression(statement.left);
		this.walkExpression(statement.right);
		this.walkStatement(statement.body);
	***REMOVED***

	prewalkForOfStatement(statement) ***REMOVED***
		if(statement.left.type === "VariableDeclaration")
			this.prewalkStatement(statement.left);
		this.prewalkStatement(statement.body);
	***REMOVED***

	walkForOfStatement(statement) ***REMOVED***
		if(statement.left.type === "VariableDeclaration")
			this.walkStatement(statement.left);
		else
			this.walkExpression(statement.left);
		this.walkExpression(statement.right);
		this.walkStatement(statement.body);
	***REMOVED***

	// Declarations
	prewalkFunctionDeclaration(statement) ***REMOVED***
		if(statement.id) ***REMOVED***
			this.scope.renames["$" + statement.id.name] = undefined;
			this.scope.definitions.push(statement.id.name);
		***REMOVED***
	***REMOVED***

	walkFunctionDeclaration(statement) ***REMOVED***
		statement.params.forEach(param => ***REMOVED***
			this.walkPattern(param);
		***REMOVED***);
		this.inScope(statement.params, () => ***REMOVED***
			if(statement.body.type === "BlockStatement") ***REMOVED***
				this.prewalkStatement(statement.body);
				this.walkStatement(statement.body);
			***REMOVED*** else ***REMOVED***
				this.walkExpression(statement.body);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	prewalkImportDeclaration(statement) ***REMOVED***
		const source = statement.source.value;
		this.applyPluginsBailResult("import", statement, source);
		statement.specifiers.forEach(function(specifier) ***REMOVED***
			const name = specifier.local.name;
			this.scope.renames["$" + name] = undefined;
			this.scope.definitions.push(name);
			switch(specifier.type) ***REMOVED***
				case "ImportDefaultSpecifier":
					this.applyPluginsBailResult("import specifier", statement, source, "default", name);
					break;
				case "ImportSpecifier":
					this.applyPluginsBailResult("import specifier", statement, source, specifier.imported.name, name);
					break;
				case "ImportNamespaceSpecifier":
					this.applyPluginsBailResult("import specifier", statement, source, null, name);
					break;
			***REMOVED***
		***REMOVED***, this);
	***REMOVED***

	prewalkExportNamedDeclaration(statement) ***REMOVED***
		let source;
		if(statement.source) ***REMOVED***
			source = statement.source.value;
			this.applyPluginsBailResult("export import", statement, source);
		***REMOVED*** else ***REMOVED***
			this.applyPluginsBailResult1("export", statement);
		***REMOVED***
		if(statement.declaration) ***REMOVED***
			if(/Expression$/.test(statement.declaration.type)) ***REMOVED***
				throw new Error("Doesn't occur?");
			***REMOVED*** else ***REMOVED***
				if(!this.applyPluginsBailResult("export declaration", statement, statement.declaration)) ***REMOVED***
					const pos = this.scope.definitions.length;
					this.prewalkStatement(statement.declaration);
					const newDefs = this.scope.definitions.slice(pos);
					for(let index = newDefs.length - 1; index >= 0; index--) ***REMOVED***
						const def = newDefs[index];
						this.applyPluginsBailResult("export specifier", statement, def, def, index);
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if(statement.specifiers) ***REMOVED***
			for(let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) ***REMOVED***
				const specifier = statement.specifiers[specifierIndex];
				switch(specifier.type) ***REMOVED***
					case "ExportSpecifier":
						***REMOVED***
							const name = specifier.exported.name;
							if(source)
								this.applyPluginsBailResult("export import specifier", statement, source, specifier.local.name, name, specifierIndex);
							else
								this.applyPluginsBailResult("export specifier", statement, specifier.local.name, name, specifierIndex);
							break;
						***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***

	walkExportNamedDeclaration(statement) ***REMOVED***
		if(statement.declaration) ***REMOVED***
			this.walkStatement(statement.declaration);
		***REMOVED***
	***REMOVED***

	prewalkExportDefaultDeclaration(statement) ***REMOVED***
		if(/Declaration$/.test(statement.declaration.type)) ***REMOVED***
			const pos = this.scope.definitions.length;
			this.prewalkStatement(statement.declaration);
			const newDefs = this.scope.definitions.slice(pos);
			for(let index = 0, len = newDefs.length; index < len; index++) ***REMOVED***
				const def = newDefs[index];
				this.applyPluginsBailResult("export specifier", statement, def, "default");
			***REMOVED***
		***REMOVED***
	***REMOVED***

	walkExportDefaultDeclaration(statement) ***REMOVED***
		this.applyPluginsBailResult1("export", statement);
		if(/Declaration$/.test(statement.declaration.type)) ***REMOVED***
			if(!this.applyPluginsBailResult("export declaration", statement, statement.declaration)) ***REMOVED***
				this.walkStatement(statement.declaration);
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			this.walkExpression(statement.declaration);
			if(!this.applyPluginsBailResult("export expression", statement, statement.declaration)) ***REMOVED***
				this.applyPluginsBailResult("export specifier", statement, statement.declaration, "default");
			***REMOVED***
		***REMOVED***
	***REMOVED***

	prewalkExportAllDeclaration(statement) ***REMOVED***
		const source = statement.source.value;
		this.applyPluginsBailResult("export import", statement, source);
		this.applyPluginsBailResult("export import specifier", statement, source, null, null, 0);
	***REMOVED***

	prewalkVariableDeclaration(statement) ***REMOVED***
		if(statement.declarations)
			this.prewalkVariableDeclarators(statement.declarations);
	***REMOVED***

	walkVariableDeclaration(statement) ***REMOVED***
		if(statement.declarations)
			this.walkVariableDeclarators(statement.declarations);
	***REMOVED***

	prewalkClassDeclaration(statement) ***REMOVED***
		if(statement.id) ***REMOVED***
			this.scope.renames["$" + statement.id.name] = undefined;
			this.scope.definitions.push(statement.id.name);
		***REMOVED***
	***REMOVED***

	walkClassDeclaration(statement) ***REMOVED***
		this.walkClass(statement);
	***REMOVED***

	prewalkSwitchCases(switchCases) ***REMOVED***
		for(let index = 0, len = switchCases.length; index < len; index++) ***REMOVED***
			const switchCase = switchCases[index];
			this.prewalkStatements(switchCase.consequent);
		***REMOVED***
	***REMOVED***

	walkSwitchCases(switchCases) ***REMOVED***
		for(let index = 0, len = switchCases.length; index < len; index++) ***REMOVED***
			const switchCase = switchCases[index];

			if(switchCase.test) ***REMOVED***
				this.walkExpression(switchCase.test);
			***REMOVED***
			this.walkStatements(switchCase.consequent);
		***REMOVED***
	***REMOVED***

	walkCatchClause(catchClause) ***REMOVED***
		this.inScope([catchClause.param], () => ***REMOVED***
			this.prewalkStatement(catchClause.body);
			this.walkStatement(catchClause.body);
		***REMOVED***);
	***REMOVED***

	prewalkVariableDeclarators(declarators) ***REMOVED***
		declarators.forEach(declarator => ***REMOVED***
			switch(declarator.type) ***REMOVED***
				case "VariableDeclarator":
					***REMOVED***
						this.enterPattern(declarator.id, (name, decl) => ***REMOVED***
							if(!this.applyPluginsBailResult1("var-" + declarator.kind + " " + name, decl)) ***REMOVED***
								if(!this.applyPluginsBailResult1("var " + name, decl)) ***REMOVED***
									this.scope.renames["$" + name] = undefined;
									if(this.scope.definitions.indexOf(name) < 0)
										this.scope.definitions.push(name);
								***REMOVED***
							***REMOVED***
						***REMOVED***);
						break;
					***REMOVED***
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	walkVariableDeclarators(declarators) ***REMOVED***
		declarators.forEach(declarator => ***REMOVED***
			switch(declarator.type) ***REMOVED***
				case "VariableDeclarator":
					***REMOVED***
						const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);
						if(renameIdentifier && declarator.id.type === "Identifier" && this.applyPluginsBailResult1("can-rename " + renameIdentifier, declarator.init)) ***REMOVED***
							// renaming with "var a = b;"
							if(!this.applyPluginsBailResult1("rename " + renameIdentifier, declarator.init)) ***REMOVED***
								this.scope.renames["$" + declarator.id.name] = this.scope.renames["$" + renameIdentifier] || renameIdentifier;
								const idx = this.scope.definitions.indexOf(declarator.id.name);
								if(idx >= 0) this.scope.definitions.splice(idx, 1);
							***REMOVED***
						***REMOVED*** else ***REMOVED***
							this.walkPattern(declarator.id);
							if(declarator.init)
								this.walkExpression(declarator.init);
						***REMOVED***
						break;
					***REMOVED***
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	walkPattern(pattern) ***REMOVED***
		if(pattern.type === "Identifier")
			return;
		if(this["walk" + pattern.type])
			this["walk" + pattern.type](pattern);
	***REMOVED***

	walkAssignmentPattern(pattern) ***REMOVED***
		this.walkExpression(pattern.right);
		this.walkPattern(pattern.left);
	***REMOVED***

	walkObjectPattern(pattern) ***REMOVED***
		for(let i = 0, len = pattern.properties.length; i < len; i++) ***REMOVED***
			const prop = pattern.properties[i];
			if(prop) ***REMOVED***
				if(prop.computed)
					this.walkExpression(prop.key);
				if(prop.value)
					this.walkPattern(prop.value);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	walkArrayPattern(pattern) ***REMOVED***
		for(let i = 0, len = pattern.elements.length; i < len; i++) ***REMOVED***
			const element = pattern.elements[i];
			if(element)
				this.walkPattern(element);
		***REMOVED***
	***REMOVED***

	walkRestElement(pattern) ***REMOVED***
		this.walkPattern(pattern.argument);
	***REMOVED***

	walkExpressions(expressions) ***REMOVED***
		for(let expressionsIndex = 0, len = expressions.length; expressionsIndex < len; expressionsIndex++) ***REMOVED***
			const expression = expressions[expressionsIndex];
			if(expression)
				this.walkExpression(expression);
		***REMOVED***
	***REMOVED***

	walkExpression(expression) ***REMOVED***
		if(this["walk" + expression.type])
			return this["walk" + expression.type](expression);
	***REMOVED***

	walkAwaitExpression(expression) ***REMOVED***
		const argument = expression.argument;
		if(this["walk" + argument.type])
			return this["walk" + argument.type](argument);
	***REMOVED***

	walkArrayExpression(expression) ***REMOVED***
		if(expression.elements)
			this.walkExpressions(expression.elements);
	***REMOVED***

	walkSpreadElement(expression) ***REMOVED***
		if(expression.argument)
			this.walkExpression(expression.argument);
	***REMOVED***

	walkObjectExpression(expression) ***REMOVED***
		for(let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) ***REMOVED***
			const prop = expression.properties[propIndex];
			if(prop.computed)
				this.walkExpression(prop.key);
			if(prop.shorthand)
				this.scope.inShorthand = true;
			this.walkExpression(prop.value);
			if(prop.shorthand)
				this.scope.inShorthand = false;
		***REMOVED***
	***REMOVED***

	walkFunctionExpression(expression) ***REMOVED***
		expression.params.forEach(param => ***REMOVED***
			this.walkPattern(param);
		***REMOVED***);
		this.inScope(expression.params, () => ***REMOVED***
			if(expression.body.type === "BlockStatement") ***REMOVED***
				this.prewalkStatement(expression.body);
				this.walkStatement(expression.body);
			***REMOVED*** else ***REMOVED***
				this.walkExpression(expression.body);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	walkArrowFunctionExpression(expression) ***REMOVED***
		expression.params.forEach(param => ***REMOVED***
			this.walkPattern(param);
		***REMOVED***);
		this.inScope(expression.params, () => ***REMOVED***
			if(expression.body.type === "BlockStatement") ***REMOVED***
				this.prewalkStatement(expression.body);
				this.walkStatement(expression.body);
			***REMOVED*** else ***REMOVED***
				this.walkExpression(expression.body);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	walkSequenceExpression(expression) ***REMOVED***
		if(expression.expressions)
			this.walkExpressions(expression.expressions);
	***REMOVED***

	walkUpdateExpression(expression) ***REMOVED***
		this.walkExpression(expression.argument);
	***REMOVED***

	walkUnaryExpression(expression) ***REMOVED***
		if(expression.operator === "typeof") ***REMOVED***
			const exprName = this.getNameForExpression(expression.argument);
			if(exprName && exprName.free) ***REMOVED***
				const result = this.applyPluginsBailResult1("typeof " + exprName.name, expression);
				if(result === true)
					return;
			***REMOVED***
		***REMOVED***
		this.walkExpression(expression.argument);
	***REMOVED***

	walkLeftRightExpression(expression) ***REMOVED***
		this.walkExpression(expression.left);
		this.walkExpression(expression.right);
	***REMOVED***

	walkBinaryExpression(expression) ***REMOVED***
		this.walkLeftRightExpression(expression);
	***REMOVED***

	walkLogicalExpression(expression) ***REMOVED***
		this.walkLeftRightExpression(expression);
	***REMOVED***

	walkAssignmentExpression(expression) ***REMOVED***
		const renameIdentifier = this.getRenameIdentifier(expression.right);
		if(expression.left.type === "Identifier" && renameIdentifier && this.applyPluginsBailResult1("can-rename " + renameIdentifier, expression.right)) ***REMOVED***
			// renaming "a = b;"
			if(!this.applyPluginsBailResult1("rename " + renameIdentifier, expression.right)) ***REMOVED***
				this.scope.renames["$" + expression.left.name] = renameIdentifier;
				const idx = this.scope.definitions.indexOf(expression.left.name);
				if(idx >= 0) this.scope.definitions.splice(idx, 1);
			***REMOVED***
		***REMOVED*** else if(expression.left.type === "Identifier") ***REMOVED***
			if(!this.applyPluginsBailResult1("assigned " + expression.left.name, expression)) ***REMOVED***
				this.walkExpression(expression.right);
			***REMOVED***
			this.scope.renames["$" + expression.left.name] = undefined;
			if(!this.applyPluginsBailResult1("assign " + expression.left.name, expression)) ***REMOVED***
				this.walkExpression(expression.left);
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			this.walkExpression(expression.right);
			this.walkPattern(expression.left);
			this.enterPattern(expression.left, (name, decl) => ***REMOVED***
				this.scope.renames["$" + name] = undefined;
			***REMOVED***);
		***REMOVED***
	***REMOVED***

	walkConditionalExpression(expression) ***REMOVED***
		const result = this.applyPluginsBailResult1("expression ?:", expression);
		if(result === undefined) ***REMOVED***
			this.walkExpression(expression.test);
			this.walkExpression(expression.consequent);
			if(expression.alternate)
				this.walkExpression(expression.alternate);
		***REMOVED*** else ***REMOVED***
			if(result)
				this.walkExpression(expression.consequent);
			else if(expression.alternate)
				this.walkExpression(expression.alternate);
		***REMOVED***
	***REMOVED***

	walkNewExpression(expression) ***REMOVED***
		this.walkExpression(expression.callee);
		if(expression.arguments)
			this.walkExpressions(expression.arguments);
	***REMOVED***

	walkYieldExpression(expression) ***REMOVED***
		if(expression.argument)
			this.walkExpression(expression.argument);
	***REMOVED***

	walkTemplateLiteral(expression) ***REMOVED***
		if(expression.expressions)
			this.walkExpressions(expression.expressions);
	***REMOVED***

	walkTaggedTemplateExpression(expression) ***REMOVED***
		if(expression.tag)
			this.walkExpression(expression.tag);
		if(expression.quasi && expression.quasi.expressions)
			this.walkExpressions(expression.quasi.expressions);
	***REMOVED***

	walkClassExpression(expression) ***REMOVED***
		this.walkClass(expression);
	***REMOVED***

	walkCallExpression(expression) ***REMOVED***
		let result;

		function walkIIFE(functionExpression, options, currentThis) ***REMOVED***
			function renameArgOrThis(argOrThis) ***REMOVED***
				const renameIdentifier = this.getRenameIdentifier(argOrThis);
				if(renameIdentifier && this.applyPluginsBailResult1("can-rename " + renameIdentifier, argOrThis)) ***REMOVED***
					if(!this.applyPluginsBailResult1("rename " + renameIdentifier, argOrThis))
						return renameIdentifier;
				***REMOVED***
				this.walkExpression(argOrThis);
			***REMOVED***
			const params = functionExpression.params;
			const renameThis = currentThis ? renameArgOrThis.call(this, currentThis) : null;
			const args = options.map(renameArgOrThis, this);
			this.inScope(params.filter(function(identifier, idx) ***REMOVED***
				return !args[idx];
			***REMOVED***), () => ***REMOVED***
				if(renameThis) ***REMOVED***
					this.scope.renames.$this = renameThis;
				***REMOVED***
				for(let i = 0; i < args.length; i++) ***REMOVED***
					const param = args[i];
					if(!param) continue;
					if(!params[i] || params[i].type !== "Identifier") continue;
					this.scope.renames["$" + params[i].name] = param;
				***REMOVED***
				if(functionExpression.body.type === "BlockStatement") ***REMOVED***
					this.prewalkStatement(functionExpression.body);
					this.walkStatement(functionExpression.body);
				***REMOVED*** else
					this.walkExpression(functionExpression.body);
			***REMOVED***);
		***REMOVED***
		if(expression.callee.type === "MemberExpression" &&
			expression.callee.object.type === "FunctionExpression" &&
			!expression.callee.computed &&
			(["call", "bind"]).indexOf(expression.callee.property.name) >= 0 &&
			expression.arguments &&
			expression.arguments.length > 0
		) ***REMOVED***
			// (function(...) ***REMOVED*** ***REMOVED***.call/bind(?, ...))
			walkIIFE.call(this, expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);
		***REMOVED*** else if(expression.callee.type === "FunctionExpression" && expression.arguments) ***REMOVED***
			// (function(...) ***REMOVED*** ***REMOVED***(...))
			walkIIFE.call(this, expression.callee, expression.arguments);
		***REMOVED*** else if(expression.callee.type === "Import") ***REMOVED***
			result = this.applyPluginsBailResult1("import-call", expression);
			if(result === true)
				return;

			if(expression.arguments)
				this.walkExpressions(expression.arguments);
		***REMOVED*** else ***REMOVED***

			const callee = this.evaluateExpression(expression.callee);
			if(callee.isIdentifier()) ***REMOVED***
				result = this.applyPluginsBailResult1("call " + callee.identifier, expression);
				if(result === true)
					return;
				let identifier = callee.identifier.replace(/\.[^.]+$/, ".*");
				if(identifier !== callee.identifier) ***REMOVED***
					result = this.applyPluginsBailResult1("call " + identifier, expression);
					if(result === true)
						return;
				***REMOVED***
			***REMOVED***

			if(expression.callee)
				this.walkExpression(expression.callee);
			if(expression.arguments)
				this.walkExpressions(expression.arguments);
		***REMOVED***
	***REMOVED***

	walkMemberExpression(expression) ***REMOVED***
		const exprName = this.getNameForExpression(expression);
		if(exprName && exprName.free) ***REMOVED***
			let result = this.applyPluginsBailResult1("expression " + exprName.name, expression);
			if(result === true)
				return;
			result = this.applyPluginsBailResult1("expression " + exprName.nameGeneral, expression);
			if(result === true)
				return;
		***REMOVED***
		this.walkExpression(expression.object);
		if(expression.computed === true)
			this.walkExpression(expression.property);
	***REMOVED***

	walkIdentifier(expression) ***REMOVED***
		if(this.scope.definitions.indexOf(expression.name) === -1) ***REMOVED***
			const result = this.applyPluginsBailResult1("expression " + (this.scope.renames["$" + expression.name] || expression.name), expression);
			if(result === true)
				return;
		***REMOVED***
	***REMOVED***

	inScope(params, fn) ***REMOVED***
		const oldScope = this.scope;
		this.scope = ***REMOVED***
			inTry: false,
			inShorthand: false,
			definitions: oldScope.definitions.slice(),
			renames: Object.create(oldScope.renames)
		***REMOVED***;

		this.scope.renames.$this = undefined;

		for(let paramIndex = 0, len = params.length; paramIndex < len; paramIndex++) ***REMOVED***
			const param = params[paramIndex];

			if(typeof param !== "string") ***REMOVED***
				this.enterPattern(param, param => ***REMOVED***
					this.scope.renames["$" + param] = undefined;
					this.scope.definitions.push(param);
				***REMOVED***);
			***REMOVED*** else ***REMOVED***
				this.scope.renames["$" + param] = undefined;
				this.scope.definitions.push(param);
			***REMOVED***
		***REMOVED***

		fn();
		this.scope = oldScope;
	***REMOVED***

	enterPattern(pattern, onIdent) ***REMOVED***
		if(pattern && this["enter" + pattern.type])
			this["enter" + pattern.type](pattern, onIdent);
	***REMOVED***

	enterIdentifier(pattern, onIdent) ***REMOVED***
		onIdent(pattern.name, pattern);
	***REMOVED***

	enterObjectPattern(pattern, onIdent) ***REMOVED***
		for(let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) ***REMOVED***
			const prop = pattern.properties[propIndex];
			this.enterPattern(prop.value, onIdent);
		***REMOVED***
	***REMOVED***

	enterArrayPattern(pattern, onIdent) ***REMOVED***
		for(let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) ***REMOVED***
			const element = pattern.elements[elementIndex];
			this.enterPattern(element, onIdent);
		***REMOVED***
	***REMOVED***

	enterRestElement(pattern, onIdent) ***REMOVED***
		this.enterPattern(pattern.argument, onIdent);
	***REMOVED***

	enterAssignmentPattern(pattern, onIdent) ***REMOVED***
		this.enterPattern(pattern.left, onIdent);
	***REMOVED***

	evaluateExpression(expression) ***REMOVED***
		try ***REMOVED***
			const result = this.applyPluginsBailResult1("evaluate " + expression.type, expression);
			if(result !== undefined)
				return result;
		***REMOVED*** catch(e) ***REMOVED***
			console.warn(e);
			// ignore error
		***REMOVED***
		return new BasicEvaluatedExpression().setRange(expression.range);
	***REMOVED***

	parseString(expression) ***REMOVED***
		switch(expression.type) ***REMOVED***
			case "BinaryExpression":
				if(expression.operator === "+")
					return this.parseString(expression.left) + this.parseString(expression.right);
				break;
			case "Literal":
				return expression.value + "";
		***REMOVED***
		throw new Error(expression.type + " is not supported as parameter for require");
	***REMOVED***

	parseCalculatedString(expression) ***REMOVED***
		switch(expression.type) ***REMOVED***
			case "BinaryExpression":
				if(expression.operator === "+") ***REMOVED***
					const left = this.parseCalculatedString(expression.left);
					const right = this.parseCalculatedString(expression.right);
					if(left.code) ***REMOVED***
						return ***REMOVED***
							range: left.range,
							value: left.value,
							code: true
						***REMOVED***;
					***REMOVED*** else if(right.code) ***REMOVED***
						return ***REMOVED***
							range: [left.range[0], right.range ? right.range[1] : left.range[1]],
							value: left.value + right.value,
							code: true
						***REMOVED***;
					***REMOVED*** else ***REMOVED***
						return ***REMOVED***
							range: [left.range[0], right.range[1]],
							value: left.value + right.value
						***REMOVED***;
					***REMOVED***
				***REMOVED***
				break;
			case "ConditionalExpression":
				***REMOVED***
					const consequent = this.parseCalculatedString(expression.consequent);
					const alternate = this.parseCalculatedString(expression.alternate);
					const items = [];
					if(consequent.conditional)
						Array.prototype.push.apply(items, consequent.conditional);
					else if(!consequent.code)
						items.push(consequent);
					else break;
					if(alternate.conditional)
						Array.prototype.push.apply(items, alternate.conditional);
					else if(!alternate.code)
						items.push(alternate);
					else break;
					return ***REMOVED***
						value: "",
						code: true,
						conditional: items
					***REMOVED***;
				***REMOVED***
			case "Literal":
				return ***REMOVED***
					range: expression.range,
					value: expression.value + ""
				***REMOVED***;
		***REMOVED***
		return ***REMOVED***
			value: "",
			code: true
		***REMOVED***;
	***REMOVED***

	parseStringArray(expression) ***REMOVED***
		if(expression.type !== "ArrayExpression") ***REMOVED***
			return [this.parseString(expression)];
		***REMOVED***

		const arr = [];
		if(expression.elements)
			expression.elements.forEach(function(expr) ***REMOVED***
				arr.push(this.parseString(expr));
			***REMOVED***, this);
		return arr;
	***REMOVED***

	parseCalculatedStringArray(expression) ***REMOVED***
		if(expression.type !== "ArrayExpression") ***REMOVED***
			return [this.parseCalculatedString(expression)];
		***REMOVED***

		const arr = [];
		if(expression.elements)
			expression.elements.forEach(function(expr) ***REMOVED***
				arr.push(this.parseCalculatedString(expr));
			***REMOVED***, this);
		return arr;
	***REMOVED***

	parse(source, initialState) ***REMOVED***
		let ast;
		const comments = [];
		for(let i = 0, len = POSSIBLE_AST_OPTIONS.length; i < len; i++) ***REMOVED***
			if(!ast) ***REMOVED***
				try ***REMOVED***
					comments.length = 0;
					POSSIBLE_AST_OPTIONS[i].onComment = comments;
					ast = acorn.parse(source, POSSIBLE_AST_OPTIONS[i]);
				***REMOVED*** catch(e) ***REMOVED***
					// ignore the error
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if(!ast) ***REMOVED***
			// for the error
			ast = acorn.parse(source, ***REMOVED***
				ranges: true,
				locations: true,
				ecmaVersion: ECMA_VERSION,
				sourceType: "module",
				plugins: ***REMOVED***
					dynamicImport: true
				***REMOVED***,
				onComment: comments
			***REMOVED***);
		***REMOVED***
		if(!ast || typeof ast !== "object")
			throw new Error("Source couldn't be parsed");
		const oldScope = this.scope;
		const oldState = this.state;
		const oldComments = this.comments;
		this.scope = ***REMOVED***
			inTry: false,
			definitions: [],
			renames: ***REMOVED******REMOVED***
		***REMOVED***;
		const state = this.state = initialState || ***REMOVED******REMOVED***;
		this.comments = comments;
		if(this.applyPluginsBailResult("program", ast, comments) === undefined) ***REMOVED***
			this.prewalkStatements(ast.body);
			this.walkStatements(ast.body);
		***REMOVED***
		this.scope = oldScope;
		this.state = oldState;
		this.comments = oldComments;
		return state;
	***REMOVED***

	evaluate(source) ***REMOVED***
		const ast = acorn.parse("(" + source + ")", ***REMOVED***
			ranges: true,
			locations: true,
			ecmaVersion: ECMA_VERSION,
			sourceType: "module",
			plugins: ***REMOVED***
				dynamicImport: true
			***REMOVED***
		***REMOVED***);
		if(!ast || typeof ast !== "object" || ast.type !== "Program")
			throw new Error("evaluate: Source couldn't be parsed");
		if(ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement")
			throw new Error("evaluate: Source is not a expression");
		return this.evaluateExpression(ast.body[0].expression);
	***REMOVED***

	getComments(range) ***REMOVED***
		return this.comments.filter(comment => comment.range[0] >= range[0] && comment.range[1] <= range[1]);
	***REMOVED***

	getCommentOptions(range) ***REMOVED***
		const comments = this.getComments(range);
		if(comments.length === 0) return null;
		const options = comments.map(comment => ***REMOVED***
			try ***REMOVED***
				return json5.parse(`***REMOVED***$***REMOVED***comment.value***REMOVED******REMOVED***`);
			***REMOVED*** catch(e) ***REMOVED***
				return ***REMOVED******REMOVED***;
			***REMOVED***
		***REMOVED***);
		return options.reduce((o, i) => Object.assign(o, i), ***REMOVED******REMOVED***);
	***REMOVED***

	getNameForExpression(expression) ***REMOVED***
		let expr = expression;
		const exprName = [];
		while(expr.type === "MemberExpression" && expr.property.type === (expr.computed ? "Literal" : "Identifier")) ***REMOVED***
			exprName.push(expr.computed ? expr.property.value : expr.property.name);
			expr = expr.object;
		***REMOVED***
		let free;
		if(expr.type === "Identifier") ***REMOVED***
			free = this.scope.definitions.indexOf(expr.name) === -1;
			exprName.push(this.scope.renames["$" + expr.name] || expr.name);
		***REMOVED*** else if(expr.type === "ThisExpression" && this.scope.renames.$this) ***REMOVED***
			free = true;
			exprName.push(this.scope.renames.$this);
		***REMOVED*** else if(expr.type === "ThisExpression") ***REMOVED***
			free = false;
			exprName.push("this");
		***REMOVED*** else ***REMOVED***
			return null;
		***REMOVED***
		let prefix = "";
		for(let i = exprName.length - 1; i >= 1; i--)
			prefix += exprName[i] + ".";
		const name = prefix + exprName[0];
		const nameGeneral = prefix + "*";
		return ***REMOVED***
			name,
			nameGeneral,
			free
		***REMOVED***;
	***REMOVED***

***REMOVED***

Parser.ECMA_VERSION = ECMA_VERSION;

module.exports = Parser;
