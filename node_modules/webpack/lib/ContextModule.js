/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";
const path = require("path");
const Module = require("./Module");
const OriginalSource = require("webpack-sources").OriginalSource;
const RawSource = require("webpack-sources").RawSource;
const AsyncDependenciesBlock = require("./AsyncDependenciesBlock");
const DepBlockHelpers = require("./dependencies/DepBlockHelpers");
const Template = require("./Template");

class ContextModule extends Module ***REMOVED***
	constructor(resolveDependencies, context, recursive, regExp, addon, asyncMode, chunkName) ***REMOVED***
		super();
		this.resolveDependencies = resolveDependencies;
		this.context = context;
		this.recursive = recursive;
		this.regExp = regExp;
		this.addon = addon;
		this.async = asyncMode;
		this.cacheable = true;
		this.contextDependencies = [context];
		this.built = false;
		this.chunkName = chunkName;
	***REMOVED***

	prettyRegExp(regexString) ***REMOVED***
		// remove the "/" at the front and the beginning
		// "/foo/" -> "foo"
		return regexString.substring(1, regexString.length - 1);
	***REMOVED***

	contextify(context, request) ***REMOVED***
		return request.split("!").map(subrequest => ***REMOVED***
			let rp = path.relative(context, subrequest);
			if(path.sep === "\\")
				rp = rp.replace(/\\/g, "/");
			if(rp.indexOf("../") !== 0)
				rp = "./" + rp;
			return rp;
		***REMOVED***).join("!");
	***REMOVED***

	identifier() ***REMOVED***
		let identifier = this.context;
		if(this.async)
			identifier += ` $***REMOVED***this.async***REMOVED***`;
		if(!this.recursive)
			identifier += " nonrecursive";
		if(this.addon)
			identifier += ` $***REMOVED***this.addon***REMOVED***`;
		if(this.regExp)
			identifier += ` $***REMOVED***this.regExp***REMOVED***`;

		return identifier;
	***REMOVED***

	readableIdentifier(requestShortener) ***REMOVED***
		let identifier = requestShortener.shorten(this.context);
		if(this.async)
			identifier += ` $***REMOVED***this.async***REMOVED***`;
		if(!this.recursive)
			identifier += " nonrecursive";
		if(this.addon)
			identifier += ` $***REMOVED***requestShortener.shorten(this.addon)***REMOVED***`;
		if(this.regExp)
			identifier += ` $***REMOVED***this.prettyRegExp(this.regExp + "")***REMOVED***`;

		return identifier;
	***REMOVED***

	libIdent(options) ***REMOVED***
		let identifier = this.contextify(options.context, this.context);
		if(this.async)
			identifier += ` $***REMOVED***this.async***REMOVED***`;
		if(this.recursive)
			identifier += " recursive";
		if(this.addon)
			identifier += ` $***REMOVED***this.contextify(options.context, this.addon)***REMOVED***`;
		if(this.regExp)
			identifier += ` $***REMOVED***this.prettyRegExp(this.regExp + "")***REMOVED***`;

		return identifier;
	***REMOVED***

	needRebuild(fileTimestamps, contextTimestamps) ***REMOVED***
		const ts = contextTimestamps[this.context];
		if(!ts) ***REMOVED***
			return true;
		***REMOVED***

		return ts >= this.builtTime;
	***REMOVED***

	unbuild() ***REMOVED***
		this.built = false;
		super.unbuild();
	***REMOVED***

	build(options, compilation, resolver, fs, callback) ***REMOVED***
		this.built = true;
		this.builtTime = Date.now();
		this.resolveDependencies(fs, this.context, this.recursive, this.regExp, (err, dependencies) => ***REMOVED***
			if(err) return callback(err);

			// Reset children
			this.dependencies = [];
			this.blocks = [];

			// abort if something failed
			// this will create an empty context
			if(!dependencies) ***REMOVED***
				callback();
				return;
			***REMOVED***

			// enhance dependencies with meta info
			dependencies.forEach(dep => ***REMOVED***
				dep.loc = dep.userRequest;
				dep.request = this.addon + dep.request;
			***REMOVED***);

			if(!this.async || this.async === "eager") ***REMOVED***

				// if we have an sync or eager context
				// just add all dependencies and continue
				this.dependencies = dependencies;

			***REMOVED*** else if(this.async === "lazy-once") ***REMOVED***

				// for the lazy-once mode create a new async dependency block
				// and add that block to this context
				if(dependencies.length > 0) ***REMOVED***
					const block = new AsyncDependenciesBlock(this.chunkName, this);
					dependencies.forEach(dep => ***REMOVED***
						block.addDependency(dep);
					***REMOVED***);
					this.addBlock(block);
				***REMOVED***

			***REMOVED*** else if(this.async === "weak" || this.async === "async-weak") ***REMOVED***

				// we mark all dependencies as weak
				dependencies.forEach(dep => dep.weak = true);
				this.dependencies = dependencies;

			***REMOVED*** else ***REMOVED***
				// if we are lazy create a new async dependency block per dependency
				// and add all blocks to this context
				dependencies.forEach((dep, idx) => ***REMOVED***
					let chunkName = this.chunkName;
					if(chunkName) ***REMOVED***
						if(!/\[(index|request)\]/.test(chunkName))
							chunkName += "[index]";
						chunkName = chunkName.replace(/\[index\]/g, idx);
						chunkName = chunkName.replace(/\[request\]/g, Template.toPath(dep.userRequest));
					***REMOVED***
					const block = new AsyncDependenciesBlock(chunkName, dep.module, dep.loc);
					block.addDependency(dep);
					this.addBlock(block);
				***REMOVED***);
			***REMOVED***
			callback();
		***REMOVED***);
	***REMOVED***

	getUserRequestMap(dependencies) ***REMOVED***
		// if we filter first we get a new array
		// therefor we dont need to create a clone of dependencies explicitly
		// therefore the order of this is !important!
		return dependencies
			.filter(dependency => dependency.module)
			.sort((a, b) => ***REMOVED***
				if(a.userRequest === b.userRequest) ***REMOVED***
					return 0;
				***REMOVED***
				return a.userRequest < b.userRequest ? -1 : 1;
			***REMOVED***).reduce(function(map, dep) ***REMOVED***
				map[dep.userRequest] = dep.module.id;
				return map;
			***REMOVED***, Object.create(null));
	***REMOVED***

	getSyncSource(dependencies, id) ***REMOVED***
		const map = this.getUserRequestMap(dependencies);
		return `var map = $***REMOVED***JSON.stringify(map, null, "\t")***REMOVED***;
function webpackContext(req) ***REMOVED***
	return __webpack_require__(webpackContextResolve(req));
***REMOVED***;
function webpackContextResolve(req) ***REMOVED***
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
***REMOVED***;
webpackContext.keys = function webpackContextKeys() ***REMOVED***
	return Object.keys(map);
***REMOVED***;
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = $***REMOVED***JSON.stringify(id)***REMOVED***;`;
	***REMOVED***

	getWeakSyncSource(dependencies, id) ***REMOVED***
		const map = this.getUserRequestMap(dependencies);
		return `var map = $***REMOVED***JSON.stringify(map, null, "\t")***REMOVED***;
function webpackContext(req) ***REMOVED***
	var id = webpackContextResolve(req);
	if(!__webpack_require__.m[id])
		throw new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");
	return __webpack_require__(id);
***REMOVED***;
function webpackContextResolve(req) ***REMOVED***
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
***REMOVED***;
webpackContext.keys = function webpackContextKeys() ***REMOVED***
	return Object.keys(map);
***REMOVED***;
webpackContext.resolve = webpackContextResolve;
webpackContext.id = $***REMOVED***JSON.stringify(id)***REMOVED***;
module.exports = webpackContext;`;
	***REMOVED***

	getAsyncWeakSource(dependencies, id) ***REMOVED***
		const map = this.getUserRequestMap(dependencies);

		return `var map = $***REMOVED***JSON.stringify(map, null, "\t")***REMOVED***;
function webpackAsyncContext(req) ***REMOVED***
	return webpackAsyncContextResolve(req).then(function(id) ***REMOVED***
		if(!__webpack_require__.m[id])
			throw new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");
		return __webpack_require__(id);
	***REMOVED***);
***REMOVED***;
function webpackAsyncContextResolve(req) ***REMOVED***
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() ***REMOVED***
		var id = map[req];
		if(!(id + 1)) // check for number or string
			throw new Error("Cannot find module '" + req + "'.");
		return id;
	***REMOVED***);
***REMOVED***;
webpackAsyncContext.keys = function webpackAsyncContextKeys() ***REMOVED***
	return Object.keys(map);
***REMOVED***;
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = $***REMOVED***JSON.stringify(id)***REMOVED***;
module.exports = webpackAsyncContext;`;
	***REMOVED***

	getEagerSource(dependencies, id) ***REMOVED***
		const map = this.getUserRequestMap(dependencies);
		return `var map = $***REMOVED***JSON.stringify(map, null, "\t")***REMOVED***;
function webpackAsyncContext(req) ***REMOVED***
	return webpackAsyncContextResolve(req).then(__webpack_require__);
***REMOVED***;
function webpackAsyncContextResolve(req) ***REMOVED***
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() ***REMOVED***
		var id = map[req];
		if(!(id + 1)) // check for number or string
			throw new Error("Cannot find module '" + req + "'.");
		return id;
	***REMOVED***);
***REMOVED***;
webpackAsyncContext.keys = function webpackAsyncContextKeys() ***REMOVED***
	return Object.keys(map);
***REMOVED***;
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = $***REMOVED***JSON.stringify(id)***REMOVED***;
module.exports = webpackAsyncContext;`;
	***REMOVED***

	getLazyOnceSource(block, dependencies, id, outputOptions, requestShortener) ***REMOVED***
		const promise = DepBlockHelpers.getDepBlockPromise(block, outputOptions, requestShortener, "lazy-once context");
		const map = this.getUserRequestMap(dependencies);
		return `var map = $***REMOVED***JSON.stringify(map, null, "\t")***REMOVED***;
function webpackAsyncContext(req) ***REMOVED***
	return webpackAsyncContextResolve(req).then(__webpack_require__);
***REMOVED***;
function webpackAsyncContextResolve(req) ***REMOVED***
	return $***REMOVED***promise***REMOVED***.then(function() ***REMOVED***
		var id = map[req];
		if(!(id + 1)) // check for number or string
			throw new Error("Cannot find module '" + req + "'.");
		return id;
	***REMOVED***);
***REMOVED***;
webpackAsyncContext.keys = function webpackAsyncContextKeys() ***REMOVED***
	return Object.keys(map);
***REMOVED***;
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = $***REMOVED***JSON.stringify(id)***REMOVED***;
module.exports = webpackAsyncContext;`;
	***REMOVED***

	getLazySource(blocks, id) ***REMOVED***
		let hasMultipleOrNoChunks = false;
		const map = blocks
			.filter(block => block.dependencies[0].module)
			.map((block) => (***REMOVED***
				dependency: block.dependencies[0],
				block: block,
				userRequest: block.dependencies[0].userRequest
			***REMOVED***)).sort((a, b) => ***REMOVED***
				if(a.userRequest === b.userRequest) return 0;
				return a.userRequest < b.userRequest ? -1 : 1;
			***REMOVED***).reduce((map, item) => ***REMOVED***
				const chunks = item.block.chunks || [];
				if(chunks.length !== 1) ***REMOVED***
					hasMultipleOrNoChunks = true;
				***REMOVED***
				map[item.userRequest] = [item.dependency.module.id]
					.concat(chunks.map(chunk => chunk.id));

				return map;
			***REMOVED***, Object.create(null));

		const requestPrefix = hasMultipleOrNoChunks ?
			"Promise.all(ids.slice(1).map(__webpack_require__.e))" :
			"__webpack_require__.e(ids[1])";

		return `var map = $***REMOVED***JSON.stringify(map, null, "\t")***REMOVED***;
function webpackAsyncContext(req) ***REMOVED***
	var ids = map[req];
	if(!ids)
		return Promise.reject(new Error("Cannot find module '" + req + "'."));
	return $***REMOVED***requestPrefix***REMOVED***.then(function() ***REMOVED***
		return __webpack_require__(ids[0]);
	***REMOVED***);
***REMOVED***;
webpackAsyncContext.keys = function webpackAsyncContextKeys() ***REMOVED***
	return Object.keys(map);
***REMOVED***;
webpackAsyncContext.id = $***REMOVED***JSON.stringify(id)***REMOVED***;
module.exports = webpackAsyncContext;`;
	***REMOVED***

	getSourceForEmptyContext(id) ***REMOVED***
		return `function webpackEmptyContext(req) ***REMOVED***
	throw new Error("Cannot find module '" + req + "'.");
***REMOVED***
webpackEmptyContext.keys = function() ***REMOVED*** return []; ***REMOVED***;
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = $***REMOVED***JSON.stringify(id)***REMOVED***;`;
	***REMOVED***

	getSourceForEmptyAsyncContext(id) ***REMOVED***
		return `function webpackEmptyAsyncContext(req) ***REMOVED***
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() ***REMOVED***
		throw new Error("Cannot find module '" + req + "'.");
	***REMOVED***);
***REMOVED***
webpackEmptyAsyncContext.keys = function() ***REMOVED*** return []; ***REMOVED***;
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = $***REMOVED***JSON.stringify(id)***REMOVED***;`;
	***REMOVED***

	getSourceString(asyncMode, outputOptions, requestShortener) ***REMOVED***
		if(asyncMode === "lazy") ***REMOVED***
			if(this.blocks && this.blocks.length > 0) ***REMOVED***
				return this.getLazySource(this.blocks, this.id);
			***REMOVED***
			return this.getSourceForEmptyAsyncContext(this.id);
		***REMOVED***
		if(asyncMode === "eager") ***REMOVED***
			if(this.dependencies && this.dependencies.length > 0) ***REMOVED***
				return this.getEagerSource(this.dependencies, this.id);
			***REMOVED***
			return this.getSourceForEmptyAsyncContext(this.id);
		***REMOVED***
		if(asyncMode === "lazy-once") ***REMOVED***
			const block = this.blocks[0];
			if(block) ***REMOVED***
				return this.getLazyOnceSource(block, block.dependencies, this.id, outputOptions, requestShortener);
			***REMOVED***
			return this.getSourceForEmptyAsyncContext(this.id);
		***REMOVED***
		if(asyncMode === "async-weak") ***REMOVED***
			if(this.dependencies && this.dependencies.length > 0) ***REMOVED***
				return this.getAsyncWeakSource(this.dependencies, this.id);
			***REMOVED***
			return this.getSourceForEmptyAsyncContext(this.id);
		***REMOVED***
		if(asyncMode === "weak") ***REMOVED***
			if(this.dependencies && this.dependencies.length > 0) ***REMOVED***
				return this.getWeakSyncSource(this.dependencies, this.id);
			***REMOVED***
		***REMOVED***
		if(this.dependencies && this.dependencies.length > 0) ***REMOVED***
			return this.getSyncSource(this.dependencies, this.id);
		***REMOVED***
		return this.getSourceForEmptyContext(this.id);
	***REMOVED***

	getSource(sourceString) ***REMOVED***
		if(this.useSourceMap) ***REMOVED***
			return new OriginalSource(sourceString, this.identifier());
		***REMOVED***
		return new RawSource(sourceString);
	***REMOVED***

	source(dependencyTemplates, outputOptions, requestShortener) ***REMOVED***
		return this.getSource(
			this.getSourceString(this.async, outputOptions, requestShortener)
		);
	***REMOVED***

	size() ***REMOVED***
		// base penalty
		const initialSize = 160;

		// if we dont have dependencies we stop here.
		return this.dependencies
			.reduce((size, dependency) => size + 5 + dependency.userRequest.length, initialSize);
	***REMOVED***
***REMOVED***

module.exports = ContextModule;
