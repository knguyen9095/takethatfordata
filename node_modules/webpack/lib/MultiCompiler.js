/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const Tapable = require("tapable");
const asyncLib = require("async");
const MultiWatching = require("./MultiWatching");
const MultiStats = require("./MultiStats");

module.exports = class MultiCompiler extends Tapable ***REMOVED***
	constructor(compilers) ***REMOVED***
		super();
		if(!Array.isArray(compilers)) ***REMOVED***
			compilers = Object.keys(compilers).map((name) => ***REMOVED***
				compilers[name].name = name;
				return compilers[name];
			***REMOVED***);
		***REMOVED***
		this.compilers = compilers;
		let doneCompilers = 0;
		let compilerStats = [];
		this.compilers.forEach((compiler, idx) => ***REMOVED***
			let compilerDone = false;
			compiler.plugin("done", stats => ***REMOVED***
				if(!compilerDone) ***REMOVED***
					compilerDone = true;
					doneCompilers++;
				***REMOVED***
				compilerStats[idx] = stats;
				if(doneCompilers === this.compilers.length) ***REMOVED***
					this.applyPlugins("done", new MultiStats(compilerStats));
				***REMOVED***
			***REMOVED***);
			compiler.plugin("invalid", () => ***REMOVED***
				if(compilerDone) ***REMOVED***
					compilerDone = false;
					doneCompilers--;
				***REMOVED***
				this.applyPlugins("invalid");
			***REMOVED***);
		***REMOVED***, this);
	***REMOVED***

	get outputPath() ***REMOVED***
		let commonPath = this.compilers[0].outputPath;
		for(const compiler of this.compilers) ***REMOVED***
			while(compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\]/.test(commonPath)) ***REMOVED***
				commonPath = commonPath.replace(/[/\\][^/\\]*$/, "");
			***REMOVED***
		***REMOVED***

		if(!commonPath && this.compilers[0].outputPath[0] === "/") return "/";
		return commonPath;
	***REMOVED***

	get inputFileSystem() ***REMOVED***
		throw new Error("Cannot read inputFileSystem of a MultiCompiler");
	***REMOVED***

	get outputFileSystem() ***REMOVED***
		throw new Error("Cannot read outputFileSystem of a MultiCompiler");
	***REMOVED***

	set inputFileSystem(value) ***REMOVED***
		this.compilers.forEach(compiler => ***REMOVED***
			compiler.inputFileSystem = value;
		***REMOVED***);
	***REMOVED***

	set outputFileSystem(value) ***REMOVED***
		this.compilers.forEach(compiler => ***REMOVED***
			compiler.outputFileSystem = value;
		***REMOVED***);
	***REMOVED***

	runWithDependencies(compilers, fn, callback) ***REMOVED***
		let fulfilledNames = ***REMOVED******REMOVED***;
		let remainingCompilers = compilers;
		const isDependencyFulfilled = (d) => fulfilledNames[d];
		const getReadyCompilers = () => ***REMOVED***
			let readyCompilers = [];
			let list = remainingCompilers;
			remainingCompilers = [];
			for(const c of list) ***REMOVED***
				const ready = !c.dependencies || c.dependencies.every(isDependencyFulfilled);
				if(ready)
					readyCompilers.push(c);
				else
					remainingCompilers.push(c);
			***REMOVED***
			return readyCompilers;
		***REMOVED***;
		const runCompilers = (callback) => ***REMOVED***
			if(remainingCompilers.length === 0) return callback();
			asyncLib.map(getReadyCompilers(), (compiler, callback) => ***REMOVED***
				fn(compiler, (err) => ***REMOVED***
					if(err) return callback(err);
					fulfilledNames[compiler.name] = true;
					runCompilers(callback);
				***REMOVED***);
			***REMOVED***, callback);
		***REMOVED***;
		runCompilers(callback);
	***REMOVED***

	watch(watchOptions, handler) ***REMOVED***
		let watchings = [];
		let allStats = this.compilers.map(() => null);
		let compilerStatus = this.compilers.map(() => false);
		this.runWithDependencies(this.compilers, (compiler, callback) => ***REMOVED***
			const compilerIdx = this.compilers.indexOf(compiler);
			let firstRun = true;
			let watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[compilerIdx] : watchOptions, (err, stats) => ***REMOVED***
				if(err)
					handler(err);
				if(stats) ***REMOVED***
					allStats[compilerIdx] = stats;
					compilerStatus[compilerIdx] = "new";
					if(compilerStatus.every(Boolean)) ***REMOVED***
						const freshStats = allStats.filter((s, idx) => ***REMOVED***
							return compilerStatus[idx] === "new";
						***REMOVED***);
						compilerStatus.fill(true);
						const multiStats = new MultiStats(freshStats);
						handler(null, multiStats);
					***REMOVED***
				***REMOVED***
				if(firstRun && !err) ***REMOVED***
					firstRun = false;
					callback();
				***REMOVED***
			***REMOVED***);
			watchings.push(watching);
		***REMOVED***, () => ***REMOVED***
			// ignore
		***REMOVED***);

		return new MultiWatching(watchings, this);
	***REMOVED***

	run(callback) ***REMOVED***
		const allStats = this.compilers.map(() => null);
		this.runWithDependencies(this.compilers, ((compiler, callback) => ***REMOVED***
			const compilerIdx = this.compilers.indexOf(compiler);
			compiler.run((err, stats) => ***REMOVED***
				if(err) return callback(err);
				allStats[compilerIdx] = stats;
				callback();
			***REMOVED***);
		***REMOVED***), (err) => ***REMOVED***
			if(err) return callback(err);
			callback(null, new MultiStats(allStats));
		***REMOVED***);
	***REMOVED***

	purgeInputFileSystem() ***REMOVED***
		this.compilers.forEach((compiler) => ***REMOVED***
			if(compiler.inputFileSystem && compiler.inputFileSystem.purge)
				compiler.inputFileSystem.purge();
		***REMOVED***);
	***REMOVED***
***REMOVED***;
