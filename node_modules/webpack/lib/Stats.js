/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const RequestShortener = require("./RequestShortener");
const SizeFormatHelpers = require("./SizeFormatHelpers");
const formatLocation = require("./formatLocation");
const identifierUtils = require("./util/identifier");

const optionsOrFallback = function() ***REMOVED***
	let optionValues = [];
	optionValues.push.apply(optionValues, arguments);
	return optionValues.find(optionValue => typeof optionValue !== "undefined");
***REMOVED***;

class Stats ***REMOVED***
	constructor(compilation) ***REMOVED***
		this.compilation = compilation;
		this.hash = compilation.hash;
	***REMOVED***

	static filterWarnings(warnings, warningsFilter) ***REMOVED***
		// we dont have anything to filter so all warnings can be shown
		if(!warningsFilter) ***REMOVED***
			return warnings;
		***REMOVED***

		// create a chain of filters
		// if they return "true" a warning should be surpressed
		const normalizedWarningsFilters = [].concat(warningsFilter).map(filter => ***REMOVED***
			if(typeof filter === "string") ***REMOVED***
				return warning => warning.indexOf(filter) > -1;
			***REMOVED***

			if(filter instanceof RegExp) ***REMOVED***
				return warning => filter.test(warning);
			***REMOVED***

			if(typeof filter === "function") ***REMOVED***
				return filter;
			***REMOVED***

			throw new Error(`Can only filter warnings with Strings or RegExps. (Given: $***REMOVED***filter***REMOVED***)`);
		***REMOVED***);
		return warnings.filter(warning => ***REMOVED***
			return !normalizedWarningsFilters.some(check => check(warning));
		***REMOVED***);
	***REMOVED***

	hasWarnings() ***REMOVED***
		return this.compilation.warnings.length > 0;
	***REMOVED***

	hasErrors() ***REMOVED***
		return this.compilation.errors.length > 0;
	***REMOVED***

	// remove a prefixed "!" that can be specified to reverse sort order
	normalizeFieldKey(field) ***REMOVED***
		if(field[0] === "!") ***REMOVED***
			return field.substr(1);
		***REMOVED***
		return field;
	***REMOVED***

	// if a field is prefixed by a "!" reverse sort order
	sortOrderRegular(field) ***REMOVED***
		if(field[0] === "!") ***REMOVED***
			return false;
		***REMOVED***
		return true;
	***REMOVED***

	toJson(options, forToString) ***REMOVED***
		if(typeof options === "boolean" || typeof options === "string") ***REMOVED***
			options = Stats.presetToOptions(options);
		***REMOVED*** else if(!options) ***REMOVED***
			options = ***REMOVED******REMOVED***;
		***REMOVED***

		const optionOrLocalFallback = (v, def) =>
			typeof v !== "undefined" ? v :
			typeof options.all !== "undefined" ? options.all : def;

		const testAgainstGivenOption = (item) => ***REMOVED***
			if(typeof item === "string") ***REMOVED***
				const regExp = new RegExp(`[\\\\/]$***REMOVED***item.replace(/[\-\[\]\/\***REMOVED***\***REMOVED***\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")***REMOVED***([\\\\/]|$|!|\\?)`); // eslint-disable-line no-useless-escape
				return ident => regExp.test(ident);
			***REMOVED***
			if(item && typeof item === "object" && typeof item.test === "function")
				return ident => item.test(ident);
			if(typeof item === "function")
				return item;
		***REMOVED***;

		const compilation = this.compilation;
		const context = optionsOrFallback(options.context, process.cwd());
		const requestShortener = new RequestShortener(context);
		const showPerformance = optionOrLocalFallback(options.performance, true);
		const showHash = optionOrLocalFallback(options.hash, true);
		const showEnv = optionOrLocalFallback(options.env, false);
		const showVersion = optionOrLocalFallback(options.version, true);
		const showTimings = optionOrLocalFallback(options.timings, true);
		const showAssets = optionOrLocalFallback(options.assets, true);
		const showEntrypoints = optionOrLocalFallback(options.entrypoints, !forToString);
		const showChunks = optionOrLocalFallback(options.chunks, !forToString);
		const showChunkModules = optionOrLocalFallback(options.chunkModules, true);
		const showChunkOrigins = optionOrLocalFallback(options.chunkOrigins, !forToString);
		const showModules = optionOrLocalFallback(options.modules, true);
		const showDepth = optionOrLocalFallback(options.depth, !forToString);
		const showCachedModules = optionOrLocalFallback(options.cached, true);
		const showCachedAssets = optionOrLocalFallback(options.cachedAssets, true);
		const showReasons = optionOrLocalFallback(options.reasons, !forToString);
		const showUsedExports = optionOrLocalFallback(options.usedExports, !forToString);
		const showProvidedExports = optionOrLocalFallback(options.providedExports, !forToString);
		const showOptimizationBailout = optionOrLocalFallback(options.optimizationBailout, !forToString);
		const showChildren = optionOrLocalFallback(options.children, true);
		const showSource = optionOrLocalFallback(options.source, !forToString);
		const showModuleTrace = optionOrLocalFallback(options.moduleTrace, true);
		const showErrors = optionOrLocalFallback(options.errors, true);
		const showErrorDetails = optionOrLocalFallback(options.errorDetails, !forToString);
		const showWarnings = optionOrLocalFallback(options.warnings, true);
		const warningsFilter = optionsOrFallback(options.warningsFilter, null);
		const showPublicPath = optionOrLocalFallback(options.publicPath, !forToString);
		const excludeModules = [].concat(optionsOrFallback(options.excludeModules, options.exclude, [])).map(testAgainstGivenOption);
		const excludeAssets = [].concat(optionsOrFallback(options.excludeAssets, [])).map(testAgainstGivenOption);
		const maxModules = optionsOrFallback(options.maxModules, forToString ? 15 : Infinity);
		const sortModules = optionsOrFallback(options.modulesSort, "id");
		const sortChunks = optionsOrFallback(options.chunksSort, "id");
		const sortAssets = optionsOrFallback(options.assetsSort, "");

		if(!showCachedModules) ***REMOVED***
			excludeModules.push((ident, module) => !module.built);
		***REMOVED***

		const createModuleFilter = () => ***REMOVED***
			let i = 0;
			return module => ***REMOVED***
				if(excludeModules.length > 0) ***REMOVED***
					const ident = requestShortener.shorten(module.resource);
					const excluded = excludeModules.some(fn => fn(ident, module));
					if(excluded)
						return false;
				***REMOVED***
				return i++ < maxModules;
			***REMOVED***;
		***REMOVED***;

		const createAssetFilter = () => ***REMOVED***
			return asset => ***REMOVED***
				if(excludeAssets.length > 0) ***REMOVED***
					const ident = asset.name;
					const excluded = excludeAssets.some(fn => fn(ident, asset));
					if(excluded)
						return false;
				***REMOVED***
				return showCachedAssets || asset.emitted;
			***REMOVED***;
		***REMOVED***;

		const sortByFieldAndOrder = (fieldKey, a, b) => ***REMOVED***
			if(a[fieldKey] === null && b[fieldKey] === null) return 0;
			if(a[fieldKey] === null) return 1;
			if(b[fieldKey] === null) return -1;
			if(a[fieldKey] === b[fieldKey]) return 0;
			return a[fieldKey] < b[fieldKey] ? -1 : 1;
		***REMOVED***;

		const sortByField = (field) => (a, b) => ***REMOVED***
			if(!field) ***REMOVED***
				return 0;
			***REMOVED***

			const fieldKey = this.normalizeFieldKey(field);

			// if a field is prefixed with a "!" the sort is reversed!
			const sortIsRegular = this.sortOrderRegular(field);

			return sortByFieldAndOrder(fieldKey, sortIsRegular ? a : b, sortIsRegular ? b : a);
		***REMOVED***;

		const formatError = (e) => ***REMOVED***
			let text = "";
			if(typeof e === "string")
				e = ***REMOVED***
					message: e
				***REMOVED***;
			if(e.chunk) ***REMOVED***
				text += `chunk $***REMOVED***e.chunk.name || e.chunk.id***REMOVED***$***REMOVED***e.chunk.hasRuntime() ? " [entry]" : e.chunk.isInitial() ? " [initial]" : ""***REMOVED***\n`;
			***REMOVED***
			if(e.file) ***REMOVED***
				text += `$***REMOVED***e.file***REMOVED***\n`;
			***REMOVED***
			if(e.module && e.module.readableIdentifier && typeof e.module.readableIdentifier === "function") ***REMOVED***
				text += `$***REMOVED***e.module.readableIdentifier(requestShortener)***REMOVED***\n`;
			***REMOVED***
			text += e.message;
			if(showErrorDetails && e.details) text += `\n$***REMOVED***e.details***REMOVED***`;
			if(showErrorDetails && e.missing) text += e.missing.map(item => `\n[$***REMOVED***item***REMOVED***]`).join("");
			if(showModuleTrace && e.origin) ***REMOVED***
				text += `\n @ $***REMOVED***e.origin.readableIdentifier(requestShortener)***REMOVED***`;
				if(typeof e.originLoc === "object") ***REMOVED***
					const locInfo = formatLocation(e.originLoc);
					if(locInfo)
						text += ` $***REMOVED***locInfo***REMOVED***`;
				***REMOVED***
				if(e.dependencies) ***REMOVED***
					e.dependencies.forEach(dep => ***REMOVED***
						if(!dep.loc) return;
						if(typeof dep.loc === "string") return;
						const locInfo = formatLocation(dep.loc);
						if(!locInfo) return;
						text += ` $***REMOVED***locInfo***REMOVED***`;
					***REMOVED***);
				***REMOVED***
				let current = e.origin;
				while(current.issuer) ***REMOVED***
					current = current.issuer;
					text += `\n @ $***REMOVED***current.readableIdentifier(requestShortener)***REMOVED***`;
				***REMOVED***
			***REMOVED***
			return text;
		***REMOVED***;

		const obj = ***REMOVED***
			errors: compilation.errors.map(formatError),
			warnings: Stats.filterWarnings(compilation.warnings.map(formatError), warningsFilter)
		***REMOVED***;

		//We just hint other renderers since actually omitting
		//errors/warnings from the JSON would be kind of weird.
		Object.defineProperty(obj, "_showWarnings", ***REMOVED***
			value: showWarnings,
			enumerable: false
		***REMOVED***);
		Object.defineProperty(obj, "_showErrors", ***REMOVED***
			value: showErrors,
			enumerable: false
		***REMOVED***);

		if(showVersion) ***REMOVED***
			obj.version = require("../package.json").version;
		***REMOVED***

		if(showHash) obj.hash = this.hash;
		if(showTimings && this.startTime && this.endTime) ***REMOVED***
			obj.time = this.endTime - this.startTime;
		***REMOVED***

		if(showEnv && options._env) ***REMOVED***
			obj.env = options._env;
		***REMOVED***

		if(compilation.needAdditionalPass) ***REMOVED***
			obj.needAdditionalPass = true;
		***REMOVED***
		if(showPublicPath) ***REMOVED***
			obj.publicPath = this.compilation.mainTemplate.getPublicPath(***REMOVED***
				hash: this.compilation.hash
			***REMOVED***);
		***REMOVED***
		if(showAssets) ***REMOVED***
			const assetsByFile = ***REMOVED******REMOVED***;
			const compilationAssets = Object.keys(compilation.assets);
			obj.assetsByChunkName = ***REMOVED******REMOVED***;
			obj.assets = compilationAssets.map(asset => ***REMOVED***
				const obj = ***REMOVED***
					name: asset,
					size: compilation.assets[asset].size(),
					chunks: [],
					chunkNames: [],
					emitted: compilation.assets[asset].emitted
				***REMOVED***;

				if(showPerformance) ***REMOVED***
					obj.isOverSizeLimit = compilation.assets[asset].isOverSizeLimit;
				***REMOVED***

				assetsByFile[asset] = obj;
				return obj;
			***REMOVED***).filter(createAssetFilter());
			obj.filteredAssets = compilationAssets.length - obj.assets.length;

			compilation.chunks.forEach(chunk => ***REMOVED***
				chunk.files.forEach(asset => ***REMOVED***
					if(assetsByFile[asset]) ***REMOVED***
						chunk.ids.forEach(id => ***REMOVED***
							assetsByFile[asset].chunks.push(id);
						***REMOVED***);
						if(chunk.name) ***REMOVED***
							assetsByFile[asset].chunkNames.push(chunk.name);
							if(obj.assetsByChunkName[chunk.name])
								obj.assetsByChunkName[chunk.name] = [].concat(obj.assetsByChunkName[chunk.name]).concat([asset]);
							else
								obj.assetsByChunkName[chunk.name] = asset;
						***REMOVED***
					***REMOVED***
				***REMOVED***);
			***REMOVED***);
			obj.assets.sort(sortByField(sortAssets));
		***REMOVED***

		if(showEntrypoints) ***REMOVED***
			obj.entrypoints = ***REMOVED******REMOVED***;
			Object.keys(compilation.entrypoints).forEach(name => ***REMOVED***
				const ep = compilation.entrypoints[name];
				obj.entrypoints[name] = ***REMOVED***
					chunks: ep.chunks.map(c => c.id),
					assets: ep.chunks.reduce((array, c) => array.concat(c.files || []), [])
				***REMOVED***;
				if(showPerformance) ***REMOVED***
					obj.entrypoints[name].isOverSizeLimit = ep.isOverSizeLimit;
				***REMOVED***
			***REMOVED***);
		***REMOVED***

		function fnModule(module) ***REMOVED***
			const obj = ***REMOVED***
				id: module.id,
				identifier: module.identifier(),
				name: module.readableIdentifier(requestShortener),
				index: module.index,
				index2: module.index2,
				size: module.size(),
				cacheable: !!module.cacheable,
				built: !!module.built,
				optional: !!module.optional,
				prefetched: !!module.prefetched,
				chunks: module.mapChunks(chunk => chunk.id),
				assets: Object.keys(module.assets || ***REMOVED******REMOVED***),
				issuer: module.issuer && module.issuer.identifier(),
				issuerId: module.issuer && module.issuer.id,
				issuerName: module.issuer && module.issuer.readableIdentifier(requestShortener),
				profile: module.profile,
				failed: !!module.error,
				errors: module.errors && module.dependenciesErrors && (module.errors.length + module.dependenciesErrors.length),
				warnings: module.errors && module.dependenciesErrors && (module.warnings.length + module.dependenciesWarnings.length)
			***REMOVED***;
			if(showReasons) ***REMOVED***
				obj.reasons = module.reasons.filter(reason => reason.dependency && reason.module).map(reason => ***REMOVED***
					const obj = ***REMOVED***
						moduleId: reason.module.id,
						moduleIdentifier: reason.module.identifier(),
						module: reason.module.readableIdentifier(requestShortener),
						moduleName: reason.module.readableIdentifier(requestShortener),
						type: reason.dependency.type,
						userRequest: reason.dependency.userRequest
					***REMOVED***;
					const locInfo = formatLocation(reason.dependency.loc);
					if(locInfo) obj.loc = locInfo;
					return obj;
				***REMOVED***).sort((a, b) => a.moduleId - b.moduleId);
			***REMOVED***
			if(showUsedExports) ***REMOVED***
				obj.usedExports = module.used ? module.usedExports : false;
			***REMOVED***
			if(showProvidedExports) ***REMOVED***
				obj.providedExports = Array.isArray(module.providedExports) ? module.providedExports : null;
			***REMOVED***
			if(showOptimizationBailout) ***REMOVED***
				obj.optimizationBailout = module.optimizationBailout.map(item => ***REMOVED***
					if(typeof item === "function") return item(requestShortener);
					return item;
				***REMOVED***);
			***REMOVED***
			if(showDepth) ***REMOVED***
				obj.depth = module.depth;
			***REMOVED***
			if(showSource && module._source) ***REMOVED***
				obj.source = module._source.source();
			***REMOVED***
			return obj;
		***REMOVED***
		if(showChunks) ***REMOVED***
			obj.chunks = compilation.chunks.map(chunk => ***REMOVED***
				const obj = ***REMOVED***
					id: chunk.id,
					rendered: chunk.rendered,
					initial: chunk.isInitial(),
					entry: chunk.hasRuntime(),
					recorded: chunk.recorded,
					extraAsync: !!chunk.extraAsync,
					size: chunk.mapModules(m => m.size()).reduce((size, moduleSize) => size + moduleSize, 0),
					names: chunk.name ? [chunk.name] : [],
					files: chunk.files.slice(),
					hash: chunk.renderedHash,
					parents: chunk.parents.map(c => c.id)
				***REMOVED***;
				if(showChunkModules) ***REMOVED***
					obj.modules = chunk
						.getModules()
						.sort(sortByField("depth"))
						.filter(createModuleFilter())
						.map(fnModule);
					obj.filteredModules = chunk.getNumberOfModules() - obj.modules.length;
					obj.modules.sort(sortByField(sortModules));
				***REMOVED***
				if(showChunkOrigins) ***REMOVED***
					obj.origins = chunk.origins.map(origin => (***REMOVED***
						moduleId: origin.module ? origin.module.id : undefined,
						module: origin.module ? origin.module.identifier() : "",
						moduleIdentifier: origin.module ? origin.module.identifier() : "",
						moduleName: origin.module ? origin.module.readableIdentifier(requestShortener) : "",
						loc: formatLocation(origin.loc),
						name: origin.name,
						reasons: origin.reasons || []
					***REMOVED***));
				***REMOVED***
				return obj;
			***REMOVED***);
			obj.chunks.sort(sortByField(sortChunks));
		***REMOVED***
		if(showModules) ***REMOVED***
			obj.modules = compilation.modules
				.slice()
				.sort(sortByField("depth"))
				.filter(createModuleFilter())
				.map(fnModule);
			obj.filteredModules = compilation.modules.length - obj.modules.length;
			obj.modules.sort(sortByField(sortModules));
		***REMOVED***
		if(showChildren) ***REMOVED***
			obj.children = compilation.children.map((child, idx) => ***REMOVED***
				const childOptions = Stats.getChildOptions(options, idx);
				const obj = new Stats(child).toJson(childOptions, forToString);
				delete obj.hash;
				delete obj.version;
				if(child.name)
					obj.name = identifierUtils.makePathsRelative(context, child.name, compilation.cache);
				return obj;
			***REMOVED***);
		***REMOVED***

		return obj;
	***REMOVED***

	toString(options) ***REMOVED***
		if(typeof options === "boolean" || typeof options === "string") ***REMOVED***
			options = Stats.presetToOptions(options);
		***REMOVED*** else if(!options) ***REMOVED***
			options = ***REMOVED******REMOVED***;
		***REMOVED***

		const useColors = optionsOrFallback(options.colors, false);

		const obj = this.toJson(options, true);

		return Stats.jsonToString(obj, useColors);
	***REMOVED***

	static jsonToString(obj, useColors) ***REMOVED***
		const buf = [];

		const defaultColors = ***REMOVED***
			bold: "\u001b[1m",
			yellow: "\u001b[1m\u001b[33m",
			red: "\u001b[1m\u001b[31m",
			green: "\u001b[1m\u001b[32m",
			cyan: "\u001b[1m\u001b[36m",
			magenta: "\u001b[1m\u001b[35m"
		***REMOVED***;

		const colors = Object.keys(defaultColors).reduce((obj, color) => ***REMOVED***
			obj[color] = str => ***REMOVED***
				if(useColors) ***REMOVED***
					buf.push(
						(useColors === true || useColors[color] === undefined) ?
						defaultColors[color] : useColors[color]
					);
				***REMOVED***
				buf.push(str);
				if(useColors) ***REMOVED***
					buf.push("\u001b[39m\u001b[22m");
				***REMOVED***
			***REMOVED***;
			return obj;
		***REMOVED***, ***REMOVED***
			normal: (str) => buf.push(str)
		***REMOVED***);

		const coloredTime = (time) => ***REMOVED***
			let times = [800, 400, 200, 100];
			if(obj.time) ***REMOVED***
				times = [obj.time / 2, obj.time / 4, obj.time / 8, obj.time / 16];
			***REMOVED***
			if(time < times[3])
				colors.normal(`$***REMOVED***time***REMOVED***ms`);
			else if(time < times[2])
				colors.bold(`$***REMOVED***time***REMOVED***ms`);
			else if(time < times[1])
				colors.green(`$***REMOVED***time***REMOVED***ms`);
			else if(time < times[0])
				colors.yellow(`$***REMOVED***time***REMOVED***ms`);
			else
				colors.red(`$***REMOVED***time***REMOVED***ms`);
		***REMOVED***;

		const newline = () => buf.push("\n");

		const getText = (arr, row, col) => ***REMOVED***
			return arr[row][col].value;
		***REMOVED***;

		const table = (array, align, splitter) => ***REMOVED***
			const rows = array.length;
			const cols = array[0].length;
			const colSizes = new Array(cols);
			for(let col = 0; col < cols; col++)
				colSizes[col] = 0;
			for(let row = 0; row < rows; row++) ***REMOVED***
				for(let col = 0; col < cols; col++) ***REMOVED***
					const value = `$***REMOVED***getText(array, row, col)***REMOVED***`;
					if(value.length > colSizes[col]) ***REMOVED***
						colSizes[col] = value.length;
					***REMOVED***
				***REMOVED***
			***REMOVED***
			for(let row = 0; row < rows; row++) ***REMOVED***
				for(let col = 0; col < cols; col++) ***REMOVED***
					const format = array[row][col].color;
					const value = `$***REMOVED***getText(array, row, col)***REMOVED***`;
					let l = value.length;
					if(align[col] === "l")
						format(value);
					for(; l < colSizes[col] && col !== cols - 1; l++)
						colors.normal(" ");
					if(align[col] === "r")
						format(value);
					if(col + 1 < cols && colSizes[col] !== 0)
						colors.normal(splitter || "  ");
				***REMOVED***
				newline();
			***REMOVED***
		***REMOVED***;

		const getAssetColor = (asset, defaultColor) => ***REMOVED***
			if(asset.isOverSizeLimit) ***REMOVED***
				return colors.yellow;
			***REMOVED***

			return defaultColor;
		***REMOVED***;

		if(obj.hash) ***REMOVED***
			colors.normal("Hash: ");
			colors.bold(obj.hash);
			newline();
		***REMOVED***
		if(obj.version) ***REMOVED***
			colors.normal("Version: webpack ");
			colors.bold(obj.version);
			newline();
		***REMOVED***
		if(typeof obj.time === "number") ***REMOVED***
			colors.normal("Time: ");
			colors.bold(obj.time);
			colors.normal("ms");
			newline();
		***REMOVED***
		if(obj.env) ***REMOVED***
			colors.normal("Environment (--env): ");
			colors.bold(JSON.stringify(obj.env, null, 2));
			newline();
		***REMOVED***
		if(obj.publicPath) ***REMOVED***
			colors.normal("PublicPath: ");
			colors.bold(obj.publicPath);
			newline();
		***REMOVED***

		if(obj.assets && obj.assets.length > 0) ***REMOVED***
			const t = [
				[***REMOVED***
					value: "Asset",
					color: colors.bold
				***REMOVED***, ***REMOVED***
					value: "Size",
					color: colors.bold
				***REMOVED***, ***REMOVED***
					value: "Chunks",
					color: colors.bold
				***REMOVED***, ***REMOVED***
					value: "",
					color: colors.bold
				***REMOVED***, ***REMOVED***
					value: "",
					color: colors.bold
				***REMOVED***, ***REMOVED***
					value: "Chunk Names",
					color: colors.bold
				***REMOVED***]
			];
			obj.assets.forEach(asset => ***REMOVED***
				t.push([***REMOVED***
					value: asset.name,
					color: getAssetColor(asset, colors.green)
				***REMOVED***, ***REMOVED***
					value: SizeFormatHelpers.formatSize(asset.size),
					color: getAssetColor(asset, colors.normal)
				***REMOVED***, ***REMOVED***
					value: asset.chunks.join(", "),
					color: colors.bold
				***REMOVED***, ***REMOVED***
					value: asset.emitted ? "[emitted]" : "",
					color: colors.green
				***REMOVED***, ***REMOVED***
					value: asset.isOverSizeLimit ? "[big]" : "",
					color: getAssetColor(asset, colors.normal)
				***REMOVED***, ***REMOVED***
					value: asset.chunkNames.join(", "),
					color: colors.normal
				***REMOVED***]);
			***REMOVED***);
			table(t, "rrrlll");
		***REMOVED***
		if(obj.filteredAssets > 0) ***REMOVED***
			colors.normal(" ");
			if(obj.assets.length > 0)
				colors.normal("+ ");
			colors.normal(obj.filteredAssets);
			if(obj.assets.length > 0)
				colors.normal(" hidden");
			colors.normal(obj.filteredAssets !== 1 ? " assets" : " asset");
			newline();
		***REMOVED***
		if(obj.entrypoints) ***REMOVED***
			Object.keys(obj.entrypoints).forEach(name => ***REMOVED***
				const ep = obj.entrypoints[name];
				colors.normal("Entrypoint ");
				colors.bold(name);
				if(ep.isOverSizeLimit) ***REMOVED***
					colors.normal(" ");
					colors.yellow("[big]");
				***REMOVED***
				colors.normal(" =");
				ep.assets.forEach(asset => ***REMOVED***
					colors.normal(" ");
					colors.green(asset);
				***REMOVED***);
				newline();
			***REMOVED***);
		***REMOVED***
		const modulesByIdentifier = ***REMOVED******REMOVED***;
		if(obj.modules) ***REMOVED***
			obj.modules.forEach(module => ***REMOVED***
				modulesByIdentifier[`$$***REMOVED***module.identifier***REMOVED***`] = module;
			***REMOVED***);
		***REMOVED*** else if(obj.chunks) ***REMOVED***
			obj.chunks.forEach(chunk => ***REMOVED***
				if(chunk.modules) ***REMOVED***
					chunk.modules.forEach(module => ***REMOVED***
						modulesByIdentifier[`$$***REMOVED***module.identifier***REMOVED***`] = module;
					***REMOVED***);
				***REMOVED***
			***REMOVED***);
		***REMOVED***

		const processModuleAttributes = (module) => ***REMOVED***
			colors.normal(" ");
			colors.normal(SizeFormatHelpers.formatSize(module.size));
			if(module.chunks) ***REMOVED***
				module.chunks.forEach(chunk => ***REMOVED***
					colors.normal(" ***REMOVED***");
					colors.yellow(chunk);
					colors.normal("***REMOVED***");
				***REMOVED***);
			***REMOVED***
			if(typeof module.depth === "number") ***REMOVED***
				colors.normal(` [depth $***REMOVED***module.depth***REMOVED***]`);
			***REMOVED***
			if(!module.cacheable) ***REMOVED***
				colors.red(" [not cacheable]");
			***REMOVED***
			if(module.optional) ***REMOVED***
				colors.yellow(" [optional]");
			***REMOVED***
			if(module.built) ***REMOVED***
				colors.green(" [built]");
			***REMOVED***
			if(module.prefetched) ***REMOVED***
				colors.magenta(" [prefetched]");
			***REMOVED***
			if(module.failed)
				colors.red(" [failed]");
			if(module.warnings)
				colors.yellow(` [$***REMOVED***module.warnings***REMOVED*** warning$***REMOVED***module.warnings === 1 ? "" : "s"***REMOVED***]`);
			if(module.errors)
				colors.red(` [$***REMOVED***module.errors***REMOVED*** error$***REMOVED***module.errors === 1 ? "" : "s"***REMOVED***]`);
		***REMOVED***;

		const processModuleContent = (module, prefix) => ***REMOVED***
			if(Array.isArray(module.providedExports)) ***REMOVED***
				colors.normal(prefix);
				if(module.providedExports.length === 0)
					colors.cyan("[no exports]");
				else
					colors.cyan(`[exports: $***REMOVED***module.providedExports.join(", ")***REMOVED***]`);
				newline();
			***REMOVED***
			if(module.usedExports !== undefined) ***REMOVED***
				if(module.usedExports !== true) ***REMOVED***
					colors.normal(prefix);
					if(module.usedExports === false || module.usedExports.length === 0)
						colors.cyan("[no exports used]");
					else
						colors.cyan(`[only some exports used: $***REMOVED***module.usedExports.join(", ")***REMOVED***]`);
					newline();
				***REMOVED***
			***REMOVED***
			if(Array.isArray(module.optimizationBailout)) ***REMOVED***
				module.optimizationBailout.forEach(item => ***REMOVED***
					colors.normal(prefix);
					colors.yellow(item);
					newline();
				***REMOVED***);
			***REMOVED***
			if(module.reasons) ***REMOVED***
				module.reasons.forEach(reason => ***REMOVED***
					colors.normal(prefix);
					colors.normal(reason.type);
					colors.normal(" ");
					colors.cyan(reason.userRequest);
					colors.normal(" [");
					colors.normal(reason.moduleId);
					colors.normal("] ");
					colors.magenta(reason.module);
					if(reason.loc) ***REMOVED***
						colors.normal(" ");
						colors.normal(reason.loc);
					***REMOVED***
					newline();
				***REMOVED***);
			***REMOVED***
			if(module.profile) ***REMOVED***
				colors.normal(prefix);
				let sum = 0;
				const path = [];
				let current = module;
				while(current.issuer) ***REMOVED***
					path.push(current = current.issuer);
				***REMOVED***
				path.reverse().forEach(module => ***REMOVED***
					colors.normal("[");
					colors.normal(module.id);
					colors.normal("] ");
					if(module.profile) ***REMOVED***
						const time = (module.profile.factory || 0) + (module.profile.building || 0);
						coloredTime(time);
						sum += time;
						colors.normal(" ");
					***REMOVED***
					colors.normal("->");
				***REMOVED***);
				Object.keys(module.profile).forEach(key => ***REMOVED***
					colors.normal(` $***REMOVED***key***REMOVED***:`);
					const time = module.profile[key];
					coloredTime(time);
					sum += time;
				***REMOVED***);
				colors.normal(" = ");
				coloredTime(sum);
				newline();
			***REMOVED***
		***REMOVED***;

		const processModulesList = (obj, prefix) => ***REMOVED***
			if(obj.modules) ***REMOVED***
				obj.modules.forEach(module => ***REMOVED***
					colors.normal(prefix);
					if(module.id < 1000) colors.normal(" ");
					if(module.id < 100) colors.normal(" ");
					if(module.id < 10) colors.normal(" ");
					colors.normal("[");
					colors.normal(module.id);
					colors.normal("] ");
					colors.bold(module.name || module.identifier);
					processModuleAttributes(module);
					newline();
					processModuleContent(module, prefix + "       ");
				***REMOVED***);
				if(obj.filteredModules > 0) ***REMOVED***
					colors.normal(prefix);
					colors.normal("   ");
					if(obj.modules.length > 0)
						colors.normal(" + ");
					colors.normal(obj.filteredModules);
					if(obj.modules.length > 0)
						colors.normal(" hidden");
					colors.normal(obj.filteredModules !== 1 ? " modules" : " module");
					newline();
				***REMOVED***
			***REMOVED***
		***REMOVED***;

		if(obj.chunks) ***REMOVED***
			obj.chunks.forEach(chunk => ***REMOVED***
				colors.normal("chunk ");
				if(chunk.id < 1000) colors.normal(" ");
				if(chunk.id < 100) colors.normal(" ");
				if(chunk.id < 10) colors.normal(" ");
				colors.normal("***REMOVED***");
				colors.yellow(chunk.id);
				colors.normal("***REMOVED*** ");
				colors.green(chunk.files.join(", "));
				if(chunk.names && chunk.names.length > 0) ***REMOVED***
					colors.normal(" (");
					colors.normal(chunk.names.join(", "));
					colors.normal(")");
				***REMOVED***
				colors.normal(" ");
				colors.normal(SizeFormatHelpers.formatSize(chunk.size));
				chunk.parents.forEach(id => ***REMOVED***
					colors.normal(" ***REMOVED***");
					colors.yellow(id);
					colors.normal("***REMOVED***");
				***REMOVED***);
				if(chunk.entry) ***REMOVED***
					colors.yellow(" [entry]");
				***REMOVED*** else if(chunk.initial) ***REMOVED***
					colors.yellow(" [initial]");
				***REMOVED***
				if(chunk.rendered) ***REMOVED***
					colors.green(" [rendered]");
				***REMOVED***
				if(chunk.recorded) ***REMOVED***
					colors.green(" [recorded]");
				***REMOVED***
				newline();
				if(chunk.origins) ***REMOVED***
					chunk.origins.forEach(origin => ***REMOVED***
						colors.normal("    > ");
						if(origin.reasons && origin.reasons.length) ***REMOVED***
							colors.yellow(origin.reasons.join(" "));
							colors.normal(" ");
						***REMOVED***
						if(origin.name) ***REMOVED***
							colors.normal(origin.name);
							colors.normal(" ");
						***REMOVED***
						if(origin.module) ***REMOVED***
							colors.normal("[");
							colors.normal(origin.moduleId);
							colors.normal("] ");
							const module = modulesByIdentifier[`$$***REMOVED***origin.module***REMOVED***`];
							if(module) ***REMOVED***
								colors.bold(module.name);
								colors.normal(" ");
							***REMOVED***
							if(origin.loc) ***REMOVED***
								colors.normal(origin.loc);
							***REMOVED***
						***REMOVED***
						newline();
					***REMOVED***);
				***REMOVED***
				processModulesList(chunk, " ");
			***REMOVED***);
		***REMOVED***

		processModulesList(obj, "");

		if(obj._showWarnings && obj.warnings) ***REMOVED***
			obj.warnings.forEach(warning => ***REMOVED***
				newline();
				colors.yellow(`WARNING in $***REMOVED***warning***REMOVED***`);
				newline();
			***REMOVED***);
		***REMOVED***
		if(obj._showErrors && obj.errors) ***REMOVED***
			obj.errors.forEach(error => ***REMOVED***
				newline();
				colors.red(`ERROR in $***REMOVED***error***REMOVED***`);
				newline();
			***REMOVED***);
		***REMOVED***
		if(obj.children) ***REMOVED***
			obj.children.forEach(child => ***REMOVED***
				const childString = Stats.jsonToString(child, useColors);
				if(childString) ***REMOVED***
					if(child.name) ***REMOVED***
						colors.normal("Child ");
						colors.bold(child.name);
						colors.normal(":");
					***REMOVED*** else ***REMOVED***
						colors.normal("Child");
					***REMOVED***
					newline();
					buf.push("    ");
					buf.push(childString.replace(/\n/g, "\n    "));
					newline();
				***REMOVED***
			***REMOVED***);
		***REMOVED***
		if(obj.needAdditionalPass) ***REMOVED***
			colors.yellow("Compilation needs an additional pass and will compile again.");
		***REMOVED***

		while(buf[buf.length - 1] === "\n") buf.pop();
		return buf.join("");
	***REMOVED***

	static presetToOptions(name) ***REMOVED***
		// Accepted values: none, errors-only, minimal, normal, detailed, verbose
		// Any other falsy value will behave as 'none', truthy values as 'normal'
		const pn = (typeof name === "string") && name.toLowerCase() || name || "none";
		switch(pn) ***REMOVED***
			case "none":
				return ***REMOVED***
					all: false
				***REMOVED***;
			case "verbose":
				return ***REMOVED***
					entrypoints: true,
					modules: false,
					chunks: true,
					chunkModules: true,
					chunkOrigins: true,
					depth: true,
					env: true,
					reasons: true,
					usedExports: true,
					providedExports: true,
					optimizationBailout: true,
					errorDetails: true,
					publicPath: true,
					exclude: () => false,
					maxModules: Infinity,
				***REMOVED***;
			case "detailed":
				return ***REMOVED***
					entrypoints: true,
					chunks: true,
					chunkModules: false,
					chunkOrigins: true,
					depth: true,
					usedExports: true,
					providedExports: true,
					optimizationBailout: true,
					errorDetails: true,
					publicPath: true,
					exclude: () => false,
					maxModules: Infinity,
				***REMOVED***;
			case "minimal":
				return ***REMOVED***
					all: false,
					modules: true,
					maxModules: 0,
					errors: true,
					warnings: true,
				***REMOVED***;
			case "errors-only":
				return ***REMOVED***
					all: false,
					errors: true,
					moduleTrace: true,
				***REMOVED***;
			default:
				return ***REMOVED******REMOVED***;
		***REMOVED***
	***REMOVED***

	static getChildOptions(options, idx) ***REMOVED***
		let innerOptions;
		if(Array.isArray(options.children)) ***REMOVED***
			if(idx < options.children.length)
				innerOptions = options.children[idx];
		***REMOVED*** else if(typeof options.children === "object" && options.children) ***REMOVED***
			innerOptions = options.children;
		***REMOVED***
		if(typeof innerOptions === "boolean" || typeof innerOptions === "string")
			innerOptions = Stats.presetToOptions(innerOptions);
		if(!innerOptions)
			return options;
		const childOptions = Object.assign(***REMOVED******REMOVED***, options);
		delete childOptions.children; // do not inherit children
		return Object.assign(childOptions, innerOptions);
	***REMOVED***
***REMOVED***

module.exports = Stats;
