/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*global $hash$ $requestTimeout$ installedModules $require$ hotDownloadManifest hotDownloadUpdateChunk hotDisposeChunk modules */
module.exports = function() ***REMOVED***

	var hotApplyOnUpdate = true;
	var hotCurrentHash = $hash$; // eslint-disable-line no-unused-vars
	var hotRequestTimeout = $requestTimeout$;
	var hotCurrentModuleData = ***REMOVED******REMOVED***;
	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars

	function hotCreateRequire(moduleId) ***REMOVED*** // eslint-disable-line no-unused-vars
		var me = installedModules[moduleId];
		if(!me) return $require$;
		var fn = function(request) ***REMOVED***
			if(me.hot.active) ***REMOVED***
				if(installedModules[request]) ***REMOVED***
					if(installedModules[request].parents.indexOf(moduleId) < 0)
						installedModules[request].parents.push(moduleId);
				***REMOVED*** else ***REMOVED***
					hotCurrentParents = [moduleId];
					hotCurrentChildModule = request;
				***REMOVED***
				if(me.children.indexOf(request) < 0)
					me.children.push(request);
			***REMOVED*** else ***REMOVED***
				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
				hotCurrentParents = [];
			***REMOVED***
			return $require$(request);
		***REMOVED***;
		var ObjectFactory = function ObjectFactory(name) ***REMOVED***
			return ***REMOVED***
				configurable: true,
				enumerable: true,
				get: function() ***REMOVED***
					return $require$[name];
				***REMOVED***,
				set: function(value) ***REMOVED***
					$require$[name] = value;
				***REMOVED***
			***REMOVED***;
		***REMOVED***;
		for(var name in $require$) ***REMOVED***
			if(Object.prototype.hasOwnProperty.call($require$, name) && name !== "e") ***REMOVED***
				Object.defineProperty(fn, name, ObjectFactory(name));
			***REMOVED***
		***REMOVED***
		fn.e = function(chunkId) ***REMOVED***
			if(hotStatus === "ready")
				hotSetStatus("prepare");
			hotChunksLoading++;
			return $require$.e(chunkId).then(finishChunkLoading, function(err) ***REMOVED***
				finishChunkLoading();
				throw err;
			***REMOVED***);

			function finishChunkLoading() ***REMOVED***
				hotChunksLoading--;
				if(hotStatus === "prepare") ***REMOVED***
					if(!hotWaitingFilesMap[chunkId]) ***REMOVED***
						hotEnsureUpdateChunk(chunkId);
					***REMOVED***
					if(hotChunksLoading === 0 && hotWaitingFiles === 0) ***REMOVED***
						hotUpdateDownloaded();
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***;
		return fn;
	***REMOVED***

	function hotCreateModule(moduleId) ***REMOVED*** // eslint-disable-line no-unused-vars
		var hot = ***REMOVED***
			// private stuff
			_acceptedDependencies: ***REMOVED******REMOVED***,
			_declinedDependencies: ***REMOVED******REMOVED***,
			_selfAccepted: false,
			_selfDeclined: false,
			_disposeHandlers: [],
			_main: hotCurrentChildModule !== moduleId,

			// Module API
			active: true,
			accept: function(dep, callback) ***REMOVED***
				if(typeof dep === "undefined")
					hot._selfAccepted = true;
				else if(typeof dep === "function")
					hot._selfAccepted = dep;
				else if(typeof dep === "object")
					for(var i = 0; i < dep.length; i++)
						hot._acceptedDependencies[dep[i]] = callback || function() ***REMOVED******REMOVED***;
				else
					hot._acceptedDependencies[dep] = callback || function() ***REMOVED******REMOVED***;
			***REMOVED***,
			decline: function(dep) ***REMOVED***
				if(typeof dep === "undefined")
					hot._selfDeclined = true;
				else if(typeof dep === "object")
					for(var i = 0; i < dep.length; i++)
						hot._declinedDependencies[dep[i]] = true;
				else
					hot._declinedDependencies[dep] = true;
			***REMOVED***,
			dispose: function(callback) ***REMOVED***
				hot._disposeHandlers.push(callback);
			***REMOVED***,
			addDisposeHandler: function(callback) ***REMOVED***
				hot._disposeHandlers.push(callback);
			***REMOVED***,
			removeDisposeHandler: function(callback) ***REMOVED***
				var idx = hot._disposeHandlers.indexOf(callback);
				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
			***REMOVED***,

			// Management API
			check: hotCheck,
			apply: hotApply,
			status: function(l) ***REMOVED***
				if(!l) return hotStatus;
				hotStatusHandlers.push(l);
			***REMOVED***,
			addStatusHandler: function(l) ***REMOVED***
				hotStatusHandlers.push(l);
			***REMOVED***,
			removeStatusHandler: function(l) ***REMOVED***
				var idx = hotStatusHandlers.indexOf(l);
				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
			***REMOVED***,

			//inherit from previous dispose call
			data: hotCurrentModuleData[moduleId]
		***REMOVED***;
		hotCurrentChildModule = undefined;
		return hot;
	***REMOVED***

	var hotStatusHandlers = [];
	var hotStatus = "idle";

	function hotSetStatus(newStatus) ***REMOVED***
		hotStatus = newStatus;
		for(var i = 0; i < hotStatusHandlers.length; i++)
			hotStatusHandlers[i].call(null, newStatus);
	***REMOVED***

	// while downloading
	var hotWaitingFiles = 0;
	var hotChunksLoading = 0;
	var hotWaitingFilesMap = ***REMOVED******REMOVED***;
	var hotRequestedFilesMap = ***REMOVED******REMOVED***;
	var hotAvailableFilesMap = ***REMOVED******REMOVED***;
	var hotDeferred;

	// The update info
	var hotUpdate, hotUpdateNewHash;

	function toModuleId(id) ***REMOVED***
		var isNumber = (+id) + "" === id;
		return isNumber ? +id : id;
	***REMOVED***

	function hotCheck(apply) ***REMOVED***
		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
		hotApplyOnUpdate = apply;
		hotSetStatus("check");
		return hotDownloadManifest(hotRequestTimeout).then(function(update) ***REMOVED***
			if(!update) ***REMOVED***
				hotSetStatus("idle");
				return null;
			***REMOVED***
			hotRequestedFilesMap = ***REMOVED******REMOVED***;
			hotWaitingFilesMap = ***REMOVED******REMOVED***;
			hotAvailableFilesMap = update.c;
			hotUpdateNewHash = update.h;

			hotSetStatus("prepare");
			var promise = new Promise(function(resolve, reject) ***REMOVED***
				hotDeferred = ***REMOVED***
					resolve: resolve,
					reject: reject
				***REMOVED***;
			***REMOVED***);
			hotUpdate = ***REMOVED******REMOVED***;
			/*foreachInstalledChunks*/
			***REMOVED*** // eslint-disable-line no-lone-blocks
				/*globals chunkId */
				hotEnsureUpdateChunk(chunkId);
			***REMOVED***
			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) ***REMOVED***
				hotUpdateDownloaded();
			***REMOVED***
			return promise;
		***REMOVED***);
	***REMOVED***

	function hotAddUpdateChunk(chunkId, moreModules) ***REMOVED*** // eslint-disable-line no-unused-vars
		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
			return;
		hotRequestedFilesMap[chunkId] = false;
		for(var moduleId in moreModules) ***REMOVED***
			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) ***REMOVED***
				hotUpdate[moduleId] = moreModules[moduleId];
			***REMOVED***
		***REMOVED***
		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) ***REMOVED***
			hotUpdateDownloaded();
		***REMOVED***
	***REMOVED***

	function hotEnsureUpdateChunk(chunkId) ***REMOVED***
		if(!hotAvailableFilesMap[chunkId]) ***REMOVED***
			hotWaitingFilesMap[chunkId] = true;
		***REMOVED*** else ***REMOVED***
			hotRequestedFilesMap[chunkId] = true;
			hotWaitingFiles++;
			hotDownloadUpdateChunk(chunkId);
		***REMOVED***
	***REMOVED***

	function hotUpdateDownloaded() ***REMOVED***
		hotSetStatus("ready");
		var deferred = hotDeferred;
		hotDeferred = null;
		if(!deferred) return;
		if(hotApplyOnUpdate) ***REMOVED***
			// Wrap deferred object in Promise to mark it as a well-handled Promise to
			// avoid triggering uncaught exception warning in Chrome.
			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
			Promise.resolve().then(function() ***REMOVED***
				return hotApply(hotApplyOnUpdate);
			***REMOVED***).then(
				function(result) ***REMOVED***
					deferred.resolve(result);
				***REMOVED***,
				function(err) ***REMOVED***
					deferred.reject(err);
				***REMOVED***
			);
		***REMOVED*** else ***REMOVED***
			var outdatedModules = [];
			for(var id in hotUpdate) ***REMOVED***
				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) ***REMOVED***
					outdatedModules.push(toModuleId(id));
				***REMOVED***
			***REMOVED***
			deferred.resolve(outdatedModules);
		***REMOVED***
	***REMOVED***

	function hotApply(options) ***REMOVED***
		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
		options = options || ***REMOVED******REMOVED***;

		var cb;
		var i;
		var j;
		var module;
		var moduleId;

		function getAffectedStuff(updateModuleId) ***REMOVED***
			var outdatedModules = [updateModuleId];
			var outdatedDependencies = ***REMOVED******REMOVED***;

			var queue = outdatedModules.slice().map(function(id) ***REMOVED***
				return ***REMOVED***
					chain: [id],
					id: id
				***REMOVED***;
			***REMOVED***);
			while(queue.length > 0) ***REMOVED***
				var queueItem = queue.pop();
				var moduleId = queueItem.id;
				var chain = queueItem.chain;
				module = installedModules[moduleId];
				if(!module || module.hot._selfAccepted)
					continue;
				if(module.hot._selfDeclined) ***REMOVED***
					return ***REMOVED***
						type: "self-declined",
						chain: chain,
						moduleId: moduleId
					***REMOVED***;
				***REMOVED***
				if(module.hot._main) ***REMOVED***
					return ***REMOVED***
						type: "unaccepted",
						chain: chain,
						moduleId: moduleId
					***REMOVED***;
				***REMOVED***
				for(var i = 0; i < module.parents.length; i++) ***REMOVED***
					var parentId = module.parents[i];
					var parent = installedModules[parentId];
					if(!parent) continue;
					if(parent.hot._declinedDependencies[moduleId]) ***REMOVED***
						return ***REMOVED***
							type: "declined",
							chain: chain.concat([parentId]),
							moduleId: moduleId,
							parentId: parentId
						***REMOVED***;
					***REMOVED***
					if(outdatedModules.indexOf(parentId) >= 0) continue;
					if(parent.hot._acceptedDependencies[moduleId]) ***REMOVED***
						if(!outdatedDependencies[parentId])
							outdatedDependencies[parentId] = [];
						addAllToSet(outdatedDependencies[parentId], [moduleId]);
						continue;
					***REMOVED***
					delete outdatedDependencies[parentId];
					outdatedModules.push(parentId);
					queue.push(***REMOVED***
						chain: chain.concat([parentId]),
						id: parentId
					***REMOVED***);
				***REMOVED***
			***REMOVED***

			return ***REMOVED***
				type: "accepted",
				moduleId: updateModuleId,
				outdatedModules: outdatedModules,
				outdatedDependencies: outdatedDependencies
			***REMOVED***;
		***REMOVED***

		function addAllToSet(a, b) ***REMOVED***
			for(var i = 0; i < b.length; i++) ***REMOVED***
				var item = b[i];
				if(a.indexOf(item) < 0)
					a.push(item);
			***REMOVED***
		***REMOVED***

		// at begin all updates modules are outdated
		// the "outdated" status can propagate to parents if they don't accept the children
		var outdatedDependencies = ***REMOVED******REMOVED***;
		var outdatedModules = [];
		var appliedUpdate = ***REMOVED******REMOVED***;

		var warnUnexpectedRequire = function warnUnexpectedRequire() ***REMOVED***
			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
		***REMOVED***;

		for(var id in hotUpdate) ***REMOVED***
			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) ***REMOVED***
				moduleId = toModuleId(id);
				var result;
				if(hotUpdate[id]) ***REMOVED***
					result = getAffectedStuff(moduleId);
				***REMOVED*** else ***REMOVED***
					result = ***REMOVED***
						type: "disposed",
						moduleId: id
					***REMOVED***;
				***REMOVED***
				var abortError = false;
				var doApply = false;
				var doDispose = false;
				var chainInfo = "";
				if(result.chain) ***REMOVED***
					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
				***REMOVED***
				switch(result.type) ***REMOVED***
					case "self-declined":
						if(options.onDeclined)
							options.onDeclined(result);
						if(!options.ignoreDeclined)
							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
						break;
					case "declined":
						if(options.onDeclined)
							options.onDeclined(result);
						if(!options.ignoreDeclined)
							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
						break;
					case "unaccepted":
						if(options.onUnaccepted)
							options.onUnaccepted(result);
						if(!options.ignoreUnaccepted)
							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
						break;
					case "accepted":
						if(options.onAccepted)
							options.onAccepted(result);
						doApply = true;
						break;
					case "disposed":
						if(options.onDisposed)
							options.onDisposed(result);
						doDispose = true;
						break;
					default:
						throw new Error("Unexception type " + result.type);
				***REMOVED***
				if(abortError) ***REMOVED***
					hotSetStatus("abort");
					return Promise.reject(abortError);
				***REMOVED***
				if(doApply) ***REMOVED***
					appliedUpdate[moduleId] = hotUpdate[moduleId];
					addAllToSet(outdatedModules, result.outdatedModules);
					for(moduleId in result.outdatedDependencies) ***REMOVED***
						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) ***REMOVED***
							if(!outdatedDependencies[moduleId])
								outdatedDependencies[moduleId] = [];
							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
						***REMOVED***
					***REMOVED***
				***REMOVED***
				if(doDispose) ***REMOVED***
					addAllToSet(outdatedModules, [result.moduleId]);
					appliedUpdate[moduleId] = warnUnexpectedRequire;
				***REMOVED***
			***REMOVED***
		***REMOVED***

		// Store self accepted outdated modules to require them later by the module system
		var outdatedSelfAcceptedModules = [];
		for(i = 0; i < outdatedModules.length; i++) ***REMOVED***
			moduleId = outdatedModules[i];
			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
				outdatedSelfAcceptedModules.push(***REMOVED***
					module: moduleId,
					errorHandler: installedModules[moduleId].hot._selfAccepted
				***REMOVED***);
		***REMOVED***

		// Now in "dispose" phase
		hotSetStatus("dispose");
		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) ***REMOVED***
			if(hotAvailableFilesMap[chunkId] === false) ***REMOVED***
				hotDisposeChunk(chunkId);
			***REMOVED***
		***REMOVED***);

		var idx;
		var queue = outdatedModules.slice();
		while(queue.length > 0) ***REMOVED***
			moduleId = queue.pop();
			module = installedModules[moduleId];
			if(!module) continue;

			var data = ***REMOVED******REMOVED***;

			// Call dispose handlers
			var disposeHandlers = module.hot._disposeHandlers;
			for(j = 0; j < disposeHandlers.length; j++) ***REMOVED***
				cb = disposeHandlers[j];
				cb(data);
			***REMOVED***
			hotCurrentModuleData[moduleId] = data;

			// disable module (this disables requires from this module)
			module.hot.active = false;

			// remove module from cache
			delete installedModules[moduleId];

			// when disposing there is no need to call dispose handler
			delete outdatedDependencies[moduleId];

			// remove "parents" references from all children
			for(j = 0; j < module.children.length; j++) ***REMOVED***
				var child = installedModules[module.children[j]];
				if(!child) continue;
				idx = child.parents.indexOf(moduleId);
				if(idx >= 0) ***REMOVED***
					child.parents.splice(idx, 1);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		// remove outdated dependency from module children
		var dependency;
		var moduleOutdatedDependencies;
		for(moduleId in outdatedDependencies) ***REMOVED***
			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) ***REMOVED***
				module = installedModules[moduleId];
				if(module) ***REMOVED***
					moduleOutdatedDependencies = outdatedDependencies[moduleId];
					for(j = 0; j < moduleOutdatedDependencies.length; j++) ***REMOVED***
						dependency = moduleOutdatedDependencies[j];
						idx = module.children.indexOf(dependency);
						if(idx >= 0) module.children.splice(idx, 1);
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***

		// Not in "apply" phase
		hotSetStatus("apply");

		hotCurrentHash = hotUpdateNewHash;

		// insert new code
		for(moduleId in appliedUpdate) ***REMOVED***
			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) ***REMOVED***
				modules[moduleId] = appliedUpdate[moduleId];
			***REMOVED***
		***REMOVED***

		// call accept handlers
		var error = null;
		for(moduleId in outdatedDependencies) ***REMOVED***
			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) ***REMOVED***
				module = installedModules[moduleId];
				if(module) ***REMOVED***
					moduleOutdatedDependencies = outdatedDependencies[moduleId];
					var callbacks = [];
					for(i = 0; i < moduleOutdatedDependencies.length; i++) ***REMOVED***
						dependency = moduleOutdatedDependencies[i];
						cb = module.hot._acceptedDependencies[dependency];
						if(cb) ***REMOVED***
							if(callbacks.indexOf(cb) >= 0) continue;
							callbacks.push(cb);
						***REMOVED***
					***REMOVED***
					for(i = 0; i < callbacks.length; i++) ***REMOVED***
						cb = callbacks[i];
						try ***REMOVED***
							cb(moduleOutdatedDependencies);
						***REMOVED*** catch(err) ***REMOVED***
							if(options.onErrored) ***REMOVED***
								options.onErrored(***REMOVED***
									type: "accept-errored",
									moduleId: moduleId,
									dependencyId: moduleOutdatedDependencies[i],
									error: err
								***REMOVED***);
							***REMOVED***
							if(!options.ignoreErrored) ***REMOVED***
								if(!error)
									error = err;
							***REMOVED***
						***REMOVED***
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***

		// Load self accepted modules
		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) ***REMOVED***
			var item = outdatedSelfAcceptedModules[i];
			moduleId = item.module;
			hotCurrentParents = [moduleId];
			try ***REMOVED***
				$require$(moduleId);
			***REMOVED*** catch(err) ***REMOVED***
				if(typeof item.errorHandler === "function") ***REMOVED***
					try ***REMOVED***
						item.errorHandler(err);
					***REMOVED*** catch(err2) ***REMOVED***
						if(options.onErrored) ***REMOVED***
							options.onErrored(***REMOVED***
								type: "self-accept-error-handler-errored",
								moduleId: moduleId,
								error: err2,
								orginalError: err, // TODO remove in webpack 4
								originalError: err
							***REMOVED***);
						***REMOVED***
						if(!options.ignoreErrored) ***REMOVED***
							if(!error)
								error = err2;
						***REMOVED***
						if(!error)
							error = err;
					***REMOVED***
				***REMOVED*** else ***REMOVED***
					if(options.onErrored) ***REMOVED***
						options.onErrored(***REMOVED***
							type: "self-accept-errored",
							moduleId: moduleId,
							error: err
						***REMOVED***);
					***REMOVED***
					if(!options.ignoreErrored) ***REMOVED***
						if(!error)
							error = err;
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***

		// handle errors in accept handlers and self accepted module load
		if(error) ***REMOVED***
			hotSetStatus("fail");
			return Promise.reject(error);
		***REMOVED***

		hotSetStatus("idle");
		return new Promise(function(resolve) ***REMOVED***
			resolve(outdatedModules);
		***REMOVED***);
	***REMOVED***
***REMOVED***;
