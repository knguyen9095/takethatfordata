/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const HarmonyImportDependency = require("../dependencies/HarmonyImportDependency");
const ModuleHotAcceptDependency = require("../dependencies/ModuleHotAcceptDependency");
const ModuleHotDeclineDependency = require("../dependencies/ModuleHotDeclineDependency");
const ConcatenatedModule = require("./ConcatenatedModule");
const HarmonyExportImportedSpecifierDependency = require("../dependencies/HarmonyExportImportedSpecifierDependency");
const HarmonyCompatibilityDependency = require("../dependencies/HarmonyCompatibilityDependency");

function formatBailoutReason(msg) ***REMOVED***
	return "ModuleConcatenation bailout: " + msg;
***REMOVED***

class ModuleConcatenationPlugin ***REMOVED***
	constructor(options) ***REMOVED***
		if(typeof options !== "object") options = ***REMOVED******REMOVED***;
		this.options = options;
	***REMOVED***

	apply(compiler) ***REMOVED***
		compiler.plugin("compilation", (compilation, params) => ***REMOVED***
			params.normalModuleFactory.plugin("parser", (parser, parserOptions) => ***REMOVED***
				parser.plugin("call eval", () => ***REMOVED***
					parser.state.module.meta.hasEval = true;
				***REMOVED***);
			***REMOVED***);
			const bailoutReasonMap = new Map();

			function setBailoutReason(module, reason) ***REMOVED***
				bailoutReasonMap.set(module, reason);
				module.optimizationBailout.push(typeof reason === "function" ? (rs) => formatBailoutReason(reason(rs)) : formatBailoutReason(reason));
			***REMOVED***

			function getBailoutReason(module, requestShortener) ***REMOVED***
				const reason = bailoutReasonMap.get(module);
				if(typeof reason === "function") return reason(requestShortener);
				return reason;
			***REMOVED***

			compilation.plugin("optimize-chunk-modules", (chunks, modules) => ***REMOVED***
				const relevantModules = [];
				const possibleInners = new Set();
				for(const module of modules) ***REMOVED***
					// Only harmony modules are valid for optimization
					if(!module.meta || !module.meta.harmonyModule || !module.dependencies.some(d => d instanceof HarmonyCompatibilityDependency)) ***REMOVED***
						setBailoutReason(module, "Module is not an ECMAScript module");
						continue;
					***REMOVED***

					// Because of variable renaming we can't use modules with eval
					if(module.meta && module.meta.hasEval) ***REMOVED***
						setBailoutReason(module, "Module uses eval()");
						continue;
					***REMOVED***

					// Exports must be known (and not dynamic)
					if(!Array.isArray(module.providedExports)) ***REMOVED***
						setBailoutReason(module, "Module exports are unknown");
						continue;
					***REMOVED***

					// Using dependency variables is not possible as this wraps the code in a function
					if(module.variables.length > 0) ***REMOVED***
						setBailoutReason(module, `Module uses injected variables ($***REMOVED***module.variables.map(v => v.name).join(", ")***REMOVED***)`);
						continue;
					***REMOVED***

					// Hot Module Replacement need it's own module to work correctly
					if(module.dependencies.some(dep => dep instanceof ModuleHotAcceptDependency || dep instanceof ModuleHotDeclineDependency)) ***REMOVED***
						setBailoutReason(module, "Module uses Hot Module Replacement");
						continue;
					***REMOVED***

					relevantModules.push(module);

					// Module must not be the entry points
					if(module.getChunks().some(chunk => chunk.entryModule === module)) ***REMOVED***
						setBailoutReason(module, "Module is an entry point");
						continue;
					***REMOVED***

					// Module must only be used by Harmony Imports
					const nonHarmonyReasons = module.reasons.filter(reason => !(reason.dependency instanceof HarmonyImportDependency));
					if(nonHarmonyReasons.length > 0) ***REMOVED***
						const importingModules = new Set(nonHarmonyReasons.map(r => r.module));
						const importingModuleTypes = new Map(Array.from(importingModules).map(m => [m, new Set(nonHarmonyReasons.filter(r => r.module === m).map(r => r.dependency.type).sort())]));
						setBailoutReason(module, (requestShortener) => ***REMOVED***
							const names = Array.from(importingModules).map(m => `$***REMOVED***m.readableIdentifier(requestShortener)***REMOVED*** (referenced with $***REMOVED***Array.from(importingModuleTypes.get(m)).join(", ")***REMOVED***)`).sort();
							return `Module is referenced from these modules with unsupported syntax: $***REMOVED***names.join(", ")***REMOVED***`;
						***REMOVED***);
						continue;
					***REMOVED***

					possibleInners.add(module);
				***REMOVED***
				// sort by depth
				// modules with lower depth are more likely suited as roots
				// this improves performance, because modules already selected as inner are skipped
				relevantModules.sort((a, b) => ***REMOVED***
					return a.depth - b.depth;
				***REMOVED***);
				const concatConfigurations = [];
				const usedAsInner = new Set();
				for(const currentRoot of relevantModules) ***REMOVED***
					// when used by another configuration as inner:
					// the other configuration is better and we can skip this one
					if(usedAsInner.has(currentRoot))
						continue;

					// create a configuration with the root
					const currentConfiguration = new ConcatConfiguration(currentRoot);

					// cache failures to add modules
					const failureCache = new Map();

					// try to add all imports
					for(const imp of this.getImports(currentRoot)) ***REMOVED***
						const problem = this.tryToAdd(currentConfiguration, imp, possibleInners, failureCache);
						if(problem) ***REMOVED***
							failureCache.set(imp, problem);
							currentConfiguration.addWarning(imp, problem);
						***REMOVED***
					***REMOVED***
					if(!currentConfiguration.isEmpty()) ***REMOVED***
						concatConfigurations.push(currentConfiguration);
						for(const module of currentConfiguration.modules) ***REMOVED***
							if(module !== currentConfiguration.rootModule)
								usedAsInner.add(module);
						***REMOVED***
					***REMOVED***
				***REMOVED***
				// HACK: Sort configurations by length and start with the longest one
				// to get the biggers groups possible. Used modules are marked with usedModules
				// TODO: Allow to reuse existing configuration while trying to add dependencies.
				// This would improve performance. O(n^2) -> O(n)
				concatConfigurations.sort((a, b) => ***REMOVED***
					return b.modules.size - a.modules.size;
				***REMOVED***);
				const usedModules = new Set();
				for(const concatConfiguration of concatConfigurations) ***REMOVED***
					if(usedModules.has(concatConfiguration.rootModule))
						continue;
					const newModule = new ConcatenatedModule(concatConfiguration.rootModule, Array.from(concatConfiguration.modules));
					concatConfiguration.sortWarnings();
					for(const warning of concatConfiguration.warnings) ***REMOVED***
						newModule.optimizationBailout.push((requestShortener) => ***REMOVED***
							const reason = getBailoutReason(warning[0], requestShortener);
							const reasonWithPrefix = reason ? ` (<- $***REMOVED***reason***REMOVED***)` : "";
							if(warning[0] === warning[1])
								return formatBailoutReason(`Cannot concat with $***REMOVED***warning[0].readableIdentifier(requestShortener)***REMOVED***$***REMOVED***reasonWithPrefix***REMOVED***`);
							else
								return formatBailoutReason(`Cannot concat with $***REMOVED***warning[0].readableIdentifier(requestShortener)***REMOVED*** because of $***REMOVED***warning[1].readableIdentifier(requestShortener)***REMOVED***$***REMOVED***reasonWithPrefix***REMOVED***`);
						***REMOVED***);
					***REMOVED***
					const chunks = concatConfiguration.rootModule.getChunks();
					for(const m of concatConfiguration.modules) ***REMOVED***
						usedModules.add(m);
						chunks.forEach(chunk => chunk.removeModule(m));
					***REMOVED***
					chunks.forEach(chunk => ***REMOVED***
						chunk.addModule(newModule);
						newModule.addChunk(chunk);
						if(chunk.entryModule === concatConfiguration.rootModule)
							chunk.entryModule = newModule;
					***REMOVED***);
					compilation.modules.push(newModule);
					newModule.reasons.forEach(reason => reason.dependency.module = newModule);
					newModule.dependencies.forEach(dep => ***REMOVED***
						if(dep.module) ***REMOVED***
							dep.module.reasons.forEach(reason => ***REMOVED***
								if(reason.dependency === dep)
									reason.module = newModule;
							***REMOVED***);
						***REMOVED***
					***REMOVED***);
				***REMOVED***
				compilation.modules = compilation.modules.filter(m => !usedModules.has(m));
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	getImports(module) ***REMOVED***
		return Array.from(new Set(module.dependencies

			// Only harmony Dependencies
			.filter(dep => dep instanceof HarmonyImportDependency && dep.module)

			// Dependencies are simple enough to concat them
			.filter(dep => ***REMOVED***
				return !module.dependencies.some(d =>
					d instanceof HarmonyExportImportedSpecifierDependency &&
					d.importDependency === dep &&
					!d.id &&
					!Array.isArray(dep.module.providedExports)
				);
			***REMOVED***)

			// Take the imported module
			.map(dep => dep.module)
		));
	***REMOVED***

	tryToAdd(config, module, possibleModules, failureCache) ***REMOVED***
		const cacheEntry = failureCache.get(module);
		if(cacheEntry) ***REMOVED***
			return cacheEntry;
		***REMOVED***

		// Already added?
		if(config.has(module)) ***REMOVED***
			return null;
		***REMOVED***

		// Not possible to add?
		if(!possibleModules.has(module)) ***REMOVED***
			failureCache.set(module, module); // cache failures for performance
			return module;
		***REMOVED***

		// module must be in the same chunks
		if(!config.rootModule.hasEqualsChunks(module)) ***REMOVED***
			failureCache.set(module, module); // cache failures for performance
			return module;
		***REMOVED***

		// Clone config to make experimental changes
		const testConfig = config.clone();

		// Add the module
		testConfig.add(module);

		// Every module which depends on the added module must be in the configuration too.
		for(const reason of module.reasons) ***REMOVED***
			const problem = this.tryToAdd(testConfig, reason.module, possibleModules, failureCache);
			if(problem) ***REMOVED***
				failureCache.set(module, problem); // cache failures for performance
				return problem;
			***REMOVED***
		***REMOVED***

		// Eagerly try to add imports too if possible
		for(const imp of this.getImports(module)) ***REMOVED***
			const problem = this.tryToAdd(testConfig, imp, possibleModules, failureCache);
			if(problem) ***REMOVED***
				config.addWarning(module, problem);
			***REMOVED***
		***REMOVED***

		// Commit experimental changes
		config.set(testConfig);
		return null;
	***REMOVED***
***REMOVED***

class ConcatConfiguration ***REMOVED***
	constructor(rootModule) ***REMOVED***
		this.rootModule = rootModule;
		this.modules = new Set([rootModule]);
		this.warnings = new Map();
	***REMOVED***

	add(module) ***REMOVED***
		this.modules.add(module);
	***REMOVED***

	has(module) ***REMOVED***
		return this.modules.has(module);
	***REMOVED***

	isEmpty() ***REMOVED***
		return this.modules.size === 1;
	***REMOVED***

	addWarning(module, problem) ***REMOVED***
		this.warnings.set(module, problem);
	***REMOVED***

	sortWarnings() ***REMOVED***
		this.warnings = new Map(Array.from(this.warnings).sort((a, b) => ***REMOVED***
			const ai = a[0].identifier();
			const bi = b[0].identifier();
			if(ai < bi) return -1;
			if(ai > bi) return 1;
			return 0;
		***REMOVED***));
	***REMOVED***

	clone() ***REMOVED***
		const clone = new ConcatConfiguration(this.rootModule);
		for(const module of this.modules)
			clone.add(module);
		for(const pair of this.warnings)
			clone.addWarning(pair[0], pair[1]);
		return clone;
	***REMOVED***

	set(config) ***REMOVED***
		this.rootModule = config.rootModule;
		this.modules = new Set(config.modules);
		this.warnings = new Map(config.warnings);
	***REMOVED***
***REMOVED***

module.exports = ModuleConcatenationPlugin;
