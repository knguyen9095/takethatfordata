/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

class AggressiveMergingPlugin ***REMOVED***
	constructor(options) ***REMOVED***
		if(options !== undefined && typeof options !== "object" || Array.isArray(options)) ***REMOVED***
			throw new Error("Argument should be an options object. To use defaults, pass in nothing.\nFor more info on options, see https://webpack.js.org/plugins/");
		***REMOVED***
		this.options = options || ***REMOVED******REMOVED***;
	***REMOVED***

	apply(compiler) ***REMOVED***
		const options = this.options;
		const minSizeReduce = options.minSizeReduce || 1.5;

		function getParentsWeight(chunk) ***REMOVED***
			return chunk.parents.map((p) => ***REMOVED***
				return p.isInitial() ? options.entryChunkMultiplicator || 10 : 1;
			***REMOVED***).reduce((a, b) => ***REMOVED***
				return a + b;
			***REMOVED***, 0);
		***REMOVED***
		compiler.plugin("this-compilation", (compilation) => ***REMOVED***
			compilation.plugin("optimize-chunks-advanced", (chunks) => ***REMOVED***
				let combinations = [];
				chunks.forEach((a, idx) => ***REMOVED***
					if(a.isInitial()) return;
					for(let i = 0; i < idx; i++) ***REMOVED***
						const b = chunks[i];
						if(b.isInitial()) continue;
						combinations.push(***REMOVED***
							a,
							b,
							improvement: undefined
						***REMOVED***);
					***REMOVED***
				***REMOVED***);

				combinations.forEach((pair) => ***REMOVED***
					const a = pair.b.size(***REMOVED***
						chunkOverhead: 0
					***REMOVED***);
					const b = pair.a.size(***REMOVED***
						chunkOverhead: 0
					***REMOVED***);
					const ab = pair.b.integratedSize(pair.a, ***REMOVED***
						chunkOverhead: 0
					***REMOVED***);
					let newSize;
					if(ab === false) ***REMOVED***
						pair.improvement = false;
						return;
					***REMOVED*** else if(options.moveToParents) ***REMOVED***
						const aOnly = ab - b;
						const bOnly = ab - a;
						const common = a + b - ab;
						newSize = common + getParentsWeight(pair.b) * aOnly + getParentsWeight(pair.a) * bOnly;
					***REMOVED*** else ***REMOVED***
						newSize = ab;
					***REMOVED***

					pair.improvement = (a + b) / newSize;
				***REMOVED***);
				combinations = combinations.filter((pair) => ***REMOVED***
					return pair.improvement !== false;
				***REMOVED***);
				combinations.sort((a, b) => ***REMOVED***
					return b.improvement - a.improvement;
				***REMOVED***);

				const pair = combinations[0];

				if(!pair) return;
				if(pair.improvement < minSizeReduce) return;

				if(options.moveToParents) ***REMOVED***
					const commonModules = pair.b.modules.filter((m) => ***REMOVED***
						return pair.a.modules.indexOf(m) >= 0;
					***REMOVED***);
					const aOnlyModules = pair.b.modules.filter((m) => ***REMOVED***
						return commonModules.indexOf(m) < 0;
					***REMOVED***);
					const bOnlyModules = pair.a.modules.filter((m) => ***REMOVED***
						return commonModules.indexOf(m) < 0;
					***REMOVED***);
					aOnlyModules.forEach((m) => ***REMOVED***
						pair.b.removeModule(m);
						m.removeChunk(pair.b);
						pair.b.parents.forEach((c) => ***REMOVED***
							c.addModule(m);
							m.addChunk(c);
						***REMOVED***);
					***REMOVED***);
					bOnlyModules.forEach((m) => ***REMOVED***
						pair.a.removeModule(m);
						m.removeChunk(pair.a);
						pair.a.parents.forEach((c) => ***REMOVED***
							c.addModule(m);
							m.addChunk(c);
						***REMOVED***);
					***REMOVED***);
				***REMOVED***
				if(pair.b.integrate(pair.a, "aggressive-merge")) ***REMOVED***
					chunks.splice(chunks.indexOf(pair.a), 1);
					return true;
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = AggressiveMergingPlugin;
