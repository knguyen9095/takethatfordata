/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

class OccurrenceOrderPlugin ***REMOVED***
	constructor(preferEntry) ***REMOVED***
		if(preferEntry !== undefined && typeof preferEntry !== "boolean") ***REMOVED***
			throw new Error("Argument should be a boolean.\nFor more info on this plugin, see https://webpack.js.org/plugins/");
		***REMOVED***
		this.preferEntry = preferEntry;
	***REMOVED***
	apply(compiler) ***REMOVED***
		const preferEntry = this.preferEntry;
		compiler.plugin("compilation", (compilation) => ***REMOVED***
			compilation.plugin("optimize-module-order", (modules) => ***REMOVED***
				const occursInInitialChunksMap = new Map();
				const occursInAllChunksMap = new Map();

				const initialChunkChunkMap = new Map();
				const entryCountMap = new Map();
				modules.forEach(m => ***REMOVED***
					let initial = 0;
					let entry = 0;
					m.forEachChunk(c => ***REMOVED***
						if(c.isInitial()) initial++;
						if(c.entryModule === m) entry++;
					***REMOVED***);
					initialChunkChunkMap.set(m, initial);
					entryCountMap.set(m, entry);
				***REMOVED***);

				const countOccursInEntry = (sum, r) => ***REMOVED***
					if(!r.module) return sum;
					return sum + initialChunkChunkMap.get(r.module);
				***REMOVED***;
				const countOccurs = (sum, r) => ***REMOVED***
					if(!r.module) return sum;
					return sum + r.module.getNumberOfChunks();
				***REMOVED***;

				if(preferEntry) ***REMOVED***
					modules.forEach(m => ***REMOVED***
						const result = m.reasons.reduce(countOccursInEntry, 0) + initialChunkChunkMap.get(m) + entryCountMap.get(m);
						occursInInitialChunksMap.set(m, result);
					***REMOVED***);
				***REMOVED***

				modules.forEach(m => ***REMOVED***
					const result = m.reasons.reduce(countOccurs, 0) + m.getNumberOfChunks() + entryCountMap.get(m);
					occursInAllChunksMap.set(m, result);
				***REMOVED***);

				modules.sort((a, b) => ***REMOVED***
					if(preferEntry) ***REMOVED***
						const aEntryOccurs = occursInInitialChunksMap.get(a);
						const bEntryOccurs = occursInInitialChunksMap.get(b);
						if(aEntryOccurs > bEntryOccurs) return -1;
						if(aEntryOccurs < bEntryOccurs) return 1;
					***REMOVED***
					const aOccurs = occursInAllChunksMap.get(a);
					const bOccurs = occursInAllChunksMap.get(b);
					if(aOccurs > bOccurs) return -1;
					if(aOccurs < bOccurs) return 1;
					if(a.index > b.index) return 1;
					if(a.index < b.index) return -1;
					return 0;
				***REMOVED***);
			***REMOVED***);
			compilation.plugin("optimize-chunk-order", (chunks) => ***REMOVED***
				const occursInInitialChunksMap = new Map();

				chunks.forEach(c => ***REMOVED***
					const result = c.parents.reduce((sum, p) => ***REMOVED***
						if(p.isInitial()) return sum + 1;
						return sum;
					***REMOVED***, 0);
					return occursInInitialChunksMap.set(c, result);
				***REMOVED***);

				function occurs(c) ***REMOVED***
					return c.blocks.length;
				***REMOVED***

				chunks.sort((a, b) => ***REMOVED***
					const aEntryOccurs = occursInInitialChunksMap.get(a);
					const bEntryOccurs = occursInInitialChunksMap.get(b);
					if(aEntryOccurs > bEntryOccurs) return -1;
					if(aEntryOccurs < bEntryOccurs) return 1;
					const aOccurs = occurs(a);
					const bOccurs = occurs(b);
					if(aOccurs > bOccurs) return -1;
					if(aOccurs < bOccurs) return 1;
					return a.compareTo(b);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = OccurrenceOrderPlugin;
