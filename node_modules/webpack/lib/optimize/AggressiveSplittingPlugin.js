/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const identifierUtils = require("../util/identifier");

function moveModuleBetween(oldChunk, newChunk) ***REMOVED***
	return function(module) ***REMOVED***
		oldChunk.moveModule(module, newChunk);
	***REMOVED***;
***REMOVED***

function isNotAEntryModule(entryModule) ***REMOVED***
	return function(module) ***REMOVED***
		return entryModule !== module;
	***REMOVED***;
***REMOVED***

function copyWithReason(obj) ***REMOVED***
	const newObj = ***REMOVED******REMOVED***;
	Object.keys(obj).forEach((key) => ***REMOVED***
		newObj[key] = obj[key];
	***REMOVED***);
	if(!newObj.reasons || newObj.reasons.indexOf("aggressive-splitted") < 0)
		newObj.reasons = (newObj.reasons || []).concat("aggressive-splitted");
	return newObj;
***REMOVED***

class AggressiveSplittingPlugin ***REMOVED***
	constructor(options) ***REMOVED***
		this.options = options || ***REMOVED******REMOVED***;
		if(typeof this.options.minSize !== "number") this.options.minSize = 30 * 1024;
		if(typeof this.options.maxSize !== "number") this.options.maxSize = 50 * 1024;
		if(typeof this.options.chunkOverhead !== "number") this.options.chunkOverhead = 0;
		if(typeof this.options.entryChunkMultiplicator !== "number") this.options.entryChunkMultiplicator = 1;
	***REMOVED***
	apply(compiler) ***REMOVED***
		compiler.plugin("this-compilation", (compilation) => ***REMOVED***
			compilation.plugin("optimize-chunks-advanced", (chunks) => ***REMOVED***
				// Precompute stuff
				const nameToModuleMap = new Map();
				compilation.modules.forEach(m => ***REMOVED***
					const name = identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache);
					nameToModuleMap.set(name, m);
				***REMOVED***);

				const savedSplits = compilation.records && compilation.records.aggressiveSplits || [];
				const usedSplits = compilation._aggressiveSplittingSplits ?
					savedSplits.concat(compilation._aggressiveSplittingSplits) : savedSplits;

				const minSize = this.options.minSize;
				const maxSize = this.options.maxSize;
				// 1. try to restore to recorded splitting
				for(let j = 0; j < usedSplits.length; j++) ***REMOVED***
					const splitData = usedSplits[j];
					const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name));

					// Does the modules exist at all?
					if(selectedModules.every(Boolean)) ***REMOVED***

						// Find all chunks containing all modules in the split
						for(let i = 0; i < chunks.length; i++) ***REMOVED***
							const chunk = chunks[i];

							// Cheap check if chunk is suitable at all
							if(chunk.getNumberOfModules() < splitData.modules.length)
								continue;

							// Check if all modules are in the chunk
							if(selectedModules.every(m => chunk.containsModule(m))) ***REMOVED***

								// Is chunk identical to the split or do we need to split it?
								if(chunk.getNumberOfModules() > splitData.modules.length) ***REMOVED***
									// split the chunk into two parts
									const newChunk = compilation.addChunk();
									selectedModules.forEach(moveModuleBetween(chunk, newChunk));
									chunk.split(newChunk);
									chunk.name = null;
									newChunk._fromAggressiveSplitting = true;
									if(j < savedSplits.length)
										newChunk._fromAggressiveSplittingIndex = j;
									if(splitData.id !== null && splitData.id !== undefined) ***REMOVED***
										newChunk.id = splitData.id;
									***REMOVED***
									newChunk.origins = chunk.origins.map(copyWithReason);
									chunk.origins = chunk.origins.map(copyWithReason);
									return true;
								***REMOVED*** else ***REMOVED*** // chunk is identical to the split
									if(j < savedSplits.length)
										chunk._fromAggressiveSplittingIndex = j;
									chunk.name = null;
									if(splitData.id !== null && splitData.id !== undefined) ***REMOVED***
										chunk.id = splitData.id;
									***REMOVED***
								***REMOVED***
							***REMOVED***
						***REMOVED***
					***REMOVED***
				***REMOVED***

				// 2. for any other chunk which isn't splitted yet, split it
				for(let i = 0; i < chunks.length; i++) ***REMOVED***
					const chunk = chunks[i];
					const size = chunk.size(this.options);
					if(size > maxSize && chunk.getNumberOfModules() > 1) ***REMOVED***
						const newChunk = compilation.addChunk();
						const modules = chunk.getModules()
							.filter(isNotAEntryModule(chunk.entryModule))
							.sort((a, b) => ***REMOVED***
								a = a.identifier();
								b = b.identifier();
								if(a > b) return 1;
								if(a < b) return -1;
								return 0;
							***REMOVED***);
						for(let k = 0; k < modules.length; k++) ***REMOVED***
							chunk.moveModule(modules[k], newChunk);
							const newSize = newChunk.size(this.options);
							const chunkSize = chunk.size(this.options);
							// break early if it's fine
							if(chunkSize < maxSize && newSize < maxSize && newSize >= minSize && chunkSize >= minSize)
								break;
							if(newSize > maxSize && k === 0) ***REMOVED***
								// break if there is a single module which is bigger than maxSize
								break;
							***REMOVED***
							if(newSize > maxSize || chunkSize < minSize) ***REMOVED***
								// move it back
								newChunk.moveModule(modules[k], chunk);
								// check if it's fine now
								if(newSize < maxSize && newSize >= minSize && chunkSize >= minSize)
									break;
							***REMOVED***
						***REMOVED***
						if(newChunk.getNumberOfModules() > 0) ***REMOVED***
							chunk.split(newChunk);
							chunk.name = null;
							newChunk.origins = chunk.origins.map(copyWithReason);
							chunk.origins = chunk.origins.map(copyWithReason);
							compilation._aggressiveSplittingSplits = (compilation._aggressiveSplittingSplits || []).concat(***REMOVED***
								modules: newChunk.mapModules(m => identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache))
							***REMOVED***);
							return true;
						***REMOVED*** else ***REMOVED***
							chunks.splice(chunks.indexOf(newChunk), 1);
						***REMOVED***
					***REMOVED***
				***REMOVED***
			***REMOVED***);
			compilation.plugin("record-hash", (records) => ***REMOVED***
				// 3. save to made splittings to records
				const minSize = this.options.minSize;
				if(!records.aggressiveSplits) records.aggressiveSplits = [];
				compilation.chunks.forEach((chunk) => ***REMOVED***
					if(chunk.hasEntryModule()) return;
					const size = chunk.size(this.options);
					const incorrectSize = size < minSize;
					const modules = chunk.mapModules(m => identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache));
					if(typeof chunk._fromAggressiveSplittingIndex === "undefined") ***REMOVED***
						if(incorrectSize) return;
						chunk.recorded = true;
						records.aggressiveSplits.push(***REMOVED***
							modules: modules,
							hash: chunk.hash,
							id: chunk.id
						***REMOVED***);
					***REMOVED*** else ***REMOVED***
						const splitData = records.aggressiveSplits[chunk._fromAggressiveSplittingIndex];
						if(splitData.hash !== chunk.hash || incorrectSize) ***REMOVED***
							if(chunk._fromAggressiveSplitting) ***REMOVED***
								chunk._aggressiveSplittingInvalid = true;
								splitData.invalid = true;
							***REMOVED*** else ***REMOVED***
								splitData.hash = chunk.hash;
							***REMOVED***
						***REMOVED***
					***REMOVED***
				***REMOVED***);
				records.aggressiveSplits = records.aggressiveSplits.filter((splitData) => ***REMOVED***
					return !splitData.invalid;
				***REMOVED***);
			***REMOVED***);
			compilation.plugin("need-additional-seal", (callback) => ***REMOVED***
				const invalid = compilation.chunks.some((chunk) => ***REMOVED***
					return chunk._aggressiveSplittingInvalid;
				***REMOVED***);
				if(invalid)
					return true;
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***
module.exports = AggressiveSplittingPlugin;
