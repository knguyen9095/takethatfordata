/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const ConcatSource = require("webpack-sources").ConcatSource;
const OriginalSource = require("webpack-sources").OriginalSource;
const PrefixSource = require("webpack-sources").PrefixSource;
const Template = require("./Template");

// require function shortcuts:
// __webpack_require__.s = the module id of the entry point
// __webpack_require__.c = the module cache
// __webpack_require__.m = the module functions
// __webpack_require__.p = the bundle public path
// __webpack_require__.i = the identity function used for harmony imports
// __webpack_require__.e = the chunk ensure function
// __webpack_require__.d = the exported propery define getter function
// __webpack_require__.o = Object.prototype.hasOwnProperty.call
// __webpack_require__.n = compatibility get default export
// __webpack_require__.h = the webpack hash
// __webpack_require__.oe = the uncatched error handler for the webpack runtime
// __webpack_require__.nc = the script nonce

module.exports = class MainTemplate extends Template ***REMOVED***
	constructor(outputOptions) ***REMOVED***
		super(outputOptions);
		this.plugin("startup", (source, chunk, hash) => ***REMOVED***
			const buf = [];
			if(chunk.entryModule) ***REMOVED***
				buf.push("// Load entry module and return exports");
				buf.push(`return $***REMOVED***this.renderRequireFunctionForModule(hash, chunk, JSON.stringify(chunk.entryModule.id))***REMOVED***($***REMOVED***this.requireFn***REMOVED***.s = $***REMOVED***JSON.stringify(chunk.entryModule.id)***REMOVED***);`);
			***REMOVED***
			return this.asString(buf);
		***REMOVED***);
		this.plugin("render", (bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) => ***REMOVED***
			const source = new ConcatSource();
			source.add("/******/ (function(modules) ***REMOVED*** // webpackBootstrap\n");
			source.add(new PrefixSource("/******/", bootstrapSource));
			source.add("/******/ ***REMOVED***)\n");
			source.add("/************************************************************************/\n");
			source.add("/******/ (");
			const modules = this.renderChunkModules(chunk, moduleTemplate, dependencyTemplates, "/******/ ");
			source.add(this.applyPluginsWaterfall("modules", modules, chunk, hash, moduleTemplate, dependencyTemplates));
			source.add(")");
			return source;
		***REMOVED***);
		this.plugin("local-vars", (source, chunk, hash) => ***REMOVED***
			return this.asString([
				source,
				"// The module cache",
				"var installedModules = ***REMOVED******REMOVED***;"
			]);
		***REMOVED***);
		this.plugin("require", (source, chunk, hash) => ***REMOVED***
			return this.asString([
				source,
				"// Check if module is in cache",
				"if(installedModules[moduleId]) ***REMOVED***",
				this.indent("return installedModules[moduleId].exports;"),
				"***REMOVED***",
				"// Create a new module (and put it into the cache)",
				"var module = installedModules[moduleId] = ***REMOVED***",
				this.indent(this.applyPluginsWaterfall("module-obj", "", chunk, hash, "moduleId")),
				"***REMOVED***;",
				"",
				this.asString(outputOptions.strictModuleExceptionHandling ? [
					"// Execute the module function",
					"var threw = true;",
					"try ***REMOVED***",
					this.indent([
						`modules[moduleId].call(module.exports, module, module.exports, $***REMOVED***this.renderRequireFunctionForModule(hash, chunk, "moduleId")***REMOVED***);`,
						"threw = false;"
					]),
					"***REMOVED*** finally ***REMOVED***",
					this.indent([
						"if(threw) delete installedModules[moduleId];"
					]),
					"***REMOVED***"
				] : [
					"// Execute the module function",
					`modules[moduleId].call(module.exports, module, module.exports, $***REMOVED***this.renderRequireFunctionForModule(hash, chunk, "moduleId")***REMOVED***);`,
				]),
				"",
				"// Flag the module as loaded",
				"module.l = true;",
				"",
				"// Return the exports of the module",
				"return module.exports;"
			]);
		***REMOVED***);
		this.plugin("module-obj", (source, chunk, hash, varModuleId) => ***REMOVED***
			return this.asString([
				"i: moduleId,",
				"l: false,",
				"exports: ***REMOVED******REMOVED***"
			]);
		***REMOVED***);
		this.plugin("require-extensions", (source, chunk, hash) => ***REMOVED***
			const buf = [];
			if(chunk.chunks.length > 0) ***REMOVED***
				buf.push("// This file contains only the entry chunk.");
				buf.push("// The chunk loading function for additional chunks");
				buf.push(`$***REMOVED***this.requireFn***REMOVED***.e = function requireEnsure(chunkId) ***REMOVED***`);
				buf.push(this.indent(this.applyPluginsWaterfall("require-ensure", "throw new Error('Not chunk loading available');", chunk, hash, "chunkId")));
				buf.push("***REMOVED***;");
			***REMOVED***
			buf.push("");
			buf.push("// expose the modules object (__webpack_modules__)");
			buf.push(`$***REMOVED***this.requireFn***REMOVED***.m = modules;`);

			buf.push("");
			buf.push("// expose the module cache");
			buf.push(`$***REMOVED***this.requireFn***REMOVED***.c = installedModules;`);

			buf.push("");
			buf.push("// define getter function for harmony exports");
			buf.push(`$***REMOVED***this.requireFn***REMOVED***.d = function(exports, name, getter) ***REMOVED***`);
			buf.push(this.indent([
				`if(!$***REMOVED***this.requireFn***REMOVED***.o(exports, name)) ***REMOVED***`,
				this.indent([
					"Object.defineProperty(exports, name, ***REMOVED***",
					this.indent([
						"configurable: false,",
						"enumerable: true,",
						"get: getter"
					]),
					"***REMOVED***);"
				]),
				"***REMOVED***"
			]));
			buf.push("***REMOVED***;");

			buf.push("");
			buf.push("// getDefaultExport function for compatibility with non-harmony modules");
			buf.push(this.requireFn + ".n = function(module) ***REMOVED***");
			buf.push(this.indent([
				"var getter = module && module.__esModule ?",
				this.indent([
					"function getDefault() ***REMOVED*** return module['default']; ***REMOVED*** :",
					"function getModuleExports() ***REMOVED*** return module; ***REMOVED***;"
				]),
				`$***REMOVED***this.requireFn***REMOVED***.d(getter, 'a', getter);`,
				"return getter;"
			]));
			buf.push("***REMOVED***;");

			buf.push("");
			buf.push("// Object.prototype.hasOwnProperty.call");
			buf.push(`$***REMOVED***this.requireFn***REMOVED***.o = function(object, property) ***REMOVED*** return Object.prototype.hasOwnProperty.call(object, property); ***REMOVED***;`);

			const publicPath = this.getPublicPath(***REMOVED***
				hash: hash
			***REMOVED***);
			buf.push("");
			buf.push("// __webpack_public_path__");
			buf.push(`$***REMOVED***this.requireFn***REMOVED***.p = $***REMOVED***JSON.stringify(publicPath)***REMOVED***;`);
			return this.asString(buf);
		***REMOVED***);

		this.requireFn = "__webpack_require__";
	***REMOVED***

	render(hash, chunk, moduleTemplate, dependencyTemplates) ***REMOVED***
		const buf = [];
		buf.push(this.applyPluginsWaterfall("bootstrap", "", chunk, hash, moduleTemplate, dependencyTemplates));
		buf.push(this.applyPluginsWaterfall("local-vars", "", chunk, hash));
		buf.push("");
		buf.push("// The require function");
		buf.push(`function $***REMOVED***this.requireFn***REMOVED***(moduleId) ***REMOVED***`);
		buf.push(this.indent(this.applyPluginsWaterfall("require", "", chunk, hash)));
		buf.push("***REMOVED***");
		buf.push("");
		buf.push(this.asString(this.applyPluginsWaterfall("require-extensions", "", chunk, hash)));
		buf.push("");
		buf.push(this.asString(this.applyPluginsWaterfall("startup", "", chunk, hash)));
		let source = this.applyPluginsWaterfall("render", new OriginalSource(this.prefix(buf, " \t") + "\n", `webpack/bootstrap $***REMOVED***hash***REMOVED***`), chunk, hash, moduleTemplate, dependencyTemplates);
		if(chunk.hasEntryModule()) ***REMOVED***
			source = this.applyPluginsWaterfall("render-with-entry", source, chunk, hash);
		***REMOVED***
		if(!source) throw new Error("Compiler error: MainTemplate plugin 'render' should return something");
		chunk.rendered = true;
		return new ConcatSource(source, ";");
	***REMOVED***

	renderRequireFunctionForModule(hash, chunk, varModuleId) ***REMOVED***
		return this.applyPluginsWaterfall("module-require", this.requireFn, chunk, hash, varModuleId);
	***REMOVED***

	renderAddModule(hash, chunk, varModuleId, varModule) ***REMOVED***
		return this.applyPluginsWaterfall("add-module", `modules[$***REMOVED***varModuleId***REMOVED***] = $***REMOVED***varModule***REMOVED***;`, chunk, hash, varModuleId, varModule);
	***REMOVED***

	renderCurrentHashCode(hash, length) ***REMOVED***
		length = length || Infinity;
		return this.applyPluginsWaterfall("current-hash", JSON.stringify(hash.substr(0, length)), length);
	***REMOVED***

	entryPointInChildren(chunk) ***REMOVED***
		const checkChildren = (chunk, alreadyCheckedChunks) => ***REMOVED***
			return chunk.chunks.some((child) => ***REMOVED***
				if(alreadyCheckedChunks.indexOf(child) >= 0) return;
				alreadyCheckedChunks.push(child);
				return child.hasEntryModule() || checkChildren(child, alreadyCheckedChunks);
			***REMOVED***);
		***REMOVED***;
		return checkChildren(chunk, []);
	***REMOVED***

	getPublicPath(options) ***REMOVED***
		return this.applyPluginsWaterfall("asset-path", this.outputOptions.publicPath || "", options);
	***REMOVED***

	updateHash(hash) ***REMOVED***
		hash.update("maintemplate");
		hash.update("3");
		hash.update(this.outputOptions.publicPath + "");
		this.applyPlugins("hash", hash);
	***REMOVED***

	updateHashForChunk(hash, chunk) ***REMOVED***
		this.updateHash(hash);
		this.applyPlugins("hash-for-chunk", hash, chunk);
	***REMOVED***

	useChunkHash(chunk) ***REMOVED***
		const paths = this.applyPluginsWaterfall("global-hash-paths", []);
		return !this.applyPluginsBailResult("global-hash", chunk, paths);
	***REMOVED***
***REMOVED***;
