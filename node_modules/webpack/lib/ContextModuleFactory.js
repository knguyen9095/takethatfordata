/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const asyncLib = require("async");
const path = require("path");

const Tapable = require("tapable");
const ContextModule = require("./ContextModule");
const ContextElementDependency = require("./dependencies/ContextElementDependency");

module.exports = class ContextModuleFactory extends Tapable ***REMOVED***
	constructor(resolvers) ***REMOVED***
		super();
		this.resolvers = resolvers;
	***REMOVED***

	create(data, callback) ***REMOVED***
		const context = data.context;
		const dependencies = data.dependencies;
		const dependency = dependencies[0];
		this.applyPluginsAsyncWaterfall("before-resolve", ***REMOVED***
			context: context,
			request: dependency.request,
			recursive: dependency.recursive,
			regExp: dependency.regExp,
			async: dependency.async,
			dependencies: dependencies
		***REMOVED***, (err, result) => ***REMOVED***
			if(err) return callback(err);

			// Ignored
			if(!result) return callback();

			const context = result.context;
			const request = result.request;
			const recursive = result.recursive;
			const regExp = result.regExp;
			const asyncContext = result.async;
			const dependencies = result.dependencies;

			let loaders, resource, loadersPrefix = "";
			const idx = request.lastIndexOf("!");
			if(idx >= 0) ***REMOVED***
				loaders = request.substr(0, idx + 1);
				let i;
				for(i = 0; i < loaders.length && loaders[i] === "!"; i++) ***REMOVED***
					loadersPrefix += "!";
				***REMOVED***
				loaders = loaders.substr(i).replace(/!+$/, "").replace(/!!+/g, "!");
				if(loaders === "") loaders = [];
				else loaders = loaders.split("!");
				resource = request.substr(idx + 1);
			***REMOVED*** else ***REMOVED***
				loaders = [];
				resource = request;
			***REMOVED***

			const resolvers = this.resolvers;

			asyncLib.parallel([
				function(callback) ***REMOVED***
					resolvers.context.resolve(***REMOVED******REMOVED***, context, resource, function(err, result) ***REMOVED***
						if(err) return callback(err);
						callback(null, result);
					***REMOVED***);
				***REMOVED***,
				function(callback) ***REMOVED***
					asyncLib.map(loaders, function(loader, callback) ***REMOVED***
						resolvers.loader.resolve(***REMOVED******REMOVED***, context, loader, function(err, result) ***REMOVED***
							if(err) return callback(err);
							callback(null, result);
						***REMOVED***);
					***REMOVED***, callback);
				***REMOVED***
			], (err, result) => ***REMOVED***
				if(err) return callback(err);

				this.applyPluginsAsyncWaterfall("after-resolve", ***REMOVED***
					loaders: loadersPrefix + result[1].join("!") + (result[1].length > 0 ? "!" : ""),
					resource: result[0],
					recursive: recursive,
					regExp: regExp,
					async: asyncContext,
					dependencies: dependencies,
					resolveDependencies: this.resolveDependencies.bind(this)
				***REMOVED***, function(err, result) ***REMOVED***
					if(err) return callback(err);

					// Ignored
					if(!result) return callback();

					return callback(null, new ContextModule(result.resolveDependencies, result.resource, result.recursive, result.regExp, result.loaders, result.async, dependency.chunkName));
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	resolveDependencies(fs, resource, recursive, regExp, callback) ***REMOVED***
		const cmf = this;
		if(!regExp || !resource)
			return callback(null, []);
		(function addDirectory(directory, callback) ***REMOVED***
			fs.readdir(directory, (err, files) => ***REMOVED***
				if(err) return callback(err);
				files = cmf.applyPluginsWaterfall("context-module-files", files);
				if(!files || files.length === 0) return callback(null, []);
				asyncLib.map(files.filter(function(p) ***REMOVED***
					return p.indexOf(".") !== 0;
				***REMOVED***), (seqment, callback) => ***REMOVED***

					const subResource = path.join(directory, seqment);

					fs.stat(subResource, (err, stat) => ***REMOVED***
						if(err) ***REMOVED***
							if(err.code === "ENOENT") ***REMOVED***
								// ENOENT is ok here because the file may have been deleted between
								// the readdir and stat calls.
								return callback();
							***REMOVED*** else ***REMOVED***
								return callback(err);
							***REMOVED***
						***REMOVED***

						if(stat.isDirectory()) ***REMOVED***

							if(!recursive) return callback();
							addDirectory.call(this, subResource, callback);

						***REMOVED*** else if(stat.isFile()) ***REMOVED***

							const obj = ***REMOVED***
								context: resource,
								request: "." + subResource.substr(resource.length).replace(/\\/g, "/")
							***REMOVED***;

							this.applyPluginsAsyncWaterfall("alternatives", [obj], (err, alternatives) => ***REMOVED***
								if(err) return callback(err);
								alternatives = alternatives.filter(function(obj) ***REMOVED***
									return regExp.test(obj.request);
								***REMOVED***).map(function(obj) ***REMOVED***
									const dep = new ContextElementDependency(obj.request);
									dep.optional = true;
									return dep;
								***REMOVED***);
								callback(null, alternatives);
							***REMOVED***);

						***REMOVED*** else callback();

					***REMOVED***);

				***REMOVED***, (err, result) => ***REMOVED***
					if(err) return callback(err);

					if(!result) return callback(null, []);

					callback(null, result.filter(function(i) ***REMOVED***
						return !!i;
					***REMOVED***).reduce(function(a, i) ***REMOVED***
						return a.concat(i);
					***REMOVED***, []));
				***REMOVED***);
			***REMOVED***);
		***REMOVED***.call(this, resource, callback));
	***REMOVED***
***REMOVED***;
