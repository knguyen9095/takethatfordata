/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const Tapable = require("tapable");
const ConcatSource = require("webpack-sources").ConcatSource;

const START_LOWERCASE_ALPHABET_CODE = "a".charCodeAt(0);
const START_UPPERCASE_ALPHABET_CODE = "A".charCodeAt(0);
const DELTA_A_TO_Z = "z".charCodeAt(0) - START_LOWERCASE_ALPHABET_CODE + 1;
const FUNCTION_CONTENT_REGEX = /^function\s?\(\)\s?\***REMOVED***\n?|\n?\***REMOVED***$/g;
const INDENT_MULTILINE_REGEX = /^\t/mg;
const IDENTIFIER_NAME_REPLACE_REGEX = /^[^a-zA-Z$_]/;
const IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$_]/g;
const PATH_NAME_NORMALIZE_REPLACE_REGEX = /[^a-zA-Z0-9_!§$()=\-^°]+/g;
const MATCH_PADDED_HYPHENS_REPLACE_REGEX = /^-|-$/g;

module.exports = class Template extends Tapable ***REMOVED***
	constructor(outputOptions) ***REMOVED***
		super();
		this.outputOptions = outputOptions || ***REMOVED******REMOVED***;
	***REMOVED***

	static getFunctionContent(fn) ***REMOVED***
		return fn.toString().replace(FUNCTION_CONTENT_REGEX, "").replace(INDENT_MULTILINE_REGEX, "");
	***REMOVED***

	static toIdentifier(str) ***REMOVED***
		if(typeof str !== "string") return "";
		return str.replace(IDENTIFIER_NAME_REPLACE_REGEX, "_").replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, "_");
	***REMOVED***

	static toPath(str) ***REMOVED***
		if(typeof str !== "string") return "";
		return str.replace(PATH_NAME_NORMALIZE_REPLACE_REGEX, "-").replace(MATCH_PADDED_HYPHENS_REPLACE_REGEX, "");
	***REMOVED***

	// map number to a single character a-z, A-Z or <_ + number> if number is too big
	static numberToIdentifer(n) ***REMOVED***
		// lower case
		if(n < DELTA_A_TO_Z) return String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n);

		// upper case
		n -= DELTA_A_TO_Z;
		if(n < DELTA_A_TO_Z) return String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n);

		// fall back to _ + number
		n -= DELTA_A_TO_Z;
		return "_" + n;
	***REMOVED***

	indent(str) ***REMOVED***
		if(Array.isArray(str)) ***REMOVED***
			return str.map(this.indent.bind(this)).join("\n");
		***REMOVED*** else ***REMOVED***
			str = str.trimRight();
			if(!str) return "";
			var ind = (str[0] === "\n" ? "" : "\t");
			return ind + str.replace(/\n([^\n])/g, "\n\t$1");
		***REMOVED***
	***REMOVED***

	prefix(str, prefix) ***REMOVED***
		if(Array.isArray(str)) ***REMOVED***
			str = str.join("\n");
		***REMOVED***
		str = str.trim();
		if(!str) return "";
		const ind = (str[0] === "\n" ? "" : prefix);
		return ind + str.replace(/\n([^\n])/g, "\n" + prefix + "$1");
	***REMOVED***

	asString(str) ***REMOVED***
		if(Array.isArray(str)) ***REMOVED***
			return str.join("\n");
		***REMOVED***
		return str;
	***REMOVED***

	getModulesArrayBounds(modules) ***REMOVED***
		if(!modules.every(moduleIdIsNumber))
			return false;
		var maxId = -Infinity;
		var minId = Infinity;
		modules.forEach(function(module) ***REMOVED***
			if(maxId < module.id) maxId = module.id;
			if(minId > module.id) minId = module.id;
		***REMOVED***);
		if(minId < 16 + ("" + minId).length) ***REMOVED***
			// add minId x ',' instead of 'Array(minId).concat(...)'
			minId = 0;
		***REMOVED***
		var objectOverhead = modules.map(function(module) ***REMOVED***
			var idLength = (module.id + "").length;
			return idLength + 2;
		***REMOVED***).reduce(function(a, b) ***REMOVED***
			return a + b;
		***REMOVED***, -1);
		var arrayOverhead = minId === 0 ? maxId : 16 + ("" + minId).length + maxId;
		return arrayOverhead < objectOverhead ? [minId, maxId] : false;
	***REMOVED***

	renderChunkModules(chunk, moduleTemplate, dependencyTemplates, prefix) ***REMOVED***
		if(!prefix) prefix = "";
		var source = new ConcatSource();
		if(chunk.getNumberOfModules() === 0) ***REMOVED***
			source.add("[]");
			return source;
		***REMOVED***
		var removedModules = chunk.removedModules;
		var allModules = chunk.mapModules(function(module) ***REMOVED***
			return ***REMOVED***
				id: module.id,
				source: moduleTemplate.render(module, dependencyTemplates, chunk)
			***REMOVED***;
		***REMOVED***);
		if(removedModules && removedModules.length > 0) ***REMOVED***
			removedModules.forEach(function(id) ***REMOVED***
				allModules.push(***REMOVED***
					id: id,
					source: "false"
				***REMOVED***);
			***REMOVED***);
		***REMOVED***
		var bounds = this.getModulesArrayBounds(allModules);

		if(bounds) ***REMOVED***
			// Render a spare array
			var minId = bounds[0];
			var maxId = bounds[1];
			if(minId !== 0) source.add("Array(" + minId + ").concat(");
			source.add("[\n");
			var modules = ***REMOVED******REMOVED***;
			allModules.forEach(function(module) ***REMOVED***
				modules[module.id] = module;
			***REMOVED***);
			for(var idx = minId; idx <= maxId; idx++) ***REMOVED***
				var module = modules[idx];
				if(idx !== minId) source.add(",\n");
				source.add("/* " + idx + " */");
				if(module) ***REMOVED***
					source.add("\n");
					source.add(module.source);
				***REMOVED***
			***REMOVED***
			source.add("\n" + prefix + "]");
			if(minId !== 0) source.add(")");
		***REMOVED*** else ***REMOVED***
			// Render an object
			source.add("***REMOVED***\n");
			allModules
				.sort(stringifyIdSortPredicate)
				.forEach(function(module, idx) ***REMOVED***
					if(idx !== 0) source.add(",\n");
					source.add(`\n/***/ $***REMOVED***JSON.stringify(module.id)***REMOVED***:\n`);
					source.add(module.source);
				***REMOVED***);
			source.add("\n\n" + prefix + "***REMOVED***");
		***REMOVED***
		return source;
	***REMOVED***
***REMOVED***;

function stringifyIdSortPredicate(a, b) ***REMOVED***
	var aId = a.id + "";
	var bId = b.id + "";
	if(aId < bId) return -1;
	if(aId > bId) return 1;
	return 0;
***REMOVED***

function moduleIdIsNumber(module) ***REMOVED***
	return typeof module.id === "number";
***REMOVED***
