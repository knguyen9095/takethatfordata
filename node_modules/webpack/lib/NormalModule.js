/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const path = require("path");
const NativeModule = require("module");
const crypto = require("crypto");

const SourceMapSource = require("webpack-sources").SourceMapSource;
const OriginalSource = require("webpack-sources").OriginalSource;
const RawSource = require("webpack-sources").RawSource;
const ReplaceSource = require("webpack-sources").ReplaceSource;
const CachedSource = require("webpack-sources").CachedSource;
const LineToLineMappedSource = require("webpack-sources").LineToLineMappedSource;

const WebpackError = require("./WebpackError");
const Module = require("./Module");
const ModuleParseError = require("./ModuleParseError");
const ModuleBuildError = require("./ModuleBuildError");
const ModuleError = require("./ModuleError");
const ModuleWarning = require("./ModuleWarning");

const runLoaders = require("loader-runner").runLoaders;
const getContext = require("loader-runner").getContext;

function asString(buf) ***REMOVED***
	if(Buffer.isBuffer(buf)) ***REMOVED***
		return buf.toString("utf-8");
	***REMOVED***
	return buf;
***REMOVED***

function contextify(context, request) ***REMOVED***
	return request.split("!").map(function(r) ***REMOVED***
		const splitPath = r.split("?");
		splitPath[0] = path.relative(context, splitPath[0]);
		if(path.sep === "\\")
			splitPath[0] = splitPath[0].replace(/\\/g, "/");
		if(splitPath[0].indexOf("../") !== 0)
			splitPath[0] = "./" + splitPath[0];
		return splitPath.join("?");
	***REMOVED***).join("!");
***REMOVED***

class NonErrorEmittedError extends WebpackError ***REMOVED***
	constructor(error) ***REMOVED***
		super();

		this.name = "NonErrorEmittedError";
		this.message = "(Emitted value instead of an instance of Error) " + error;

		Error.captureStackTrace(this, this.constructor);
	***REMOVED***
***REMOVED***

const dependencyTemplatesHashMap = new WeakMap();

class NormalModule extends Module ***REMOVED***

	constructor(request, userRequest, rawRequest, loaders, resource, parser) ***REMOVED***
		super();
		this.request = request;
		this.userRequest = userRequest;
		this.rawRequest = rawRequest;
		this.parser = parser;
		this.resource = resource;
		this.context = getContext(resource);
		this.loaders = loaders;
		this.fileDependencies = [];
		this.contextDependencies = [];
		this.warnings = [];
		this.errors = [];
		this.error = null;
		this._source = null;
		this.assets = ***REMOVED******REMOVED***;
		this.built = false;
		this._cachedSource = null;
	***REMOVED***

	identifier() ***REMOVED***
		return this.request;
	***REMOVED***

	readableIdentifier(requestShortener) ***REMOVED***
		return requestShortener.shorten(this.userRequest);
	***REMOVED***

	libIdent(options) ***REMOVED***
		return contextify(options.context, this.userRequest);
	***REMOVED***

	nameForCondition() ***REMOVED***
		const idx = this.resource.indexOf("?");
		if(idx >= 0) return this.resource.substr(0, idx);
		return this.resource;
	***REMOVED***

	createSourceForAsset(name, content, sourceMap) ***REMOVED***
		if(!sourceMap) ***REMOVED***
			return new RawSource(content);
		***REMOVED***

		if(typeof sourceMap === "string") ***REMOVED***
			return new OriginalSource(content, sourceMap);
		***REMOVED***

		return new SourceMapSource(content, name, sourceMap);
	***REMOVED***

	createLoaderContext(resolver, options, compilation, fs) ***REMOVED***
		const loaderContext = ***REMOVED***
			version: 2,
			emitWarning: (warning) => ***REMOVED***
				if(!(warning instanceof Error))
					warning = new NonErrorEmittedError(warning);
				this.warnings.push(new ModuleWarning(this, warning));
			***REMOVED***,
			emitError: (error) => ***REMOVED***
				if(!(error instanceof Error))
					error = new NonErrorEmittedError(error);
				this.errors.push(new ModuleError(this, error));
			***REMOVED***,
			exec: (code, filename) => ***REMOVED***
				const module = new NativeModule(filename, this);
				module.paths = NativeModule._nodeModulePaths(this.context);
				module.filename = filename;
				module._compile(code, filename);
				return module.exports;
			***REMOVED***,
			resolve(context, request, callback) ***REMOVED***
				resolver.resolve(***REMOVED******REMOVED***, context, request, callback);
			***REMOVED***,
			resolveSync(context, request) ***REMOVED***
				return resolver.resolveSync(***REMOVED******REMOVED***, context, request);
			***REMOVED***,
			emitFile: (name, content, sourceMap) => ***REMOVED***
				this.assets[name] = this.createSourceForAsset(name, content, sourceMap);
			***REMOVED***,
			options: options,
			webpack: true,
			sourceMap: !!this.useSourceMap,
			_module: this,
			_compilation: compilation,
			_compiler: compilation.compiler,
			fs: fs,
		***REMOVED***;

		compilation.applyPlugins("normal-module-loader", loaderContext, this);
		if(options.loader)
			Object.assign(loaderContext, options.loader);

		return loaderContext;
	***REMOVED***

	createSource(source, resourceBuffer, sourceMap) ***REMOVED***
		// if there is no identifier return raw source
		if(!this.identifier) ***REMOVED***
			return new RawSource(source);
		***REMOVED***

		// from here on we assume we have an identifier
		const identifier = this.identifier();

		if(this.lineToLine && resourceBuffer) ***REMOVED***
			return new LineToLineMappedSource(
				source, identifier, asString(resourceBuffer));
		***REMOVED***

		if(this.useSourceMap && sourceMap) ***REMOVED***
			return new SourceMapSource(source, identifier, sourceMap);
		***REMOVED***

		return new OriginalSource(source, identifier);
	***REMOVED***

	doBuild(options, compilation, resolver, fs, callback) ***REMOVED***
		this.cacheable = false;
		const loaderContext = this.createLoaderContext(resolver, options, compilation, fs);

		runLoaders(***REMOVED***
			resource: this.resource,
			loaders: this.loaders,
			context: loaderContext,
			readResource: fs.readFile.bind(fs)
		***REMOVED***, (err, result) => ***REMOVED***
			if(result) ***REMOVED***
				this.cacheable = result.cacheable;
				this.fileDependencies = result.fileDependencies;
				this.contextDependencies = result.contextDependencies;
			***REMOVED***

			if(err) ***REMOVED***
				const error = new ModuleBuildError(this, err);
				return callback(error);
			***REMOVED***

			const resourceBuffer = result.resourceBuffer;
			const source = result.result[0];
			const sourceMap = result.result[1];

			if(!Buffer.isBuffer(source) && typeof source !== "string") ***REMOVED***
				const error = new ModuleBuildError(this, new Error("Final loader didn't return a Buffer or String"));
				return callback(error);
			***REMOVED***

			this._source = this.createSource(asString(source), resourceBuffer, sourceMap);
			return callback();
		***REMOVED***);
	***REMOVED***

	disconnect() ***REMOVED***
		this.built = false;
		super.disconnect();
	***REMOVED***

	markModuleAsErrored(error) ***REMOVED***
		this.meta = null;
		this.error = error;
		this.errors.push(this.error);
		this._source = new RawSource("throw new Error(" + JSON.stringify(this.error.message) + ");");
	***REMOVED***

	applyNoParseRule(rule, content) ***REMOVED***
		// must start with "rule" if rule is a string
		if(typeof rule === "string") ***REMOVED***
			return content.indexOf(rule) === 0;
		***REMOVED***

		if(typeof rule === "function") ***REMOVED***
			return rule(content);
		***REMOVED***
		// we assume rule is a regexp
		return rule.test(content);
	***REMOVED***

	// check if module should not be parsed
	// returns "true" if the module should !not! be parsed
	// returns "false" if the module !must! be parsed
	shouldPreventParsing(noParseRule, request) ***REMOVED***
		// if no noParseRule exists, return false
		// the module !must! be parsed.
		if(!noParseRule) ***REMOVED***
			return false;
		***REMOVED***

		// we only have one rule to check
		if(!Array.isArray(noParseRule)) ***REMOVED***
			// returns "true" if the module is !not! to be parsed
			return this.applyNoParseRule(noParseRule, request);
		***REMOVED***

		for(let i = 0; i < noParseRule.length; i++) ***REMOVED***
			const rule = noParseRule[i];
			// early exit on first truthy match
			// this module is !not! to be parsed
			if(this.applyNoParseRule(rule, request)) ***REMOVED***
				return true;
			***REMOVED***
		***REMOVED***
		// no match found, so this module !should! be parsed
		return false;
	***REMOVED***

	build(options, compilation, resolver, fs, callback) ***REMOVED***
		this.buildTimestamp = Date.now();
		this.built = true;
		this._source = null;
		this.error = null;
		this.errors.length = 0;
		this.warnings.length = 0;
		this.meta = ***REMOVED******REMOVED***;

		return this.doBuild(options, compilation, resolver, fs, (err) => ***REMOVED***
			this.dependencies.length = 0;
			this.variables.length = 0;
			this.blocks.length = 0;
			this._cachedSource = null;

			// if we have an error mark module as failed and exit
			if(err) ***REMOVED***
				this.markModuleAsErrored(err);
				return callback();
			***REMOVED***

			// check if this module should !not! be parsed.
			// if so, exit here;
			const noParseRule = options.module && options.module.noParse;
			if(this.shouldPreventParsing(noParseRule, this.request)) ***REMOVED***
				return callback();
			***REMOVED***

			try ***REMOVED***
				this.parser.parse(this._source.source(), ***REMOVED***
					current: this,
					module: this,
					compilation: compilation,
					options: options
				***REMOVED***);
			***REMOVED*** catch(e) ***REMOVED***
				const source = this._source.source();
				const error = new ModuleParseError(this, source, e);
				this.markModuleAsErrored(error);
				return callback();
			***REMOVED***
			return callback();
		***REMOVED***);
	***REMOVED***

	getHashDigest(dependencyTemplates) ***REMOVED***
		let dtHash = dependencyTemplatesHashMap.get("hash");
		const hash = crypto.createHash("md5");
		this.updateHash(hash);
		hash.update(`$***REMOVED***dtHash***REMOVED***`);
		return hash.digest("hex");
	***REMOVED***

	sourceDependency(dependency, dependencyTemplates, source, outputOptions, requestShortener) ***REMOVED***
		const template = dependencyTemplates.get(dependency.constructor);
		if(!template) throw new Error("No template for dependency: " + dependency.constructor.name);
		template.apply(dependency, source, outputOptions, requestShortener, dependencyTemplates);
	***REMOVED***

	sourceVariables(variable, availableVars, dependencyTemplates, outputOptions, requestShortener) ***REMOVED***
		const name = variable.name;
		const expr = variable.expressionSource(dependencyTemplates, outputOptions, requestShortener);

		if(availableVars.some(v => v.name === name && v.expression.source() === expr.source())) ***REMOVED***
			return;
		***REMOVED***
		return ***REMOVED***
			name: name,
			expression: expr
		***REMOVED***;
	***REMOVED***

	/*
	 * creates the start part of a IIFE around the module to inject a variable name
	 * (function(...)***REMOVED***   <- this part
	 * ***REMOVED***.call(...))
	 */
	variableInjectionFunctionWrapperStartCode(varNames) ***REMOVED***
		const args = varNames.join(", ");
		return `/* WEBPACK VAR INJECTION */(function($***REMOVED***args***REMOVED***) ***REMOVED***`;
	***REMOVED***

	contextArgument(block) ***REMOVED***
		if(this === block) ***REMOVED***
			return this.exportsArgument || "exports";
		***REMOVED***
		return "this";
	***REMOVED***

	/*
	 * creates the end part of a IIFE around the module to inject a variable name
	 * (function(...)***REMOVED***
	 * ***REMOVED***.call(...))   <- this part
	 */
	variableInjectionFunctionWrapperEndCode(varExpressions, block) ***REMOVED***
		const firstParam = this.contextArgument(block);
		const furtherParams = varExpressions.map(e => e.source()).join(", ");
		return `***REMOVED***.call($***REMOVED***firstParam***REMOVED***, $***REMOVED***furtherParams***REMOVED***))`;
	***REMOVED***

	splitVariablesInUniqueNamedChunks(vars) ***REMOVED***
		const startState = [
			[]
		];
		return vars.reduce((chunks, variable) => ***REMOVED***
			const current = chunks[chunks.length - 1];
			// check if variable with same name exists already
			// if so create a new chunk of variables.
			const variableNameAlreadyExists = current.some(v => v.name === variable.name);

			if(variableNameAlreadyExists) ***REMOVED***
				// start new chunk with current variable
				chunks.push([variable]);
			***REMOVED*** else ***REMOVED***
				// else add it to current chunk
				current.push(variable);
			***REMOVED***
			return chunks;
		***REMOVED***, startState);
	***REMOVED***

	sourceBlock(block, availableVars, dependencyTemplates, source, outputOptions, requestShortener) ***REMOVED***
		block.dependencies.forEach((dependency) => this.sourceDependency(
			dependency, dependencyTemplates, source, outputOptions, requestShortener));

		/**
		 * Get the variables of all blocks that we need to inject.
		 * These will contain the variable name and its expression.
		 * The name will be added as a paramter in a IIFE the expression as its value.
		 */
		const vars = block.variables.reduce((result, value) => ***REMOVED***
			const variable = this.sourceVariables(
				value, availableVars, dependencyTemplates, outputOptions, requestShortener);

			if(variable) ***REMOVED***
				result.push(variable);
			***REMOVED***

			return result;
		***REMOVED***, []);

		/**
		 * if we actually have variables
		 * this is important as how #splitVariablesInUniqueNamedChunks works
		 * it will always return an array in an array which would lead to a IIFE wrapper around
		 * a module if we do this with an empty vars array.
		 */
		if(vars.length > 0) ***REMOVED***
			/**
			 * Split all variables up into chunks of unique names.
			 * e.g. imagine you have the following variable names that need to be injected:
			 * [foo, bar, baz, foo, some, more]
			 * we can not inject "foo" twice, therefore we just make two IIFEs like so:
			 * (function(foo, bar, baz)***REMOVED***
			 *   (function(foo, some, more)***REMOVED***
			 *     ...
			 *   ***REMOVED***(...));
			 * ***REMOVED***(...));
			 *
			 * "splitVariablesInUniqueNamedChunks" splits the variables shown above up to this:
			 * [[foo, bar, baz], [foo, some, more]]
			 */
			const injectionVariableChunks = this.splitVariablesInUniqueNamedChunks(vars);

			// create all the beginnings of IIFEs
			const functionWrapperStarts = injectionVariableChunks.map((variableChunk) => ***REMOVED***
				return this.variableInjectionFunctionWrapperStartCode(
					variableChunk.map(variable => variable.name)
				);
			***REMOVED***);

			// and all the ends
			const functionWrapperEnds = injectionVariableChunks.map((variableChunk) => ***REMOVED***
				return this.variableInjectionFunctionWrapperEndCode(
					variableChunk.map(variable => variable.expression), block
				);
			***REMOVED***);

			// join them to one big string
			const varStartCode = functionWrapperStarts.join("");

			// reverse the ends first before joining them, as the last added must be the inner most
			const varEndCode = functionWrapperEnds.reverse().join("");

			// if we have anything, add it to the source
			if(varStartCode && varEndCode) ***REMOVED***
				const start = block.range ? block.range[0] : -10;
				const end = block.range ? block.range[1] : (this._source.size() + 1);
				source.insert(start + 0.5, varStartCode);
				source.insert(end + 0.5, "\n/* WEBPACK VAR INJECTION */" + varEndCode);
			***REMOVED***
		***REMOVED***

		block.blocks.forEach((block) =>
			this.sourceBlock(
				block,
				availableVars.concat(vars),
				dependencyTemplates,
				source,
				outputOptions,
				requestShortener
			)
		);
	***REMOVED***

	source(dependencyTemplates, outputOptions, requestShortener) ***REMOVED***
		const hashDigest = this.getHashDigest(dependencyTemplates);
		if(this._cachedSource && this._cachedSource.hash === hashDigest) ***REMOVED***
			return this._cachedSource.source;
		***REMOVED***

		if(!this._source) ***REMOVED***
			return new RawSource("throw new Error('No source available');");
		***REMOVED***

		const source = new ReplaceSource(this._source);
		this._cachedSource = ***REMOVED***
			source: source,
			hash: hashDigest
		***REMOVED***;

		this.sourceBlock(this, [], dependencyTemplates, source, outputOptions, requestShortener);
		return new CachedSource(source);
	***REMOVED***

	originalSource() ***REMOVED***
		return this._source;
	***REMOVED***

	getHighestTimestamp(keys, timestampsByKey) ***REMOVED***
		let highestTimestamp = 0;
		for(let i = 0; i < keys.length; i++) ***REMOVED***
			const key = keys[i];
			const timestamp = timestampsByKey[key];
			// if there is no timestamp yet, early return with Infinity
			if(!timestamp) return Infinity;
			highestTimestamp = Math.max(highestTimestamp, timestamp);
		***REMOVED***
		return highestTimestamp;
	***REMOVED***

	needRebuild(fileTimestamps, contextTimestamps) ***REMOVED***
		const highestFileDepTimestamp = this.getHighestTimestamp(
			this.fileDependencies, fileTimestamps);
		// if the hightest is Infinity, we need a rebuild
		// exit early here.
		if(highestFileDepTimestamp === Infinity) ***REMOVED***
			return true;
		***REMOVED***

		const highestContextDepTimestamp = this.getHighestTimestamp(
			this.contextDependencies, contextTimestamps);

		// Again if the hightest is Infinity, we need a rebuild
		// exit early here.
		if(highestContextDepTimestamp === Infinity) ***REMOVED***
			return true;
		***REMOVED***

		// else take the highest of file and context timestamps and compare
		// to last build timestamp
		return Math.max(highestContextDepTimestamp, highestFileDepTimestamp) >= this.buildTimestamp;
	***REMOVED***

	size() ***REMOVED***
		return this._source ? this._source.size() : -1;
	***REMOVED***

	updateHashWithSource(hash) ***REMOVED***
		if(!this._source) ***REMOVED***
			hash.update("null");
			return;
		***REMOVED***
		hash.update("source");
		this._source.updateHash(hash);
	***REMOVED***

	updateHashWithMeta(hash) ***REMOVED***
		hash.update("meta");
		hash.update(JSON.stringify(this.meta));
	***REMOVED***

	updateHash(hash) ***REMOVED***
		this.updateHashWithSource(hash);
		this.updateHashWithMeta(hash);
		super.updateHash(hash);
	***REMOVED***

***REMOVED***

module.exports = NormalModule;
