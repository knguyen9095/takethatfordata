'use strict';
const childProcess = require('child_process');
const util = require('util');
const crossSpawn = require('cross-spawn');
const stripEof = require('strip-eof');
const npmRunPath = require('npm-run-path');
const isStream = require('is-stream');
const _getStream = require('get-stream');
const pFinally = require('p-finally');
const onExit = require('signal-exit');
const errname = require('./lib/errname');
const stdio = require('./lib/stdio');

const TEN_MEGABYTES = 1000 * 1000 * 10;

function handleArgs(cmd, args, opts) ***REMOVED***
	let parsed;

	if (opts && opts.env && opts.extendEnv !== false) ***REMOVED***
		opts.env = Object.assign(***REMOVED******REMOVED***, process.env, opts.env);
	***REMOVED***

	if (opts && opts.__winShell === true) ***REMOVED***
		delete opts.__winShell;
		parsed = ***REMOVED***
			command: cmd,
			args,
			options: opts,
			file: cmd,
			original: cmd
		***REMOVED***;
	***REMOVED*** else ***REMOVED***
		parsed = crossSpawn._parse(cmd, args, opts);
	***REMOVED***

	opts = Object.assign(***REMOVED***
		maxBuffer: TEN_MEGABYTES,
		stripEof: true,
		preferLocal: true,
		localDir: parsed.options.cwd || process.cwd(),
		encoding: 'utf8',
		reject: true,
		cleanup: true
	***REMOVED***, parsed.options);

	opts.stdio = stdio(opts);

	if (opts.preferLocal) ***REMOVED***
		opts.env = npmRunPath.env(Object.assign(***REMOVED******REMOVED***, opts, ***REMOVED***cwd: opts.localDir***REMOVED***));
	***REMOVED***

	return ***REMOVED***
		cmd: parsed.command,
		args: parsed.args,
		opts,
		parsed
	***REMOVED***;
***REMOVED***

function handleInput(spawned, opts) ***REMOVED***
	const input = opts.input;

	if (input === null || input === undefined) ***REMOVED***
		return;
	***REMOVED***

	if (isStream(input)) ***REMOVED***
		input.pipe(spawned.stdin);
	***REMOVED*** else ***REMOVED***
		spawned.stdin.end(input);
	***REMOVED***
***REMOVED***

function handleOutput(opts, val) ***REMOVED***
	if (val && opts.stripEof) ***REMOVED***
		val = stripEof(val);
	***REMOVED***

	return val;
***REMOVED***

function handleShell(fn, cmd, opts) ***REMOVED***
	let file = '/bin/sh';
	let args = ['-c', cmd];

	opts = Object.assign(***REMOVED******REMOVED***, opts);

	if (process.platform === 'win32') ***REMOVED***
		opts.__winShell = true;
		file = process.env.comspec || 'cmd.exe';
		args = ['/s', '/c', `"$***REMOVED***cmd***REMOVED***"`];
		opts.windowsVerbatimArguments = true;
	***REMOVED***

	if (opts.shell) ***REMOVED***
		file = opts.shell;
		delete opts.shell;
	***REMOVED***

	return fn(file, args, opts);
***REMOVED***

function getStream(process, stream, encoding, maxBuffer) ***REMOVED***
	if (!process[stream]) ***REMOVED***
		return null;
	***REMOVED***

	let ret;

	if (encoding) ***REMOVED***
		ret = _getStream(process[stream], ***REMOVED***
			encoding,
			maxBuffer
		***REMOVED***);
	***REMOVED*** else ***REMOVED***
		ret = _getStream.buffer(process[stream], ***REMOVED***maxBuffer***REMOVED***);
	***REMOVED***

	return ret.catch(err => ***REMOVED***
		err.stream = stream;
		err.message = `$***REMOVED***stream***REMOVED*** $***REMOVED***err.message***REMOVED***`;
		throw err;
	***REMOVED***);
***REMOVED***

module.exports = (cmd, args, opts) => ***REMOVED***
	let joinedCmd = cmd;

	if (Array.isArray(args) && args.length > 0) ***REMOVED***
		joinedCmd += ' ' + args.join(' ');
	***REMOVED***

	const parsed = handleArgs(cmd, args, opts);
	const encoding = parsed.opts.encoding;
	const maxBuffer = parsed.opts.maxBuffer;

	let spawned;
	try ***REMOVED***
		spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
	***REMOVED*** catch (err) ***REMOVED***
		return Promise.reject(err);
	***REMOVED***

	let removeExitHandler;
	if (parsed.opts.cleanup) ***REMOVED***
		removeExitHandler = onExit(() => ***REMOVED***
			spawned.kill();
		***REMOVED***);
	***REMOVED***

	let timeoutId = null;
	let timedOut = false;

	const cleanupTimeout = () => ***REMOVED***
		if (timeoutId) ***REMOVED***
			clearTimeout(timeoutId);
			timeoutId = null;
		***REMOVED***
	***REMOVED***;

	if (parsed.opts.timeout > 0) ***REMOVED***
		timeoutId = setTimeout(() => ***REMOVED***
			timeoutId = null;
			timedOut = true;
			spawned.kill(parsed.opts.killSignal);
		***REMOVED***, parsed.opts.timeout);
	***REMOVED***

	const processDone = new Promise(resolve => ***REMOVED***
		spawned.on('exit', (code, signal) => ***REMOVED***
			cleanupTimeout();
			resolve(***REMOVED***code, signal***REMOVED***);
		***REMOVED***);

		spawned.on('error', err => ***REMOVED***
			cleanupTimeout();
			resolve(***REMOVED***err***REMOVED***);
		***REMOVED***);

		if (spawned.stdin) ***REMOVED***
			spawned.stdin.on('error', err => ***REMOVED***
				cleanupTimeout();
				resolve(***REMOVED***err***REMOVED***);
			***REMOVED***);
		***REMOVED***
	***REMOVED***);

	function destroy() ***REMOVED***
		if (spawned.stdout) ***REMOVED***
			spawned.stdout.destroy();
		***REMOVED***

		if (spawned.stderr) ***REMOVED***
			spawned.stderr.destroy();
		***REMOVED***
	***REMOVED***

	const promise = pFinally(Promise.all([
		processDone,
		getStream(spawned, 'stdout', encoding, maxBuffer),
		getStream(spawned, 'stderr', encoding, maxBuffer)
	]).then(arr => ***REMOVED***
		const result = arr[0];
		const stdout = arr[1];
		const stderr = arr[2];

		let err = result.err;
		const code = result.code;
		const signal = result.signal;

		if (removeExitHandler) ***REMOVED***
			removeExitHandler();
		***REMOVED***

		if (err || code !== 0 || signal !== null) ***REMOVED***
			if (!err) ***REMOVED***
				let output = '';

				if (Array.isArray(parsed.opts.stdio)) ***REMOVED***
					if (parsed.opts.stdio[2] !== 'inherit') ***REMOVED***
						output += output.length > 0 ? stderr : `\n$***REMOVED***stderr***REMOVED***`;
					***REMOVED***

					if (parsed.opts.stdio[1] !== 'inherit') ***REMOVED***
						output += `\n$***REMOVED***stdout***REMOVED***`;
					***REMOVED***
				***REMOVED*** else if (parsed.opts.stdio !== 'inherit') ***REMOVED***
					output = `\n$***REMOVED***stderr***REMOVED***$***REMOVED***stdout***REMOVED***`;
				***REMOVED***

				err = new Error(`Command failed: $***REMOVED***joinedCmd***REMOVED***$***REMOVED***output***REMOVED***`);
				err.code = code < 0 ? errname(code) : code;
			***REMOVED***

			// TODO: missing some timeout logic for killed
			// https://github.com/nodejs/node/blob/master/lib/child_process.js#L203
			// err.killed = spawned.killed || killed;
			err.killed = err.killed || spawned.killed;

			err.stdout = stdout;
			err.stderr = stderr;
			err.failed = true;
			err.signal = signal || null;
			err.cmd = joinedCmd;
			err.timedOut = timedOut;

			if (!parsed.opts.reject) ***REMOVED***
				return err;
			***REMOVED***

			throw err;
		***REMOVED***

		return ***REMOVED***
			stdout: handleOutput(parsed.opts, stdout),
			stderr: handleOutput(parsed.opts, stderr),
			code: 0,
			failed: false,
			killed: false,
			signal: null,
			cmd: joinedCmd,
			timedOut: false
		***REMOVED***;
	***REMOVED***), destroy);

	crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);

	handleInput(spawned, parsed.opts);

	spawned.then = promise.then.bind(promise);
	spawned.catch = promise.catch.bind(promise);

	return spawned;
***REMOVED***;

module.exports.stdout = function () ***REMOVED***
	// TODO: set `stderr: 'ignore'` when that option is implemented
	return module.exports.apply(null, arguments).then(x => x.stdout);
***REMOVED***;

module.exports.stderr = function () ***REMOVED***
	// TODO: set `stdout: 'ignore'` when that option is implemented
	return module.exports.apply(null, arguments).then(x => x.stderr);
***REMOVED***;

module.exports.shell = (cmd, opts) => handleShell(module.exports, cmd, opts);

module.exports.sync = (cmd, args, opts) => ***REMOVED***
	const parsed = handleArgs(cmd, args, opts);

	if (isStream(parsed.opts.input)) ***REMOVED***
		throw new TypeError('The `input` option cannot be a stream in sync mode');
	***REMOVED***

	const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);

	if (result.error || result.status !== 0) ***REMOVED***
		throw (result.error || new Error(result.stderr === '' ? result.stdout : result.stderr));
	***REMOVED***

	result.stdout = handleOutput(parsed.opts, result.stdout);
	result.stderr = handleOutput(parsed.opts, result.stderr);

	return result;
***REMOVED***;

module.exports.shellSync = (cmd, opts) => handleShell(module.exports.sync, cmd, opts);

module.exports.spawn = util.deprecate(module.exports, 'execa.spawn() is deprecated. Use execa() instead.');
