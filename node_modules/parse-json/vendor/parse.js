/*
 * Author: Alex Kocharin <alex@kocharin.ru>
 * GIT: https://github.com/rlidwka/jju
 * License: WTFPL, grab your copy here: http://www.wtfpl.net/txt/copying/
 */

// RTFM: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf

var Uni = require('./unicode')

function isHexDigit(x) ***REMOVED***
  return (x >= '0' && x <= '9')
      || (x >= 'A' && x <= 'F')
      || (x >= 'a' && x <= 'f')
***REMOVED***

function isOctDigit(x) ***REMOVED***
  return x >= '0' && x <= '7'
***REMOVED***

function isDecDigit(x) ***REMOVED***
  return x >= '0' && x <= '9'
***REMOVED***

var unescapeMap = ***REMOVED***
  '\'': '\'',
  '"' : '"',
  '\\': '\\',
  'b' : '\b',
  'f' : '\f',
  'n' : '\n',
  'r' : '\r',
  't' : '\t',
  'v' : '\v',
  '/' : '/',
***REMOVED***

function formatError(input, msg, position, lineno, column, json5) ***REMOVED***
  var result = msg + ' at ' + (lineno + 1) + ':' + (column + 1)
    , tmppos = position - column - 1
    , srcline = ''
    , underline = ''

  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON

  // output no more than 70 characters before the wrong ones
  if (tmppos < position - 70) ***REMOVED***
    tmppos = position - 70
  ***REMOVED***

  while (1) ***REMOVED***
    var chr = input[++tmppos]

    if (isLineTerminator(chr) || tmppos === input.length) ***REMOVED***
      if (position >= tmppos) ***REMOVED***
        // ending line error, so show it after the last char
        underline += '^'
      ***REMOVED***
      break
    ***REMOVED***
    srcline += chr

    if (position === tmppos) ***REMOVED***
      underline += '^'
    ***REMOVED*** else if (position > tmppos) ***REMOVED***
      underline += input[tmppos] === '\t' ? '\t' : ' '
    ***REMOVED***

    // output no more than 78 characters on the string
    if (srcline.length > 78) break
  ***REMOVED***

  return result + '\n' + srcline + '\n' + underline
***REMOVED***

function parse(input, options) ***REMOVED***
  // parse as a standard JSON mode
  var json5 = !(options.mode === 'json' || options.legacy)
  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON
  var isWhiteSpace = json5 ? Uni.isWhiteSpace : Uni.isWhiteSpaceJSON

  var length = input.length
    , lineno = 0
    , linestart = 0
    , position = 0
    , stack = []

  var tokenStart = function() ***REMOVED******REMOVED***
  var tokenEnd = function(v) ***REMOVED***return v***REMOVED***

  /* tokenize(***REMOVED***
       raw: '...',
       type: 'whitespace'|'comment'|'key'|'literal'|'separator'|'newline',
       value: 'number'|'string'|'whatever',
       path: [...],
     ***REMOVED***)
  */
  if (options._tokenize) ***REMOVED***
    ;(function() ***REMOVED***
      var start = null
      tokenStart = function() ***REMOVED***
        if (start !== null) throw Error('internal error, token overlap')
        start = position
      ***REMOVED***

      tokenEnd = function(v, type) ***REMOVED***
        if (start != position) ***REMOVED***
          var hash = ***REMOVED***
            raw: input.substr(start, position-start),
            type: type,
            stack: stack.slice(0),
          ***REMOVED***
          if (v !== undefined) hash.value = v
          options._tokenize.call(null, hash)
        ***REMOVED***
        start = null
        return v
      ***REMOVED***
    ***REMOVED***)()
  ***REMOVED***

  function fail(msg) ***REMOVED***
    var column = position - linestart

    if (!msg) ***REMOVED***
      if (position < length) ***REMOVED***
        var token = '\'' +
          JSON
            .stringify(input[position])
            .replace(/^"|"$/g, '')
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"')
          + '\''

        if (!msg) msg = 'Unexpected token ' + token
      ***REMOVED*** else ***REMOVED***
        if (!msg) msg = 'Unexpected end of input'
      ***REMOVED***
    ***REMOVED***

    var error = SyntaxError(formatError(input, msg, position, lineno, column, json5))
    error.row = lineno + 1
    error.column = column + 1
    throw error
  ***REMOVED***

  function newline(chr) ***REMOVED***
    // account for <cr><lf>
    if (chr === '\r' && input[position] === '\n') position++
    linestart = position
    lineno++
  ***REMOVED***

  function parseGeneric() ***REMOVED***
    var result

    while (position < length) ***REMOVED***
      tokenStart()
      var chr = input[position++]

      if (chr === '"' || (chr === '\'' && json5)) ***REMOVED***
        return tokenEnd(parseString(chr), 'literal')

      ***REMOVED*** else if (chr === '***REMOVED***') ***REMOVED***
        tokenEnd(undefined, 'separator')
        return parseObject()

      ***REMOVED*** else if (chr === '[') ***REMOVED***
        tokenEnd(undefined, 'separator')
        return parseArray()

      ***REMOVED*** else if (chr === '-'
             ||  chr === '.'
             ||  isDecDigit(chr)
                 //           + number       Infinity          NaN
             ||  (json5 && (chr === '+' || chr === 'I' || chr === 'N'))
      ) ***REMOVED***
        return tokenEnd(parseNumber(), 'literal')

      ***REMOVED*** else if (chr === 'n') ***REMOVED***
        parseKeyword('null')
        return tokenEnd(null, 'literal')

      ***REMOVED*** else if (chr === 't') ***REMOVED***
        parseKeyword('true')
        return tokenEnd(true, 'literal')

      ***REMOVED*** else if (chr === 'f') ***REMOVED***
        parseKeyword('false')
        return tokenEnd(false, 'literal')

      ***REMOVED*** else ***REMOVED***
        position--
        return tokenEnd(undefined)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function parseKey() ***REMOVED***
    var result

    while (position < length) ***REMOVED***
      tokenStart()
      var chr = input[position++]

      if (chr === '"' || (chr === '\'' && json5)) ***REMOVED***
        return tokenEnd(parseString(chr), 'key')

      ***REMOVED*** else if (chr === '***REMOVED***') ***REMOVED***
        tokenEnd(undefined, 'separator')
        return parseObject()

      ***REMOVED*** else if (chr === '[') ***REMOVED***
        tokenEnd(undefined, 'separator')
        return parseArray()

      ***REMOVED*** else if (chr === '.'
             ||  isDecDigit(chr)
      ) ***REMOVED***
        return tokenEnd(parseNumber(true), 'key')

      ***REMOVED*** else if (json5
             &&  Uni.isIdentifierStart(chr) || (chr === '\\' && input[position] === 'u')) ***REMOVED***
        // unicode char or a unicode sequence
        var rollback = position - 1
        var result = parseIdentifier()

        if (result === undefined) ***REMOVED***
          position = rollback
          return tokenEnd(undefined)
        ***REMOVED*** else ***REMOVED***
          return tokenEnd(result, 'key')
        ***REMOVED***

      ***REMOVED*** else ***REMOVED***
        position--
        return tokenEnd(undefined)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function skipWhiteSpace() ***REMOVED***
    tokenStart()
    while (position < length) ***REMOVED***
      var chr = input[position++]

      if (isLineTerminator(chr)) ***REMOVED***
        position--
        tokenEnd(undefined, 'whitespace')
        tokenStart()
        position++
        newline(chr)
        tokenEnd(undefined, 'newline')
        tokenStart()

      ***REMOVED*** else if (isWhiteSpace(chr)) ***REMOVED***
        // nothing

      ***REMOVED*** else if (chr === '/'
             && json5
             && (input[position] === '/' || input[position] === '*')
      ) ***REMOVED***
        position--
        tokenEnd(undefined, 'whitespace')
        tokenStart()
        position++
        skipComment(input[position++] === '*')
        tokenEnd(undefined, 'comment')
        tokenStart()

      ***REMOVED*** else ***REMOVED***
        position--
        break
      ***REMOVED***
    ***REMOVED***
    return tokenEnd(undefined, 'whitespace')
  ***REMOVED***

  function skipComment(multi) ***REMOVED***
    while (position < length) ***REMOVED***
      var chr = input[position++]

      if (isLineTerminator(chr)) ***REMOVED***
        // LineTerminator is an end of singleline comment
        if (!multi) ***REMOVED***
          // let parent function deal with newline
          position--
          return
        ***REMOVED***

        newline(chr)

      ***REMOVED*** else if (chr === '*' && multi) ***REMOVED***
        // end of multiline comment
        if (input[position] === '/') ***REMOVED***
          position++
          return
        ***REMOVED***

      ***REMOVED*** else ***REMOVED***
        // nothing
      ***REMOVED***
    ***REMOVED***

    if (multi) ***REMOVED***
      fail('Unclosed multiline comment')
    ***REMOVED***
  ***REMOVED***

  function parseKeyword(keyword) ***REMOVED***
    // keyword[0] is not checked because it should've checked earlier
    var _pos = position
    var len = keyword.length
    for (var i=1; i<len; i++) ***REMOVED***
      if (position >= length || keyword[i] != input[position]) ***REMOVED***
        position = _pos-1
        fail()
      ***REMOVED***
      position++
    ***REMOVED***
  ***REMOVED***

  function parseObject() ***REMOVED***
    var result = options.null_prototype ? Object.create(null) : ***REMOVED******REMOVED***
      , empty_object = ***REMOVED******REMOVED***
      , is_non_empty = false

    while (position < length) ***REMOVED***
      skipWhiteSpace()
      var item1 = parseKey()
      skipWhiteSpace()
      tokenStart()
      var chr = input[position++]
      tokenEnd(undefined, 'separator')

      if (chr === '***REMOVED***' && item1 === undefined) ***REMOVED***
        if (!json5 && is_non_empty) ***REMOVED***
          position--
          fail('Trailing comma in object')
        ***REMOVED***
        return result

      ***REMOVED*** else if (chr === ':' && item1 !== undefined) ***REMOVED***
        skipWhiteSpace()
        stack.push(item1)
        var item2 = parseGeneric()
        stack.pop()

        if (item2 === undefined) fail('No value found for key ' + item1)
        if (typeof(item1) !== 'string') ***REMOVED***
          if (!json5 || typeof(item1) !== 'number') ***REMOVED***
            fail('Wrong key type: ' + item1)
          ***REMOVED***
        ***REMOVED***

        if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== 'replace') ***REMOVED***
          if (options.reserved_keys === 'throw') ***REMOVED***
            fail('Reserved key: ' + item1)
          ***REMOVED*** else ***REMOVED***
            // silently ignore it
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          if (typeof(options.reviver) === 'function') ***REMOVED***
            item2 = options.reviver.call(null, item1, item2)
          ***REMOVED***

          if (item2 !== undefined) ***REMOVED***
            is_non_empty = true
            Object.defineProperty(result, item1, ***REMOVED***
              value: item2,
              enumerable: true,
              configurable: true,
              writable: true,
            ***REMOVED***)
          ***REMOVED***
        ***REMOVED***

        skipWhiteSpace()

        tokenStart()
        var chr = input[position++]
        tokenEnd(undefined, 'separator')

        if (chr === ',') ***REMOVED***
          continue

        ***REMOVED*** else if (chr === '***REMOVED***') ***REMOVED***
          return result

        ***REMOVED*** else ***REMOVED***
          fail()
        ***REMOVED***

      ***REMOVED*** else ***REMOVED***
        position--
        fail()
      ***REMOVED***
    ***REMOVED***

    fail()
  ***REMOVED***

  function parseArray() ***REMOVED***
    var result = []

    while (position < length) ***REMOVED***
      skipWhiteSpace()
      stack.push(result.length)
      var item = parseGeneric()
      stack.pop()
      skipWhiteSpace()
      tokenStart()
      var chr = input[position++]
      tokenEnd(undefined, 'separator')

      if (item !== undefined) ***REMOVED***
        if (typeof(options.reviver) === 'function') ***REMOVED***
          item = options.reviver.call(null, String(result.length), item)
        ***REMOVED***
        if (item === undefined) ***REMOVED***
          result.length++
          item = true // hack for check below, not included into result
        ***REMOVED*** else ***REMOVED***
          result.push(item)
        ***REMOVED***
      ***REMOVED***

      if (chr === ',') ***REMOVED***
        if (item === undefined) ***REMOVED***
          fail('Elisions are not supported')
        ***REMOVED***

      ***REMOVED*** else if (chr === ']') ***REMOVED***
        if (!json5 && item === undefined && result.length) ***REMOVED***
          position--
          fail('Trailing comma in array')
        ***REMOVED***
        return result

      ***REMOVED*** else ***REMOVED***
        position--
        fail()
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function parseNumber() ***REMOVED***
    // rewind because we don't know first char
    position--

    var start = position
      , chr = input[position++]
      , t

    var to_num = function(is_octal) ***REMOVED***
      var str = input.substr(start, position - start)

      if (is_octal) ***REMOVED***
        var result = parseInt(str.replace(/^0o?/, ''), 8)
      ***REMOVED*** else ***REMOVED***
        var result = Number(str)
      ***REMOVED***

      if (Number.isNaN(result)) ***REMOVED***
        position--
        fail('Bad numeric literal - "' + input.substr(start, position - start + 1) + '"')
      ***REMOVED*** else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) ***REMOVED***
        // additional restrictions imposed by json
        position--
        fail('Non-json numeric literal - "' + input.substr(start, position - start + 1) + '"')
      ***REMOVED*** else ***REMOVED***
        return result
      ***REMOVED***
    ***REMOVED***

    // ex: -5982475.249875e+29384
    //     ^ skipping this
    if (chr === '-' || (chr === '+' && json5)) chr = input[position++]

    if (chr === 'N' && json5) ***REMOVED***
      parseKeyword('NaN')
      return NaN
    ***REMOVED***

    if (chr === 'I' && json5) ***REMOVED***
      parseKeyword('Infinity')

      // returning +inf or -inf
      return to_num()
    ***REMOVED***

    if (chr >= '1' && chr <= '9') ***REMOVED***
      // ex: -5982475.249875e+29384
      //        ^^^ skipping these
      while (position < length && isDecDigit(input[position])) position++
      chr = input[position++]
    ***REMOVED***

    // special case for leading zero: 0.123456
    if (chr === '0') ***REMOVED***
      chr = input[position++]

      //             new syntax, "0o777"           old syntax, "0777"
      var is_octal = chr === 'o' || chr === 'O' || isOctDigit(chr)
      var is_hex = chr === 'x' || chr === 'X'

      if (json5 && (is_octal || is_hex)) ***REMOVED***
        while (position < length
           &&  (is_hex ? isHexDigit : isOctDigit)( input[position] )
        ) position++

        var sign = 1
        if (input[start] === '-') ***REMOVED***
          sign = -1
          start++
        ***REMOVED*** else if (input[start] === '+') ***REMOVED***
          start++
        ***REMOVED***

        return sign * to_num(is_octal)
      ***REMOVED***
    ***REMOVED***

    if (chr === '.') ***REMOVED***
      // ex: -5982475.249875e+29384
      //                ^^^ skipping these
      while (position < length && isDecDigit(input[position])) position++
      chr = input[position++]
    ***REMOVED***

    if (chr === 'e' || chr === 'E') ***REMOVED***
      chr = input[position++]
      if (chr === '-' || chr === '+') position++
      // ex: -5982475.249875e+29384
      //                       ^^^ skipping these
      while (position < length && isDecDigit(input[position])) position++
      chr = input[position++]
    ***REMOVED***

    // we have char in the buffer, so count for it
    position--
    return to_num()
  ***REMOVED***

  function parseIdentifier() ***REMOVED***
    // rewind because we don't know first char
    position--

    var result = ''

    while (position < length) ***REMOVED***
      var chr = input[position++]

      if (chr === '\\'
      &&  input[position] === 'u'
      &&  isHexDigit(input[position+1])
      &&  isHexDigit(input[position+2])
      &&  isHexDigit(input[position+3])
      &&  isHexDigit(input[position+4])
      ) ***REMOVED***
        // UnicodeEscapeSequence
        chr = String.fromCharCode(parseInt(input.substr(position+1, 4), 16))
        position += 5
      ***REMOVED***

      if (result.length) ***REMOVED***
        // identifier started
        if (Uni.isIdentifierPart(chr)) ***REMOVED***
          result += chr
        ***REMOVED*** else ***REMOVED***
          position--
          return result
        ***REMOVED***

      ***REMOVED*** else ***REMOVED***
        if (Uni.isIdentifierStart(chr)) ***REMOVED***
          result += chr
        ***REMOVED*** else ***REMOVED***
          return undefined
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    fail()
  ***REMOVED***

  function parseString(endChar) ***REMOVED***
    // 7.8.4 of ES262 spec
    var result = ''

    while (position < length) ***REMOVED***
      var chr = input[position++]

      if (chr === endChar) ***REMOVED***
        return result

      ***REMOVED*** else if (chr === '\\') ***REMOVED***
        if (position >= length) fail()
        chr = input[position++]

        if (unescapeMap[chr] && (json5 || (chr != 'v' && chr != "'"))) ***REMOVED***
          result += unescapeMap[chr]

        ***REMOVED*** else if (json5 && isLineTerminator(chr)) ***REMOVED***
          // line continuation
          newline(chr)

        ***REMOVED*** else if (chr === 'u' || (chr === 'x' && json5)) ***REMOVED***
          // unicode/character escape sequence
          var off = chr === 'u' ? 4 : 2

          // validation for \uXXXX
          for (var i=0; i<off; i++) ***REMOVED***
            if (position >= length) fail()
            if (!isHexDigit(input[position])) fail('Bad escape sequence')
            position++
          ***REMOVED***

          result += String.fromCharCode(parseInt(input.substr(position-off, off), 16))
        ***REMOVED*** else if (json5 && isOctDigit(chr)) ***REMOVED***
          if (chr < '4' && isOctDigit(input[position]) && isOctDigit(input[position+1])) ***REMOVED***
            // three-digit octal
            var digits = 3
          ***REMOVED*** else if (isOctDigit(input[position])) ***REMOVED***
            // two-digit octal
            var digits = 2
          ***REMOVED*** else ***REMOVED***
            var digits = 1
          ***REMOVED***
          position += digits - 1
          result += String.fromCharCode(parseInt(input.substr(position-digits, digits), 8))
          /*if (!isOctDigit(input[position])) ***REMOVED***
            // \0 is allowed still
            result += '\0'
          ***REMOVED*** else ***REMOVED***
            fail('Octal literals are not supported')
          ***REMOVED****/

        ***REMOVED*** else if (json5) ***REMOVED***
          // \X -> x
          result += chr

        ***REMOVED*** else ***REMOVED***
          position--
          fail()
        ***REMOVED***

      ***REMOVED*** else if (isLineTerminator(chr)) ***REMOVED***
        fail()

      ***REMOVED*** else ***REMOVED***
        if (!json5 && chr.charCodeAt(0) < 32) ***REMOVED***
          position--
          fail('Unexpected control character')
        ***REMOVED***

        // SourceCharacter but not one of " or \ or LineTerminator
        result += chr
      ***REMOVED***
    ***REMOVED***

    fail()
  ***REMOVED***

  skipWhiteSpace()
  var return_value = parseGeneric()
  if (return_value !== undefined || position < length) ***REMOVED***
    skipWhiteSpace()

    if (position >= length) ***REMOVED***
      if (typeof(options.reviver) === 'function') ***REMOVED***
        return_value = options.reviver.call(null, '', return_value)
      ***REMOVED***
      return return_value
    ***REMOVED*** else ***REMOVED***
      fail()
    ***REMOVED***

  ***REMOVED*** else ***REMOVED***
    if (position) ***REMOVED***
      fail('No data, only a whitespace')
    ***REMOVED*** else ***REMOVED***
      fail('No data, empty input')
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/*
 * parse(text, options)
 * or
 * parse(text, reviver)
 *
 * where:
 * text - string
 * options - object
 * reviver - function
 */
module.exports.parse = function parseJSON(input, options) ***REMOVED***
  // support legacy functions
  if (typeof(options) === 'function') ***REMOVED***
    options = ***REMOVED***
      reviver: options
    ***REMOVED***
  ***REMOVED***

  if (input === undefined) ***REMOVED***
    // parse(stringify(x)) should be equal x
    // with JSON functions it is not 'cause of undefined
    // so we're fixing it
    return undefined
  ***REMOVED***

  // JSON.parse compat
  if (typeof(input) !== 'string') input = String(input)
  if (options == null) options = ***REMOVED******REMOVED***
  if (options.reserved_keys == null) options.reserved_keys = 'ignore'

  if (options.reserved_keys === 'throw' || options.reserved_keys === 'ignore') ***REMOVED***
    if (options.null_prototype == null) ***REMOVED***
      options.null_prototype = true
    ***REMOVED***
  ***REMOVED***

  try ***REMOVED***
    return parse(input, options)
  ***REMOVED*** catch(err) ***REMOVED***
    // jju is a recursive parser, so JSON.parse("***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***") could blow up the stack
    //
    // this catch is used to skip all those internal calls
    if (err instanceof SyntaxError && err.row != null && err.column != null) ***REMOVED***
      var old_err = err
      err = SyntaxError(old_err.message)
      err.column = old_err.column
      err.row = old_err.row
    ***REMOVED***
    throw err
  ***REMOVED***
***REMOVED***

module.exports.tokenize = function tokenizeJSON(input, options) ***REMOVED***
  if (options == null) options = ***REMOVED******REMOVED***

  options._tokenize = function(smth) ***REMOVED***
    if (options._addstack) smth.stack.unshift.apply(smth.stack, options._addstack)
    tokens.push(smth)
  ***REMOVED***

  var tokens = []
  tokens.data = module.exports.parse(input, options)
  return tokens
***REMOVED***

