/*!
 * to-regex-range <https://github.com/jonschlinkert/to-regex-range>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var repeat = require('repeat-string');
var isNumber = require('is-number');
var cache = ***REMOVED******REMOVED***;

function toRegexRange(min, max, options) ***REMOVED***
  if (isNumber(min) === false) ***REMOVED***
    throw new RangeError('toRegexRange: first argument is invalid.');
  ***REMOVED***

  if (typeof max === 'undefined' || min === max) ***REMOVED***
    return String(min);
  ***REMOVED***

  if (isNumber(max) === false) ***REMOVED***
    throw new RangeError('toRegexRange: second argument is invalid.');
  ***REMOVED***

  options = options || ***REMOVED******REMOVED***;
  var relax = String(options.relaxZeros);
  var shorthand = String(options.shorthand);
  var capture = String(options.capture);
  var key = min + ':' + max + '=' + relax + shorthand + capture;
  if (cache.hasOwnProperty(key)) ***REMOVED***
    return cache[key].result;
  ***REMOVED***

  var a = Math.min(min, max);
  var b = Math.max(min, max);

  if (Math.abs(a - b) === 1) ***REMOVED***
    var result = min + '|' + max;
    if (options.capture) ***REMOVED***
      return '(' + result + ')';
    ***REMOVED***
    return result;
  ***REMOVED***

  var isPadded = padding(min) || padding(max);
  var positives = [];
  var negatives = [];

  var tok = ***REMOVED***min: min, max: max, a: a, b: b***REMOVED***;
  if (isPadded) ***REMOVED***
    tok.isPadded = isPadded;
    tok.maxLen = String(tok.max).length;
  ***REMOVED***

  if (a < 0) ***REMOVED***
    var newMin = b < 0 ? Math.abs(b) : 1;
    var newMax = Math.abs(a);
    negatives = splitToPatterns(newMin, newMax, tok, options);
    a = tok.a = 0;
  ***REMOVED***

  if (b >= 0) ***REMOVED***
    positives = splitToPatterns(a, b, tok, options);
  ***REMOVED***

  tok.negatives = negatives;
  tok.positives = positives;
  tok.result = siftPatterns(negatives, positives, options);

  if (options.capture && (positives.length + negatives.length) > 1) ***REMOVED***
    tok.result = '(' + tok.result + ')';
  ***REMOVED***

  cache[key] = tok;
  return tok.result;
***REMOVED***

function siftPatterns(neg, pos, options) ***REMOVED***
  var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  var intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
***REMOVED***

function splitToRanges(min, max) ***REMOVED***
  min = Number(min);
  max = Number(max);

  var nines = 1;
  var stops = [max];
  var stop = +countNines(min, nines);

  while (min <= stop && stop <= max) ***REMOVED***
    stops = push(stops, stop);
    nines += 1;
    stop = +countNines(min, nines);
  ***REMOVED***

  var zeros = 1;
  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) ***REMOVED***
    stops = push(stops, stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  ***REMOVED***

  stops.sort(compare);
  return stops;
***REMOVED***

/**
 * Convert a range to a regex pattern
 * @param ***REMOVED***Number***REMOVED*** `start`
 * @param ***REMOVED***Number***REMOVED*** `stop`
 * @return ***REMOVED***String***REMOVED***
 */

function rangeToPattern(start, stop, options) ***REMOVED***
  if (start === stop) ***REMOVED***
    return ***REMOVED***pattern: String(start), digits: []***REMOVED***;
  ***REMOVED***

  var zipped = zip(String(start), String(stop));
  var len = zipped.length, i = -1;

  var pattern = '';
  var digits = 0;

  while (++i < len) ***REMOVED***
    var numbers = zipped[i];
    var startDigit = numbers[0];
    var stopDigit = numbers[1];

    if (startDigit === stopDigit) ***REMOVED***
      pattern += startDigit;

    ***REMOVED*** else if (startDigit !== '0' || stopDigit !== '9') ***REMOVED***
      pattern += toCharacterClass(startDigit, stopDigit);

    ***REMOVED*** else ***REMOVED***
      digits += 1;
    ***REMOVED***
  ***REMOVED***

  if (digits) ***REMOVED***
    pattern += options.shorthand ? '\\d' : '[0-9]';
  ***REMOVED***

  return ***REMOVED*** pattern: pattern, digits: [digits] ***REMOVED***;
***REMOVED***

function splitToPatterns(min, max, tok, options) ***REMOVED***
  var ranges = splitToRanges(min, max);
  var len = ranges.length;
  var idx = -1;

  var tokens = [];
  var start = min;
  var prev;

  while (++idx < len) ***REMOVED***
    var range = ranges[idx];
    var obj = rangeToPattern(start, range, options);
    var zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) ***REMOVED***
      if (prev.digits.length > 1) ***REMOVED***
        prev.digits.pop();
      ***REMOVED***
      prev.digits.push(obj.digits[0]);
      prev.string = prev.pattern + toQuantifier(prev.digits);
      start = range + 1;
      continue;
    ***REMOVED***

    if (tok.isPadded) ***REMOVED***
      zeros = padZeros(range, tok);
    ***REMOVED***

    obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
    tokens.push(obj);
    start = range + 1;
    prev = obj;
  ***REMOVED***

  return tokens;
***REMOVED***

function filterPatterns(arr, comparison, prefix, intersection, options) ***REMOVED***
  var res = [];

  for (var i = 0; i < arr.length; i++) ***REMOVED***
    var tok = arr[i];
    var ele = tok.string;

    if (options.relaxZeros !== false) ***REMOVED***
      if (prefix === '-' && ele.charAt(0) === '0') ***REMOVED***
        if (ele.charAt(1) === '***REMOVED***') ***REMOVED***
          ele = '0*' + ele.replace(/^0\***REMOVED***\d+\***REMOVED***/, '');
        ***REMOVED*** else ***REMOVED***
          ele = '0*' + ele.slice(1);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (!intersection && !contains(comparison, 'string', ele)) ***REMOVED***
      res.push(prefix + ele);
    ***REMOVED***

    if (intersection && contains(comparison, 'string', ele)) ***REMOVED***
      res.push(prefix + ele);
    ***REMOVED***
  ***REMOVED***
  return res;
***REMOVED***

/**
 * Zip strings (`for in` can be used on string characters)
 */

function zip(a, b) ***REMOVED***
  var arr = [];
  for (var ch in a) arr.push([a[ch], b[ch]]);
  return arr;
***REMOVED***

function compare(a, b) ***REMOVED***
  return a > b ? 1 : b > a ? -1 : 0;
***REMOVED***

function push(arr, ele) ***REMOVED***
  if (arr.indexOf(ele) === -1) arr.push(ele);
  return arr;
***REMOVED***

function contains(arr, key, val) ***REMOVED***
  for (var i = 0; i < arr.length; i++) ***REMOVED***
    if (arr[i][key] === val) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***

function countNines(min, len) ***REMOVED***
  return String(min).slice(0, -len) + repeat('9', len);
***REMOVED***

function countZeros(integer, zeros) ***REMOVED***
  return integer - (integer % Math.pow(10, zeros));
***REMOVED***

function toQuantifier(digits) ***REMOVED***
  var start = digits[0];
  var stop = digits[1] ? (',' + digits[1]) : '';
  if (!stop && (!start || start === 1)) ***REMOVED***
    return '';
  ***REMOVED***
  return '***REMOVED***' + start + stop + '***REMOVED***';
***REMOVED***

function toCharacterClass(a, b) ***REMOVED***
  return '[' + a + ((b - a === 1) ? '' : '-') + b + ']';
***REMOVED***

function padding(str) ***REMOVED***
  return /^-?(0+)\d/.exec(str);
***REMOVED***

function padZeros(val, tok) ***REMOVED***
  if (tok.isPadded) ***REMOVED***
    var diff = Math.abs(tok.maxLen - String(val).length);
    switch (diff) ***REMOVED***
      case 0:
        return '';
      case 1:
        return '0';
      default: ***REMOVED***
        return '0***REMOVED***' + diff + '***REMOVED***';
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return val;
***REMOVED***

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;
