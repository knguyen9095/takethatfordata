/* globals window, HTMLElement */

'use strict';

/**!
 * is
 * the definitive JavaScript type testing library
 *
 * @copyright 2013-2014 Enrico Marino / Jordan Harband
 * @license MIT
 */

var objProto = Object.prototype;
var owns = objProto.hasOwnProperty;
var toStr = objProto.toString;
var symbolValueOf;
if (typeof Symbol === 'function') ***REMOVED***
  symbolValueOf = Symbol.prototype.valueOf;
***REMOVED***
var isActualNaN = function (value) ***REMOVED***
  return value !== value;
***REMOVED***;
var NON_HOST_TYPES = ***REMOVED***
  'boolean': 1,
  number: 1,
  string: 1,
  undefined: 1
***REMOVED***;

var base64Regex = /^([A-Za-z0-9+/]***REMOVED***4***REMOVED***)*([A-Za-z0-9+/]***REMOVED***4***REMOVED***|[A-Za-z0-9+/]***REMOVED***3***REMOVED***=|[A-Za-z0-9+/]***REMOVED***2***REMOVED***==)$/;
var hexRegex = /^[A-Fa-f0-9]+$/;

/**
 * Expose `is`
 */

var is = ***REMOVED******REMOVED***;

/**
 * Test general.
 */

/**
 * is.type
 * Test if `value` is a type of `type`.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @param ***REMOVED***String***REMOVED*** type type
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a type of `type`, false otherwise
 * @api public
 */

is.a = is.type = function (value, type) ***REMOVED***
  return typeof value === type;
***REMOVED***;

/**
 * is.defined
 * Test if `value` is defined.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if 'value' is defined, false otherwise
 * @api public
 */

is.defined = function (value) ***REMOVED***
  return typeof value !== 'undefined';
***REMOVED***;

/**
 * is.empty
 * Test if `value` is empty.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is empty, false otherwise
 * @api public
 */

is.empty = function (value) ***REMOVED***
  var type = toStr.call(value);
  var key;

  if (type === '[object Array]' || type === '[object Arguments]' || type === '[object String]') ***REMOVED***
    return value.length === 0;
  ***REMOVED***

  if (type === '[object Object]') ***REMOVED***
    for (key in value) ***REMOVED***
      if (owns.call(value, key)) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED***
    return true;
  ***REMOVED***

  return !value;
***REMOVED***;

/**
 * is.equal
 * Test if `value` is equal to `other`.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @param ***REMOVED***Mixed***REMOVED*** other value to compare with
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is equal to `other`, false otherwise
 */

is.equal = function equal(value, other) ***REMOVED***
  if (value === other) ***REMOVED***
    return true;
  ***REMOVED***

  var type = toStr.call(value);
  var key;

  if (type !== toStr.call(other)) ***REMOVED***
    return false;
  ***REMOVED***

  if (type === '[object Object]') ***REMOVED***
    for (key in value) ***REMOVED***
      if (!is.equal(value[key], other[key]) || !(key in other)) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED***
    for (key in other) ***REMOVED***
      if (!is.equal(value[key], other[key]) || !(key in value)) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED***
    return true;
  ***REMOVED***

  if (type === '[object Array]') ***REMOVED***
    key = value.length;
    if (key !== other.length) ***REMOVED***
      return false;
    ***REMOVED***
    while (key--) ***REMOVED***
      if (!is.equal(value[key], other[key])) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED***
    return true;
  ***REMOVED***

  if (type === '[object Function]') ***REMOVED***
    return value.prototype === other.prototype;
  ***REMOVED***

  if (type === '[object Date]') ***REMOVED***
    return value.getTime() === other.getTime();
  ***REMOVED***

  return false;
***REMOVED***;

/**
 * is.hosted
 * Test if `value` is hosted by `host`.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value to test
 * @param ***REMOVED***Mixed***REMOVED*** host host to test with
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is hosted by `host`, false otherwise
 * @api public
 */

is.hosted = function (value, host) ***REMOVED***
  var type = typeof host[value];
  return type === 'object' ? !!host[value] : !NON_HOST_TYPES[type];
***REMOVED***;

/**
 * is.instance
 * Test if `value` is an instance of `constructor`.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an instance of `constructor`
 * @api public
 */

is.instance = is['instanceof'] = function (value, constructor) ***REMOVED***
  return value instanceof constructor;
***REMOVED***;

/**
 * is.nil / is.null
 * Test if `value` is null.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is null, false otherwise
 * @api public
 */

is.nil = is['null'] = function (value) ***REMOVED***
  return value === null;
***REMOVED***;

/**
 * is.undef / is.undefined
 * Test if `value` is undefined.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is undefined, false otherwise
 * @api public
 */

is.undef = is.undefined = function (value) ***REMOVED***
  return typeof value === 'undefined';
***REMOVED***;

/**
 * Test arguments.
 */

/**
 * is.args
 * Test if `value` is an arguments object.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an arguments object, false otherwise
 * @api public
 */

is.args = is.arguments = function (value) ***REMOVED***
  var isStandardArguments = toStr.call(value) === '[object Arguments]';
  var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);
  return isStandardArguments || isOldArguments;
***REMOVED***;

/**
 * Test array.
 */

/**
 * is.array
 * Test if 'value' is an array.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an array, false otherwise
 * @api public
 */

is.array = Array.isArray || function (value) ***REMOVED***
  return toStr.call(value) === '[object Array]';
***REMOVED***;

/**
 * is.arguments.empty
 * Test if `value` is an empty arguments object.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an empty arguments object, false otherwise
 * @api public
 */
is.args.empty = function (value) ***REMOVED***
  return is.args(value) && value.length === 0;
***REMOVED***;

/**
 * is.array.empty
 * Test if `value` is an empty array.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an empty array, false otherwise
 * @api public
 */
is.array.empty = function (value) ***REMOVED***
  return is.array(value) && value.length === 0;
***REMOVED***;

/**
 * is.arraylike
 * Test if `value` is an arraylike object.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an arguments object, false otherwise
 * @api public
 */

is.arraylike = function (value) ***REMOVED***
  return !!value && !is.bool(value)
    && owns.call(value, 'length')
    && isFinite(value.length)
    && is.number(value.length)
    && value.length >= 0;
***REMOVED***;

/**
 * Test boolean.
 */

/**
 * is.bool
 * Test if `value` is a boolean.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a boolean, false otherwise
 * @api public
 */

is.bool = is['boolean'] = function (value) ***REMOVED***
  return toStr.call(value) === '[object Boolean]';
***REMOVED***;

/**
 * is.false
 * Test if `value` is false.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is false, false otherwise
 * @api public
 */

is['false'] = function (value) ***REMOVED***
  return is.bool(value) && Boolean(Number(value)) === false;
***REMOVED***;

/**
 * is.true
 * Test if `value` is true.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is true, false otherwise
 * @api public
 */

is['true'] = function (value) ***REMOVED***
  return is.bool(value) && Boolean(Number(value)) === true;
***REMOVED***;

/**
 * Test date.
 */

/**
 * is.date
 * Test if `value` is a date.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a date, false otherwise
 * @api public
 */

is.date = function (value) ***REMOVED***
  return toStr.call(value) === '[object Date]';
***REMOVED***;

/**
 * is.date.valid
 * Test if `value` is a valid date.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @returns ***REMOVED***Boolean***REMOVED*** true if `value` is a valid date, false otherwise
 */
is.date.valid = function (value) ***REMOVED***
  return is.date(value) && !isNaN(Number(value));
***REMOVED***;

/**
 * Test element.
 */

/**
 * is.element
 * Test if `value` is an html element.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an HTML Element, false otherwise
 * @api public
 */

is.element = function (value) ***REMOVED***
  return value !== undefined
    && typeof HTMLElement !== 'undefined'
    && value instanceof HTMLElement
    && value.nodeType === 1;
***REMOVED***;

/**
 * Test error.
 */

/**
 * is.error
 * Test if `value` is an error object.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an error object, false otherwise
 * @api public
 */

is.error = function (value) ***REMOVED***
  return toStr.call(value) === '[object Error]';
***REMOVED***;

/**
 * Test function.
 */

/**
 * is.fn / is.function (deprecated)
 * Test if `value` is a function.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a function, false otherwise
 * @api public
 */

is.fn = is['function'] = function (value) ***REMOVED***
  var isAlert = typeof window !== 'undefined' && value === window.alert;
  if (isAlert) ***REMOVED***
    return true;
  ***REMOVED***
  var str = toStr.call(value);
  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
***REMOVED***;

/**
 * Test number.
 */

/**
 * is.number
 * Test if `value` is a number.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a number, false otherwise
 * @api public
 */

is.number = function (value) ***REMOVED***
  return toStr.call(value) === '[object Number]';
***REMOVED***;

/**
 * is.infinite
 * Test if `value` is positive or negative infinity.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is positive or negative Infinity, false otherwise
 * @api public
 */
is.infinite = function (value) ***REMOVED***
  return value === Infinity || value === -Infinity;
***REMOVED***;

/**
 * is.decimal
 * Test if `value` is a decimal number.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a decimal number, false otherwise
 * @api public
 */

is.decimal = function (value) ***REMOVED***
  return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;
***REMOVED***;

/**
 * is.divisibleBy
 * Test if `value` is divisible by `n`.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @param ***REMOVED***Number***REMOVED*** n dividend
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is divisible by `n`, false otherwise
 * @api public
 */

is.divisibleBy = function (value, n) ***REMOVED***
  var isDividendInfinite = is.infinite(value);
  var isDivisorInfinite = is.infinite(n);
  var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;
  return isDividendInfinite || isDivisorInfinite || (isNonZeroNumber && value % n === 0);
***REMOVED***;

/**
 * is.integer
 * Test if `value` is an integer.
 *
 * @param value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an integer, false otherwise
 * @api public
 */

is.integer = is['int'] = function (value) ***REMOVED***
  return is.number(value) && !isActualNaN(value) && value % 1 === 0;
***REMOVED***;

/**
 * is.maximum
 * Test if `value` is greater than 'others' values.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @param ***REMOVED***Array***REMOVED*** others values to compare with
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is greater than `others` values
 * @api public
 */

is.maximum = function (value, others) ***REMOVED***
  if (isActualNaN(value)) ***REMOVED***
    throw new TypeError('NaN is not a valid value');
  ***REMOVED*** else if (!is.arraylike(others)) ***REMOVED***
    throw new TypeError('second argument must be array-like');
  ***REMOVED***
  var len = others.length;

  while (--len >= 0) ***REMOVED***
    if (value < others[len]) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***;

/**
 * is.minimum
 * Test if `value` is less than `others` values.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @param ***REMOVED***Array***REMOVED*** others values to compare with
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is less than `others` values
 * @api public
 */

is.minimum = function (value, others) ***REMOVED***
  if (isActualNaN(value)) ***REMOVED***
    throw new TypeError('NaN is not a valid value');
  ***REMOVED*** else if (!is.arraylike(others)) ***REMOVED***
    throw new TypeError('second argument must be array-like');
  ***REMOVED***
  var len = others.length;

  while (--len >= 0) ***REMOVED***
    if (value > others[len]) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***;

/**
 * is.nan
 * Test if `value` is not a number.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is not a number, false otherwise
 * @api public
 */

is.nan = function (value) ***REMOVED***
  return !is.number(value) || value !== value;
***REMOVED***;

/**
 * is.even
 * Test if `value` is an even number.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an even number, false otherwise
 * @api public
 */

is.even = function (value) ***REMOVED***
  return is.infinite(value) || (is.number(value) && value === value && value % 2 === 0);
***REMOVED***;

/**
 * is.odd
 * Test if `value` is an odd number.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an odd number, false otherwise
 * @api public
 */

is.odd = function (value) ***REMOVED***
  return is.infinite(value) || (is.number(value) && value === value && value % 2 !== 0);
***REMOVED***;

/**
 * is.ge
 * Test if `value` is greater than or equal to `other`.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @param ***REMOVED***Number***REMOVED*** other value to compare with
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

is.ge = function (value, other) ***REMOVED***
  if (isActualNaN(value) || isActualNaN(other)) ***REMOVED***
    throw new TypeError('NaN is not a valid value');
  ***REMOVED***
  return !is.infinite(value) && !is.infinite(other) && value >= other;
***REMOVED***;

/**
 * is.gt
 * Test if `value` is greater than `other`.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @param ***REMOVED***Number***REMOVED*** other value to compare with
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

is.gt = function (value, other) ***REMOVED***
  if (isActualNaN(value) || isActualNaN(other)) ***REMOVED***
    throw new TypeError('NaN is not a valid value');
  ***REMOVED***
  return !is.infinite(value) && !is.infinite(other) && value > other;
***REMOVED***;

/**
 * is.le
 * Test if `value` is less than or equal to `other`.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @param ***REMOVED***Number***REMOVED*** other value to compare with
 * @return ***REMOVED***Boolean***REMOVED*** if 'value' is less than or equal to 'other'
 * @api public
 */

is.le = function (value, other) ***REMOVED***
  if (isActualNaN(value) || isActualNaN(other)) ***REMOVED***
    throw new TypeError('NaN is not a valid value');
  ***REMOVED***
  return !is.infinite(value) && !is.infinite(other) && value <= other;
***REMOVED***;

/**
 * is.lt
 * Test if `value` is less than `other`.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @param ***REMOVED***Number***REMOVED*** other value to compare with
 * @return ***REMOVED***Boolean***REMOVED*** if `value` is less than `other`
 * @api public
 */

is.lt = function (value, other) ***REMOVED***
  if (isActualNaN(value) || isActualNaN(other)) ***REMOVED***
    throw new TypeError('NaN is not a valid value');
  ***REMOVED***
  return !is.infinite(value) && !is.infinite(other) && value < other;
***REMOVED***;

/**
 * is.within
 * Test if `value` is within `start` and `finish`.
 *
 * @param ***REMOVED***Number***REMOVED*** value value to test
 * @param ***REMOVED***Number***REMOVED*** start lower bound
 * @param ***REMOVED***Number***REMOVED*** finish upper bound
 * @return ***REMOVED***Boolean***REMOVED*** true if 'value' is is within 'start' and 'finish'
 * @api public
 */
is.within = function (value, start, finish) ***REMOVED***
  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) ***REMOVED***
    throw new TypeError('NaN is not a valid value');
  ***REMOVED*** else if (!is.number(value) || !is.number(start) || !is.number(finish)) ***REMOVED***
    throw new TypeError('all arguments must be numbers');
  ***REMOVED***
  var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);
  return isAnyInfinite || (value >= start && value <= finish);
***REMOVED***;

/**
 * Test object.
 */

/**
 * is.object
 * Test if `value` is an object.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is an object, false otherwise
 * @api public
 */
is.object = function (value) ***REMOVED***
  return toStr.call(value) === '[object Object]';
***REMOVED***;

/**
 * is.primitive
 * Test if `value` is a primitive.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a primitive, false otherwise
 * @api public
 */
is.primitive = function isPrimitive(value) ***REMOVED***
  if (!value) ***REMOVED***
    return true;
  ***REMOVED***
  if (typeof value === 'object' || is.object(value) || is.fn(value) || is.array(value)) ***REMOVED***
    return false;
  ***REMOVED***
  return true;
***REMOVED***;

/**
 * is.hash
 * Test if `value` is a hash - a plain object literal.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a hash, false otherwise
 * @api public
 */

is.hash = function (value) ***REMOVED***
  return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
***REMOVED***;

/**
 * Test regexp.
 */

/**
 * is.regexp
 * Test if `value` is a regular expression.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a regexp, false otherwise
 * @api public
 */

is.regexp = function (value) ***REMOVED***
  return toStr.call(value) === '[object RegExp]';
***REMOVED***;

/**
 * Test string.
 */

/**
 * is.string
 * Test if `value` is a string.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if 'value' is a string, false otherwise
 * @api public
 */

is.string = function (value) ***REMOVED***
  return toStr.call(value) === '[object String]';
***REMOVED***;

/**
 * Test base64 string.
 */

/**
 * is.base64
 * Test if `value` is a valid base64 encoded string.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if 'value' is a base64 encoded string, false otherwise
 * @api public
 */

is.base64 = function (value) ***REMOVED***
  return is.string(value) && (!value.length || base64Regex.test(value));
***REMOVED***;

/**
 * Test base64 string.
 */

/**
 * is.hex
 * Test if `value` is a valid hex encoded string.
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if 'value' is a hex encoded string, false otherwise
 * @api public
 */

is.hex = function (value) ***REMOVED***
  return is.string(value) && (!value.length || hexRegex.test(value));
***REMOVED***;

/**
 * is.symbol
 * Test if `value` is an ES6 Symbol
 *
 * @param ***REMOVED***Mixed***REMOVED*** value value to test
 * @return ***REMOVED***Boolean***REMOVED*** true if `value` is a Symbol, false otherise
 * @api public
 */

is.symbol = function (value) ***REMOVED***
  return typeof Symbol === 'function' && toStr.call(value) === '[object Symbol]' && typeof symbolValueOf.call(value) === 'symbol';
***REMOVED***;

module.exports = is;
