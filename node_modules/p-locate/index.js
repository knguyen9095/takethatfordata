'use strict';
const pLimit = require('p-limit');

class EndError extends Error ***REMOVED***
	constructor(value) ***REMOVED***
		super();
		this.value = value;
	***REMOVED***
***REMOVED***

// the input can also be a promise, so we `Promise.all()` them both
const finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));

module.exports = (iterable, tester, opts) => ***REMOVED***
	opts = Object.assign(***REMOVED***
		concurrency: Infinity,
		preserveOrder: true
	***REMOVED***, opts);

	const limit = pLimit(opts.concurrency);

	// start all the promises concurrently with optional limit
	const items = Array.from(iterable).map(el => [el, limit(() => Promise.resolve(el).then(tester))]);

	// check the promises either serially or concurrently
	const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);

	return Promise.all(items.map(el => checkLimit(() => finder(el))))
		.then(() => ***REMOVED******REMOVED***)
		.catch(err => err instanceof EndError ? err.value : Promise.reject(err));
***REMOVED***;
