'use strict';

var map        = require('es5-ext/object/map')
  , isCallable = require('es5-ext/object/is-callable')
  , validValue = require('es5-ext/object/valid-value')
  , contains   = require('es5-ext/string/#/contains')

  , call = Function.prototype.call
  , defineProperty = Object.defineProperty
  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
  , getPrototypeOf = Object.getPrototypeOf
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , cacheDesc = ***REMOVED*** configurable: false, enumerable: false, writable: false,
		value: null ***REMOVED***
  , define;

define = function (name, options) ***REMOVED***
	var value, dgs, cacheName, desc, writable = false, resolvable
	  , flat;
	options = Object(validValue(options));
	cacheName = options.cacheName;
	flat = options.flat;
	if (cacheName == null) cacheName = name;
	delete options.cacheName;
	value = options.value;
	resolvable = isCallable(value);
	delete options.value;
	dgs = ***REMOVED*** configurable: Boolean(options.configurable),
		enumerable: Boolean(options.enumerable) ***REMOVED***;
	if (name !== cacheName) ***REMOVED***
		dgs.get = function () ***REMOVED***
			if (hasOwnProperty.call(this, cacheName)) return this[cacheName];
			cacheDesc.value = resolvable ? call.call(value, this, options) : value;
			cacheDesc.writable = writable;
			defineProperty(this, cacheName, cacheDesc);
			cacheDesc.value = null;
			if (desc) defineProperty(this, name, desc);
			return this[cacheName];
		***REMOVED***;
	***REMOVED*** else if (!flat) ***REMOVED***
		dgs.get = function self() ***REMOVED***
			var ownDesc;
			if (hasOwnProperty.call(this, name)) ***REMOVED***
				ownDesc = getOwnPropertyDescriptor(this, name);
				// It happens in Safari, that getter is still called after property
				// was defined with a value, following workarounds that
				// While in IE11 it may happen that here ownDesc is undefined (go figure)
				if (ownDesc) ***REMOVED***
					if (ownDesc.hasOwnProperty('value')) return ownDesc.value;
					if ((typeof ownDesc.get === 'function') && (ownDesc.get !== self)) ***REMOVED***
						return ownDesc.get.call(this);
					***REMOVED***
					return value;
				***REMOVED***
			***REMOVED***
			desc.value = resolvable ? call.call(value, this, options) : value;
			defineProperty(this, name, desc);
			desc.value = null;
			return this[name];
		***REMOVED***;
	***REMOVED*** else ***REMOVED***
		dgs.get = function self() ***REMOVED***
			var base = this, ownDesc;
			if (hasOwnProperty.call(this, name)) ***REMOVED***
				// It happens in Safari, that getter is still called after property
				// was defined with a value, following workarounds that
				ownDesc = getOwnPropertyDescriptor(this, name);
				if (ownDesc.hasOwnProperty('value')) return ownDesc.value;
				if ((typeof ownDesc.get === 'function') && (ownDesc.get !== self)) ***REMOVED***
					return ownDesc.get.call(this);
				***REMOVED***
			***REMOVED***
			while (!hasOwnProperty.call(base, name)) base = getPrototypeOf(base);
			desc.value = resolvable ? call.call(value, base, options) : value;
			defineProperty(base, name, desc);
			desc.value = null;
			return base[name];
		***REMOVED***;
	***REMOVED***
	dgs.set = function (value) ***REMOVED***
		if (hasOwnProperty.call(this, name)) ***REMOVED***
			throw new TypeError("Cannot assign to lazy defined '" + name + "' property of " + this);
		***REMOVED***
		dgs.get.call(this);
		this[cacheName] = value;
	***REMOVED***;
	if (options.desc) ***REMOVED***
		desc = ***REMOVED***
			configurable: contains.call(options.desc, 'c'),
			enumerable: contains.call(options.desc, 'e')
		***REMOVED***;
		if (cacheName === name) ***REMOVED***
			desc.writable = contains.call(options.desc, 'w');
			desc.value = null;
		***REMOVED*** else ***REMOVED***
			writable = contains.call(options.desc, 'w');
			desc.get = dgs.get;
			desc.set = dgs.set;
		***REMOVED***
		delete options.desc;
	***REMOVED*** else if (cacheName === name) ***REMOVED***
		desc = ***REMOVED***
			configurable: Boolean(options.configurable),
			enumerable: Boolean(options.enumerable),
			writable: Boolean(options.writable),
			value: null
		***REMOVED***;
	***REMOVED***
	delete options.configurable;
	delete options.enumerable;
	delete options.writable;
	return dgs;
***REMOVED***;

module.exports = function (props) ***REMOVED***
	return map(props, function (desc, name) ***REMOVED*** return define(name, desc); ***REMOVED***);
***REMOVED***;
