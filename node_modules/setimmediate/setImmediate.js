(function (global, undefined) ***REMOVED***
    "use strict";

    if (global.setImmediate) ***REMOVED***
        return;
    ***REMOVED***

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = ***REMOVED******REMOVED***;
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) ***REMOVED***
      // Callback can either be a function or a string
      if (typeof callback !== "function") ***REMOVED***
        callback = new Function("" + callback);
      ***REMOVED***
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) ***REMOVED***
          args[i] = arguments[i + 1];
      ***REMOVED***
      // Store and register the task
      var task = ***REMOVED*** callback: callback, args: args ***REMOVED***;
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    ***REMOVED***

    function clearImmediate(handle) ***REMOVED***
        delete tasksByHandle[handle];
    ***REMOVED***

    function run(task) ***REMOVED***
        var callback = task.callback;
        var args = task.args;
        switch (args.length) ***REMOVED***
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        ***REMOVED***
    ***REMOVED***

    function runIfPresent(handle) ***REMOVED***
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) ***REMOVED***
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        ***REMOVED*** else ***REMOVED***
            var task = tasksByHandle[handle];
            if (task) ***REMOVED***
                currentlyRunningATask = true;
                try ***REMOVED***
                    run(task);
                ***REMOVED*** finally ***REMOVED***
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    function installNextTickImplementation() ***REMOVED***
        registerImmediate = function(handle) ***REMOVED***
            process.nextTick(function () ***REMOVED*** runIfPresent(handle); ***REMOVED***);
        ***REMOVED***;
    ***REMOVED***

    function canUsePostMessage() ***REMOVED***
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) ***REMOVED***
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() ***REMOVED***
                postMessageIsAsynchronous = false;
            ***REMOVED***;
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        ***REMOVED***
    ***REMOVED***

    function installPostMessageImplementation() ***REMOVED***
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) ***REMOVED***
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) ***REMOVED***
                runIfPresent(+event.data.slice(messagePrefix.length));
            ***REMOVED***
        ***REMOVED***;

        if (global.addEventListener) ***REMOVED***
            global.addEventListener("message", onGlobalMessage, false);
        ***REMOVED*** else ***REMOVED***
            global.attachEvent("onmessage", onGlobalMessage);
        ***REMOVED***

        registerImmediate = function(handle) ***REMOVED***
            global.postMessage(messagePrefix + handle, "*");
        ***REMOVED***;
    ***REMOVED***

    function installMessageChannelImplementation() ***REMOVED***
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) ***REMOVED***
            var handle = event.data;
            runIfPresent(handle);
        ***REMOVED***;

        registerImmediate = function(handle) ***REMOVED***
            channel.port2.postMessage(handle);
        ***REMOVED***;
    ***REMOVED***

    function installReadyStateChangeImplementation() ***REMOVED***
        var html = doc.documentElement;
        registerImmediate = function(handle) ***REMOVED***
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () ***REMOVED***
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            ***REMOVED***;
            html.appendChild(script);
        ***REMOVED***;
    ***REMOVED***

    function installSetTimeoutImplementation() ***REMOVED***
        registerImmediate = function(handle) ***REMOVED***
            setTimeout(runIfPresent, 0, handle);
        ***REMOVED***;
    ***REMOVED***

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if (***REMOVED******REMOVED***.toString.call(global.process) === "[object process]") ***REMOVED***
        // For Node.js before 0.9
        installNextTickImplementation();

    ***REMOVED*** else if (canUsePostMessage()) ***REMOVED***
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    ***REMOVED*** else if (global.MessageChannel) ***REMOVED***
        // For web workers, where supported
        installMessageChannelImplementation();

    ***REMOVED*** else if (doc && "onreadystatechange" in doc.createElement("script")) ***REMOVED***
        // For IE 6â€“8
        installReadyStateChangeImplementation();

    ***REMOVED*** else ***REMOVED***
        // For older browsers
        installSetTimeoutImplementation();
    ***REMOVED***

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
***REMOVED***(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
