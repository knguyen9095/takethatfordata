import ***REMOVED***types as tt***REMOVED*** from "./tokentype"
import ***REMOVED***Parser***REMOVED*** from "./state"
import ***REMOVED***lineBreak, skipWhiteSpace***REMOVED*** from "./whitespace"

const pp = Parser.prototype

// ## Parser utilities

const literal = /^(?:'((?:[^\']|\.)*)'|"((?:[^\"]|\.)*)"|;)/
pp.strictDirective = function(start) ***REMOVED***
  for (;;) ***REMOVED***
    skipWhiteSpace.lastIndex = start
    start += skipWhiteSpace.exec(this.input)[0].length
    let match = literal.exec(this.input.slice(start))
    if (!match) return false
    if ((match[1] || match[2]) == "use strict") return true
    start += match[0].length
  ***REMOVED***
***REMOVED***

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) ***REMOVED***
  if (this.type === type) ***REMOVED***
    this.next()
    return true
  ***REMOVED*** else ***REMOVED***
    return false
  ***REMOVED***
***REMOVED***

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) ***REMOVED***
  return this.type === tt.name && this.value === name
***REMOVED***

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) ***REMOVED***
  return this.value === name && this.eat(tt.name)
***REMOVED***

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) ***REMOVED***
  if (!this.eatContextual(name)) this.unexpected()
***REMOVED***

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() ***REMOVED***
  return this.type === tt.eof ||
    this.type === tt.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
***REMOVED***

pp.insertSemicolon = function() ***REMOVED***
  if (this.canInsertSemicolon()) ***REMOVED***
    if (this.options.onInsertedSemicolon)
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)
    return true
  ***REMOVED***
***REMOVED***

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() ***REMOVED***
  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()
***REMOVED***

pp.afterTrailingComma = function(tokType, notNext) ***REMOVED***
  if (this.type == tokType) ***REMOVED***
    if (this.options.onTrailingComma)
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)
    if (!notNext)
      this.next()
    return true
  ***REMOVED***
***REMOVED***

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) ***REMOVED***
  this.eat(type) || this.unexpected()
***REMOVED***

// Raise an unexpected token error.

pp.unexpected = function(pos) ***REMOVED***
  this.raise(pos != null ? pos : this.start, "Unexpected token")
***REMOVED***

export class DestructuringErrors ***REMOVED***
  constructor() ***REMOVED***
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1
  ***REMOVED***
***REMOVED***

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) ***REMOVED***
  if (!refDestructuringErrors) return
  if (refDestructuringErrors.trailingComma > -1)
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element")
  let parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind
  if (parens > -1) this.raiseRecoverable(parens, "Parenthesized pattern")
***REMOVED***

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) ***REMOVED***
  let pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1
  if (!andThrow) return pos >= 0
  if (pos > -1) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns")
***REMOVED***

pp.checkYieldAwaitInDefaultParams = function() ***REMOVED***
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    this.raise(this.yieldPos, "Yield expression cannot be a default value")
  if (this.awaitPos)
    this.raise(this.awaitPos, "Await expression cannot be a default value")
***REMOVED***

pp.isSimpleAssignTarget = function(expr) ***REMOVED***
  if (expr.type === "ParenthesizedExpression")
    return this.isSimpleAssignTarget(expr.expression)
  return expr.type === "Identifier" || expr.type === "MemberExpression"
***REMOVED***
