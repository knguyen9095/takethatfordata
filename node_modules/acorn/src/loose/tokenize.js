import ***REMOVED***tokTypes as tt, Token, isNewLine, SourceLocation, getLineInfo, lineBreakG***REMOVED*** from "../index"
import ***REMOVED***LooseParser***REMOVED*** from "./state"

const lp = LooseParser.prototype

function isSpace(ch) ***REMOVED***
  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || isNewLine(ch)
***REMOVED***

lp.next = function() ***REMOVED***
  this.last = this.tok
  if (this.ahead.length)
    this.tok = this.ahead.shift()
  else
    this.tok = this.readToken()

  if (this.tok.start >= this.nextLineStart) ***REMOVED***
    while (this.tok.start >= this.nextLineStart) ***REMOVED***
      this.curLineStart = this.nextLineStart
      this.nextLineStart = this.lineEnd(this.curLineStart) + 1
    ***REMOVED***
    this.curIndent = this.indentationAfter(this.curLineStart)
  ***REMOVED***
***REMOVED***

lp.readToken = function() ***REMOVED***
  for (;;) ***REMOVED***
    try ***REMOVED***
      this.toks.next()
      if (this.toks.type === tt.dot &&
          this.input.substr(this.toks.end, 1) === "." &&
          this.options.ecmaVersion >= 6) ***REMOVED***
        this.toks.end++
        this.toks.type = tt.ellipsis
      ***REMOVED***
      return new Token(this.toks)
    ***REMOVED*** catch(e) ***REMOVED***
      if (!(e instanceof SyntaxError)) throw e

      // Try to skip some text, based on the error message, and then continue
      let msg = e.message, pos = e.raisedAt, replace = true
      if (/unterminated/i.test(msg)) ***REMOVED***
        pos = this.lineEnd(e.pos + 1)
        if (/string/.test(msg)) ***REMOVED***
          replace = ***REMOVED***start: e.pos, end: pos, type: tt.string, value: this.input.slice(e.pos + 1, pos)***REMOVED***
        ***REMOVED*** else if (/regular expr/i.test(msg)) ***REMOVED***
          let re = this.input.slice(e.pos, pos)
          try ***REMOVED*** re = new RegExp(re) ***REMOVED*** catch(e) ***REMOVED******REMOVED***
          replace = ***REMOVED***start: e.pos, end: pos, type: tt.regexp, value: re***REMOVED***
        ***REMOVED*** else if (/template/.test(msg)) ***REMOVED***
          replace = ***REMOVED***start: e.pos, end: pos,
                     type: tt.template,
                     value: this.input.slice(e.pos, pos)***REMOVED***
        ***REMOVED*** else ***REMOVED***
          replace = false
        ***REMOVED***
      ***REMOVED*** else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) ***REMOVED***
        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos
      ***REMOVED*** else if (/character escape|expected hexadecimal/i.test(msg)) ***REMOVED***
        while (pos < this.input.length) ***REMOVED***
          let ch = this.input.charCodeAt(pos++)
          if (ch === 34 || ch === 39 || isNewLine(ch)) break
        ***REMOVED***
      ***REMOVED*** else if (/unexpected character/i.test(msg)) ***REMOVED***
        pos++
        replace = false
      ***REMOVED*** else if (/regular expression/i.test(msg)) ***REMOVED***
        replace = true
      ***REMOVED*** else ***REMOVED***
        throw e
      ***REMOVED***
      this.resetTo(pos)
      if (replace === true) replace = ***REMOVED***start: pos, end: pos, type: tt.name, value: "âœ–"***REMOVED***
      if (replace) ***REMOVED***
        if (this.options.locations)
          replace.loc = new SourceLocation(
            this.toks,
            getLineInfo(this.input, replace.start),
            getLineInfo(this.input, replace.end))
        return replace
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

lp.resetTo = function(pos) ***REMOVED***
  this.toks.pos = pos
  let ch = this.input.charAt(pos - 1)
  this.toks.exprAllowed = !ch || /[\[\***REMOVED***\(,;:?\/*=+\-~!|&%^<>]/.test(ch) ||
    /[enwfd]/.test(ch) &&
    /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos))

  if (this.options.locations) ***REMOVED***
    this.toks.curLine = 1
    this.toks.lineStart = lineBreakG.lastIndex = 0
    let match
    while ((match = lineBreakG.exec(this.input)) && match.index < pos) ***REMOVED***
      ++this.toks.curLine
      this.toks.lineStart = match.index + match[0].length
    ***REMOVED***
  ***REMOVED***
***REMOVED***

lp.lookAhead = function(n) ***REMOVED***
  while (n > this.ahead.length)
    this.ahead.push(this.readToken())
  return this.ahead[n - 1]
***REMOVED***
