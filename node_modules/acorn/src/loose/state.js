import ***REMOVED***tokenizer, SourceLocation, tokTypes as tt, Node, lineBreak, isNewLine***REMOVED*** from "../index"

// Registered plugins
export const pluginsLoose = ***REMOVED******REMOVED***

export class LooseParser ***REMOVED***
  constructor(input, options = ***REMOVED******REMOVED***) ***REMOVED***
    this.toks = tokenizer(input, options)
    this.options = this.toks.options
    this.input = this.toks.input
    this.tok = this.last = ***REMOVED***type: tt.eof, start: 0, end: 0***REMOVED***
    if (this.options.locations) ***REMOVED***
      let here = this.toks.curPosition()
      this.tok.loc = new SourceLocation(this.toks, here, here)
    ***REMOVED***
    this.ahead = [] // Tokens ahead
    this.context = [] // Indentation contexted
    this.curIndent = 0
    this.curLineStart = 0
    this.nextLineStart = this.lineEnd(this.curLineStart) + 1
    this.inAsync = false
    // Load plugins
    this.options.pluginsLoose = options.pluginsLoose || ***REMOVED******REMOVED***
    this.loadPlugins(this.options.pluginsLoose)
  ***REMOVED***

  startNode() ***REMOVED***
    return new Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)
  ***REMOVED***

  storeCurrentPos() ***REMOVED***
    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start
  ***REMOVED***

  startNodeAt(pos) ***REMOVED***
    if (this.options.locations) ***REMOVED***
      return new Node(this.toks, pos[0], pos[1])
    ***REMOVED*** else ***REMOVED***
      return new Node(this.toks, pos)
    ***REMOVED***
  ***REMOVED***

  finishNode(node, type) ***REMOVED***
    node.type = type
    node.end = this.last.end
    if (this.options.locations)
      node.loc.end = this.last.loc.end
    if (this.options.ranges)
      node.range[1] = this.last.end
    return node
  ***REMOVED***

  dummyNode(type) ***REMOVED***
    let dummy = this.startNode()
    dummy.type = type
    dummy.end = dummy.start
    if (this.options.locations)
      dummy.loc.end = dummy.loc.start
    if (this.options.ranges)
      dummy.range[1] = dummy.start
    this.last = ***REMOVED***type: tt.name, start: dummy.start, end: dummy.start, loc: dummy.loc***REMOVED***
    return dummy
  ***REMOVED***

  dummyIdent() ***REMOVED***
    let dummy = this.dummyNode("Identifier")
    dummy.name = "✖"
    return dummy
  ***REMOVED***

  dummyString() ***REMOVED***
    let dummy = this.dummyNode("Literal")
    dummy.value = dummy.raw = "✖"
    return dummy
  ***REMOVED***

  eat(type) ***REMOVED***
    if (this.tok.type === type) ***REMOVED***
      this.next()
      return true
    ***REMOVED*** else ***REMOVED***
      return false
    ***REMOVED***
  ***REMOVED***

  isContextual(name) ***REMOVED***
    return this.tok.type === tt.name && this.tok.value === name
  ***REMOVED***

  eatContextual(name) ***REMOVED***
    return this.tok.value === name && this.eat(tt.name)
  ***REMOVED***

  canInsertSemicolon() ***REMOVED***
    return this.tok.type === tt.eof || this.tok.type === tt.braceR ||
      lineBreak.test(this.input.slice(this.last.end, this.tok.start))
  ***REMOVED***

  semicolon() ***REMOVED***
    return this.eat(tt.semi)
  ***REMOVED***

  expect(type) ***REMOVED***
    if (this.eat(type)) return true
    for (let i = 1; i <= 2; i++) ***REMOVED***
      if (this.lookAhead(i).type == type) ***REMOVED***
        for (let j = 0; j < i; j++) this.next()
        return true
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  pushCx() ***REMOVED***
    this.context.push(this.curIndent)
  ***REMOVED***

  popCx() ***REMOVED***
    this.curIndent = this.context.pop()
  ***REMOVED***

  lineEnd(pos) ***REMOVED***
    while (pos < this.input.length && !isNewLine(this.input.charCodeAt(pos))) ++pos
    return pos
  ***REMOVED***

  indentationAfter(pos) ***REMOVED***
    for (let count = 0;; ++pos) ***REMOVED***
      let ch = this.input.charCodeAt(pos)
      if (ch === 32) ++count
      else if (ch === 9) count += this.options.tabSize
      else return count
    ***REMOVED***
  ***REMOVED***

  closes(closeTok, indent, line, blockHeuristic) ***REMOVED***
    if (this.tok.type === closeTok || this.tok.type === tt.eof) return true
    return line != this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&
      (!blockHeuristic || this.nextLineStart >= this.input.length ||
       this.indentationAfter(this.nextLineStart) < indent)
  ***REMOVED***

  tokenStartsLine() ***REMOVED***
    for (let p = this.tok.start - 1; p >= this.curLineStart; --p) ***REMOVED***
      let ch = this.input.charCodeAt(p)
      if (ch !== 9 && ch !== 32) return false
    ***REMOVED***
    return true
  ***REMOVED***

  extend(name, f) ***REMOVED***
    this[name] = f(this[name])
  ***REMOVED***

  loadPlugins(pluginConfigs) ***REMOVED***
    for (let name in pluginConfigs) ***REMOVED***
      let plugin = pluginsLoose[name]
      if (!plugin) throw new Error("Plugin '" + name + "' not found")
      plugin(this, pluginConfigs[name])
    ***REMOVED***
  ***REMOVED***
***REMOVED***
