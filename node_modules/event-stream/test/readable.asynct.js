
var es = require('../')
  , it = require('it-is').style('colour')
  , u = require('ubelt')

exports ['read an array'] = function (test) ***REMOVED***


  console.log('readable')
  return test.end()
  var readThis = u.map(3, 6, 100, u.id) //array of multiples of 3 < 100

  console.log('readable')

  var reader = 
    es.readable(function (i, callback) ***REMOVED***
      if(i >= readThis.length)
        return this.emit('end')
      console.log('readable')
      callback(null, readThis[i])
    ***REMOVED***)

  var writer = es.writeArray(function (err, array)***REMOVED***
    if(err) throw err
    it(array).deepEqual(readThis)
    test.done()
  ***REMOVED***)

  reader.pipe(writer)
***REMOVED***

exports ['read an array - async'] = function (test) ***REMOVED***

  var readThis = u.map(3, 6, 100, u.id) //array of multiples of 3 < 100

  var reader = 
    es.readable(function (i, callback) ***REMOVED***
      if(i >= readThis.length)
        return this.emit('end')
      u.delay(callback)(null, readThis[i])
    ***REMOVED***)

  var writer = es.writeArray(function (err, array)***REMOVED***
    if(err) throw err
    it(array).deepEqual(readThis)
    test.done()
  ***REMOVED***)

  reader.pipe(writer)
***REMOVED***


exports ['emit data then call next() also works'] = function (test) ***REMOVED***

  var readThis = u.map(3, 6, 100, u.id) //array of multiples of 3 < 100

  var reader = 
    es.readable(function (i, next) ***REMOVED***
      if(i >= readThis.length)
        return this.emit('end')
      this.emit('data', readThis[i])
      next()
    ***REMOVED***)

  var writer = es.writeArray(function (err, array)***REMOVED***
    if(err) throw err
    it(array).deepEqual(readThis)
    test.done()     
  ***REMOVED***)

  reader.pipe(writer)
***REMOVED***


exports ['callback emits error, then stops'] = function (test) ***REMOVED***

  var err = new Error('INTENSIONAL ERROR')
    , called = 0

  var reader = 
    es.readable(function (i, callback) ***REMOVED***
      if(called++)
        return
      callback(err)
    ***REMOVED***)

  reader.on('error', function (_err)***REMOVED***
    it(_err).deepEqual(err)
    u.delay(function() ***REMOVED***
      it(called).equal(1)
      test.done()
    ***REMOVED***, 50)()
  ***REMOVED***)
***REMOVED***

exports['readable does not call read concurrently'] = function (test) ***REMOVED***

  var current = 0
  var source = es.readable(function(count, cb)***REMOVED***
    current ++
    if(count > 100)
      return this.emit('end')
    u.delay(function()***REMOVED***
      current --
      it(current).equal(0)      
      cb(null, ***REMOVED***ok: true, n: count***REMOVED***);
    ***REMOVED***)();
  ***REMOVED***);

  var destination = es.map(function(data, cb)***REMOVED***
    //console.info(data); 
    cb();
  ***REMOVED***);

  var all = es.connect(source, destination);

  destination.on('end', test.done)
***REMOVED***

exports ['does not raise a warning: Recursive process.nextTick detected'] = function (test) ***REMOVED***
    var readThisDelayed;

    u.delay(function () ***REMOVED***
        readThisDelayed = [1, 3, 5];
    ***REMOVED***)();

    es.readable(function (count, callback) ***REMOVED***

        if (readThisDelayed) ***REMOVED***
            var that = this;
            readThisDelayed.forEach(function (item) ***REMOVED***
                that.emit('data', item);
            ***REMOVED***);

            this.emit('end');
            test.done();
        ***REMOVED***

        callback();
    ***REMOVED***);
***REMOVED***;

//
// emitting multiple errors is not supported by stream.
//
// I do not think that this is a good idea, at least, there should be an option to pipe to 
// continue on error. it makes alot ef sense, if you are using Stream like I am, to be able to emit multiple errors.
// an error might not necessarily mean the end of the stream. it depends on the error, at least.
//
// I will start a thread on the mailing list. I'd rather that than use a custom `pipe` implementation.
// 
// basically, I want to be able use pipe to transform objects, and if one object is invalid, 
// the next might still be good, so I should get to choose if it's gonna stop.
// re-enstate this test when this issue progresses.
//
// hmm. I could add this to es.connect by deregistering the error listener, 
// but I would rather it be an option in core.

/*
exports ['emit multiple errors, with 2nd parameter (continueOnError)'] = function (test) ***REMOVED***

  var readThis = d.map(1, 100, d.id)
    , errors = 0
  var reader = 
    es.readable(function (i, callback) ***REMOVED***
      console.log(i, readThis.length)
      if(i >= readThis.length)
        return this.emit('end')
      if(!(readThis[i] % 7))
        return callback(readThis[i])
      callback(null, readThis[i])
    ***REMOVED***, true)

  var writer = es.writeArray(function (err, array) ***REMOVED***
    if(err) throw err
    it(array).every(function (u)***REMOVED***
      it(u % 7).notEqual(0)      
    ***REMOVED***).property('length', 80)
    it(errors).equal(14)
    test.done()     
  ***REMOVED***)

  reader.on('error', function (u) ***REMOVED***
    errors ++
    console.log(u)
    if('number' !== typeof u)
      throw u

    it(u % 7).equal(0)

  ***REMOVED***)

  reader.pipe(writer)
***REMOVED***
*/

require('./helper')(module)
