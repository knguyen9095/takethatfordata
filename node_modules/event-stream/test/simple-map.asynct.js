'use strict';

var es = require('../')
  , it = require('it-is')
  , u = require('ubelt')
  , spec = require('stream-spec')
  , Stream = require('stream')
  , from = require('from')
  , through = require('through')

//REFACTOR THIS TEST TO USE es.readArray and es.writeArray

function writeArray(array, stream) ***REMOVED***

  array.forEach( function (j) ***REMOVED***
    stream.write(j)
  ***REMOVED***)
  stream.end()

***REMOVED***

function readStream(stream, done) ***REMOVED***

  var array = [] 
  stream.on('data', function (data) ***REMOVED***
    array.push(data)
  ***REMOVED***)
  stream.on('error', done)
  stream.on('end', function (data) ***REMOVED***
    done(null, array)
  ***REMOVED***)

***REMOVED*** 

//call sink on each write,
//and complete when finished.

function pauseStream (prob, delay) ***REMOVED*** 
  var pauseIf = (
      'number' == typeof prob 
    ? function () ***REMOVED***
        return Math.random() < prob
      ***REMOVED*** 
    : 'function' == typeof prob 
    ? prob
    : 0.1
  )
  var delayer = ( 
      !delay 
    ? process.nextTick
    : 'number' == typeof delay 
    ? function (next) ***REMOVED*** setTimeout(next, delay) ***REMOVED***
    : delay
  )   

  return es.through(function (data) ***REMOVED***    
    if(!this.paused && pauseIf()) ***REMOVED***
      console.log('PAUSE STREAM PAUSING')
      this.pause()
      var self = this
      delayer(function () ***REMOVED***
        console.log('PAUSE STREAM RESUMING')
        self.resume()
      ***REMOVED***)
    ***REMOVED***
    console.log("emit ('data', " + data + ')')
    this.emit('data', data) 
  ***REMOVED***)
***REMOVED***

exports ['simple map'] = function (test) ***REMOVED***

  var input = u.map(1, 1000, function () ***REMOVED***
    return Math.random() 
  ***REMOVED***)
  var expected = input.map(function (v) ***REMOVED***
    return v * 2
  ***REMOVED***)

  var pause = pauseStream(0.1)
  var fs = from(input)
  var ts = es.writeArray(function (err, ar) ***REMOVED***
    it(ar).deepEqual(expected)
    test.done()
  ***REMOVED***)
  var map = es.through(function (data) ***REMOVED***
    this.emit('data', data * 2)
  ***REMOVED***) 

  spec(map).through().validateOnExit()
  spec(pause).through().validateOnExit()

  fs.pipe(map).pipe(pause).pipe(ts)
***REMOVED***

exports ['simple map applied to a stream'] = function (test) ***REMOVED***

  var input = [1,2,3,7,5,3,1,9,0,2,4,6]
  //create event stream from

  var doubler = es.map(function (data, cb) ***REMOVED***
    cb(null, data * 2)
  ***REMOVED***)

  spec(doubler).through().validateOnExit()

  //a map is only a middle man, so it is both readable and writable
  
  it(doubler).has(***REMOVED***
    readable: true,
    writable: true,   
  ***REMOVED***)

  readStream(doubler, function (err, output) ***REMOVED***
    it(output).deepEqual(input.map(function (j) ***REMOVED***
      return j * 2
    ***REMOVED***))
//    process.nextTick(x.validate)
    test.done()
  ***REMOVED***)
  
  writeArray(input, doubler)
  
***REMOVED***

exports['pipe two maps together'] = function (test) ***REMOVED***

  var input = [1,2,3,7,5,3,1,9,0,2,4,6]
  //create event stream from
  function dd (data, cb) ***REMOVED***
    cb(null, data * 2)
  ***REMOVED***
  var doubler1 = es.map(dd), doubler2 = es.map(dd)

  doubler1.pipe(doubler2)
  
  spec(doubler1).through().validateOnExit()
  spec(doubler2).through().validateOnExit()

  readStream(doubler2, function (err, output) ***REMOVED***
    it(output).deepEqual(input.map(function (j) ***REMOVED***
      return j * 4
    ***REMOVED***))
    test.done()
  ***REMOVED***)
  
  writeArray(input, doubler1)

***REMOVED***

//next:
//
// test pause, resume and drian.
//

// then make a pipe joiner:
//
// plumber (evStr1, evStr2, evStr3, evStr4, evStr5)
//
// will return a single stream that write goes to the first 

exports ['map will not call end until the callback'] = function (test) ***REMOVED***

  var ticker = es.map(function (data, cb) ***REMOVED***
    process.nextTick(function () ***REMOVED***
      cb(null, data * 2)
    ***REMOVED***)
  ***REMOVED***)

  spec(ticker).through().validateOnExit()

  ticker.write('x')
  ticker.end() 

  ticker.on('end', function () ***REMOVED***
    test.done()
  ***REMOVED***)
***REMOVED***


exports ['emit error thrown'] = function (test) ***REMOVED***

  var err = new Error('INTENSIONAL ERROR')
    , mapper = 
  es.map(function () ***REMOVED***
    throw err
  ***REMOVED***)

  mapper.on('error', function (_err) ***REMOVED***
    it(_err).equal(err)  
    test.done()
  ***REMOVED***)

//  onExit(spec(mapper).basic().validate)
//need spec that says stream may error.

  mapper.write('hello')

***REMOVED***

exports ['emit error calledback'] = function (test) ***REMOVED***

  var err = new Error('INTENSIONAL ERROR')
    , mapper = 
  es.map(function (data, callback) ***REMOVED***
    callback(err)
  ***REMOVED***)

  mapper.on('error', function (_err) ***REMOVED***
    it(_err).equal(err)  
    test.done()
  ***REMOVED***)

  mapper.write('hello')

***REMOVED***

exports ['do not emit drain if not paused'] = function (test) ***REMOVED***

  var map = es.map(function (data, callback) ***REMOVED***
    u.delay(callback)(null, 1)
    return true
  ***REMOVED***)
  
  spec(map).through().pausable().validateOnExit()

  map.on('drain', function () ***REMOVED***
    it(false).ok('should not emit drain unless the stream is paused')
  ***REMOVED***)

  it(map.write('hello')).equal(true)
  it(map.write('hello')).equal(true)
  it(map.write('hello')).equal(true)
  setTimeout(function () ***REMOVED***map.end()***REMOVED***,10)
  map.on('end', test.done)
***REMOVED***

exports ['emits drain if paused, when all '] = function (test) ***REMOVED***
  var active = 0
  var drained = false
  var map = es.map(function (data, callback) ***REMOVED***
    active ++
    u.delay(function () ***REMOVED***
      active --
      callback(null, 1)
    ***REMOVED***)()
    console.log('WRITE', false)
    return false
  ***REMOVED***)

  spec(map).through().validateOnExit()

  map.on('drain', function () ***REMOVED***
    drained = true
    it(active).equal(0, 'should emit drain when all maps are done')
  ***REMOVED***)

  it(map.write('hello')).equal(false)
  it(map.write('hello')).equal(false)
  it(map.write('hello')).equal(false)

  process.nextTick(function () ***REMOVED***map.end()***REMOVED***,10)

  map.on('end', function () ***REMOVED***
    console.log('end')
    it(drained).ok('shoud have emitted drain before end')
    test.done() 
  ***REMOVED***)

***REMOVED***

exports ['map applied to a stream with filtering'] = function (test) ***REMOVED***

  var input = [1,2,3,7,5,3,1,9,0,2,4,6]

  var doubler = es.map(function (data, callback) ***REMOVED***
    if (data % 2)
      callback(null, data * 2)
    else
      callback()
  ***REMOVED***)
  
  readStream(doubler, function (err, output) ***REMOVED***
    it(output).deepEqual(input.filter(function (j) ***REMOVED***
      return j % 2
    ***REMOVED***).map(function (j) ***REMOVED***
      return j * 2
    ***REMOVED***))
    test.done()
  ***REMOVED***)
  
  spec(doubler).through().validateOnExit()

  writeArray(input, doubler)
  
***REMOVED***

exports ['simple mapSync applied to a stream'] = function (test) ***REMOVED***

  var input = [1,2,3,7,5,3,1,9,0,2,4,6]

  var doubler = es.mapSync(function (data) ***REMOVED***
    return data * 2
  ***REMOVED***)
  
  readStream(doubler, function (err, output) ***REMOVED***
    it(output).deepEqual(input.map(function (j) ***REMOVED***
      return j * 2
    ***REMOVED***))
    test.done()
  ***REMOVED***)
  
  spec(doubler).through().validateOnExit()

  writeArray(input, doubler)
  
***REMOVED***

exports ['mapSync applied to a stream with filtering'] = function (test) ***REMOVED***

  var input = [1,2,3,7,5,3,1,9,0,2,4,6]

  var doubler = es.mapSync(function (data) ***REMOVED***
    if (data % 2)
      return data * 2
  ***REMOVED***)
  
  readStream(doubler, function (err, output) ***REMOVED***
    it(output).deepEqual(input.filter(function (j) ***REMOVED***
      return j % 2
    ***REMOVED***).map(function (j) ***REMOVED***
      return j * 2
    ***REMOVED***))
    test.done()
  ***REMOVED***)
  
  spec(doubler).through().validateOnExit()

  writeArray(input, doubler)
  
***REMOVED***

require('./helper')(module)
