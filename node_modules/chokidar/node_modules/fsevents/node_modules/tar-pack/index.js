"use strict"

var debug = require('debug')('tar-pack')
var uidNumber = require('uid-number')
var rm = require('rimraf')
var tar = require('tar')
var once = require('once')
var fstream = require('fstream')
var packer = require('fstream-ignore')

var PassThrough = require('stream').PassThrough || require('readable-stream').PassThrough
var zlib = require('zlib')
var path = require('path')

var win32 = process.platform === 'win32'
var myUid = process.getuid && process.getuid()
var myGid = process.getgid && process.getgid()

if (process.env.SUDO_UID && myUid === 0) ***REMOVED***
  if (!isNaN(process.env.SUDO_UID)) myUid = +process.env.SUDO_UID
  if (!isNaN(process.env.SUDO_GID)) myGid = +process.env.SUDO_GID
***REMOVED***

exports.pack = pack
exports.unpack = unpack

function pack(folder, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***
  if (typeof folder === 'string') ***REMOVED***

    var filter = options.filter || function (entry) ***REMOVED*** return true; ***REMOVED***

    folder = packer(***REMOVED***
      path: folder,
      type: 'Directory',
      isDirectory: true,
      ignoreFiles: options.ignoreFiles || ['.gitignore'],
      filter: function (entry) ***REMOVED*** // ***REMOVED***path, basename, dirname, type***REMOVED*** (type is "Directory" or "File")
        var basename = entry.basename
        // some files are *never* allowed under any circumstances
        // these files should always be either temporary files or
        // version control related files
        if (basename === '.git' || basename === '.lock-wscript' || basename.match(/^\.wafpickle-[0-9]+$/) ||
            basename === 'CVS' || basename === '.svn' || basename === '.hg' || basename.match(/^\..*\.swp$/) ||
            basename === '.DS_Store' ||  basename.match(/^\._/)) ***REMOVED***
          return false
        ***REMOVED***
        //custom excludes
        return filter(entry)
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***
  // By default, npm includes some proprietary attributes in the
  // package tarball.  This is sane, and allowed by the spec.
  // However, npm *itself* excludes these from its own package,
  // so that it can be more easily bootstrapped using old and
  // non-compliant tar implementations.
  var tarPack = tar.Pack(***REMOVED*** noProprietary: options.noProprietary || false, fromBase: options.fromBase || false ***REMOVED***)
  var gzip = zlib.Gzip()

  folder
    .on('error', function (er) ***REMOVED***
      if (er) debug('Error reading folder')
      return gzip.emit('error', er)
    ***REMOVED***)
  tarPack
    .on('error', function (er) ***REMOVED***
      if (er) debug('tar creation error')
      gzip.emit('error', er)
    ***REMOVED***)
  return folder.pipe(tarPack).pipe(gzip)
***REMOVED***

function unpack(unpackTarget, options, cb) ***REMOVED***
  if (typeof options === 'function' && cb === undefined) cb = options, options = undefined

  var tarball = new PassThrough()
  if (typeof cb === 'function') ***REMOVED***
    cb = once(cb)
    tarball.on('error', cb)
    tarball.on('close', function () ***REMOVED***
      cb()
    ***REMOVED***)
  ***REMOVED***

  var parent = path.dirname(unpackTarget)
  var base = path.basename(unpackTarget)

  options = options || ***REMOVED******REMOVED***
  var gid = options.gid || null
  var uid = options.uid || null
  var dMode = options.dmode || 0x0777 //npm.modes.exec
  var fMode = options.fmode || 0x0666 //npm.modes.file
  var defaultName = options.defaultName || (options.defaultName === false ? false : 'index.js')
  var strip = (options.strip !== undefined) ? options.strip : 1

  // figure out who we're supposed to be, if we're not pretending
  // to be a specific user.
  if (options.unsafe && !win32) ***REMOVED***
    uid = myUid
    gid = myGid
  ***REMOVED***

  var pending = 2
  uidNumber(uid, gid, function (er, uid, gid) ***REMOVED***
    if (er) ***REMOVED***
      tarball.emit('error', er)
      return tarball.end()
    ***REMOVED***
    if (0 === --pending) next()
  ***REMOVED***)
  if (!options.keepFiles) ***REMOVED***
    rm(unpackTarget, function (er) ***REMOVED***
      if (er) ***REMOVED***
        tarball.emit('error', er)
        return tarball.end()
      ***REMOVED***
      if (0 === --pending) next()
    ***REMOVED***)
  ***REMOVED*** else ***REMOVED***
    next()
  ***REMOVED***
  function next() ***REMOVED***
    // gzip ***REMOVED***tarball***REMOVED*** --decompress --stdout \
    //   | tar -mvxpf - --strip-components=***REMOVED***strip***REMOVED*** -C ***REMOVED***unpackTarget***REMOVED***
    gunzTarPerm(tarball, unpackTarget, dMode, fMode, uid, gid, defaultName, strip)
  ***REMOVED***
  return tarball
***REMOVED***


function gunzTarPerm(tarball, target, dMode, fMode, uid, gid, defaultName, strip) ***REMOVED***
  debug('modes %j', [dMode.toString(8), fMode.toString(8)])

  function fixEntry(entry) ***REMOVED***
    debug('fixEntry %j', entry.path)
    // never create things that are user-unreadable,
    // or dirs that are user-un-listable. Only leads to headaches.
    var originalMode = entry.mode = entry.mode || entry.props.mode
    entry.mode = entry.mode | (entry.type === 'Directory' ? dMode : fMode)
    entry.props.mode = entry.mode
    if (originalMode !== entry.mode) ***REMOVED***
      debug('modified mode %j', [entry.path, originalMode, entry.mode])
    ***REMOVED***

    // if there's a specific owner uid/gid that we want, then set that
    if (!win32 &&  typeof uid === 'number' && typeof gid === 'number') ***REMOVED***
      entry.props.uid = entry.uid = uid
      entry.props.gid = entry.gid = gid
    ***REMOVED***
  ***REMOVED***

  var extractOpts = ***REMOVED*** type: 'Directory', path: target, strip: strip ***REMOVED***

  if (!win32 && typeof uid === 'number' && typeof gid === 'number') ***REMOVED***
    extractOpts.uid = uid
    extractOpts.gid = gid
  ***REMOVED***

  extractOpts.filter = function () ***REMOVED***
    // symbolic links are not allowed in packages.
    if (this.type.match(/^.*Link$/)) ***REMOVED***
      debug('excluding symbolic link: ' + this.path.substr(target.length + 1) + ' -> ' + this.linkpath)
      return false
    ***REMOVED***
    return true
  ***REMOVED***


  type(tarball, function (err, type) ***REMOVED***
    if (err) return tarball.emit('error', err)
    var strm = tarball
    if (type === 'gzip') ***REMOVED***
      strm = strm.pipe(zlib.Unzip())
      strm.on('error', function (er) ***REMOVED***
          if (er) debug('unzip error')
          tarball.emit('error', er)
        ***REMOVED***)
      type = 'tar'
    ***REMOVED***
    if (type === 'tar') ***REMOVED***
      strm
        .pipe(tar.Extract(extractOpts))
        .on('entry', fixEntry)
        .on('error', function (er) ***REMOVED***
          if (er) debug('untar error')
          tarball.emit('error', er)
        ***REMOVED***)
        .on('close', function () ***REMOVED***
          tarball.emit('close')
        ***REMOVED***)
      return
    ***REMOVED***
    if (type === 'naked-file' && defaultName) ***REMOVED***
      var jsOpts = ***REMOVED*** path: path.resolve(target, defaultName) ***REMOVED***

      if (!win32 && typeof uid === 'number' && typeof gid === 'number') ***REMOVED***
        jsOpts.uid = uid
        jsOpts.gid = gid
      ***REMOVED***

      strm
        .pipe(fstream.Writer(jsOpts))
        .on('error', function (er) ***REMOVED***
          if (er) debug('copy error')
          tarball.emit('error', er)
        ***REMOVED***)
        .on('close', function () ***REMOVED***
          tarball.emit('close')
        ***REMOVED***)
      return
    ***REMOVED***

    return cb(new Error('Unrecognised package type'));
  ***REMOVED***)
***REMOVED***

function type(stream, callback) ***REMOVED***
  stream.on('error', handle)
  stream.on('data', parse)
  function handle(err) ***REMOVED***
    stream.removeListener('data', parse)
    stream.removeListener('error', handle)
  ***REMOVED***
  function parse(chunk) ***REMOVED***
    // detect what it is.
    // Then, depending on that, we'll figure out whether it's
    // a single-file module, gzipped tarball, or naked tarball.

    // gzipped files all start with 1f8b08
    if (chunk[0] === 0x1F && chunk[1] === 0x8B && chunk[2] === 0x08) ***REMOVED***
      callback(null, 'gzip')
    ***REMOVED*** else if (chunk.toString().match(/^package\/\u0000/)) ***REMOVED***
      // note, this will only pick up on tarballs with a root directory called package
      callback(null, 'tar')
    ***REMOVED*** else ***REMOVED***
      callback(null, 'naked-file')
    ***REMOVED***

    // now un-hook, and re-emit the chunk
    stream.removeListener('data', parse)
    stream.removeListener('error', handle)
    stream.unshift(chunk)
  ***REMOVED***
***REMOVED***
