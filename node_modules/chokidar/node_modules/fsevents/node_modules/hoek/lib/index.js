// Load modules

var Crypto = require('crypto');
var Path = require('path');
var Util = require('util');
var Escape = require('./escape');


// Declare internals

var internals = ***REMOVED******REMOVED***;


// Clone object or array

exports.clone = function (obj, seen) ***REMOVED***

    if (typeof obj !== 'object' ||
        obj === null) ***REMOVED***

        return obj;
    ***REMOVED***

    seen = seen || ***REMOVED*** orig: [], copy: [] ***REMOVED***;

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) ***REMOVED***
        return seen.copy[lookup];
    ***REMOVED***

    var newObj;
    var cloneDeep = false;

    if (!Array.isArray(obj)) ***REMOVED***
        if (Buffer.isBuffer(obj)) ***REMOVED***
            newObj = new Buffer(obj);
        ***REMOVED***
        else if (obj instanceof Date) ***REMOVED***
            newObj = new Date(obj.getTime());
        ***REMOVED***
        else if (obj instanceof RegExp) ***REMOVED***
            newObj = new RegExp(obj);
        ***REMOVED***
        else ***REMOVED***
            var proto = Object.getPrototypeOf(obj);
            if (proto &&
                proto.isImmutable) ***REMOVED***

                newObj = obj;
            ***REMOVED***
            else ***REMOVED***
                newObj = Object.create(proto);
                cloneDeep = true;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
        newObj = [];
        cloneDeep = true;
    ***REMOVED***

    seen.orig.push(obj);
    seen.copy.push(newObj);

    if (cloneDeep) ***REMOVED***
        var keys = Object.getOwnPropertyNames(obj);
        for (var i = 0, il = keys.length; i < il; ++i) ***REMOVED***
            var key = keys[i];
            var descriptor = Object.getOwnPropertyDescriptor(obj, key);
            if (descriptor &&
                (descriptor.get ||
                 descriptor.set)) ***REMOVED***

                Object.defineProperty(newObj, key, descriptor);
            ***REMOVED***
            else ***REMOVED***
                newObj[key] = exports.clone(obj[key], seen);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return newObj;
***REMOVED***;


// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied
/*eslint-disable */
exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) ***REMOVED***
/*eslint-enable */
    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) ***REMOVED***
        return target;
    ***REMOVED***

    if (Array.isArray(source)) ***REMOVED***
        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
        if (isMergeArrays === false) ***REMOVED***                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        ***REMOVED***

        for (var i = 0, il = source.length; i < il; ++i) ***REMOVED***
            target.push(exports.clone(source[i]));
        ***REMOVED***

        return target;
    ***REMOVED***

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) ***REMOVED***
        var key = keys[k];
        var value = source[key];
        if (value &&
            typeof value === 'object') ***REMOVED***

            if (!target[key] ||
                typeof target[key] !== 'object' ||
                (Array.isArray(target[key]) ^ Array.isArray(value)) ||
                value instanceof Date ||
                Buffer.isBuffer(value) ||
                value instanceof RegExp) ***REMOVED***

                target[key] = exports.clone(value);
            ***REMOVED***
            else ***REMOVED***
                exports.merge(target[key], value, isNullOverride, isMergeArrays);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            if (value !== null &&
                value !== undefined) ***REMOVED***                              // Explicit to preserve empty strings

                target[key] = value;
            ***REMOVED***
            else if (isNullOverride !== false) ***REMOVED***                    // Defaults to true
                target[key] = value;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return target;
***REMOVED***;


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options, isNullOverride) ***REMOVED***

    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) ***REMOVED***                                                 // If no options, return null
        return null;
    ***REMOVED***

    var copy = exports.clone(defaults);

    if (options === true) ***REMOVED***                                         // If options is set to true, use defaults
        return copy;
    ***REMOVED***

    return exports.merge(copy, options, isNullOverride === true, false);
***REMOVED***;


// Clone an object except for the listed keys which are shallow copied

exports.cloneWithShallow = function (source, keys) ***REMOVED***

    if (!source ||
        typeof source !== 'object') ***REMOVED***

        return source;
    ***REMOVED***

    var storage = internals.store(source, keys);    // Move shallow copy items to storage
    var copy = exports.clone(source);               // Deep copy the rest
    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore
    return copy;
***REMOVED***;


internals.store = function (source, keys) ***REMOVED***

    var storage = ***REMOVED******REMOVED***;
    for (var i = 0, il = keys.length; i < il; ++i) ***REMOVED***
        var key = keys[i];
        var value = exports.reach(source, key);
        if (value !== undefined) ***REMOVED***
            storage[key] = value;
            internals.reachSet(source, key, undefined);
        ***REMOVED***
    ***REMOVED***

    return storage;
***REMOVED***;


internals.restore = function (copy, source, storage) ***REMOVED***

    var keys = Object.keys(storage);
    for (var i = 0, il = keys.length; i < il; ++i) ***REMOVED***
        var key = keys[i];
        internals.reachSet(copy, key, storage[key]);
        internals.reachSet(source, key, storage[key]);
    ***REMOVED***
***REMOVED***;


internals.reachSet = function (obj, key, value) ***REMOVED***

    var path = key.split('.');
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i) ***REMOVED***
        var segment = path[i];
        if (i + 1 === il) ***REMOVED***
            ref[segment] = value;
        ***REMOVED***

        ref = ref[segment];
    ***REMOVED***
***REMOVED***;


// Apply options to defaults except for the listed keys which are shallow copied from option without merging

exports.applyToDefaultsWithShallow = function (defaults, options, keys) ***REMOVED***

    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
    exports.assert(keys && Array.isArray(keys), 'Invalid keys');

    if (!options) ***REMOVED***                                                 // If no options, return null
        return null;
    ***REMOVED***

    var copy = exports.cloneWithShallow(defaults, keys);

    if (options === true) ***REMOVED***                                         // If options is set to true, use defaults
        return copy;
    ***REMOVED***

    var storage = internals.store(options, keys);   // Move shallow copy items to storage
    exports.merge(copy, options, false, false);     // Deep copy the rest
    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore
    return copy;
***REMOVED***;


// Deep object or array comparison

exports.deepEqual = function (obj, ref, options, seen) ***REMOVED***

    options = options || ***REMOVED*** prototype: true ***REMOVED***;

    var type = typeof obj;

    if (type !== typeof ref) ***REMOVED***
        return false;
    ***REMOVED***

    if (type !== 'object' ||
        obj === null ||
        ref === null) ***REMOVED***

        if (obj === ref) ***REMOVED***                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
            return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0
        ***REMOVED***

        return obj !== obj && ref !== ref;                  // NaN
    ***REMOVED***

    seen = seen || [];
    if (seen.indexOf(obj) !== -1) ***REMOVED***
        return true;                            // If previous comparison failed, it would have stopped execution
    ***REMOVED***

    seen.push(obj);

    if (Array.isArray(obj)) ***REMOVED***
        if (!Array.isArray(ref)) ***REMOVED***
            return false;
        ***REMOVED***

        if (!options.part && obj.length !== ref.length) ***REMOVED***
            return false;
        ***REMOVED***

        for (var i = 0, il = obj.length; i < il; ++i) ***REMOVED***
            if (options.part) ***REMOVED***
                var found = false;
                for (var r = 0, rl = ref.length; r < rl; ++r) ***REMOVED***
                    if (exports.deepEqual(obj[i], ref[r], options, seen)) ***REMOVED***
                        found = true;
                        break;
                    ***REMOVED***
                ***REMOVED***

                return found;
            ***REMOVED***

            if (!exports.deepEqual(obj[i], ref[i], options, seen)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***

        return true;
    ***REMOVED***

    if (Buffer.isBuffer(obj)) ***REMOVED***
        if (!Buffer.isBuffer(ref)) ***REMOVED***
            return false;
        ***REMOVED***

        if (obj.length !== ref.length) ***REMOVED***
            return false;
        ***REMOVED***

        for (var j = 0, jl = obj.length; j < jl; ++j) ***REMOVED***
            if (obj[j] !== ref[j]) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***

        return true;
    ***REMOVED***

    if (obj instanceof Date) ***REMOVED***
        return (ref instanceof Date && obj.getTime() === ref.getTime());
    ***REMOVED***

    if (obj instanceof RegExp) ***REMOVED***
        return (ref instanceof RegExp && obj.toString() === ref.toString());
    ***REMOVED***

    if (options.prototype) ***REMOVED***
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***

    var keys = Object.getOwnPropertyNames(obj);

    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) ***REMOVED***
        return false;
    ***REMOVED***

    for (var k = 0, kl = keys.length; k < kl; ++k) ***REMOVED***
        var key = keys[k];
        var descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor.get) ***REMOVED***
            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***

    return true;
***REMOVED***;


// Remove duplicate items from array

exports.unique = function (array, key) ***REMOVED***

    var index = ***REMOVED******REMOVED***;
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) ***REMOVED***
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) ***REMOVED***

            result.push(array[i]);
            index[id] = true;
        ***REMOVED***
    ***REMOVED***

    return result;
***REMOVED***;


// Convert array into object

exports.mapToObject = function (array, key) ***REMOVED***

    if (!array) ***REMOVED***
        return null;
    ***REMOVED***

    var obj = ***REMOVED******REMOVED***;
    for (var i = 0, il = array.length; i < il; ++i) ***REMOVED***
        if (key) ***REMOVED***
            if (array[i][key]) ***REMOVED***
                obj[array[i][key]] = true;
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            obj[array[i]] = true;
        ***REMOVED***
    ***REMOVED***

    return obj;
***REMOVED***;


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst) ***REMOVED***

    if (!array1 || !array2) ***REMOVED***
        return [];
    ***REMOVED***

    var common = [];
    var hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);
    var found = ***REMOVED******REMOVED***;
    for (var i = 0, il = array2.length; i < il; ++i) ***REMOVED***
        if (hash[array2[i]] && !found[array2[i]]) ***REMOVED***
            if (justFirst) ***REMOVED***
                return array2[i];
            ***REMOVED***

            common.push(array2[i]);
            found[array2[i]] = true;
        ***REMOVED***
    ***REMOVED***

    return (justFirst ? null : common);
***REMOVED***;


// Test if the reference contains the values

exports.contain = function (ref, values, options) ***REMOVED***

    /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

    var valuePairs = null;
    if (typeof ref === 'object' &&
        typeof values === 'object' &&
        !Array.isArray(ref) &&
        !Array.isArray(values)) ***REMOVED***

        valuePairs = values;
        values = Object.keys(values);
    ***REMOVED***
    else ***REMOVED***
        values = [].concat(values);
    ***REMOVED***

    options = options || ***REMOVED******REMOVED***;            // deep, once, only, part

    exports.assert(arguments.length >= 2, 'Insufficient arguments');
    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
    exports.assert(values.length, 'Values array cannot be empty');

    var compare, compareFlags;
    if (options.deep) ***REMOVED***
        compare = exports.deepEqual;

        var hasOnly = options.hasOwnProperty('only'), hasPart = options.hasOwnProperty('part');

        compareFlags = ***REMOVED***
            prototype: hasOnly ? options.only : hasPart ? !options.part : false,
            part: hasOnly ? !options.only : hasPart ? options.part : true
        ***REMOVED***;
    ***REMOVED***
    else ***REMOVED***
        compare = function (a, b) ***REMOVED***

            return a === b;
        ***REMOVED***;
    ***REMOVED***

    var misses = false;
    var matches = new Array(values.length);
    for (var i = 0, il = matches.length; i < il; ++i) ***REMOVED***
        matches[i] = 0;
    ***REMOVED***

    if (typeof ref === 'string') ***REMOVED***
        var pattern = '(';
        for (i = 0, il = values.length; i < il; ++i) ***REMOVED***
            var value = values[i];
            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
            pattern += (i ? '|' : '') + exports.escapeRegex(value);
        ***REMOVED***

        var regex = new RegExp(pattern + ')', 'g');
        var leftovers = ref.replace(regex, function ($0, $1) ***REMOVED***

            var index = values.indexOf($1);
            ++matches[index];
            return '';          // Remove from string
        ***REMOVED***);

        misses = !!leftovers;
    ***REMOVED***
    else if (Array.isArray(ref)) ***REMOVED***
        for (i = 0, il = ref.length; i < il; ++i) ***REMOVED***
            for (var j = 0, jl = values.length, matched = false; j < jl && matched === false; ++j) ***REMOVED***
                matched = compare(values[j], ref[i], compareFlags) && j;
            ***REMOVED***

            if (matched !== false) ***REMOVED***
                ++matches[matched];
            ***REMOVED***
            else ***REMOVED***
                misses = true;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
        var keys = Object.keys(ref);
        for (i = 0, il = keys.length; i < il; ++i) ***REMOVED***
            var key = keys[i];
            var pos = values.indexOf(key);
            if (pos !== -1) ***REMOVED***
                if (valuePairs &&
                    !compare(valuePairs[key], ref[key], compareFlags)) ***REMOVED***

                    return false;
                ***REMOVED***

                ++matches[pos];
            ***REMOVED***
            else ***REMOVED***
                misses = true;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    var result = false;
    for (i = 0, il = matches.length; i < il; ++i) ***REMOVED***
        result = result || !!matches[i];
        if ((options.once && matches[i] > 1) ||
            (!options.part && !matches[i])) ***REMOVED***

            return false;
        ***REMOVED***
    ***REMOVED***

    if (options.only &&
        misses) ***REMOVED***

        return false;
    ***REMOVED***

    return result;
***REMOVED***;


// Flatten array

exports.flatten = function (array, target) ***REMOVED***

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) ***REMOVED***
        if (Array.isArray(array[i])) ***REMOVED***
            exports.flatten(array[i], result);
        ***REMOVED***
        else ***REMOVED***
            result.push(array[i]);
        ***REMOVED***
    ***REMOVED***

    return result;
***REMOVED***;


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain, options) ***REMOVED***

    if (chain === false ||
        chain === null ||
        typeof chain === 'undefined') ***REMOVED***

        return obj;
    ***REMOVED***

    options = options || ***REMOVED******REMOVED***;
    if (typeof options === 'string') ***REMOVED***
        options = ***REMOVED*** separator: options ***REMOVED***;
    ***REMOVED***

    var path = chain.split(options.separator || '.');
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i) ***REMOVED***
        var key = path[i];
        if (key[0] === '-' && Array.isArray(ref)) ***REMOVED***
            key = key.slice(1, key.length);
            key = ref.length - key;
        ***REMOVED***

        if (!ref ||
            !ref.hasOwnProperty(key) ||
            (typeof ref !== 'object' && options.functions === false)) ***REMOVED***         // Only object and function can have properties

            exports.assert(!options.strict || i + 1 === il, 'Missing segment', key, 'in reach path ', chain);
            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
            ref = options.default;
            break;
        ***REMOVED***

        ref = ref[key];
    ***REMOVED***

    return ref;
***REMOVED***;


exports.reachTemplate = function (obj, template, options) ***REMOVED***

    return template.replace(/***REMOVED***([^***REMOVED***]+)***REMOVED***/g, function ($0, chain) ***REMOVED***

        var value = exports.reach(obj, chain, options);
        return (value === undefined || value === null ? '' : value);
    ***REMOVED***);
***REMOVED***;


exports.formatStack = function (stack) ***REMOVED***

    var trace = [];
    for (var i = 0, il = stack.length; i < il; ++i) ***REMOVED***
        var item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    ***REMOVED***

    return trace;
***REMOVED***;


exports.formatTrace = function (trace) ***REMOVED***

    var display = [];

    for (var i = 0, il = trace.length; i < il; ++i) ***REMOVED***
        var row = trace[i];
        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    ***REMOVED***

    return display;
***REMOVED***;


exports.callStack = function (slice) ***REMOVED***

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) ***REMOVED***

        return stack;
    ***REMOVED***;

    var capture = ***REMOVED******REMOVED***;
    Error.captureStackTrace(capture, arguments.callee);     /*eslint no-caller:0 */
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) ***REMOVED***
        return trace.slice(slice);
    ***REMOVED***

    return trace;
***REMOVED***;


exports.displayStack = function (slice) ***REMOVED***

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
***REMOVED***;


exports.abortThrow = false;


exports.abort = function (message, hideStack) ***REMOVED***

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) ***REMOVED***
        throw new Error(message || 'Unknown error');
    ***REMOVED***

    var stack = '';
    if (!hideStack) ***REMOVED***
        stack = exports.displayStack(1).join('\n\t');
    ***REMOVED***
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
***REMOVED***;


exports.assert = function (condition /*, msg1, msg2, msg3 */) ***REMOVED***

    if (condition) ***REMOVED***
        return;
    ***REMOVED***

    if (arguments.length === 2 && arguments[1] instanceof Error) ***REMOVED***
        throw arguments[1];
    ***REMOVED***

    var msgs = [];
    for (var i = 1, il = arguments.length; i < il; ++i) ***REMOVED***
        if (arguments[i] !== '') ***REMOVED***
            msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations
        ***REMOVED***
    ***REMOVED***

    msgs = msgs.map(function (msg) ***REMOVED***

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);
    ***REMOVED***);
    throw new Error(msgs.join(' ') || 'Unknown error');
***REMOVED***;


exports.Timer = function () ***REMOVED***

    this.ts = 0;
    this.reset();
***REMOVED***;


exports.Timer.prototype.reset = function () ***REMOVED***

    this.ts = Date.now();
***REMOVED***;


exports.Timer.prototype.elapsed = function () ***REMOVED***

    return Date.now() - this.ts;
***REMOVED***;


exports.Bench = function () ***REMOVED***

    this.ts = 0;
    this.reset();
***REMOVED***;


exports.Bench.prototype.reset = function () ***REMOVED***

    this.ts = exports.Bench.now();
***REMOVED***;


exports.Bench.prototype.elapsed = function () ***REMOVED***

    return exports.Bench.now() - this.ts;
***REMOVED***;


exports.Bench.now = function () ***REMOVED***

    var ts = process.hrtime();
    return (ts[0] * 1e3) + (ts[1] / 1e6);
***REMOVED***;


// Escape string for Regex construction

exports.escapeRegex = function (string) ***REMOVED***

    // Escape ^$.*+-?=!:|\/()[]***REMOVED******REMOVED***,
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\***REMOVED***\***REMOVED***\,]/g, '\\$&');
***REMOVED***;


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value, encoding) ***REMOVED***

    var buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));
    return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
***REMOVED***;


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (value, encoding) ***REMOVED***

    if (value &&
        !/^[\w\-]*$/.test(value)) ***REMOVED***

        return new Error('Invalid character');
    ***REMOVED***

    try ***REMOVED***
        var buf = new Buffer(value, 'base64');
        return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));
    ***REMOVED***
    catch (err) ***REMOVED***
        return err;
    ***REMOVED***
***REMOVED***;


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) ***REMOVED***

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`***REMOVED***|***REMOVED***~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\***REMOVED***\|\***REMOVED***~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
***REMOVED***;


exports.escapeHtml = function (string) ***REMOVED***

    return Escape.escapeHtml(string);
***REMOVED***;


exports.escapeJavaScript = function (string) ***REMOVED***

    return Escape.escapeJavaScript(string);
***REMOVED***;


exports.nextTick = function (callback) ***REMOVED***

    return function () ***REMOVED***

        var args = arguments;
        process.nextTick(function () ***REMOVED***

            callback.apply(null, args);
        ***REMOVED***);
    ***REMOVED***;
***REMOVED***;


exports.once = function (method) ***REMOVED***

    if (method._hoekOnce) ***REMOVED***
        return method;
    ***REMOVED***

    var once = false;
    var wrapped = function () ***REMOVED***

        if (!once) ***REMOVED***
            once = true;
            method.apply(null, arguments);
        ***REMOVED***
    ***REMOVED***;

    wrapped._hoekOnce = true;

    return wrapped;
***REMOVED***;


exports.isAbsolutePath = function (path, platform) ***REMOVED***

    if (!path) ***REMOVED***
        return false;
    ***REMOVED***

    if (Path.isAbsolute) ***REMOVED***                      // node >= 0.11
        return Path.isAbsolute(path);
    ***REMOVED***

    platform = platform || process.platform;

    // Unix

    if (platform !== 'win32') ***REMOVED***
        return path[0] === '/';
    ***REMOVED***

    // Windows

    return !!/^(?:[a-zA-Z]:[\\\/])|(?:[\\\/]***REMOVED***2***REMOVED***[^\\\/]+[\\\/]+[^\\\/])/.test(path);        // C:\ or \\something\something
***REMOVED***;


exports.isInteger = function (value) ***REMOVED***

    return (typeof value === 'number' &&
            parseFloat(value) === parseInt(value, 10) &&
            !isNaN(value));
***REMOVED***;


exports.ignore = function () ***REMOVED*** ***REMOVED***;


exports.inherits = Util.inherits;


exports.format = Util.format;


exports.transform = function (source, transform, options) ***REMOVED***

    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');

    if (Array.isArray(source)) ***REMOVED***
        var results = [];
        for (var i = 0, il = source.length; i < il; ++i) ***REMOVED***
            results.push(exports.transform(source[i], transform, options));
        ***REMOVED***
        return results;
    ***REMOVED***

    var result = ***REMOVED******REMOVED***;
    var keys = Object.keys(transform);

    for (var k = 0, kl = keys.length; k < kl; ++k) ***REMOVED***
        var key = keys[k];
        var path = key.split('.');
        var sourcePath = transform[key];

        exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');

        var segment;
        var res = result;

        while (path.length > 1) ***REMOVED***
            segment = path.shift();
            if (!res[segment]) ***REMOVED***
                res[segment] = ***REMOVED******REMOVED***;
            ***REMOVED***
            res = res[segment];
        ***REMOVED***
        segment = path.shift();
        res[segment] = exports.reach(source, sourcePath, options);
    ***REMOVED***

    return result;
***REMOVED***;


exports.uniqueFilename = function (path, extension) ***REMOVED***

    if (extension) ***REMOVED***
        extension = extension[0] !== '.' ? '.' + extension : extension;
    ***REMOVED***
    else ***REMOVED***
        extension = '';
    ***REMOVED***

    path = Path.resolve(path);
    var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
    return Path.join(path, name);
***REMOVED***;


exports.stringify = function () ***REMOVED***

    try ***REMOVED***
        return JSON.stringify.apply(null, arguments);
    ***REMOVED***
    catch (err) ***REMOVED***
        return '[Cannot display object: ' + err.message + ']';
    ***REMOVED***
***REMOVED***;


exports.shallow = function (source) ***REMOVED***

    var target = ***REMOVED******REMOVED***;
    var keys = Object.keys(source);
    for (var i = 0, il = keys.length; i < il; ++i) ***REMOVED***
        var key = keys[i];
        target[key] = source[key];
    ***REMOVED***

    return target;
***REMOVED***;
