'use strict';

var splitString = require('split-string');
var utils = module.exports;

/**
 * Module dependencies
 */

utils.define = require('define-property');
utils.extend = require('extend-shallow');
utils.flatten = require('arr-flatten');
utils.isObject = require('isobject');
utils.fillRange = require('fill-range');
utils.repeat = require('repeat-element');
utils.unique = require('array-unique');

/**
 * Returns true if the given string contains only empty brace sets.
 */

utils.isEmptySets = function(str) ***REMOVED***
  return /^(?:\***REMOVED***,\***REMOVED***)+$/.test(str);
***REMOVED***;

/**
 * Returns true if the given string contains only empty brace sets.
 */

utils.isQuotedString = function(str) ***REMOVED***
  var open = str.charAt(0);
  if (open === '\'' || open === '"' || open === '`') ***REMOVED***
    return str.slice(-1) === open;
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Create the key to use for memoization. The unique key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) ***REMOVED***
  var id = pattern;
  if (typeof options === 'undefined') ***REMOVED***
    return id;
  ***REMOVED***
  var keys = Object.keys(options);
  for (var i = 0; i < keys.length; i++) ***REMOVED***
    var key = keys[i];
    id += ';' + key + '=' + String(options[key]);
  ***REMOVED***
  return id;
***REMOVED***;

/**
 * Normalize options
 */

utils.createOptions = function(options) ***REMOVED***
  var opts = utils.extend.apply(null, arguments);
  if (typeof opts.expand === 'boolean') ***REMOVED***
    opts.optimize = !opts.expand;
  ***REMOVED***
  if (typeof opts.optimize === 'boolean') ***REMOVED***
    opts.expand = !opts.optimize;
  ***REMOVED***
  if (opts.optimize === true) ***REMOVED***
    opts.makeRe = true;
  ***REMOVED***
  return opts;
***REMOVED***;

/**
 * Join patterns in `a` to patterns in `b`
 */

utils.join = function(a, b, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  a = utils.arrayify(a);
  b = utils.arrayify(b);

  if (!a.length) return b;
  if (!b.length) return a;

  var len = a.length;
  var idx = -1;
  var arr = [];

  while (++idx < len) ***REMOVED***
    var val = a[idx];
    if (Array.isArray(val)) ***REMOVED***
      for (var i = 0; i < val.length; i++) ***REMOVED***
        val[i] = utils.join(val[i], b, options);
      ***REMOVED***
      arr.push(val);
      continue;
    ***REMOVED***

    for (var j = 0; j < b.length; j++) ***REMOVED***
      var bval = b[j];

      if (Array.isArray(bval)) ***REMOVED***
        arr.push(utils.join(val, bval, options));
      ***REMOVED*** else ***REMOVED***
        arr.push(val + bval);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return arr;
***REMOVED***;

/**
 * Split the given string on `,` if not escaped.
 */

utils.split = function(str, options) ***REMOVED***
  var opts = utils.extend(***REMOVED***sep: ','***REMOVED***, options);
  if (typeof opts.keepQuotes !== 'boolean') ***REMOVED***
    opts.keepQuotes = true;
  ***REMOVED***
  if (opts.unescape === false) ***REMOVED***
    opts.keepEscaping = true;
  ***REMOVED***
  return splitString(str, opts, utils.escapeBrackets(opts));
***REMOVED***;

/**
 * Expand ranges or sets in the given `pattern`.
 *
 * @param ***REMOVED***String***REMOVED*** `str`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED***
 */

utils.expand = function(str, options) ***REMOVED***
  var opts = utils.extend(***REMOVED***rangeLimit: 10000***REMOVED***, options);
  var segs = utils.split(str, opts);
  var tok = ***REMOVED*** segs: segs ***REMOVED***;

  if (utils.isQuotedString(str)) ***REMOVED***
    return tok;
  ***REMOVED***

  if (opts.rangeLimit === true) ***REMOVED***
    opts.rangeLimit = 10000;
  ***REMOVED***

  if (segs.length > 1) ***REMOVED***
    if (opts.optimize === false) ***REMOVED***
      tok.val = segs[0];
      return tok;
    ***REMOVED***

    tok.segs = utils.stringifyArray(tok.segs);
  ***REMOVED*** else if (segs.length === 1) ***REMOVED***
    var arr = str.split('..');

    if (arr.length === 1) ***REMOVED***
      tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
      tok.segs = [];
      return tok;
    ***REMOVED***

    if (arr.length === 2 && arr[0] === arr[1]) ***REMOVED***
      tok.escaped = true;
      tok.val = arr[0];
      tok.segs = [];
      return tok;
    ***REMOVED***

    if (arr.length > 1) ***REMOVED***
      if (opts.optimize !== false) ***REMOVED***
        opts.optimize = true;
        delete opts.expand;
      ***REMOVED***

      if (opts.optimize !== true) ***REMOVED***
        var min = Math.min(arr[0], arr[1]);
        var max = Math.max(arr[0], arr[1]);
        var step = arr[2] || 1;

        if (opts.rangeLimit !== false && ((max - min) / step >= opts.rangeLimit)) ***REMOVED***
          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
        ***REMOVED***
      ***REMOVED***

      arr.push(opts);
      tok.segs = utils.fillRange.apply(null, arr);

      if (!tok.segs.length) ***REMOVED***
        tok.escaped = true;
        tok.val = str;
        return tok;
      ***REMOVED***

      if (opts.optimize === true) ***REMOVED***
        tok.segs = utils.stringifyArray(tok.segs);
      ***REMOVED***

      if (tok.segs === '') ***REMOVED***
        tok.val = str;
      ***REMOVED*** else ***REMOVED***
        tok.val = tok.segs[0];
      ***REMOVED***
      return tok;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    tok.val = str;
  ***REMOVED***
  return tok;
***REMOVED***;

/**
 * Ensure commas inside brackets and parens are not split.
 * @param ***REMOVED***Object***REMOVED*** `tok` Token from the `split-string` module
 * @return ***REMOVED***undefined***REMOVED***
 */

utils.escapeBrackets = function(options) ***REMOVED***
  return function(tok) ***REMOVED***
    if (tok.escaped && tok.val === 'b') ***REMOVED***
      tok.val = '\\b';
      return;
    ***REMOVED***

    if (tok.val !== '(' && tok.val !== '[') return;
    var opts = utils.extend(***REMOVED******REMOVED***, options);
    var brackets = [];
    var parens = [];
    var stack = [];
    var val = tok.val;
    var str = tok.str;
    var i = tok.idx - 1;

    while (++i < str.length) ***REMOVED***
      var ch = str[i];

      if (ch === '\\') ***REMOVED***
        val += (opts.keepEscaping === false ? '' : ch) + str[++i];
        continue;
      ***REMOVED***

      if (ch === '(') ***REMOVED***
        parens.push(ch);
        stack.push(ch);
      ***REMOVED***

      if (ch === '[') ***REMOVED***
        brackets.push(ch);
        stack.push(ch);
      ***REMOVED***

      if (ch === ')') ***REMOVED***
        parens.pop();
        stack.pop();
        if (!stack.length) ***REMOVED***
          val += ch;
          break;
        ***REMOVED***
      ***REMOVED***

      if (ch === ']') ***REMOVED***
        brackets.pop();
        stack.pop();
        if (!stack.length) ***REMOVED***
          val += ch;
          break;
        ***REMOVED***
      ***REMOVED***
      val += ch;
    ***REMOVED***

    tok.split = false;
    tok.val = val.slice(1);
    tok.idx = i;
  ***REMOVED***;
***REMOVED***;

/**
 * Returns true if the given string looks like a regex quantifier
 * @return ***REMOVED***Boolean***REMOVED***
 */

utils.isQuantifier = function(str) ***REMOVED***
  return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
***REMOVED***;

/**
 * Cast `val` to an array.
 * @param ***REMOVED*******REMOVED*** `val`
 */

utils.stringifyArray = function(arr) ***REMOVED***
  return [utils.arrayify(arr).join('|')];
***REMOVED***;

/**
 * Cast `val` to an array.
 * @param ***REMOVED*******REMOVED*** `val`
 */

utils.arrayify = function(arr) ***REMOVED***
  if (typeof arr === 'undefined') ***REMOVED***
    return [];
  ***REMOVED***
  if (typeof arr === 'string') ***REMOVED***
    return [arr];
  ***REMOVED***
  return arr;
***REMOVED***;

/**
 * Returns true if the given `str` is a non-empty string
 * @return ***REMOVED***Boolean***REMOVED***
 */

utils.isString = function(str) ***REMOVED***
  return str != null && typeof str === 'string';
***REMOVED***;

/**
 * Get the last element from `array`
 * @param ***REMOVED***Array***REMOVED*** `array`
 * @return ***REMOVED*******REMOVED***
 */

utils.last = function(arr, n) ***REMOVED***
  return arr[arr.length - (n || 1)];
***REMOVED***;

utils.escapeRegex = function(str) ***REMOVED***
  return str.replace(/\\?([!^*?()\[\]***REMOVED******REMOVED***+?/])/g, '\\$1');
***REMOVED***;
