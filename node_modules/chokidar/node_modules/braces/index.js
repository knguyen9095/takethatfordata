'use strict';

/**
 * Module dependencies
 */

var toRegex = require('to-regex');
var unique = require('array-unique');
var extend = require('extend-shallow');
var define = require('define-property');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var Braces = require('./lib/braces');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;
var cache = ***REMOVED******REMOVED***;

/**
 * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it's recommended that you read the [performance notes](#performance)).
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces('***REMOVED***a,b,c***REMOVED***'));
 * //=> ['(a|b|c)']
 *
 * console.log(braces('***REMOVED***a,b,c***REMOVED***', ***REMOVED***expand: true***REMOVED***));
 * //=> ['a', 'b', 'c']
 * ```
 * @param ***REMOVED***String***REMOVED*** `str`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***String***REMOVED***
 * @api public
 */

function braces(pattern, options) ***REMOVED***
  var key = utils.createKey(String(pattern), options);
  var arr = [];

  var disabled = options && options.cache === false;
  if (!disabled && cache.hasOwnProperty(key)) ***REMOVED***
    return cache[key];
  ***REMOVED***

  if (Array.isArray(pattern)) ***REMOVED***
    for (var i = 0; i < pattern.length; i++) ***REMOVED***
      arr.push.apply(arr, braces.create(pattern[i], options));
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    arr = braces.create(pattern, options);
  ***REMOVED***

  if (options && options.nodupes === true) ***REMOVED***
    arr = unique(arr);
  ***REMOVED***

  if (!disabled) ***REMOVED***
    cache[key] = arr;
  ***REMOVED***
  return arr;
***REMOVED***

/**
 * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it's recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/***REMOVED***b,c***REMOVED***/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Brace pattern
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.expand = function(pattern, options) ***REMOVED***
  return braces.create(pattern, extend(***REMOVED******REMOVED***, options, ***REMOVED***expand: true***REMOVED***));
***REMOVED***;

/**
 * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/***REMOVED***b,c***REMOVED***/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Brace pattern
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.optimize = function(pattern, options) ***REMOVED***
  return braces.create(pattern, options);
***REMOVED***;

/**
 * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.create('user-***REMOVED***200..300***REMOVED***/project-***REMOVED***a,b,c***REMOVED***-***REMOVED***1..10***REMOVED***'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Brace pattern
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.create = function(pattern, options) ***REMOVED***
  if (typeof pattern !== 'string') ***REMOVED***
    throw new TypeError('expected a string');
  ***REMOVED***

  if (pattern.length >= MAX_LENGTH) ***REMOVED***
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  ***REMOVED***

  function create() ***REMOVED***
    if (pattern === '' || pattern.length < 3) ***REMOVED***
      return [pattern];
    ***REMOVED***

    if (utils.isEmptySets(pattern)) ***REMOVED***
      return [];
    ***REMOVED***

    if (utils.isQuotedString(pattern)) ***REMOVED***
      return [pattern.slice(1, -1)];
    ***REMOVED***

    var proto = new Braces(options);
    var result = !options || options.expand !== true
      ? proto.optimize(pattern, options)
      : proto.expand(pattern, options);

    // get the generated pattern(s)
    var arr = result.output;

    // filter out empty strings if specified
    if (options && options.noempty === true) ***REMOVED***
      arr = arr.filter(Boolean);
    ***REMOVED***

    // filter out duplicates if specified
    if (options && options.nodupes === true) ***REMOVED***
      arr = unique(arr);
    ***REMOVED***

    define(arr, 'result', result);
    return arr;
  ***REMOVED***

  return memoize('create', pattern, options, create);
***REMOVED***;

/**
 * Create a regular expression from the given string `pattern`.
 *
 * ```js
 * var braces = require('braces');
 *
 * console.log(braces.makeRe('id-***REMOVED***200..300***REMOVED***'));
 * //=> /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` The pattern to convert to regex.
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***RegExp***REMOVED***
 * @api public
 */

braces.makeRe = function(pattern, options) ***REMOVED***
  if (typeof pattern !== 'string') ***REMOVED***
    throw new TypeError('expected a string');
  ***REMOVED***

  if (pattern.length >= MAX_LENGTH) ***REMOVED***
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  ***REMOVED***

  function makeRe() ***REMOVED***
    var arr = braces(pattern, options);
    var opts = extend(***REMOVED***strictErrors: false***REMOVED***, options);
    return toRegex(arr, opts);
  ***REMOVED***

  return memoize('makeRe', pattern, options, makeRe);
***REMOVED***;

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/***REMOVED***b,c***REMOVED***/d');
 * console.log(ast);
 * // ***REMOVED*** type: 'root',
 * //   errors: [],
 * //   input: 'a/***REMOVED***b,c***REMOVED***/d',
 * //   nodes:
 * //    [ ***REMOVED*** type: 'bos', val: '' ***REMOVED***,
 * //      ***REMOVED*** type: 'text', val: 'a/' ***REMOVED***,
 * //      ***REMOVED*** type: 'brace',
 * //        nodes:
 * //         [ ***REMOVED*** type: 'brace.open', val: '***REMOVED***' ***REMOVED***,
 * //           ***REMOVED*** type: 'text', val: 'b,c' ***REMOVED***,
 * //           ***REMOVED*** type: 'brace.close', val: '***REMOVED***' ***REMOVED*** ] ***REMOVED***,
 * //      ***REMOVED*** type: 'text', val: '/d' ***REMOVED***,
 * //      ***REMOVED*** type: 'eos', val: '' ***REMOVED*** ] ***REMOVED***
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Brace pattern to parse
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED*** Returns an AST
 * @api public
 */

braces.parse = function(pattern, options) ***REMOVED***
  var proto = new Braces(options);
  return proto.parse(pattern, options);
***REMOVED***;

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/***REMOVED***b,c***REMOVED***/d');
 * console.log(braces.compile(ast));
 * // ***REMOVED*** options: ***REMOVED*** source: 'string' ***REMOVED***,
 * //   state: ***REMOVED******REMOVED***,
 * //   compilers:
 * //    ***REMOVED*** eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] ***REMOVED***,
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    ***REMOVED*** ... ***REMOVED***,
 * //   parsingErrors: [] ***REMOVED***
 * ```
 * @param ***REMOVED***Object|String***REMOVED*** `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED*** Returns an object that has an `output` property with the compiled string.
 * @api public
 */

braces.compile = function(ast, options) ***REMOVED***
  var proto = new Braces(options);
  return proto.compile(ast, options);
***REMOVED***;

/**
 * Clear the regex cache.
 *
 * ```js
 * braces.clearCache();
 * ```
 * @api public
 */

braces.clearCache = function() ***REMOVED***
  cache = braces.cache = ***REMOVED******REMOVED***;
***REMOVED***;

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the method name, pattern, and user-defined options. Set
 * options.memoize to false to disable.
 */

function memoize(type, pattern, options, fn) ***REMOVED***
  var key = utils.createKey(type + ':' + pattern, options);
  var disabled = options && options.cache === false;
  if (disabled) ***REMOVED***
    braces.clearCache();
    return fn(pattern, options);
  ***REMOVED***

  if (cache.hasOwnProperty(key)) ***REMOVED***
    return cache[key];
  ***REMOVED***

  var res = fn(pattern, options);
  cache[key] = res;
  return res;
***REMOVED***

/**
 * Expose `Braces` constructor and methods
 * @type ***REMOVED***Function***REMOVED***
 */

braces.Braces = Braces;
braces.compilers = compilers;
braces.parsers = parsers;
braces.cache = cache;

/**
 * Expose `braces`
 * @type ***REMOVED***Function***REMOVED***
 */

module.exports = braces;
