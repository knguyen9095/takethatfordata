(function (root) ***REMOVED***

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() ***REMOVED******REMOVED***
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) ***REMOVED***
    return function () ***REMOVED***
      fn.apply(thisArg, arguments);
    ***REMOVED***;
  ***REMOVED***

  function Promise(fn) ***REMOVED***
    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  ***REMOVED***

  function handle(self, deferred) ***REMOVED***
    while (self._state === 3) ***REMOVED***
      self = self._value;
    ***REMOVED***
    if (self._state === 0) ***REMOVED***
      self._deferreds.push(deferred);
      return;
    ***REMOVED***
    self._handled = true;
    Promise._immediateFn(function () ***REMOVED***
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) ***REMOVED***
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      ***REMOVED***
      var ret;
      try ***REMOVED***
        ret = cb(self._value);
      ***REMOVED*** catch (e) ***REMOVED***
        reject(deferred.promise, e);
        return;
      ***REMOVED***
      resolve(deferred.promise, ret);
    ***REMOVED***);
  ***REMOVED***

  function resolve(self, newValue) ***REMOVED***
    try ***REMOVED***
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) ***REMOVED***
        var then = newValue.then;
        if (newValue instanceof Promise) ***REMOVED***
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        ***REMOVED*** else if (typeof then === 'function') ***REMOVED***
          doResolve(bind(then, newValue), self);
          return;
        ***REMOVED***
      ***REMOVED***
      self._state = 1;
      self._value = newValue;
      finale(self);
    ***REMOVED*** catch (e) ***REMOVED***
      reject(self, e);
    ***REMOVED***
  ***REMOVED***

  function reject(self, newValue) ***REMOVED***
    self._state = 2;
    self._value = newValue;
    finale(self);
  ***REMOVED***

  function finale(self) ***REMOVED***
    if (self._state === 2 && self._deferreds.length === 0) ***REMOVED***
      Promise._immediateFn(function() ***REMOVED***
        if (!self._handled) ***REMOVED***
          Promise._unhandledRejectionFn(self._value);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    for (var i = 0, len = self._deferreds.length; i < len; i++) ***REMOVED***
      handle(self, self._deferreds[i]);
    ***REMOVED***
    self._deferreds = null;
  ***REMOVED***

  function Handler(onFulfilled, onRejected, promise) ***REMOVED***
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  ***REMOVED***

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) ***REMOVED***
    var done = false;
    try ***REMOVED***
      fn(function (value) ***REMOVED***
        if (done) return;
        done = true;
        resolve(self, value);
      ***REMOVED***, function (reason) ***REMOVED***
        if (done) return;
        done = true;
        reject(self, reason);
      ***REMOVED***);
    ***REMOVED*** catch (ex) ***REMOVED***
      if (done) return;
      done = true;
      reject(self, ex);
    ***REMOVED***
  ***REMOVED***

  Promise.prototype['catch'] = function (onRejected) ***REMOVED***
    return this.then(null, onRejected);
  ***REMOVED***;

  Promise.prototype.then = function (onFulfilled, onRejected) ***REMOVED***
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  ***REMOVED***;

  Promise.all = function (arr) ***REMOVED***
    return new Promise(function (resolve, reject) ***REMOVED***
      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) ***REMOVED***
        try ***REMOVED***
          if (val && (typeof val === 'object' || typeof val === 'function')) ***REMOVED***
            var then = val.then;
            if (typeof then === 'function') ***REMOVED***
              then.call(val, function (val) ***REMOVED***
                res(i, val);
              ***REMOVED***, reject);
              return;
            ***REMOVED***
          ***REMOVED***
          args[i] = val;
          if (--remaining === 0) ***REMOVED***
            resolve(args);
          ***REMOVED***
        ***REMOVED*** catch (ex) ***REMOVED***
          reject(ex);
        ***REMOVED***
      ***REMOVED***

      for (var i = 0; i < args.length; i++) ***REMOVED***
        res(i, args[i]);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***;

  Promise.resolve = function (value) ***REMOVED***
    if (value && typeof value === 'object' && value.constructor === Promise) ***REMOVED***
      return value;
    ***REMOVED***

    return new Promise(function (resolve) ***REMOVED***
      resolve(value);
    ***REMOVED***);
  ***REMOVED***;

  Promise.reject = function (value) ***REMOVED***
    return new Promise(function (resolve, reject) ***REMOVED***
      reject(value);
    ***REMOVED***);
  ***REMOVED***;

  Promise.race = function (values) ***REMOVED***
    return new Promise(function (resolve, reject) ***REMOVED***
      for (var i = 0, len = values.length; i < len; i++) ***REMOVED***
        values[i].then(resolve, reject);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***;

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) ***REMOVED*** setImmediate(fn); ***REMOVED***) ||
    function (fn) ***REMOVED***
      setTimeoutFunc(fn, 0);
    ***REMOVED***;

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) ***REMOVED***
    if (typeof console !== 'undefined' && console) ***REMOVED***
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    ***REMOVED***
  ***REMOVED***;

  /**
   * Set the immediate function to execute callbacks
   * @param fn ***REMOVED***function***REMOVED*** Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) ***REMOVED***
    Promise._immediateFn = fn;
  ***REMOVED***;

  /**
   * Change the function to execute on unhandled rejection
   * @param ***REMOVED***function***REMOVED*** fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) ***REMOVED***
    Promise._unhandledRejectionFn = fn;
  ***REMOVED***;
  
  if (typeof module !== 'undefined' && module.exports) ***REMOVED***
    module.exports = Promise;
  ***REMOVED*** else if (!root.Promise) ***REMOVED***
    root.Promise = Promise;
  ***REMOVED***

***REMOVED***)(this);
