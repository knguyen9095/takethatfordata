/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

var Source = require("./Source");
var SourceNode = require("source-map").SourceNode;
var SourceListMap = require("source-list-map").SourceListMap;
var fromStringWithSourceMap = require("source-list-map").fromStringWithSourceMap;
var SourceMapConsumer = require("source-map").SourceMapConsumer;

class ReplaceSource extends Source ***REMOVED***
	constructor(source, name) ***REMOVED***
		super();
		this._source = source;
		this._name = name;
		this.replacements = [];
	***REMOVED***

	replace(start, end, newValue) ***REMOVED***
		if(typeof newValue !== "string")
			throw new Error("insertion must be a string, but is a " + typeof newValue);
		this.replacements.push([start, end, newValue, this.replacements.length]);
	***REMOVED***

	insert(pos, newValue) ***REMOVED***
		if(typeof newValue !== "string")
			throw new Error("insertion must be a string, but is a " + typeof newValue + ": " + newValue);
		this.replacements.push([pos, pos - 1, newValue, this.replacements.length]);
	***REMOVED***

	source(options) ***REMOVED***
		return this._replaceString(this._source.source());
	***REMOVED***

	original() ***REMOVED***
		return this._source;
	***REMOVED***

	_sortReplacements() ***REMOVED***
		this.replacements.sort(function(a, b) ***REMOVED***
			var diff = b[1] - a[1];
			if(diff !== 0)
				return diff;
			diff = b[0] - a[0];
			if(diff !== 0)
				return diff;
			return b[3] - a[3];
		***REMOVED***);
	***REMOVED***

	_replaceString(str) ***REMOVED***
		if(typeof str !== "string")
			throw new Error("str must be a string, but is a " + typeof str + ": " + str);
		this._sortReplacements();
		var result = [str];
		this.replacements.forEach(function(repl) ***REMOVED***
			var remSource = result.pop();
			var splitted1 = this._splitString(remSource, Math.floor(repl[1] + 1));
			var splitted2 = this._splitString(splitted1[0], Math.floor(repl[0]));
			result.push(splitted1[1], repl[2], splitted2[0]);
		***REMOVED***, this);

		// write out result array in reverse order
		let resultStr = "";
		for(let i = result.length - 1; i >= 0; --i) ***REMOVED***
			resultStr += result[i];
		***REMOVED***
		return resultStr;
	***REMOVED***

	node(options) ***REMOVED***
		this._sortReplacements();
		var result = [this._source.node(options)];
		this.replacements.forEach(function(repl) ***REMOVED***
			var remSource = result.pop();
			var splitted1 = this._splitSourceNode(remSource, Math.floor(repl[1] + 1));
			var splitted2;
			if(Array.isArray(splitted1)) ***REMOVED***
				splitted2 = this._splitSourceNode(splitted1[0], Math.floor(repl[0]));
				if(Array.isArray(splitted2)) ***REMOVED***
					result.push(splitted1[1], this._replacementToSourceNode(splitted2[1], repl[2]), splitted2[0]);
				***REMOVED*** else ***REMOVED***
					result.push(splitted1[1], this._replacementToSourceNode(splitted1[1], repl[2]), splitted1[0]);
				***REMOVED***
			***REMOVED*** else ***REMOVED***
				splitted2 = this._splitSourceNode(remSource, Math.floor(repl[0]));
				if(Array.isArray(splitted2)) ***REMOVED***
					result.push(this._replacementToSourceNode(splitted2[1], repl[2]), splitted2[0]);
				***REMOVED*** else ***REMOVED***
					result.push(repl[2], remSource);
				***REMOVED***
			***REMOVED***
		***REMOVED***, this);
		result = result.reverse();
		return new SourceNode(null, null, null, result);
	***REMOVED***

	listMap(options) ***REMOVED***
		this._sortReplacements();
		var map = this._source.listMap(options);
		var currentIndex = 0;
		var replacements = this.replacements;
		var idxReplacement = replacements.length - 1;
		var removeChars = 0;
		map = map.mapGeneratedCode(function(str) ***REMOVED***
			var newCurrentIndex = currentIndex + str.length;
			if(removeChars > str.length) ***REMOVED***
				removeChars -= str.length;
				str = "";
			***REMOVED*** else ***REMOVED***
				if(removeChars > 0) ***REMOVED***
					str = str.substr(removeChars);
					currentIndex += removeChars;
					removeChars = 0;
				***REMOVED***
				var finalStr = "";
				while(idxReplacement >= 0 && replacements[idxReplacement][0] < newCurrentIndex) ***REMOVED***
					var repl = replacements[idxReplacement];
					var start = Math.floor(repl[0]);
					var end = Math.floor(repl[1] + 1);
					var before = str.substr(0, Math.max(0, start - currentIndex));
					if(end <= newCurrentIndex) ***REMOVED***
						var after = str.substr(Math.max(0, end - currentIndex));
						finalStr += before + repl[2];
						str = after;
						currentIndex = Math.max(currentIndex, end);
					***REMOVED*** else ***REMOVED***
						finalStr += before + repl[2];
						str = "";
						removeChars = end - newCurrentIndex;
					***REMOVED***
					idxReplacement--;
				***REMOVED***
				str = finalStr + str;
			***REMOVED***
			currentIndex = newCurrentIndex;
			return str;
		***REMOVED***);
		var extraCode = "";
		while(idxReplacement >= 0) ***REMOVED***
			extraCode += replacements[idxReplacement][2];
			idxReplacement--;
		***REMOVED***
		if(extraCode) ***REMOVED***
			map.add(extraCode);
		***REMOVED***
		return map;
	***REMOVED***

	_replacementToSourceNode(oldNode, newString) ***REMOVED***
		var map = oldNode.toStringWithSourceMap(***REMOVED***
			file: "?"
		***REMOVED***).map;
		var original = new SourceMapConsumer(map.toJSON()).originalPositionFor(***REMOVED***
			line: 1,
			column: 0
		***REMOVED***);
		if(original) ***REMOVED***
			return new SourceNode(original.line, original.column, original.source, newString);
		***REMOVED*** else ***REMOVED***
			return newString;
		***REMOVED***
	***REMOVED***

	_splitSourceNode(node, position) ***REMOVED***
		if(typeof node === "string") ***REMOVED***
			if(node.length <= position) return position - node.length;
			return position <= 0 ? ["", node] : [node.substr(0, position), node.substr(position)];
		***REMOVED*** else ***REMOVED***
			for(var i = 0; i < node.children.length; i++) ***REMOVED***
				position = this._splitSourceNode(node.children[i], position);
				if(Array.isArray(position)) ***REMOVED***
					var leftNode = new SourceNode(
						node.line,
						node.column,
						node.source,
						node.children.slice(0, i).concat([position[0]]),
						node.name
					);
					var rightNode = new SourceNode(
						node.line,
						node.column,
						node.source, [position[1]].concat(node.children.slice(i + 1)),
						node.name
					);
					leftNode.sourceContents = node.sourceContents;
					return [leftNode, rightNode];
				***REMOVED***
			***REMOVED***
			return position;
		***REMOVED***
	***REMOVED***

	_splitString(str, position) ***REMOVED***
		return position <= 0 ? ["", str] : [str.substr(0, position), str.substr(position)];
	***REMOVED***
***REMOVED***

require("./SourceAndMapMixin")(ReplaceSource.prototype);

module.exports = ReplaceSource;
