/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var normalize = require("./normalize");
var errors = require("errno");
var stream = require("readable-stream");

var ReadableStream = stream.Readable;
var WritableStream = stream.Writable;

function MemoryFileSystemError(err, path) ***REMOVED***
	Error.call(this)
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, arguments.callee)
	this.code = err.code;
	this.errno = err.errno;
	this.message = err.description;
	this.path = path;
***REMOVED***
MemoryFileSystemError.prototype = new Error();

function MemoryFileSystem(data) ***REMOVED***
	this.data = data || ***REMOVED******REMOVED***;
***REMOVED***
module.exports = MemoryFileSystem;

function isDir(item) ***REMOVED***
	if(typeof item !== "object") return false;
	return item[""] === true;
***REMOVED***

function isFile(item) ***REMOVED***
	if(typeof item !== "object") return false;
	return !item[""];
***REMOVED***

function pathToArray(path) ***REMOVED***
	path = normalize(path);
	var nix = /^\//.test(path);
	if(!nix) ***REMOVED***
		if(!/^[A-Za-z]:/.test(path)) ***REMOVED***
			throw new MemoryFileSystemError(errors.code.EINVAL, path);
		***REMOVED***
		path = path.replace(/[\\\/]+/g, "\\"); // multi slashs
		path = path.split(/[\\\/]/);
		path[0] = path[0].toUpperCase();
	***REMOVED*** else ***REMOVED***
		path = path.replace(/\/+/g, "/"); // multi slashs
		path = path.substr(1).split("/");
	***REMOVED***
	if(!path[path.length-1]) path.pop();
	return path;
***REMOVED***

function trueFn() ***REMOVED*** return true; ***REMOVED***
function falseFn() ***REMOVED*** return false; ***REMOVED***

MemoryFileSystem.prototype.meta = function(_path) ***REMOVED***
	var path = pathToArray(_path);
	var current = this.data;
	for(var i = 0; i < path.length - 1; i++) ***REMOVED***
		if(!isDir(current[path[i]]))
			return;
		current = current[path[i]];
	***REMOVED***
	return current[path[i]];
***REMOVED***

MemoryFileSystem.prototype.existsSync = function(_path) ***REMOVED***
	return !!this.meta(_path);
***REMOVED***

MemoryFileSystem.prototype.statSync = function(_path) ***REMOVED***
	var current = this.meta(_path);
	if(_path === "/" || isDir(current)) ***REMOVED***
		return ***REMOVED***
			isFile: falseFn,
			isDirectory: trueFn,
			isBlockDevice: falseFn,
			isCharacterDevice: falseFn,
			isSymbolicLink: falseFn,
			isFIFO: falseFn,
			isSocket: falseFn
		***REMOVED***;
	***REMOVED*** else if(isFile(current)) ***REMOVED***
		return ***REMOVED***
			isFile: trueFn,
			isDirectory: falseFn,
			isBlockDevice: falseFn,
			isCharacterDevice: falseFn,
			isSymbolicLink: falseFn,
			isFIFO: falseFn,
			isSocket: falseFn
		***REMOVED***;
	***REMOVED*** else ***REMOVED***
		throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	***REMOVED***
***REMOVED***;

MemoryFileSystem.prototype.readFileSync = function(_path, encoding) ***REMOVED***
	var path = pathToArray(_path);
	var current = this.data;
	for(var i = 0; i < path.length - 1; i++) ***REMOVED***
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	***REMOVED***
	if(!isFile(current[path[i]])) ***REMOVED***
		if(isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.EISDIR, _path);
		else
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	***REMOVED***
	current = current[path[i]];
	return encoding ? current.toString(encoding) : current;
***REMOVED***;

MemoryFileSystem.prototype.readdirSync = function(_path) ***REMOVED***
	if(_path === "/") return Object.keys(this.data).filter(Boolean);
	var path = pathToArray(_path);
	var current = this.data;
	for(var i = 0; i < path.length - 1; i++) ***REMOVED***
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	***REMOVED***
	if(!isDir(current[path[i]])) ***REMOVED***
		if(isFile(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);
		else
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	***REMOVED***
	return Object.keys(current[path[i]]).filter(Boolean);
***REMOVED***;

MemoryFileSystem.prototype.mkdirpSync = function(_path) ***REMOVED***
	var path = pathToArray(_path);
	if(path.length === 0) return;
	var current = this.data;
	for(var i = 0; i < path.length; i++) ***REMOVED***
		if(isFile(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);
		else if(!isDir(current[path[i]]))
			current[path[i]] = ***REMOVED***"":true***REMOVED***;
		current = current[path[i]];
	***REMOVED***
	return;
***REMOVED***;

MemoryFileSystem.prototype.mkdirSync = function(_path) ***REMOVED***
	var path = pathToArray(_path);
	if(path.length === 0) return;
	var current = this.data;
	for(var i = 0; i < path.length - 1; i++) ***REMOVED***
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	***REMOVED***
	if(isDir(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.EEXIST, _path);
	else if(isFile(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);
	current[path[i]] = ***REMOVED***"":true***REMOVED***;
	return;
***REMOVED***;

MemoryFileSystem.prototype._remove = function(_path, name, testFn) ***REMOVED***
	var path = pathToArray(_path);
	if(path.length === 0) ***REMOVED***
		throw new MemoryFileSystemError(errors.code.EPERM, _path);
	***REMOVED***
	var current = this.data;
	for(var i = 0; i < path.length - 1; i++) ***REMOVED***
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	***REMOVED***
	if(!testFn(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	delete current[path[i]];
	return;
***REMOVED***;

MemoryFileSystem.prototype.rmdirSync = function(_path) ***REMOVED***
	return this._remove(_path, "Directory", isDir);
***REMOVED***;

MemoryFileSystem.prototype.unlinkSync = function(_path) ***REMOVED***
	return this._remove(_path, "File", isFile);
***REMOVED***;

MemoryFileSystem.prototype.readlinkSync = function(_path) ***REMOVED***
	throw new MemoryFileSystemError(errors.code.ENOSYS, _path);
***REMOVED***;

MemoryFileSystem.prototype.writeFileSync = function(_path, content, encoding) ***REMOVED***
	if(!content && !encoding) throw new Error("No content");
	var path = pathToArray(_path);
	if(path.length === 0) ***REMOVED***
		throw new MemoryFileSystemError(errors.code.EISDIR, _path);
	***REMOVED***
	var current = this.data;
	for(var i = 0; i < path.length - 1; i++) ***REMOVED***
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	***REMOVED***
	if(isDir(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.EISDIR, _path);
	current[path[i]] = encoding || typeof content === "string" ? new Buffer(content, encoding) : content;
	return;
***REMOVED***;

MemoryFileSystem.prototype.join = require("./join");
MemoryFileSystem.prototype.pathToArray = pathToArray;
MemoryFileSystem.prototype.normalize = normalize;

// stream functions

MemoryFileSystem.prototype.createReadStream = function(path, options) ***REMOVED***
	var stream = new ReadableStream();
	var done = false;
	var data;
	try ***REMOVED***
		data = this.readFileSync(path);
	***REMOVED*** catch (e) ***REMOVED***
		stream._read = function() ***REMOVED***
			if (done) ***REMOVED***
				return;
			***REMOVED***
			done = true;
			this.emit('error', e);
			this.push(null);
		***REMOVED***;
		return stream;
	***REMOVED***
	options = options || ***REMOVED*** ***REMOVED***;
	options.start = options.start || 0;
	options.end = options.end || data.length;
	stream._read = function() ***REMOVED***
		if (done) ***REMOVED***
			return;
		***REMOVED***
		done = true;
		this.push(data.slice(options.start, options.end));
		this.push(null);
	***REMOVED***;
	return stream;
***REMOVED***;

MemoryFileSystem.prototype.createWriteStream = function(path, options) ***REMOVED***
	var stream = new WritableStream(), self = this;
	try ***REMOVED***
		// Zero the file and make sure it is writable
		this.writeFileSync(path, new Buffer(0));
	***REMOVED*** catch(e) ***REMOVED***
		// This or setImmediate?
		stream.once('prefinish', function() ***REMOVED***
			stream.emit('error', e);
		***REMOVED***);
		return stream;
	***REMOVED***
	var bl = [ ], len = 0;
	stream._write = function(chunk, encoding, callback) ***REMOVED***
		bl.push(chunk);
		len += chunk.length;
		self.writeFile(path, Buffer.concat(bl, len), callback);
	***REMOVED***
	return stream;
***REMOVED***;

// async functions

["stat", "readdir", "mkdirp", "rmdir", "unlink", "readlink"].forEach(function(fn) ***REMOVED***
	MemoryFileSystem.prototype[fn] = function(path, callback) ***REMOVED***
		try ***REMOVED***
			var result = this[fn + "Sync"](path);
		***REMOVED*** catch(e) ***REMOVED***
			setImmediate(function() ***REMOVED***
				callback(e);
			***REMOVED***);

			return;
		***REMOVED***
		setImmediate(function() ***REMOVED***
			callback(null, result);
		***REMOVED***);
	***REMOVED***;
***REMOVED***);

["mkdir", "readFile"].forEach(function(fn) ***REMOVED***
	MemoryFileSystem.prototype[fn] = function(path, optArg, callback) ***REMOVED***
		if(!callback) ***REMOVED***
			callback = optArg;
			optArg = undefined;
		***REMOVED***
		try ***REMOVED***
			var result = this[fn + "Sync"](path, optArg);
		***REMOVED*** catch(e) ***REMOVED***
			setImmediate(function() ***REMOVED***
				callback(e);
			***REMOVED***);

			return;
		***REMOVED***
		setImmediate(function() ***REMOVED***
			callback(null, result);
		***REMOVED***);
	***REMOVED***;
***REMOVED***);

MemoryFileSystem.prototype.exists = function(path, callback) ***REMOVED***
	return callback(this.existsSync(path));
***REMOVED***

MemoryFileSystem.prototype.writeFile = function (path, content, encoding, callback) ***REMOVED***
	if(!callback) ***REMOVED***
		callback = encoding;
		encoding = undefined;
	***REMOVED***
	try ***REMOVED***
		this.writeFileSync(path, content, encoding);
	***REMOVED*** catch(e) ***REMOVED***
		return callback(e);
	***REMOVED***
	return callback();
***REMOVED***;
