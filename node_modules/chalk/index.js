'use strict';
const escapeStringRegexp = require('escape-string-regexp');
const ansiStyles = require('ansi-styles');
const supportsColor = require('supports-color');

const template = require('./templates.js');

const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];

// `color-convert` models to exclude from the Chalk API due to conflicts and such
const skipModels = new Set(['gray']);

const styles = Object.create(null);

function applyOptions(obj, options) ***REMOVED***
	options = options || ***REMOVED******REMOVED***;

	// Detect level if not set manually
	const scLevel = supportsColor ? supportsColor.level : 0;
	obj.level = options.level === undefined ? scLevel : options.level;
	obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
***REMOVED***

function Chalk(options) ***REMOVED***
	// We check for this.template here since calling `chalk.constructor()`
	// by itself will have a `this` of a previously constructed chalk object
	if (!this || !(this instanceof Chalk) || this.template) ***REMOVED***
		const chalk = ***REMOVED******REMOVED***;
		applyOptions(chalk, options);

		chalk.template = function () ***REMOVED***
			const args = [].slice.call(arguments);
			return chalkTag.apply(null, [chalk.template].concat(args));
		***REMOVED***;

		Object.setPrototypeOf(chalk, Chalk.prototype);
		Object.setPrototypeOf(chalk.template, chalk);

		chalk.template.constructor = Chalk;

		return chalk.template;
	***REMOVED***

	applyOptions(this, options);
***REMOVED***

// Use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) ***REMOVED***
	ansiStyles.blue.open = '\u001B[94m';
***REMOVED***

for (const key of Object.keys(ansiStyles)) ***REMOVED***
	ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

	styles[key] = ***REMOVED***
		get() ***REMOVED***
			const codes = ansiStyles[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		***REMOVED***
	***REMOVED***;
***REMOVED***

styles.visible = ***REMOVED***
	get() ***REMOVED***
		return build.call(this, this._styles || [], true, 'visible');
	***REMOVED***
***REMOVED***;

ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
for (const model of Object.keys(ansiStyles.color.ansi)) ***REMOVED***
	if (skipModels.has(model)) ***REMOVED***
		continue;
	***REMOVED***

	styles[model] = ***REMOVED***
		get() ***REMOVED***
			const level = this.level;
			return function () ***REMOVED***
				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
				const codes = ***REMOVED***
					open,
					close: ansiStyles.color.close,
					closeRe: ansiStyles.color.closeRe
				***REMOVED***;
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			***REMOVED***;
		***REMOVED***
	***REMOVED***;
***REMOVED***

ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
for (const model of Object.keys(ansiStyles.bgColor.ansi)) ***REMOVED***
	if (skipModels.has(model)) ***REMOVED***
		continue;
	***REMOVED***

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = ***REMOVED***
		get() ***REMOVED***
			const level = this.level;
			return function () ***REMOVED***
				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = ***REMOVED***
					open,
					close: ansiStyles.bgColor.close,
					closeRe: ansiStyles.bgColor.closeRe
				***REMOVED***;
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			***REMOVED***;
		***REMOVED***
	***REMOVED***;
***REMOVED***

const proto = Object.defineProperties(() => ***REMOVED******REMOVED***, styles);

function build(_styles, _empty, key) ***REMOVED***
	const builder = function () ***REMOVED***
		return applyStyle.apply(builder, arguments);
	***REMOVED***;

	builder._styles = _styles;
	builder._empty = _empty;

	const self = this;

	Object.defineProperty(builder, 'level', ***REMOVED***
		enumerable: true,
		get() ***REMOVED***
			return self.level;
		***REMOVED***,
		set(level) ***REMOVED***
			self.level = level;
		***REMOVED***
	***REMOVED***);

	Object.defineProperty(builder, 'enabled', ***REMOVED***
		enumerable: true,
		get() ***REMOVED***
			return self.enabled;
		***REMOVED***,
		set(enabled) ***REMOVED***
			self.enabled = enabled;
		***REMOVED***
	***REMOVED***);

	// See below for fix regarding invisible grey/dim combination on Windows
	builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	return builder;
***REMOVED***

function applyStyle() ***REMOVED***
	// Support varags, but simply cast to string in case there's only one arg
	const args = arguments;
	const argsLen = args.length;
	let str = String(arguments[0]);

	if (argsLen === 0) ***REMOVED***
		return '';
	***REMOVED***

	if (argsLen > 1) ***REMOVED***
		// Don't slice `arguments`, it prevents V8 optimizations
		for (let a = 1; a < argsLen; a++) ***REMOVED***
			str += ' ' + args[a];
		***REMOVED***
	***REMOVED***

	if (!this.enabled || this.level <= 0 || !str) ***REMOVED***
		return this._empty ? '' : str;
	***REMOVED***

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	const originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && this.hasGrey) ***REMOVED***
		ansiStyles.dim.open = '';
	***REMOVED***

	for (const code of this._styles.slice().reverse()) ***REMOVED***
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;

		// Close the styling before a linebreak and reopen
		// after next line to fix a bleed issue on macOS
		// https://github.com/chalk/chalk/pull/92
		str = str.replace(/\r?\n/g, `$***REMOVED***code.close***REMOVED***$&$***REMOVED***code.open***REMOVED***`);
	***REMOVED***

	// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
	ansiStyles.dim.open = originalDim;

	return str;
***REMOVED***

function chalkTag(chalk, strings) ***REMOVED***
	if (!Array.isArray(strings)) ***REMOVED***
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return [].slice.call(arguments, 1).join(' ');
	***REMOVED***

	const args = [].slice.call(arguments, 2);
	const parts = [strings.raw[0]];

	for (let i = 1; i < strings.length; i++) ***REMOVED***
		parts.push(String(args[i - 1]).replace(/[***REMOVED******REMOVED***\\]/g, '\\$&'));
		parts.push(String(strings.raw[i]));
	***REMOVED***

	return template(chalk, parts.join(''));
***REMOVED***

Object.defineProperties(Chalk.prototype, styles);

module.exports = Chalk(); // eslint-disable-line new-cap
module.exports.supportsColor = supportsColor;
module.exports.default = module.exports; // For TypeScript
