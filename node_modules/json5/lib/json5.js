// json5.js
// Modern JSON. See README.md for details.
//
// This file is based directly off of Douglas Crockford's json_parse.js:
// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

var JSON5 = (typeof exports === 'object' ? exports : ***REMOVED******REMOVED***);

JSON5.parse = (function () ***REMOVED***
    "use strict";

// This is a function that can parse a JSON5 text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON5 parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,           // The index of the current character
        lineNumber,   // The current line number
        columnNumber, // The current column number
        ch,           // The current character
        escapee = ***REMOVED***
            "'":  "'",
            '"':  '"',
            '\\': '\\',
            '/':  '/',
            '\n': '',       // Replace escaped newlines in strings w/ empty string
            b:    '\b',
            f:    '\f',
            n:    '\n',
            r:    '\r',
            t:    '\t'
        ***REMOVED***,
        ws = [
            ' ',
            '\t',
            '\r',
            '\n',
            '\v',
            '\f',
            '\xA0',
            '\uFEFF'
        ],
        text,

        renderChar = function (chr) ***REMOVED***
            return chr === '' ? 'EOF' : "'" + chr + "'";
        ***REMOVED***,

        error = function (m) ***REMOVED***

// Call error when something is wrong.

            var error = new SyntaxError();
            // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
            error.message = m + " at line " + lineNumber + " column " + columnNumber + " of the JSON5 data. Still to read: " + JSON.stringify(text.substring(at - 1, at + 19));
            error.at = at;
            // These two property names have been chosen to agree with the ones in Gecko, the only popular
            // environment which seems to supply this info on JSON.parse
            error.lineNumber = lineNumber;
            error.columnNumber = columnNumber;
            throw error;
        ***REMOVED***,

        next = function (c) ***REMOVED***

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) ***REMOVED***
                error("Expected " + renderChar(c) + " instead of " + renderChar(ch));
            ***REMOVED***

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at++;
            columnNumber++;
            if (ch === '\n' || ch === '\r' && peek() !== '\n') ***REMOVED***
                lineNumber++;
                columnNumber = 0;
            ***REMOVED***
            return ch;
        ***REMOVED***,

        peek = function () ***REMOVED***

// Get the next character without consuming it or
// assigning it to the ch varaible.

            return text.charAt(at);
        ***REMOVED***,

        identifier = function () ***REMOVED***

// Parse an identifier. Normally, reserved words are disallowed here, but we
// only use this for unquoted object keys, where reserved words are allowed,
// so we don't check for those here. References:
// - http://es5.github.com/#x7.6
// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
// TODO Identifiers can have Unicode "letters" in them; add support for those.

            var key = ch;

            // Identifiers must start with a letter, _ or $.
            if ((ch !== '_' && ch !== '$') &&
                    (ch < 'a' || ch > 'z') &&
                    (ch < 'A' || ch > 'Z')) ***REMOVED***
                error("Bad identifier as unquoted key");
            ***REMOVED***

            // Subsequent characters can contain digits.
            while (next() && (
                    ch === '_' || ch === '$' ||
                    (ch >= 'a' && ch <= 'z') ||
                    (ch >= 'A' && ch <= 'Z') ||
                    (ch >= '0' && ch <= '9'))) ***REMOVED***
                key += ch;
            ***REMOVED***

            return key;
        ***REMOVED***,

        number = function () ***REMOVED***

// Parse a number value.

            var number,
                sign = '',
                string = '',
                base = 10;

            if (ch === '-' || ch === '+') ***REMOVED***
                sign = ch;
                next(ch);
            ***REMOVED***

            // support for Infinity (could tweak to allow other words):
            if (ch === 'I') ***REMOVED***
                number = word();
                if (typeof number !== 'number' || isNaN(number)) ***REMOVED***
                    error('Unexpected word for number');
                ***REMOVED***
                return (sign === '-') ? -number : number;
            ***REMOVED***

            // support for NaN
            if (ch === 'N' ) ***REMOVED***
              number = word();
              if (!isNaN(number)) ***REMOVED***
                error('expected word to be NaN');
              ***REMOVED***
              // ignore sign as -NaN also is NaN
              return number;
            ***REMOVED***

            if (ch === '0') ***REMOVED***
                string += ch;
                next();
                if (ch === 'x' || ch === 'X') ***REMOVED***
                    string += ch;
                    next();
                    base = 16;
                ***REMOVED*** else if (ch >= '0' && ch <= '9') ***REMOVED***
                    error('Octal literal');
                ***REMOVED***
            ***REMOVED***

            switch (base) ***REMOVED***
            case 10:
                while (ch >= '0' && ch <= '9' ) ***REMOVED***
                    string += ch;
                    next();
                ***REMOVED***
                if (ch === '.') ***REMOVED***
                    string += '.';
                    while (next() && ch >= '0' && ch <= '9') ***REMOVED***
                        string += ch;
                    ***REMOVED***
                ***REMOVED***
                if (ch === 'e' || ch === 'E') ***REMOVED***
                    string += ch;
                    next();
                    if (ch === '-' || ch === '+') ***REMOVED***
                        string += ch;
                        next();
                    ***REMOVED***
                    while (ch >= '0' && ch <= '9') ***REMOVED***
                        string += ch;
                        next();
                    ***REMOVED***
                ***REMOVED***
                break;
            case 16:
                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') ***REMOVED***
                    string += ch;
                    next();
                ***REMOVED***
                break;
            ***REMOVED***

            if(sign === '-') ***REMOVED***
                number = -string;
            ***REMOVED*** else ***REMOVED***
                number = +string;
            ***REMOVED***

            if (!isFinite(number)) ***REMOVED***
                error("Bad number");
            ***REMOVED*** else ***REMOVED***
                return number;
            ***REMOVED***
        ***REMOVED***,

        string = function () ***REMOVED***

// Parse a string value.

            var hex,
                i,
                string = '',
                delim,      // double quote or single quote
                uffff;

// When parsing for string values, we must look for ' or " and \ characters.

            if (ch === '"' || ch === "'") ***REMOVED***
                delim = ch;
                while (next()) ***REMOVED***
                    if (ch === delim) ***REMOVED***
                        next();
                        return string;
                    ***REMOVED*** else if (ch === '\\') ***REMOVED***
                        next();
                        if (ch === 'u') ***REMOVED***
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) ***REMOVED***
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) ***REMOVED***
                                    break;
                                ***REMOVED***
                                uffff = uffff * 16 + hex;
                            ***REMOVED***
                            string += String.fromCharCode(uffff);
                        ***REMOVED*** else if (ch === '\r') ***REMOVED***
                            if (peek() === '\n') ***REMOVED***
                                next();
                            ***REMOVED***
                        ***REMOVED*** else if (typeof escapee[ch] === 'string') ***REMOVED***
                            string += escapee[ch];
                        ***REMOVED*** else ***REMOVED***
                            break;
                        ***REMOVED***
                    ***REMOVED*** else if (ch === '\n') ***REMOVED***
                        // unescaped newlines are invalid; see:
                        // https://github.com/aseemk/json5/issues/24
                        // TODO this feels special-cased; are there other
                        // invalid unescaped chars?
                        break;
                    ***REMOVED*** else ***REMOVED***
                        string += ch;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            error("Bad string");
        ***REMOVED***,

        inlineComment = function () ***REMOVED***

// Skip an inline comment, assuming this is one. The current character should
// be the second / character in the // pair that begins this inline comment.
// To finish the inline comment, we look for a newline or the end of the text.

            if (ch !== '/') ***REMOVED***
                error("Not an inline comment");
            ***REMOVED***

            do ***REMOVED***
                next();
                if (ch === '\n' || ch === '\r') ***REMOVED***
                    next();
                    return;
                ***REMOVED***
            ***REMOVED*** while (ch);
        ***REMOVED***,

        blockComment = function () ***REMOVED***

// Skip a block comment, assuming this is one. The current character should be
// the * character in the /* pair that begins this block comment.
// To finish the block comment, we look for an ending */ pair of characters,
// but we also watch for the end of text before the comment is terminated.

            if (ch !== '*') ***REMOVED***
                error("Not a block comment");
            ***REMOVED***

            do ***REMOVED***
                next();
                while (ch === '*') ***REMOVED***
                    next('*');
                    if (ch === '/') ***REMOVED***
                        next('/');
                        return;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED*** while (ch);

            error("Unterminated block comment");
        ***REMOVED***,

        comment = function () ***REMOVED***

// Skip a comment, whether inline or block-level, assuming this is one.
// Comments always begin with a / character.

            if (ch !== '/') ***REMOVED***
                error("Not a comment");
            ***REMOVED***

            next('/');

            if (ch === '/') ***REMOVED***
                inlineComment();
            ***REMOVED*** else if (ch === '*') ***REMOVED***
                blockComment();
            ***REMOVED*** else ***REMOVED***
                error("Unrecognized comment");
            ***REMOVED***
        ***REMOVED***,

        white = function () ***REMOVED***

// Skip whitespace and comments.
// Note that we're detecting comments by only a single / character.
// This works since regular expressions are not valid JSON(5), but this will
// break if there are other valid values that begin with a / character!

            while (ch) ***REMOVED***
                if (ch === '/') ***REMOVED***
                    comment();
                ***REMOVED*** else if (ws.indexOf(ch) >= 0) ***REMOVED***
                    next();
                ***REMOVED*** else ***REMOVED***
                    return;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***,

        word = function () ***REMOVED***

// true, false, or null.

            switch (ch) ***REMOVED***
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            case 'I':
                next('I');
                next('n');
                next('f');
                next('i');
                next('n');
                next('i');
                next('t');
                next('y');
                return Infinity;
            case 'N':
              next( 'N' );
              next( 'a' );
              next( 'N' );
              return NaN;
            ***REMOVED***
            error("Unexpected " + renderChar(ch));
        ***REMOVED***,

        value,  // Place holder for the value function.

        array = function () ***REMOVED***

// Parse an array value.

            var array = [];

            if (ch === '[') ***REMOVED***
                next('[');
                white();
                while (ch) ***REMOVED***
                    if (ch === ']') ***REMOVED***
                        next(']');
                        return array;   // Potentially empty array
                    ***REMOVED***
                    // ES5 allows omitting elements in arrays, e.g. [,] and
                    // [,null]. We don't allow this in JSON5.
                    if (ch === ',') ***REMOVED***
                        error("Missing array element");
                    ***REMOVED*** else ***REMOVED***
                        array.push(value());
                    ***REMOVED***
                    white();
                    // If there's no comma after this value, this needs to
                    // be the end of the array.
                    if (ch !== ',') ***REMOVED***
                        next(']');
                        return array;
                    ***REMOVED***
                    next(',');
                    white();
                ***REMOVED***
            ***REMOVED***
            error("Bad array");
        ***REMOVED***,

        object = function () ***REMOVED***

// Parse an object value.

            var key,
                object = ***REMOVED******REMOVED***;

            if (ch === '***REMOVED***') ***REMOVED***
                next('***REMOVED***');
                white();
                while (ch) ***REMOVED***
                    if (ch === '***REMOVED***') ***REMOVED***
                        next('***REMOVED***');
                        return object;   // Potentially empty object
                    ***REMOVED***

                    // Keys can be unquoted. If they are, they need to be
                    // valid JS identifiers.
                    if (ch === '"' || ch === "'") ***REMOVED***
                        key = string();
                    ***REMOVED*** else ***REMOVED***
                        key = identifier();
                    ***REMOVED***

                    white();
                    next(':');
                    object[key] = value();
                    white();
                    // If there's no comma after this pair, this needs to be
                    // the end of the object.
                    if (ch !== ',') ***REMOVED***
                        next('***REMOVED***');
                        return object;
                    ***REMOVED***
                    next(',');
                    white();
                ***REMOVED***
            ***REMOVED***
            error("Bad object");
        ***REMOVED***;

    value = function () ***REMOVED***

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) ***REMOVED***
        case '***REMOVED***':
            return object();
        case '[':
            return array();
        case '"':
        case "'":
            return string();
        case '-':
        case '+':
        case '.':
            return number();
        default:
            return ch >= '0' && ch <= '9' ? number() : word();
        ***REMOVED***
    ***REMOVED***;

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source, reviver) ***REMOVED***
        var result;

        text = String(source);
        at = 0;
        lineNumber = 1;
        columnNumber = 1;
        ch = ' ';
        result = value();
        white();
        if (ch) ***REMOVED***
            error("Syntax error");
        ***REMOVED***

// If there is a reviver function, we recursively walk the new structure,
// passing each name/value pair to the reviver function for possible
// transformation, starting with a temporary root object that holds the result
// in an empty key. If there is not a reviver function, we simply return the
// result.

        return typeof reviver === 'function' ? (function walk(holder, key) ***REMOVED***
            var k, v, value = holder[key];
            if (value && typeof value === 'object') ***REMOVED***
                for (k in value) ***REMOVED***
                    if (Object.prototype.hasOwnProperty.call(value, k)) ***REMOVED***
                        v = walk(value, k);
                        if (v !== undefined) ***REMOVED***
                            value[k] = v;
                        ***REMOVED*** else ***REMOVED***
                            delete value[k];
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return reviver.call(holder, key, value);
        ***REMOVED***(***REMOVED***'': result***REMOVED***, '')) : result;
    ***REMOVED***;
***REMOVED***());

// JSON5 stringify will not quote keys where appropriate
JSON5.stringify = function (obj, replacer, space) ***REMOVED***
    if (replacer && (typeof(replacer) !== "function" && !isArray(replacer))) ***REMOVED***
        throw new Error('Replacer must be a function or an array');
    ***REMOVED***
    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) ***REMOVED***
        var value = holder[key];

        // Replace the value with its toJSON value first, if possible
        if (value && value.toJSON && typeof value.toJSON === "function") ***REMOVED***
            value = value.toJSON();
        ***REMOVED***

        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for
        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).
        if (typeof(replacer) === "function") ***REMOVED***
            return replacer.call(holder, key, value);
        ***REMOVED*** else if(replacer) ***REMOVED***
            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) ***REMOVED***
                return value;
            ***REMOVED*** else ***REMOVED***
                return undefined;
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            return value;
        ***REMOVED***
    ***REMOVED***;

    function isWordChar(c) ***REMOVED***
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            (c >= '0' && c <= '9') ||
            c === '_' || c === '$';
    ***REMOVED***

    function isWordStart(c) ***REMOVED***
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            c === '_' || c === '$';
    ***REMOVED***

    function isWord(key) ***REMOVED***
        if (typeof key !== 'string') ***REMOVED***
            return false;
        ***REMOVED***
        if (!isWordStart(key[0])) ***REMOVED***
            return false;
        ***REMOVED***
        var i = 1, length = key.length;
        while (i < length) ***REMOVED***
            if (!isWordChar(key[i])) ***REMOVED***
                return false;
            ***REMOVED***
            i++;
        ***REMOVED***
        return true;
    ***REMOVED***

    // export for use in tests
    JSON5.isWord = isWord;

    // polyfills
    function isArray(obj) ***REMOVED***
        if (Array.isArray) ***REMOVED***
            return Array.isArray(obj);
        ***REMOVED*** else ***REMOVED***
            return Object.prototype.toString.call(obj) === '[object Array]';
        ***REMOVED***
    ***REMOVED***

    function isDate(obj) ***REMOVED***
        return Object.prototype.toString.call(obj) === '[object Date]';
    ***REMOVED***

    var objStack = [];
    function checkForCircular(obj) ***REMOVED***
        for (var i = 0; i < objStack.length; i++) ***REMOVED***
            if (objStack[i] === obj) ***REMOVED***
                throw new TypeError("Converting circular structure to JSON");
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    function makeIndent(str, num, noNewLine) ***REMOVED***
        if (!str) ***REMOVED***
            return "";
        ***REMOVED***
        // indentation no more than 10 chars
        if (str.length > 10) ***REMOVED***
            str = str.substring(0, 10);
        ***REMOVED***

        var indent = noNewLine ? "" : "\n";
        for (var i = 0; i < num; i++) ***REMOVED***
            indent += str;
        ***REMOVED***

        return indent;
    ***REMOVED***

    var indentStr;
    if (space) ***REMOVED***
        if (typeof space === "string") ***REMOVED***
            indentStr = space;
        ***REMOVED*** else if (typeof space === "number" && space >= 0) ***REMOVED***
            indentStr = makeIndent(" ", space, true);
        ***REMOVED*** else ***REMOVED***
            // ignore space parameter
        ***REMOVED***
    ***REMOVED***

    // Copied from Crokford's implementation of JSON
    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
    // Begin
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = ***REMOVED*** // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    ***REMOVED***;
    function escapeString(string) ***REMOVED***

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) ***REMOVED***
            var c = meta[a];
            return typeof c === 'string' ?
                c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        ***REMOVED***) + '"' : '"' + string + '"';
    ***REMOVED***
    // End

    function internalStringify(holder, key, isTopLevel) ***REMOVED***
        var buffer, res;

        // Replace the value, if necessary
        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);

        if (obj_part && !isDate(obj_part)) ***REMOVED***
            // unbox objects
            // don't unbox dates, since will turn it into number
            obj_part = obj_part.valueOf();
        ***REMOVED***
        switch(typeof obj_part) ***REMOVED***
            case "boolean":
                return obj_part.toString();

            case "number":
                if (isNaN(obj_part) || !isFinite(obj_part)) ***REMOVED***
                    return "null";
                ***REMOVED***
                return obj_part.toString();

            case "string":
                return escapeString(obj_part.toString());

            case "object":
                if (obj_part === null) ***REMOVED***
                    return "null";
                ***REMOVED*** else if (isArray(obj_part)) ***REMOVED***
                    checkForCircular(obj_part);
                    buffer = "[";
                    objStack.push(obj_part);

                    for (var i = 0; i < obj_part.length; i++) ***REMOVED***
                        res = internalStringify(obj_part, i, false);
                        buffer += makeIndent(indentStr, objStack.length);
                        if (res === null || typeof res === "undefined") ***REMOVED***
                            buffer += "null";
                        ***REMOVED*** else ***REMOVED***
                            buffer += res;
                        ***REMOVED***
                        if (i < obj_part.length-1) ***REMOVED***
                            buffer += ",";
                        ***REMOVED*** else if (indentStr) ***REMOVED***
                            buffer += "\n";
                        ***REMOVED***
                    ***REMOVED***
                    objStack.pop();
                    if (obj_part.length) ***REMOVED***
                        buffer += makeIndent(indentStr, objStack.length, true)
                    ***REMOVED***
                    buffer += "]";
                ***REMOVED*** else ***REMOVED***
                    checkForCircular(obj_part);
                    buffer = "***REMOVED***";
                    var nonEmpty = false;
                    objStack.push(obj_part);
                    for (var prop in obj_part) ***REMOVED***
                        if (obj_part.hasOwnProperty(prop)) ***REMOVED***
                            var value = internalStringify(obj_part, prop, false);
                            isTopLevel = false;
                            if (typeof value !== "undefined" && value !== null) ***REMOVED***
                                buffer += makeIndent(indentStr, objStack.length);
                                nonEmpty = true;
                                key = isWord(prop) ? prop : escapeString(prop);
                                buffer += key + ":" + (indentStr ? ' ' : '') + value + ",";
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                    objStack.pop();
                    if (nonEmpty) ***REMOVED***
                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + "***REMOVED***";
                    ***REMOVED*** else ***REMOVED***
                        buffer = '***REMOVED******REMOVED***';
                    ***REMOVED***
                ***REMOVED***
                return buffer;
            default:
                // functions and undefined should be ignored
                return undefined;
        ***REMOVED***
    ***REMOVED***

    // special case...when undefined is used inside of
    // a compound object/array, return null.
    // but when top-level, return undefined
    var topLevelHolder = ***REMOVED***"":obj***REMOVED***;
    if (obj === undefined) ***REMOVED***
        return getReplacedValueOrUndefined(topLevelHolder, '', true);
    ***REMOVED***
    return internalStringify(topLevelHolder, '', true);
***REMOVED***;
