/*!
 * braces <https://github.com/jonschlinkert/braces>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT license.
 */

'use strict';

/**
 * Module dependencies
 */

var expand = require('expand-range');
var repeat = require('repeat-element');
var tokens = require('preserve');

/**
 * Expose `braces`
 */

module.exports = function(str, options) ***REMOVED***
  if (typeof str !== 'string') ***REMOVED***
    throw new Error('braces expects a string');
  ***REMOVED***
  return braces(str, options);
***REMOVED***;

/**
 * Expand `***REMOVED***foo,bar***REMOVED***` or `***REMOVED***1..5***REMOVED***` braces in the
 * given `string`.
 *
 * @param  ***REMOVED***String***REMOVED*** `str`
 * @param  ***REMOVED***Array***REMOVED*** `arr`
 * @param  ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Array***REMOVED***
 */

function braces(str, arr, options) ***REMOVED***
  if (str === '') ***REMOVED***
    return [];
  ***REMOVED***

  if (!Array.isArray(arr)) ***REMOVED***
    options = arr;
    arr = [];
  ***REMOVED***

  var opts = options || ***REMOVED******REMOVED***;
  arr = arr || [];

  if (typeof opts.nodupes === 'undefined') ***REMOVED***
    opts.nodupes = true;
  ***REMOVED***

  var fn = opts.fn;
  var es6;

  if (typeof opts === 'function') ***REMOVED***
    fn = opts;
    opts = ***REMOVED******REMOVED***;
  ***REMOVED***

  if (!(patternRe instanceof RegExp)) ***REMOVED***
    patternRe = patternRegex();
  ***REMOVED***

  var matches = str.match(patternRe) || [];
  var m = matches[0];

  switch(m) ***REMOVED***
    case '\\,':
      return escapeCommas(str, arr, opts);
    case '\\.':
      return escapeDots(str, arr, opts);
    case '\/.':
      return escapePaths(str, arr, opts);
    case ' ':
      return splitWhitespace(str);
    case '***REMOVED***,***REMOVED***':
      return exponential(str, opts, braces);
    case '***REMOVED******REMOVED***':
      return emptyBraces(str, arr, opts);
    case '\\***REMOVED***':
    case '\\***REMOVED***':
      return escapeBraces(str, arr, opts);
    case '$***REMOVED***':
      if (!/\***REMOVED***[^***REMOVED***]+\***REMOVED***/.test(str)) ***REMOVED***
        return arr.concat(str);
      ***REMOVED*** else ***REMOVED***
        es6 = true;
        str = tokens.before(str, es6Regex());
      ***REMOVED***
  ***REMOVED***

  if (!(braceRe instanceof RegExp)) ***REMOVED***
    braceRe = braceRegex();
  ***REMOVED***

  var match = braceRe.exec(str);
  if (match == null) ***REMOVED***
    return [str];
  ***REMOVED***

  var outter = match[1];
  var inner = match[2];
  if (inner === '') ***REMOVED*** return [str]; ***REMOVED***

  var segs, segsLength;

  if (inner.indexOf('..') !== -1) ***REMOVED***
    segs = expand(inner, opts, fn) || inner.split(',');
    segsLength = segs.length;

  ***REMOVED*** else if (inner[0] === '"' || inner[0] === '\'') ***REMOVED***
    return arr.concat(str.split(/['"]/).join(''));

  ***REMOVED*** else ***REMOVED***
    segs = inner.split(',');
    if (opts.makeRe) ***REMOVED***
      return braces(str.replace(outter, wrap(segs, '|')), opts);
    ***REMOVED***

    segsLength = segs.length;
    if (segsLength === 1 && opts.bash) ***REMOVED***
      segs[0] = wrap(segs[0], '\\');
    ***REMOVED***
  ***REMOVED***

  var len = segs.length;
  var i = 0, val;

  while (len--) ***REMOVED***
    var path = segs[i++];

    if (/(\.[^.\/])/.test(path)) ***REMOVED***
      if (segsLength > 1) ***REMOVED***
        return segs;
      ***REMOVED*** else ***REMOVED***
        return [str];
      ***REMOVED***
    ***REMOVED***

    val = splice(str, outter, path);

    if (/\***REMOVED***[^***REMOVED******REMOVED***]+?\***REMOVED***/.test(val)) ***REMOVED***
      arr = braces(val, arr, opts);
    ***REMOVED*** else if (val !== '') ***REMOVED***
      if (opts.nodupes && arr.indexOf(val) !== -1) ***REMOVED*** continue; ***REMOVED***
      arr.push(es6 ? tokens.after(val) : val);
    ***REMOVED***
  ***REMOVED***

  if (opts.strict) ***REMOVED*** return filter(arr, filterEmpty); ***REMOVED***
  return arr;
***REMOVED***

/**
 * Expand exponential ranges
 *
 *   `a***REMOVED***,***REMOVED******REMOVED***,***REMOVED***` => ['a', 'a', 'a', 'a']
 */

function exponential(str, options, fn) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    fn = options;
    options = null;
  ***REMOVED***

  var opts = options || ***REMOVED******REMOVED***;
  var esc = '__ESC_EXP__';
  var exp = 0;
  var res;

  var parts = str.split('***REMOVED***,***REMOVED***');
  if (opts.nodupes) ***REMOVED***
    return fn(parts.join(''), opts);
  ***REMOVED***

  exp = parts.length - 1;
  res = fn(parts.join(esc), opts);
  var len = res.length;
  var arr = [];
  var i = 0;

  while (len--) ***REMOVED***
    var ele = res[i++];
    var idx = ele.indexOf(esc);

    if (idx === -1) ***REMOVED***
      arr.push(ele);

    ***REMOVED*** else ***REMOVED***
      ele = ele.split('__ESC_EXP__').join('');
      if (!!ele && opts.nodupes !== false) ***REMOVED***
        arr.push(ele);

      ***REMOVED*** else ***REMOVED***
        var num = Math.pow(2, exp);
        arr.push.apply(arr, repeat(ele, num));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return arr;
***REMOVED***

/**
 * Wrap a value with parens, brackets or braces,
 * based on the given character/separator.
 *
 * @param  ***REMOVED***String|Array***REMOVED*** `val`
 * @param  ***REMOVED***String***REMOVED*** `ch`
 * @return ***REMOVED***String***REMOVED***
 */

function wrap(val, ch) ***REMOVED***
  if (ch === '|') ***REMOVED***
    return '(' + val.join(ch) + ')';
  ***REMOVED***
  if (ch === ',') ***REMOVED***
    return '***REMOVED***' + val.join(ch) + '***REMOVED***';
  ***REMOVED***
  if (ch === '-') ***REMOVED***
    return '[' + val.join(ch) + ']';
  ***REMOVED***
  if (ch === '\\') ***REMOVED***
    return '\\***REMOVED***' + val + '\\***REMOVED***';
  ***REMOVED***
***REMOVED***

/**
 * Handle empty braces: `***REMOVED******REMOVED***`
 */

function emptyBraces(str, arr, opts) ***REMOVED***
  return braces(str.split('***REMOVED******REMOVED***').join('\\***REMOVED***\\***REMOVED***'), arr, opts);
***REMOVED***

/**
 * Filter out empty-ish values
 */

function filterEmpty(ele) ***REMOVED***
  return !!ele && ele !== '\\';
***REMOVED***

/**
 * Handle patterns with whitespace
 */

function splitWhitespace(str) ***REMOVED***
  var segs = str.split(' ');
  var len = segs.length;
  var res = [];
  var i = 0;

  while (len--) ***REMOVED***
    res.push.apply(res, braces(segs[i++]));
  ***REMOVED***
  return res;
***REMOVED***

/**
 * Handle escaped braces: `\\***REMOVED***foo,bar***REMOVED***`
 */

function escapeBraces(str, arr, opts) ***REMOVED***
  if (!/\***REMOVED***[^***REMOVED***]+\***REMOVED***/.test(str)) ***REMOVED***
    return arr.concat(str.split('\\').join(''));
  ***REMOVED*** else ***REMOVED***
    str = str.split('\\***REMOVED***').join('__LT_BRACE__');
    str = str.split('\\***REMOVED***').join('__RT_BRACE__');
    return map(braces(str, arr, opts), function(ele) ***REMOVED***
      ele = ele.split('__LT_BRACE__').join('***REMOVED***');
      return ele.split('__RT_BRACE__').join('***REMOVED***');
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Handle escaped dots: `***REMOVED***1\\.2***REMOVED***`
 */

function escapeDots(str, arr, opts) ***REMOVED***
  if (!/[^\\]\..+\\\./.test(str)) ***REMOVED***
    return arr.concat(str.split('\\').join(''));
  ***REMOVED*** else ***REMOVED***
    str = str.split('\\.').join('__ESC_DOT__');
    return map(braces(str, arr, opts), function(ele) ***REMOVED***
      return ele.split('__ESC_DOT__').join('.');
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Handle escaped dots: `***REMOVED***1\\.2***REMOVED***`
 */

function escapePaths(str, arr, opts) ***REMOVED***
  str = str.split('\/.').join('__ESC_PATH__');
  return map(braces(str, arr, opts), function(ele) ***REMOVED***
    return ele.split('__ESC_PATH__').join('\/.');
  ***REMOVED***);
***REMOVED***

/**
 * Handle escaped commas: `***REMOVED***a\\,b***REMOVED***`
 */

function escapeCommas(str, arr, opts) ***REMOVED***
  if (!/\w,/.test(str)) ***REMOVED***
    return arr.concat(str.split('\\').join(''));
  ***REMOVED*** else ***REMOVED***
    str = str.split('\\,').join('__ESC_COMMA__');
    return map(braces(str, arr, opts), function(ele) ***REMOVED***
      return ele.split('__ESC_COMMA__').join(',');
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Regex for common patterns
 */

function patternRegex() ***REMOVED***
  return /\$***REMOVED***|( (?=[***REMOVED***,***REMOVED***])|(?=[***REMOVED***,***REMOVED***]) )|***REMOVED******REMOVED***|***REMOVED***,***REMOVED***|\\,(?=.*[***REMOVED******REMOVED***])|\/\.(?=.*[***REMOVED******REMOVED***])|\\\.(?=***REMOVED***)|\\***REMOVED***|\\***REMOVED***/;
***REMOVED***

/**
 * Braces regex.
 */

function braceRegex() ***REMOVED***
  return /.*(\\?\***REMOVED***([^***REMOVED***]+)\***REMOVED***)/;
***REMOVED***

/**
 * es6 delimiter regex.
 */

function es6Regex() ***REMOVED***
  return /\$\***REMOVED***([^***REMOVED***]+)\***REMOVED***/;
***REMOVED***

var braceRe;
var patternRe;

/**
 * Faster alternative to `String.replace()` when the
 * index of the token to be replaces can't be supplied
 */

function splice(str, token, replacement) ***REMOVED***
  var i = str.indexOf(token);
  return str.substr(0, i) + replacement
    + str.substr(i + token.length);
***REMOVED***

/**
 * Fast array map
 */

function map(arr, fn) ***REMOVED***
  if (arr == null) ***REMOVED***
    return [];
  ***REMOVED***

  var len = arr.length;
  var res = new Array(len);
  var i = -1;

  while (++i < len) ***REMOVED***
    res[i] = fn(arr[i], i, arr);
  ***REMOVED***

  return res;
***REMOVED***

/**
 * Fast array filter
 */

function filter(arr, cb) ***REMOVED***
  if (arr == null) return [];
  if (typeof cb !== 'function') ***REMOVED***
    throw new TypeError('braces: filter expects a callback function.');
  ***REMOVED***

  var len = arr.length;
  var res = arr.slice();
  var i = 0;

  while (len--) ***REMOVED***
    if (!cb(arr[len], i++)) ***REMOVED***
      res.splice(len, 1);
    ***REMOVED***
  ***REMOVED***
  return res;
***REMOVED***
