/*!
 * extglob <https://github.com/jonschlinkert/extglob>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Module dependencies
 */

var isExtglob = require('is-extglob');
var re, cache = ***REMOVED******REMOVED***;

/**
 * Expose `extglob`
 */

module.exports = extglob;

/**
 * Convert the given extglob `string` to a regex-compatible
 * string.
 *
 * ```js
 * var extglob = require('extglob');
 * extglob('!(a?(b))');
 * //=> '(?!a(?:b)?)[^/]*?'
 * ```
 *
 * @param ***REMOVED***String***REMOVED*** `str` The string to convert.
 * @param ***REMOVED***Object***REMOVED*** `options`
 *   @option ***REMOVED***Boolean***REMOVED*** [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.
 *   @option ***REMOVED***Boolean***REMOVED*** [options] `regex` If `true` a regular expression is returned instead of a string.
 * @return ***REMOVED***String***REMOVED***
 * @api public
 */


function extglob(str, opts) ***REMOVED***
  opts = opts || ***REMOVED******REMOVED***;
  var o = ***REMOVED******REMOVED***, i = 0;

  // fix common character reversals
  // '*!(.js)' => '*.!(js)'
  str = str.replace(/!\(([^\w*()])/g, '$1!(');

  // support file extension negation
  str = str.replace(/([*\/])\.!\([*]\)/g, function (m, ch) ***REMOVED***
    if (ch === '/') ***REMOVED***
      return escape('\\/[^.]+');
    ***REMOVED***
    return escape('[^.]+');
  ***REMOVED***);

  // create a unique key for caching by
  // combining the string and options
  var key = str
    + String(!!opts.regex)
    + String(!!opts.contains)
    + String(!!opts.escape);

  if (cache.hasOwnProperty(key)) ***REMOVED***
    return cache[key];
  ***REMOVED***

  if (!(re instanceof RegExp)) ***REMOVED***
    re = regex();
  ***REMOVED***

  opts.negate = false;
  var m;

  while (m = re.exec(str)) ***REMOVED***
    var prefix = m[1];
    var inner = m[3];
    if (prefix === '!') ***REMOVED***
      opts.negate = true;
    ***REMOVED***

    var id = '__EXTGLOB_' + (i++) + '__';
    // use the prefix of the _last_ (outtermost) pattern
    o[id] = wrap(inner, prefix, opts.escape);
    str = str.split(m[0]).join(id);
  ***REMOVED***

  var keys = Object.keys(o);
  var len = keys.length;

  // we have to loop again to allow us to convert
  // patterns in reverse order (starting with the
  // innermost/last pattern first)
  while (len--) ***REMOVED***
    var prop = keys[len];
    str = str.split(prop).join(o[prop]);
  ***REMOVED***

  var result = opts.regex
    ? toRegex(str, opts.contains, opts.negate)
    : str;

  result = result.split('.').join('\\.');

  // cache the result and return it
  return (cache[key] = result);
***REMOVED***

/**
 * Convert `string` to a regex string.
 *
 * @param  ***REMOVED***String***REMOVED*** `str`
 * @param  ***REMOVED***String***REMOVED*** `prefix` Character that determines how to wrap the string.
 * @param  ***REMOVED***Boolean***REMOVED*** `esc` If `false` special characters will not be escaped. Defaults to `true`.
 * @return ***REMOVED***String***REMOVED***
 */

function wrap(inner, prefix, esc) ***REMOVED***
  if (esc) inner = escape(inner);

  switch (prefix) ***REMOVED***
    case '!':
      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');
    case '@':
      return '(?:' + inner + ')';
    case '+':
      return '(?:' + inner + ')+';
    case '*':
      return '(?:' + inner + ')' + (esc ? '%%' : '*')
    case '?':
      return '(?:' + inner + '|)';
    default:
      return inner;
  ***REMOVED***
***REMOVED***

function escape(str) ***REMOVED***
  str = str.split('*').join('[^/]%%%~');
  str = str.split('.').join('\\.');
  return str;
***REMOVED***

/**
 * extglob regex.
 */

function regex() ***REMOVED***
  return /(\\?[@?!+*$]\\?)(\(([^()]*?)\))/;
***REMOVED***

/**
 * Negation regex
 */

function negate(str) ***REMOVED***
  return '(?!^' + str + ').*$';
***REMOVED***

/**
 * Create the regex to do the matching. If
 * the leading character in the `pattern` is `!`
 * a negation regex is returned.
 *
 * @param ***REMOVED***String***REMOVED*** `pattern`
 * @param ***REMOVED***Boolean***REMOVED*** `contains` Allow loose matching.
 * @param ***REMOVED***Boolean***REMOVED*** `isNegated` True if the pattern is a negation pattern.
 */

function toRegex(pattern, contains, isNegated) ***REMOVED***
  var prefix = contains ? '^' : '';
  var after = contains ? '$' : '';
  pattern = ('(?:' + pattern + ')' + after);
  if (isNegated) ***REMOVED***
    pattern = prefix + negate(pattern);
  ***REMOVED***
  return new RegExp(prefix + pattern);
***REMOVED***
