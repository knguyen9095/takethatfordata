'use strict';

var fs = require('fs');
var sysPath = require('path');
var readdirp = require('readdirp');
var fsevents;
try ***REMOVED*** fsevents = require('fsevents'); ***REMOVED*** catch (error) ***REMOVED******REMOVED***

// fsevents instance helper functions

// object to hold per-process fsevents instances
// (may be shared across chokidar FSWatcher instances)
var FSEventsWatchers = Object.create(null);

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
var consolidateThreshhold = 10;

// Private function: Instantiates the fsevents interface

// * path       - string, path to be watched
// * callback   - function, called when fsevents is bound and ready

// Returns new fsevents instance
function createFSEventsInstance(path, callback) ***REMOVED***
  return (new fsevents(path)).on('fsevent', callback).start();
***REMOVED***

// Private function: Instantiates the fsevents interface or binds listeners
// to an existing one covering the same file tree

// * path       - string, path to be watched
// * realPath   - string, real path (in case of symlinks)
// * listener   - function, called when fsevents emits events
// * rawEmitter - function, passes data to listeners of the 'raw' event

// Returns close function
function setFSEventsListener(path, realPath, listener, rawEmitter) ***REMOVED***
  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
  var watchContainer;
  var parentPath = sysPath.dirname(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) ***REMOVED***
    watchPath = parentPath;
  ***REMOVED***

  var resolvedPath = sysPath.resolve(path);
  var hasSymlink = resolvedPath !== realPath;
  function filteredListener(fullPath, flags, info) ***REMOVED***
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (
      fullPath === resolvedPath ||
      !fullPath.indexOf(resolvedPath + sysPath.sep)
    ) listener(fullPath, flags, info);
  ***REMOVED***

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  function watchedParent() ***REMOVED***
    return Object.keys(FSEventsWatchers).some(function(watchedPath) ***REMOVED***
      // condition is met when indexOf returns 0
      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) ***REMOVED***
        watchPath = watchedPath;
        return true;
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  if (watchPath in FSEventsWatchers || watchedParent()) ***REMOVED***
    watchContainer = FSEventsWatchers[watchPath];
    watchContainer.listeners.push(filteredListener);
  ***REMOVED*** else ***REMOVED***
    watchContainer = FSEventsWatchers[watchPath] = ***REMOVED***
      listeners: [filteredListener],
      rawEmitters: [rawEmitter],
      watcher: createFSEventsInstance(watchPath, function(fullPath, flags) ***REMOVED***
        var info = fsevents.getInfo(fullPath, flags);
        watchContainer.listeners.forEach(function(listener) ***REMOVED***
          listener(fullPath, flags, info);
        ***REMOVED***);
        watchContainer.rawEmitters.forEach(function(emitter) ***REMOVED***
          emitter(info.event, fullPath, info);
        ***REMOVED***);
      ***REMOVED***)
    ***REMOVED***;
  ***REMOVED***
  var listenerIndex = watchContainer.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return function close() ***REMOVED***
    delete watchContainer.listeners[listenerIndex];
    delete watchContainer.rawEmitters[listenerIndex];
    if (!Object.keys(watchContainer.listeners).length) ***REMOVED***
      watchContainer.watcher.stop();
      delete FSEventsWatchers[watchPath];
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

// Decide whether or not we should start a new higher-level
// parent watcher
function couldConsolidate(path) ***REMOVED***
  var keys = Object.keys(FSEventsWatchers);
  var count = 0;

  for (var i = 0, len = keys.length; i < len; ++i) ***REMOVED***
    var watchPath = keys[i];
    if (watchPath.indexOf(path) === 0) ***REMOVED***
      count++;
      if (count >= consolidateThreshhold) ***REMOVED***
        return true;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***

// returns boolean indicating whether fsevents can be used
function canUse() ***REMOVED***
  return fsevents && Object.keys(FSEventsWatchers).length < 128;
***REMOVED***

// determines subdirectory traversal levels from root to path
function depth(path, root) ***REMOVED***
  var i = 0;
  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
  return i;
***REMOVED***

// fake constructor for attaching fsevents-specific prototype methods that
// will be copied to FSWatcher's prototype
function FsEventsHandler() ***REMOVED******REMOVED***

// Private method: Handle symlinks encountered during directory scan

// * watchPath  - string, file/dir path to be watched with fsevents
// * realPath   - string, real path (in case of symlinks)
// * transform  - function, path transformer
// * globFilter - function, path filter in case a glob pattern was provided

// Returns close function for the watcher instance
FsEventsHandler.prototype._watchWithFsEvents =
function(watchPath, realPath, transform, globFilter) ***REMOVED***
  if (this._isIgnored(watchPath)) return;
  var watchCallback = function(fullPath, flags, info) ***REMOVED***
    if (
      this.options.depth !== undefined &&
      depth(fullPath, realPath) > this.options.depth
    ) return;
    var path = transform(sysPath.join(
      watchPath, sysPath.relative(watchPath, fullPath)
    ));
    if (globFilter && !globFilter(path)) return;
    // ensure directories are tracked
    var parent = sysPath.dirname(path);
    var item = sysPath.basename(path);
    var watchedDir = this._getWatchedDir(
      info.type === 'directory' ? path : parent
    );
    var checkIgnored = function(stats) ***REMOVED***
      if (this._isIgnored(path, stats)) ***REMOVED***
        this._ignoredPaths[path] = true;
        if (stats && stats.isDirectory()) ***REMOVED***
          this._ignoredPaths[path + '/**/*'] = true;
        ***REMOVED***
        return true;
      ***REMOVED*** else ***REMOVED***
        delete this._ignoredPaths[path];
        delete this._ignoredPaths[path + '/**/*'];
      ***REMOVED***
    ***REMOVED***.bind(this);

    var handleEvent = function(event) ***REMOVED***
      if (checkIgnored()) return;

      if (event === 'unlink') ***REMOVED***
        // suppress unlink events on never before seen files
        if (info.type === 'directory' || watchedDir.has(item)) ***REMOVED***
          this._remove(parent, item);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        if (event === 'add') ***REMOVED***
          // track new directories
          if (info.type === 'directory') this._getWatchedDir(path);

          if (info.type === 'symlink' && this.options.followSymlinks) ***REMOVED***
            // push symlinks back to the top of the stack to get handled
            var curDepth = this.options.depth === undefined ?
              undefined : depth(fullPath, realPath) + 1;
            return this._addToFsEvents(path, false, true, curDepth);
          ***REMOVED*** else ***REMOVED***
            // track new paths
            // (other than symlinks being followed, which will be tracked soon)
            this._getWatchedDir(parent).add(item);
          ***REMOVED***
        ***REMOVED***
        var eventName = info.type === 'directory' ? event + 'Dir' : event;
        this._emit(eventName, path);
        if (eventName === 'addDir') this._addToFsEvents(path, false, true);
      ***REMOVED***
    ***REMOVED***.bind(this);

    function addOrChange() ***REMOVED***
      handleEvent(watchedDir.has(item) ? 'change' : 'add');
    ***REMOVED***
    function checkFd() ***REMOVED***
      fs.open(path, 'r', function(error, fd) ***REMOVED***
        if (fd) fs.close(fd);
        error && error.code !== 'EACCES' ?
          handleEvent('unlink') : addOrChange();
      ***REMOVED***);
    ***REMOVED***
    // correct for wrong events emitted
    var wrongEventFlags = [
      69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
    ];
    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') ***REMOVED***
      if (typeof this.options.ignored === 'function') ***REMOVED***
        fs.stat(path, function(error, stats) ***REMOVED***
          if (checkIgnored(stats)) return;
          stats ? addOrChange() : handleEvent('unlink');
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        checkFd();
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      switch (info.event) ***REMOVED***
      case 'created':
      case 'modified':
        return addOrChange();
      case 'deleted':
      case 'moved':
        return checkFd();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***.bind(this);

  var closer = setFSEventsListener(
    watchPath,
    realPath,
    watchCallback,
    this.emit.bind(this, 'raw')
  );

  this._emitReady();
  return closer;
***REMOVED***;

// Private method: Handle symlinks encountered during directory scan

// * linkPath   - string, path to symlink
// * fullPath   - string, absolute path to the symlink
// * transform  - function, pre-existing path transformer
// * curDepth   - int, level of subdirectories traversed to where symlink is

// Returns nothing
FsEventsHandler.prototype._handleFsEventsSymlink =
function(linkPath, fullPath, transform, curDepth) ***REMOVED***
  // don't follow the same symlink more than once
  if (this._symlinkPaths[fullPath]) return;
  else this._symlinkPaths[fullPath] = true;

  this._readyCount++;

  fs.realpath(linkPath, function(error, linkTarget) ***REMOVED***
    if (this._handleError(error) || this._isIgnored(linkTarget)) ***REMOVED***
      return this._emitReady();
    ***REMOVED***

    this._readyCount++;

    // add the linkTarget for watching with a wrapper for transform
    // that causes emitted paths to incorporate the link's path
    this._addToFsEvents(linkTarget || linkPath, function(path) ***REMOVED***
      var dotSlash = '.' + sysPath.sep;
      var aliasedPath = linkPath;
      if (linkTarget && linkTarget !== dotSlash) ***REMOVED***
        aliasedPath = path.replace(linkTarget, linkPath);
      ***REMOVED*** else if (path !== dotSlash) ***REMOVED***
        aliasedPath = sysPath.join(linkPath, path);
      ***REMOVED***
      return transform(aliasedPath);
    ***REMOVED***, false, curDepth);
  ***REMOVED***.bind(this));
***REMOVED***;

// Private method: Handle added path with fsevents

// * path       - string, file/directory path or glob pattern
// * transform  - function, converts working path to what the user expects
// * forceAdd   - boolean, ensure add is emitted
// * priorDepth - int, level of subdirectories already traversed

// Returns nothing
FsEventsHandler.prototype._addToFsEvents =
function(path, transform, forceAdd, priorDepth) ***REMOVED***

  // applies transform if provided, otherwise returns same value
  var processPath = typeof transform === 'function' ?
    transform : function(val) ***REMOVED*** return val; ***REMOVED***;

  var emitAdd = function(newPath, stats) ***REMOVED***
    var pp = processPath(newPath);
    var isDir = stats.isDirectory();
    var dirObj = this._getWatchedDir(sysPath.dirname(pp));
    var base = sysPath.basename(pp);

    // ensure empty dirs get tracked
    if (isDir) this._getWatchedDir(pp);

    if (dirObj.has(base)) return;
    dirObj.add(base);

    if (!this.options.ignoreInitial || forceAdd === true) ***REMOVED***
      this._emit(isDir ? 'addDir' : 'add', pp, stats);
    ***REMOVED***
  ***REMOVED***.bind(this);

  var wh = this._getWatchHelpers(path);

  // evaluate what is at the path we're being asked to watch
  fs[wh.statMethod](wh.watchPath, function(error, stats) ***REMOVED***
    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) ***REMOVED***
      this._emitReady();
      return this._emitReady();
    ***REMOVED***

    if (stats.isDirectory()) ***REMOVED***
      // emit addDir unless this is a glob parent
      if (!wh.globFilter) emitAdd(processPath(path), stats);

      // don't recurse further if it would exceed depth setting
      if (priorDepth && priorDepth > this.options.depth) return;

      // scan the contents of the dir
      readdirp(***REMOVED***
        root: wh.watchPath,
        entryType: 'all',
        fileFilter: wh.filterPath,
        directoryFilter: wh.filterDir,
        lstat: true,
        depth: this.options.depth - (priorDepth || 0)
      ***REMOVED***).on('data', function(entry) ***REMOVED***
        // need to check filterPath on dirs b/c filterDir is less restrictive
        if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;

        var joinedPath = sysPath.join(wh.watchPath, entry.path);
        var fullPath = entry.fullPath;

        if (wh.followSymlinks && entry.stat.isSymbolicLink()) ***REMOVED***
          // preserve the current depth here since it can't be derived from
          // real paths past the symlink
          var curDepth = this.options.depth === undefined ?
            undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
        ***REMOVED*** else ***REMOVED***
          emitAdd(joinedPath, entry.stat);
        ***REMOVED***
      ***REMOVED***.bind(this)).on('error', function() ***REMOVED***
        // Ignore readdirp errors
      ***REMOVED***).on('end', this._emitReady);
    ***REMOVED*** else ***REMOVED***
      emitAdd(wh.watchPath, stats);
      this._emitReady();
    ***REMOVED***
  ***REMOVED***.bind(this));

  if (this.options.persistent && forceAdd !== true) ***REMOVED***
    var initWatch = function(error, realPath) ***REMOVED***
      if (this.closed) return;
      var closer = this._watchWithFsEvents(
        wh.watchPath,
        sysPath.resolve(realPath || wh.watchPath),
        processPath,
        wh.globFilter
      );
      if (closer) this._closers[path] = closer;
    ***REMOVED***.bind(this);

    if (typeof transform === 'function') ***REMOVED***
      // realpath has already been resolved
      initWatch();
    ***REMOVED*** else ***REMOVED***
      fs.realpath(wh.watchPath, initWatch);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

module.exports = FsEventsHandler;
module.exports.canUse = canUse;
