/*!
 * micromatch <https://github.com/jonschlinkert/micromatch>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var expand = require('./lib/expand');
var utils = require('./lib/utils');

/**
 * The main function. Pass an array of filepaths,
 * and a string or array of glob patterns
 *
 * @param  ***REMOVED***Array|String***REMOVED*** `files`
 * @param  ***REMOVED***Array|String***REMOVED*** `patterns`
 * @param  ***REMOVED***Object***REMOVED*** `opts`
 * @return ***REMOVED***Array***REMOVED*** Array of matches
 */

function micromatch(files, patterns, opts) ***REMOVED***
  if (!files || !patterns) return [];
  opts = opts || ***REMOVED******REMOVED***;

  if (typeof opts.cache === 'undefined') ***REMOVED***
    opts.cache = true;
  ***REMOVED***

  if (!Array.isArray(patterns)) ***REMOVED***
    return match(files, patterns, opts);
  ***REMOVED***

  var len = patterns.length, i = 0;
  var omit = [], keep = [];

  while (len--) ***REMOVED***
    var glob = patterns[i++];
    if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) ***REMOVED***
      omit.push.apply(omit, match(files, glob.slice(1), opts));
    ***REMOVED*** else ***REMOVED***
      keep.push.apply(keep, match(files, glob, opts));
    ***REMOVED***
  ***REMOVED***
  return utils.diff(keep, omit);
***REMOVED***

/**
 * Return an array of files that match the given glob pattern.
 *
 * This function is called by the main `micromatch` function If you only
 * need to pass a single pattern you might get very minor speed improvements
 * using this function.
 *
 * @param  ***REMOVED***Array***REMOVED*** `files`
 * @param  ***REMOVED***String***REMOVED*** `pattern`
 * @param  ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Array***REMOVED***
 */

function match(files, pattern, opts) ***REMOVED***
  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) ***REMOVED***
    throw new Error(msg('match', 'files', 'a string or array'));
  ***REMOVED***

  files = utils.arrayify(files);
  opts = opts || ***REMOVED******REMOVED***;

  var negate = opts.negate || false;
  var orig = pattern;

  if (typeof pattern === 'string') ***REMOVED***
    negate = pattern.charAt(0) === '!';
    if (negate) ***REMOVED***
      pattern = pattern.slice(1);
    ***REMOVED***

    // we need to remove the character regardless,
    // so the above logic is still needed
    if (opts.nonegate === true) ***REMOVED***
      negate = false;
    ***REMOVED***
  ***REMOVED***

  var _isMatch = matcher(pattern, opts);
  var len = files.length, i = 0;
  var res = [];

  while (i < len) ***REMOVED***
    var file = files[i++];
    var fp = utils.unixify(file, opts);

    if (!_isMatch(fp)) ***REMOVED*** continue; ***REMOVED***
    res.push(fp);
  ***REMOVED***

  if (res.length === 0) ***REMOVED***
    if (opts.failglob === true) ***REMOVED***
      throw new Error('micromatch.match() found no matches for: "' + orig + '".');
    ***REMOVED***

    if (opts.nonull || opts.nullglob) ***REMOVED***
      res.push(utils.unescapeGlob(orig));
    ***REMOVED***
  ***REMOVED***

  // if `negate` was defined, diff negated files
  if (negate) ***REMOVED*** res = utils.diff(files, res); ***REMOVED***

  // if `ignore` was defined, diff ignored filed
  if (opts.ignore && opts.ignore.length) ***REMOVED***
    pattern = opts.ignore;
    opts = utils.omit(opts, ['ignore']);
    res = utils.diff(res, micromatch(res, pattern, opts));
  ***REMOVED***

  if (opts.nodupes) ***REMOVED***
    return utils.unique(res);
  ***REMOVED***
  return res;
***REMOVED***

/**
 * Returns a function that takes a glob pattern or array of glob patterns
 * to be used with `Array#filter()`. (Internally this function generates
 * the matching function using the [matcher] method).
 *
 * ```js
 * var fn = mm.filter('[a-c]');
 * ['a', 'b', 'c', 'd', 'e'].filter(fn);
 * //=> ['a', 'b', 'c']
 * ```
 * @param  ***REMOVED***String|Array***REMOVED*** `patterns` Can be a glob or array of globs.
 * @param  ***REMOVED***Options***REMOVED*** `opts` Options to pass to the [matcher] method.
 * @return ***REMOVED***Function***REMOVED*** Filter function to be passed to `Array#filter()`.
 */

function filter(patterns, opts) ***REMOVED***
  if (!Array.isArray(patterns) && typeof patterns !== 'string') ***REMOVED***
    throw new TypeError(msg('filter', 'patterns', 'a string or array'));
  ***REMOVED***

  patterns = utils.arrayify(patterns);
  var len = patterns.length, i = 0;
  var patternMatchers = Array(len);
  while (i < len) ***REMOVED***
    patternMatchers[i] = matcher(patterns[i++], opts);
  ***REMOVED***

  return function(fp) ***REMOVED***
    if (fp == null) return [];
    var len = patternMatchers.length, i = 0;
    var res = true;

    fp = utils.unixify(fp, opts);
    while (i < len) ***REMOVED***
      var fn = patternMatchers[i++];
      if (!fn(fp)) ***REMOVED***
        res = false;
        break;
      ***REMOVED***
    ***REMOVED***
    return res;
  ***REMOVED***;
***REMOVED***

/**
 * Returns true if the filepath contains the given
 * pattern. Can also return a function for matching.
 *
 * ```js
 * isMatch('foo.md', '*.md', ***REMOVED******REMOVED***);
 * //=> true
 *
 * isMatch('*.md', ***REMOVED******REMOVED***)('foo.md')
 * //=> true
 * ```
 * @param  ***REMOVED***String***REMOVED*** `fp`
 * @param  ***REMOVED***String***REMOVED*** `pattern`
 * @param  ***REMOVED***Object***REMOVED*** `opts`
 * @return ***REMOVED***Boolean***REMOVED***
 */

function isMatch(fp, pattern, opts) ***REMOVED***
  if (typeof fp !== 'string') ***REMOVED***
    throw new TypeError(msg('isMatch', 'filepath', 'a string'));
  ***REMOVED***

  fp = utils.unixify(fp, opts);
  if (utils.typeOf(pattern) === 'object') ***REMOVED***
    return matcher(fp, pattern);
  ***REMOVED***
  return matcher(pattern, opts)(fp);
***REMOVED***

/**
 * Returns true if the filepath matches the
 * given pattern.
 */

function contains(fp, pattern, opts) ***REMOVED***
  if (typeof fp !== 'string') ***REMOVED***
    throw new TypeError(msg('contains', 'pattern', 'a string'));
  ***REMOVED***

  opts = opts || ***REMOVED******REMOVED***;
  opts.contains = (pattern !== '');
  fp = utils.unixify(fp, opts);

  if (opts.contains && !utils.isGlob(pattern)) ***REMOVED***
    return fp.indexOf(pattern) !== -1;
  ***REMOVED***
  return matcher(pattern, opts)(fp);
***REMOVED***

/**
 * Returns true if a file path matches any of the
 * given patterns.
 *
 * @param  ***REMOVED***String***REMOVED*** `fp` The filepath to test.
 * @param  ***REMOVED***String|Array***REMOVED*** `patterns` Glob patterns to use.
 * @param  ***REMOVED***Object***REMOVED*** `opts` Options to pass to the `matcher()` function.
 * @return ***REMOVED***String***REMOVED***
 */

function any(fp, patterns, opts) ***REMOVED***
  if (!Array.isArray(patterns) && typeof patterns !== 'string') ***REMOVED***
    throw new TypeError(msg('any', 'patterns', 'a string or array'));
  ***REMOVED***

  patterns = utils.arrayify(patterns);
  var len = patterns.length;

  fp = utils.unixify(fp, opts);
  while (len--) ***REMOVED***
    var isMatch = matcher(patterns[len], opts);
    if (isMatch(fp)) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***

/**
 * Filter the keys of an object with the given `glob` pattern
 * and `options`
 *
 * @param  ***REMOVED***Object***REMOVED*** `object`
 * @param  ***REMOVED***Pattern***REMOVED*** `object`
 * @return ***REMOVED***Array***REMOVED***
 */

function matchKeys(obj, glob, options) ***REMOVED***
  if (utils.typeOf(obj) !== 'object') ***REMOVED***
    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));
  ***REMOVED***

  var fn = matcher(glob, options);
  var res = ***REMOVED******REMOVED***;

  for (var key in obj) ***REMOVED***
    if (obj.hasOwnProperty(key) && fn(key)) ***REMOVED***
      res[key] = obj[key];
    ***REMOVED***
  ***REMOVED***
  return res;
***REMOVED***

/**
 * Return a function for matching based on the
 * given `pattern` and `options`.
 *
 * @param  ***REMOVED***String***REMOVED*** `pattern`
 * @param  ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Function***REMOVED***
 */

function matcher(pattern, opts) ***REMOVED***
  // pattern is a function
  if (typeof pattern === 'function') ***REMOVED***
    return pattern;
  ***REMOVED***
  // pattern is a regex
  if (pattern instanceof RegExp) ***REMOVED***
    return function(fp) ***REMOVED***
      return pattern.test(fp);
    ***REMOVED***;
  ***REMOVED***

  if (typeof pattern !== 'string') ***REMOVED***
    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));
  ***REMOVED***

  // strings, all the way down...
  pattern = utils.unixify(pattern, opts);

  // pattern is a non-glob string
  if (!utils.isGlob(pattern)) ***REMOVED***
    return utils.matchPath(pattern, opts);
  ***REMOVED***
  // pattern is a glob string
  var re = makeRe(pattern, opts);

  // `matchBase` is defined
  if (opts && opts.matchBase) ***REMOVED***
    return utils.hasFilename(re, opts);
  ***REMOVED***
  // `matchBase` is not defined
  return function(fp) ***REMOVED***
    fp = utils.unixify(fp, opts);
    return re.test(fp);
  ***REMOVED***;
***REMOVED***

/**
 * Create and cache a regular expression for matching
 * file paths.
 *
 * If the leading character in the `glob` is `!`, a negation
 * regex is returned.
 *
 * @param  ***REMOVED***String***REMOVED*** `glob`
 * @param  ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***RegExp***REMOVED***
 */

function toRegex(glob, options) ***REMOVED***
  // clone options to prevent  mutating the original object
  var opts = Object.create(options || ***REMOVED******REMOVED***);
  var flags = opts.flags || '';
  if (opts.nocase && flags.indexOf('i') === -1) ***REMOVED***
    flags += 'i';
  ***REMOVED***

  var parsed = expand(glob, opts);

  // pass in tokens to avoid parsing more than once
  opts.negated = opts.negated || parsed.negated;
  opts.negate = opts.negated;
  glob = wrapGlob(parsed.pattern, opts);
  var re;

  try ***REMOVED***
    re = new RegExp(glob, flags);
    return re;
  ***REMOVED*** catch (err) ***REMOVED***
    err.reason = 'micromatch invalid regex: (' + re + ')';
    if (opts.strict) throw new SyntaxError(err);
  ***REMOVED***

  // we're only here if a bad pattern was used and the user
  // passed `options.silent`, so match nothing
  return /$^/;
***REMOVED***

/**
 * Create the regex to do the matching. If the leading
 * character in the `glob` is `!` a negation regex is returned.
 *
 * @param ***REMOVED***String***REMOVED*** `glob`
 * @param ***REMOVED***Boolean***REMOVED*** `negate`
 */

function wrapGlob(glob, opts) ***REMOVED***
  var prefix = (opts && !opts.contains) ? '^' : '';
  var after = (opts && !opts.contains) ? '$' : '';
  glob = ('(?:' + glob + ')' + after);
  if (opts && opts.negate) ***REMOVED***
    return prefix + ('(?!^' + glob + ').*$');
  ***REMOVED***
  return prefix + glob;
***REMOVED***

/**
 * Create and cache a regular expression for matching file paths.
 * If the leading character in the `glob` is `!`, a negation
 * regex is returned.
 *
 * @param  ***REMOVED***String***REMOVED*** `glob`
 * @param  ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***RegExp***REMOVED***
 */

function makeRe(glob, opts) ***REMOVED***
  if (utils.typeOf(glob) !== 'string') ***REMOVED***
    throw new Error(msg('makeRe', 'glob', 'a string'));
  ***REMOVED***
  return utils.cache(toRegex, glob, opts);
***REMOVED***

/**
 * Make error messages consistent. Follows this format:
 *
 * ```js
 * msg(methodName, argNumber, nativeType);
 * // example:
 * msg('matchKeys', 'first', 'an object');
 * ```
 *
 * @param  ***REMOVED***String***REMOVED*** `method`
 * @param  ***REMOVED***String***REMOVED*** `num`
 * @param  ***REMOVED***String***REMOVED*** `type`
 * @return ***REMOVED***String***REMOVED***
 */

function msg(method, what, type) ***REMOVED***
  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';
***REMOVED***

/**
 * Public methods
 */

/* eslint no-multi-spaces: 0 */
micromatch.any       = any;
micromatch.braces    = micromatch.braceExpand = utils.braces;
micromatch.contains  = contains;
micromatch.expand    = expand;
micromatch.filter    = filter;
micromatch.isMatch   = isMatch;
micromatch.makeRe    = makeRe;
micromatch.match     = match;
micromatch.matcher   = matcher;
micromatch.matchKeys = matchKeys;

/**
 * Expose `micromatch`
 */

module.exports = micromatch;
