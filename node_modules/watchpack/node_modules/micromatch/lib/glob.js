'use strict';

var chars = require('./chars');
var utils = require('./utils');

/**
 * Expose `Glob`
 */

var Glob = module.exports = function Glob(pattern, options) ***REMOVED***
  if (!(this instanceof Glob)) ***REMOVED***
    return new Glob(pattern, options);
  ***REMOVED***
  this.options = options || ***REMOVED******REMOVED***;
  this.pattern = pattern;
  this.history = [];
  this.tokens = ***REMOVED******REMOVED***;
  this.init(pattern);
***REMOVED***;

/**
 * Initialize defaults
 */

Glob.prototype.init = function(pattern) ***REMOVED***
  this.orig = pattern;
  this.negated = this.isNegated();
  this.options.track = this.options.track || false;
  this.options.makeRe = true;
***REMOVED***;

/**
 * Push a change into `glob.history`. Useful
 * for debugging.
 */

Glob.prototype.track = function(msg) ***REMOVED***
  if (this.options.track) ***REMOVED***
    this.history.push(***REMOVED***msg: msg, pattern: this.pattern***REMOVED***);
  ***REMOVED***
***REMOVED***;

/**
 * Return true if `glob.pattern` was negated
 * with `!`, also remove the `!` from the pattern.
 *
 * @return ***REMOVED***Boolean***REMOVED***
 */

Glob.prototype.isNegated = function() ***REMOVED***
  if (this.pattern.charCodeAt(0) === 33 /* '!' */) ***REMOVED***
    this.pattern = this.pattern.slice(1);
    return true;
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Expand braces in the given glob pattern.
 *
 * We only need to use the [braces] lib when
 * patterns are nested.
 */

Glob.prototype.braces = function() ***REMOVED***
  if (this.options.nobraces !== true && this.options.nobrace !== true) ***REMOVED***
    // naive/fast check for imbalanced characters
    var a = this.pattern.match(/[\***REMOVED***\(\[]/g);
    var b = this.pattern.match(/[\***REMOVED***\)\]]/g);

    // if imbalanced, don't optimize the pattern
    if (a && b && (a.length !== b.length)) ***REMOVED***
      this.options.makeRe = false;
    ***REMOVED***

    // expand brace patterns and join the resulting array
    var expanded = utils.braces(this.pattern, this.options);
    this.pattern = expanded.join('|');
  ***REMOVED***
***REMOVED***;

/**
 * Expand bracket expressions in `glob.pattern`
 */

Glob.prototype.brackets = function() ***REMOVED***
  if (this.options.nobrackets !== true) ***REMOVED***
    this.pattern = utils.brackets(this.pattern);
  ***REMOVED***
***REMOVED***;

/**
 * Expand bracket expressions in `glob.pattern`
 */

Glob.prototype.extglob = function() ***REMOVED***
  if (this.options.noextglob === true) return;

  if (utils.isExtglob(this.pattern)) ***REMOVED***
    this.pattern = utils.extglob(this.pattern, ***REMOVED***escape: true***REMOVED***);
  ***REMOVED***
***REMOVED***;

/**
 * Parse the given pattern
 */

Glob.prototype.parse = function(pattern) ***REMOVED***
  this.tokens = utils.parseGlob(pattern || this.pattern, true);
  return this.tokens;
***REMOVED***;

/**
 * Replace `a` with `b`. Also tracks the change before and
 * after each replacement. This is disabled by default, but
 * can be enabled by setting `options.track` to true.
 *
 * Also, when the pattern is a string, `.split()` is used,
 * because it's much faster than replace.
 *
 * @param  ***REMOVED***RegExp|String***REMOVED*** `a`
 * @param  ***REMOVED***String***REMOVED*** `b`
 * @param  ***REMOVED***Boolean***REMOVED*** `escape` When `true`, escapes `*` and `?` in the replacement.
 * @return ***REMOVED***String***REMOVED***
 */

Glob.prototype._replace = function(a, b, escape) ***REMOVED***
  this.track('before (find): "' + a + '" (replace with): "' + b + '"');
  if (escape) b = esc(b);
  if (a && b && typeof a === 'string') ***REMOVED***
    this.pattern = this.pattern.split(a).join(b);
  ***REMOVED*** else ***REMOVED***
    this.pattern = this.pattern.replace(a, b);
  ***REMOVED***
  this.track('after');
***REMOVED***;

/**
 * Escape special characters in the given string.
 *
 * @param  ***REMOVED***String***REMOVED*** `str` Glob pattern
 * @return ***REMOVED***String***REMOVED***
 */

Glob.prototype.escape = function(str) ***REMOVED***
  this.track('before escape: ');
  var re = /["\\](['"]?[^"'\\]['"]?)/g;

  this.pattern = str.replace(re, function($0, $1) ***REMOVED***
    var o = chars.ESC;
    var ch = o && o[$1];
    if (ch) ***REMOVED***
      return ch;
    ***REMOVED***
    if (/[a-z]/i.test($0)) ***REMOVED***
      return $0.split('\\').join('');
    ***REMOVED***
    return $0;
  ***REMOVED***);

  this.track('after escape: ');
***REMOVED***;

/**
 * Unescape special characters in the given string.
 *
 * @param  ***REMOVED***String***REMOVED*** `str`
 * @return ***REMOVED***String***REMOVED***
 */

Glob.prototype.unescape = function(str) ***REMOVED***
  var re = /__([A-Z]+)_([A-Z]+)__/g;
  this.pattern = str.replace(re, function($0, $1) ***REMOVED***
    return chars[$1][$0];
  ***REMOVED***);
  this.pattern = unesc(this.pattern);
***REMOVED***;

/**
 * Escape/unescape utils
 */

function esc(str) ***REMOVED***
  str = str.split('?').join('%~');
  str = str.split('*').join('%%');
  return str;
***REMOVED***

function unesc(str) ***REMOVED***
  str = str.split('%~').join('?');
  str = str.split('%%').join('*');
  return str;
***REMOVED***
