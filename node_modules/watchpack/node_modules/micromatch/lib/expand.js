/*!
 * micromatch <https://github.com/jonschlinkert/micromatch>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var utils = require('./utils');
var Glob = require('./glob');

/**
 * Expose `expand`
 */

module.exports = expand;

/**
 * Expand a glob pattern to resolve braces and
 * similar patterns before converting to regex.
 *
 * @param  ***REMOVED***String|Array***REMOVED*** `pattern`
 * @param  ***REMOVED***Array***REMOVED*** `files`
 * @param  ***REMOVED***Options***REMOVED*** `opts`
 * @return ***REMOVED***Array***REMOVED***
 */

function expand(pattern, options) ***REMOVED***
  if (typeof pattern !== 'string') ***REMOVED***
    throw new TypeError('micromatch.expand(): argument should be a string.');
  ***REMOVED***

  var glob = new Glob(pattern, options || ***REMOVED******REMOVED***);
  var opts = glob.options;

  if (!utils.isGlob(pattern)) ***REMOVED***
    glob.pattern = glob.pattern.replace(/([\/.])/g, '\\$1');
    return glob;
  ***REMOVED***

  glob.pattern = glob.pattern.replace(/(\+)(?!\()/g, '\\$1');
  glob.pattern = glob.pattern.split('$').join('\\$');

  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') ***REMOVED***
    opts.braces = true;
  ***REMOVED***

  if (glob.pattern === '.*') ***REMOVED***
    return ***REMOVED***
      pattern: '\\.' + star,
      tokens: tok,
      options: opts
    ***REMOVED***;
  ***REMOVED***

  if (glob.pattern === '*') ***REMOVED***
    return ***REMOVED***
      pattern: oneStar(opts.dot),
      tokens: tok,
      options: opts
    ***REMOVED***;
  ***REMOVED***

  // parse the glob pattern into tokens
  glob.parse();
  var tok = glob.tokens;
  tok.is.negated = opts.negated;

  // dotfile handling
  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) ***REMOVED***
    opts.dotfiles = true;
    opts.dot = true;
  ***REMOVED***

  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) ***REMOVED***
    opts.dotdirs = true;
    opts.dot = true;
  ***REMOVED***

  // check for braces with a dotfile pattern
  if (/[***REMOVED***,]\./.test(glob.pattern)) ***REMOVED***
    opts.makeRe = false;
    opts.dot = true;
  ***REMOVED***

  if (opts.nonegate !== true) ***REMOVED***
    opts.negated = glob.negated;
  ***REMOVED***

  // if the leading character is a dot or a slash, escape it
  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') ***REMOVED***
    glob.pattern = '\\' + glob.pattern;
  ***REMOVED***

  /**
   * Extended globs
   */

  // expand braces, e.g `***REMOVED***1..5***REMOVED***`
  glob.track('before braces');
  if (tok.is.braces) ***REMOVED***
    glob.braces();
  ***REMOVED***
  glob.track('after braces');

  // expand extglobs, e.g `foo/!(a|b)`
  glob.track('before extglob');
  if (tok.is.extglob) ***REMOVED***
    glob.extglob();
  ***REMOVED***
  glob.track('after extglob');

  // expand brackets, e.g `[[:alpha:]]`
  glob.track('before brackets');
  if (tok.is.brackets) ***REMOVED***
    glob.brackets();
  ***REMOVED***
  glob.track('after brackets');

  // special patterns
  glob._replace('[!', '[^');
  glob._replace('(?', '(%~');
  glob._replace(/\[\]/, '\\[\\]');
  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);
  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);
  glob._replace('/.', '/(?=.)\\.', true);

  // windows drives
  glob._replace(/^(\w):([\\\/]+?)/gi, '(?=.)$1:$2', true);

  // negate slashes in exclusion ranges
  if (glob.pattern.indexOf('[^') !== -1) ***REMOVED***
    glob.pattern = negateSlash(glob.pattern);
  ***REMOVED***

  if (opts.globstar !== false && glob.pattern === '**') ***REMOVED***
    glob.pattern = globstar(opts.dot);

  ***REMOVED*** else ***REMOVED***
    glob.pattern = balance(glob.pattern, '[', ']');
    glob.escape(glob.pattern);

    // if the pattern has `**`
    if (tok.is.globstar) ***REMOVED***
      glob.pattern = collapse(glob.pattern, '/**');
      glob.pattern = collapse(glob.pattern, '**/');
      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);
      glob._replace(/\****REMOVED***2,***REMOVED***/g, '**');

      // 'foo/*'
      glob._replace(/(\w+)\*(?!\/)/g, '$1[^/]*?', true);
      glob._replace(/\*\*\/\*(\w)/g, globstar(opts.dot) + '\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);

      if (opts.dot !== true) ***REMOVED***
        glob._replace(/\*\*\/(.)/g, '(?:**\\/|)$1');
      ***REMOVED***

      // 'foo/**' or '***REMOVED*****,****REMOVED***', but not 'foo**'
      if (tok.path.dirname !== '' || /,\*\*|\*\*,/.test(glob.orig)) ***REMOVED***
        glob._replace('**', globstar(opts.dot), true);
      ***REMOVED***
    ***REMOVED***

    // ends with /*
    glob._replace(/\/\*$/, '\\/' + oneStar(opts.dot), true);
    // ends with *, no slashes
    glob._replace(/(?!\/)\*$/, star, true);
    // has 'n*.' (partial wildcard w/ file extension)
    glob._replace(/([^\/]+)\*/, '$1' + oneStar(true), true);
    // has '*'
    glob._replace('*', oneStar(opts.dot), true);
    glob._replace('?.', '?\\.', true);
    glob._replace('?:', '?:', true);

    glob._replace(/\?+/g, function(match) ***REMOVED***
      var len = match.length;
      if (len === 1) ***REMOVED***
        return qmark;
      ***REMOVED***
      return qmark + '***REMOVED***' + len + '***REMOVED***';
    ***REMOVED***);

    // escape '.abc' => '\\.abc'
    glob._replace(/\.([*\w]+)/g, '\\.$1');
    // fix '[^\\\\/]'
    glob._replace(/\[\^[\\\/]+\]/g, qmark);
    // '///' => '\/'
    glob._replace(/\/+/g, '\\/');
    // '\\\\\\' => '\\'
    glob._replace(/\\***REMOVED***2,***REMOVED***/g, '\\');
  ***REMOVED***

  // unescape previously escaped patterns
  glob.unescape(glob.pattern);
  glob._replace('__UNESC_STAR__', '*');

  // escape dots that follow qmarks
  glob._replace('?.', '?\\.');

  // remove unnecessary slashes in character classes
  glob._replace('[^\\/]', qmark);

  if (glob.pattern.length > 1) ***REMOVED***
    if (/^[\[?*]/.test(glob.pattern)) ***REMOVED***
      // only prepend the string if we don't want to match dotfiles
      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;
    ***REMOVED***
  ***REMOVED***

  return glob;
***REMOVED***

/**
 * Collapse repeated character sequences.
 *
 * ```js
 * collapse('a/../../../b', '../');
 * //=> 'a/../b'
 * ```
 *
 * @param  ***REMOVED***String***REMOVED*** `str`
 * @param  ***REMOVED***String***REMOVED*** `ch` Character sequence to collapse
 * @return ***REMOVED***String***REMOVED***
 */

function collapse(str, ch) ***REMOVED***
  var res = str.split(ch);
  var isFirst = res[0] === '';
  var isLast = res[res.length - 1] === '';
  res = res.filter(Boolean);
  if (isFirst) res.unshift('');
  if (isLast) res.push('');
  return res.join(ch);
***REMOVED***

/**
 * Negate slashes in exclusion ranges, per glob spec:
 *
 * ```js
 * negateSlash('[^foo]');
 * //=> '[^\\/foo]'
 * ```
 *
 * @param  ***REMOVED***String***REMOVED*** `str` glob pattern
 * @return ***REMOVED***String***REMOVED***
 */

function negateSlash(str) ***REMOVED***
  return str.replace(/\[\^([^\]]*?)\]/g, function(match, inner) ***REMOVED***
    if (inner.indexOf('/') === -1) ***REMOVED***
      inner = '\\/' + inner;
    ***REMOVED***
    return '[^' + inner + ']';
  ***REMOVED***);
***REMOVED***

/**
 * Escape imbalanced braces/bracket. This is a very
 * basic, naive implementation that only does enough
 * to serve the purpose.
 */

function balance(str, a, b) ***REMOVED***
  var aarr = str.split(a);
  var alen = aarr.join('').length;
  var blen = str.split(b).join('').length;

  if (alen !== blen) ***REMOVED***
    str = aarr.join('\\' + a);
    return str.split(b).join('\\' + b);
  ***REMOVED***
  return str;
***REMOVED***

/**
 * Special patterns to be converted to regex.
 * Heuristics are used to simplify patterns
 * and speed up processing.
 */

/* eslint no-multi-spaces: 0 */
var qmark       = '[^/]';
var star        = qmark + '*?';
var nodot       = '(?!\\.)(?=.)';
var dotfileGlob = '(?:\\/|^)\\.***REMOVED***1,2***REMOVED***($|\\/)';
var dotfiles    = '(?!' + dotfileGlob + ')(?=.)';
var twoStarDot  = '(?:(?!' + dotfileGlob + ').)*?';

/**
 * Create a regex for `*`.
 *
 * If `dot` is true, or the pattern does not begin with
 * a leading star, then return the simpler regex.
 */

function oneStar(dotfile) ***REMOVED***
  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : (nodot + star);
***REMOVED***

function globstar(dotfile) ***REMOVED***
  if (dotfile) ***REMOVED*** return twoStarDot; ***REMOVED***
  return '(?:(?!(?:\\/|^)\\.).)*?';
***REMOVED***
