'use strict'
var Progress = require('are-we-there-yet')
var Gauge = require('gauge')
var EE = require('events').EventEmitter
var log = exports = module.exports = new EE()
var util = require('util')

var setBlocking = require('set-blocking')
var consoleControl = require('console-control-strings')

setBlocking(true)
var stream = process.stderr
Object.defineProperty(log, 'stream', ***REMOVED***
  set: function (newStream) ***REMOVED***
    stream = newStream
    if (this.gauge) this.gauge.setWriteTo(stream, stream)
  ***REMOVED***,
  get: function () ***REMOVED***
    return stream
  ***REMOVED***
***REMOVED***)

// by default, decide based on tty-ness.
var colorEnabled
log.useColor = function () ***REMOVED***
  return colorEnabled != null ? colorEnabled : stream.isTTY
***REMOVED***

log.enableColor = function () ***REMOVED***
  colorEnabled = true
  this.gauge.setTheme(***REMOVED***hasColor: colorEnabled, hasUnicode: unicodeEnabled***REMOVED***)
***REMOVED***
log.disableColor = function () ***REMOVED***
  colorEnabled = false
  this.gauge.setTheme(***REMOVED***hasColor: colorEnabled, hasUnicode: unicodeEnabled***REMOVED***)
***REMOVED***

// default level
log.level = 'info'

log.gauge = new Gauge(stream, ***REMOVED***
  enabled: false, // no progress bars unless asked
  theme: ***REMOVED***hasColor: log.useColor()***REMOVED***,
  template: [
    ***REMOVED***type: 'progressbar', length: 20***REMOVED***,
    ***REMOVED***type: 'activityIndicator', kerning: 1, length: 1***REMOVED***,
    ***REMOVED***type: 'section', default: ''***REMOVED***,
    ':',
    ***REMOVED***type: 'logline', kerning: 1, default: ''***REMOVED***
  ]
***REMOVED***)

log.tracker = new Progress.TrackerGroup()

// we track this separately as we may need to temporarily disable the
// display of the status bar for our own loggy purposes.
log.progressEnabled = log.gauge.isEnabled()

var unicodeEnabled

log.enableUnicode = function () ***REMOVED***
  unicodeEnabled = true
  this.gauge.setTheme(***REMOVED***hasColor: this.useColor(), hasUnicode: unicodeEnabled***REMOVED***)
***REMOVED***

log.disableUnicode = function () ***REMOVED***
  unicodeEnabled = false
  this.gauge.setTheme(***REMOVED***hasColor: this.useColor(), hasUnicode: unicodeEnabled***REMOVED***)
***REMOVED***

log.setGaugeThemeset = function (themes) ***REMOVED***
  this.gauge.setThemeset(themes)
***REMOVED***

log.setGaugeTemplate = function (template) ***REMOVED***
  this.gauge.setTemplate(template)
***REMOVED***

log.enableProgress = function () ***REMOVED***
  if (this.progressEnabled) return
  this.progressEnabled = true
  this.tracker.on('change', this.showProgress)
  if (this._pause) return
  this.gauge.enable()
***REMOVED***

log.disableProgress = function () ***REMOVED***
  if (!this.progressEnabled) return
  this.progressEnabled = false
  this.tracker.removeListener('change', this.showProgress)
  this.gauge.disable()
***REMOVED***

var trackerConstructors = ['newGroup', 'newItem', 'newStream']

var mixinLog = function (tracker) ***REMOVED***
  // mixin the public methods from log into the tracker
  // (except: conflicts and one's we handle specially)
  Object.keys(log).forEach(function (P) ***REMOVED***
    if (P[0] === '_') return
    if (trackerConstructors.filter(function (C) ***REMOVED*** return C === P ***REMOVED***).length) return
    if (tracker[P]) return
    if (typeof log[P] !== 'function') return
    var func = log[P]
    tracker[P] = function () ***REMOVED***
      return func.apply(log, arguments)
    ***REMOVED***
  ***REMOVED***)
  // if the new tracker is a group, make sure any subtrackers get
  // mixed in too
  if (tracker instanceof Progress.TrackerGroup) ***REMOVED***
    trackerConstructors.forEach(function (C) ***REMOVED***
      var func = tracker[C]
      tracker[C] = function () ***REMOVED*** return mixinLog(func.apply(tracker, arguments)) ***REMOVED***
    ***REMOVED***)
  ***REMOVED***
  return tracker
***REMOVED***

// Add tracker constructors to the top level log object
trackerConstructors.forEach(function (C) ***REMOVED***
  log[C] = function () ***REMOVED*** return mixinLog(this.tracker[C].apply(this.tracker, arguments)) ***REMOVED***
***REMOVED***)

log.clearProgress = function (cb) ***REMOVED***
  if (!this.progressEnabled) return cb && process.nextTick(cb)
  this.gauge.hide(cb)
***REMOVED***

log.showProgress = function (name, completed) ***REMOVED***
  if (!this.progressEnabled) return
  var values = ***REMOVED******REMOVED***
  if (name) values.section = name
  var last = log.record[log.record.length - 1]
  if (last) ***REMOVED***
    values.subsection = last.prefix
    var disp = log.disp[last.level] || last.level
    var logline = this._format(disp, log.style[last.level])
    if (last.prefix) logline += ' ' + this._format(last.prefix, this.prefixStyle)
    logline += ' ' + last.message.split(/\r?\n/)[0]
    values.logline = logline
  ***REMOVED***
  values.completed = completed || this.tracker.completed()
  this.gauge.show(values)
***REMOVED***.bind(log) // bind for use in tracker's on-change listener

// temporarily stop emitting, but don't drop
log.pause = function () ***REMOVED***
  this._paused = true
  if (this.progressEnabled) this.gauge.disable()
***REMOVED***

log.resume = function () ***REMOVED***
  if (!this._paused) return
  this._paused = false

  var b = this._buffer
  this._buffer = []
  b.forEach(function (m) ***REMOVED***
    this.emitLog(m)
  ***REMOVED***, this)
  if (this.progressEnabled) this.gauge.enable()
***REMOVED***

log._buffer = []

var id = 0
log.record = []
log.maxRecordSize = 10000
log.log = function (lvl, prefix, message) ***REMOVED***
  var l = this.levels[lvl]
  if (l === undefined) ***REMOVED***
    return this.emit('error', new Error(util.format(
      'Undefined log level: %j', lvl)))
  ***REMOVED***

  var a = new Array(arguments.length - 2)
  var stack = null
  for (var i = 2; i < arguments.length; i++) ***REMOVED***
    var arg = a[i - 2] = arguments[i]

    // resolve stack traces to a plain string.
    if (typeof arg === 'object' && arg &&
        (arg instanceof Error) && arg.stack) ***REMOVED***
      arg.stack = stack = arg.stack + ''
    ***REMOVED***
  ***REMOVED***
  if (stack) a.unshift(stack + '\n')
  message = util.format.apply(util, a)

  var m = ***REMOVED*** id: id++,
            level: lvl,
            prefix: String(prefix || ''),
            message: message,
            messageRaw: a ***REMOVED***

  this.emit('log', m)
  this.emit('log.' + lvl, m)
  if (m.prefix) this.emit(m.prefix, m)

  this.record.push(m)
  var mrs = this.maxRecordSize
  var n = this.record.length - mrs
  if (n > mrs / 10) ***REMOVED***
    var newSize = Math.floor(mrs * 0.9)
    this.record = this.record.slice(-1 * newSize)
  ***REMOVED***

  this.emitLog(m)
***REMOVED***.bind(log)

log.emitLog = function (m) ***REMOVED***
  if (this._paused) ***REMOVED***
    this._buffer.push(m)
    return
  ***REMOVED***
  if (this.progressEnabled) this.gauge.pulse(m.prefix)
  var l = this.levels[m.level]
  if (l === undefined) return
  if (l < this.levels[this.level]) return
  if (l > 0 && !isFinite(l)) return

  // If 'disp' is null or undefined, use the lvl as a default
  // Allows: '', 0 as valid disp
  var disp = log.disp[m.level] != null ? log.disp[m.level] : m.level
  this.clearProgress()
  m.message.split(/\r?\n/).forEach(function (line) ***REMOVED***
    if (this.heading) ***REMOVED***
      this.write(this.heading, this.headingStyle)
      this.write(' ')
    ***REMOVED***
    this.write(disp, log.style[m.level])
    var p = m.prefix || ''
    if (p) this.write(' ')
    this.write(p, this.prefixStyle)
    this.write(' ' + line + '\n')
  ***REMOVED***, this)
  this.showProgress()
***REMOVED***

log._format = function (msg, style) ***REMOVED***
  if (!stream) return

  var output = ''
  if (this.useColor()) ***REMOVED***
    style = style || ***REMOVED******REMOVED***
    var settings = []
    if (style.fg) settings.push(style.fg)
    if (style.bg) settings.push('bg' + style.bg[0].toUpperCase() + style.bg.slice(1))
    if (style.bold) settings.push('bold')
    if (style.underline) settings.push('underline')
    if (style.inverse) settings.push('inverse')
    if (settings.length) output += consoleControl.color(settings)
    if (style.beep) output += consoleControl.beep()
  ***REMOVED***
  output += msg
  if (this.useColor()) ***REMOVED***
    output += consoleControl.color('reset')
  ***REMOVED***
  return output
***REMOVED***

log.write = function (msg, style) ***REMOVED***
  if (!stream) return

  stream.write(this._format(msg, style))
***REMOVED***

log.addLevel = function (lvl, n, style, disp) ***REMOVED***
  // If 'disp' is null or undefined, use the lvl as a default
  if (disp == null) disp = lvl
  this.levels[lvl] = n
  this.style[lvl] = style
  if (!this[lvl]) ***REMOVED***
    this[lvl] = function () ***REMOVED***
      var a = new Array(arguments.length + 1)
      a[0] = lvl
      for (var i = 0; i < arguments.length; i++) ***REMOVED***
        a[i + 1] = arguments[i]
      ***REMOVED***
      return this.log.apply(this, a)
    ***REMOVED***.bind(this)
  ***REMOVED***
  this.disp[lvl] = disp
***REMOVED***

log.prefixStyle = ***REMOVED*** fg: 'magenta' ***REMOVED***
log.headingStyle = ***REMOVED*** fg: 'white', bg: 'black' ***REMOVED***

log.style = ***REMOVED******REMOVED***
log.levels = ***REMOVED******REMOVED***
log.disp = ***REMOVED******REMOVED***
log.addLevel('silly', -Infinity, ***REMOVED*** inverse: true ***REMOVED***, 'sill')
log.addLevel('verbose', 1000, ***REMOVED*** fg: 'blue', bg: 'black' ***REMOVED***, 'verb')
log.addLevel('info', 2000, ***REMOVED*** fg: 'green' ***REMOVED***)
log.addLevel('timing', 2500, ***REMOVED*** fg: 'green', bg: 'black' ***REMOVED***)
log.addLevel('http', 3000, ***REMOVED*** fg: 'green', bg: 'black' ***REMOVED***)
log.addLevel('notice', 3500, ***REMOVED*** fg: 'blue', bg: 'black' ***REMOVED***)
log.addLevel('warn', 4000, ***REMOVED*** fg: 'black', bg: 'yellow' ***REMOVED***, 'WARN')
log.addLevel('error', 5000, ***REMOVED*** fg: 'red', bg: 'black' ***REMOVED***, 'ERR!')
log.addLevel('silent', Infinity)

// allow 'error' prefix
log.on('error', function () ***REMOVED******REMOVED***)
