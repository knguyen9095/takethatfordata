var wrappy = require('wrappy')
var reqs = Object.create(null)
var once = require('once')

module.exports = wrappy(inflight)

function inflight (key, cb) ***REMOVED***
  if (reqs[key]) ***REMOVED***
    reqs[key].push(cb)
    return null
  ***REMOVED*** else ***REMOVED***
    reqs[key] = [cb]
    return makeres(key)
  ***REMOVED***
***REMOVED***

function makeres (key) ***REMOVED***
  return once(function RES () ***REMOVED***
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try ***REMOVED***
      for (var i = 0; i < len; i++) ***REMOVED***
        cbs[i].apply(null, args)
      ***REMOVED***
    ***REMOVED*** finally ***REMOVED***
      if (cbs.length > len) ***REMOVED***
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () ***REMOVED***
          RES.apply(null, args)
        ***REMOVED***)
      ***REMOVED*** else ***REMOVED***
        delete reqs[key]
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***)
***REMOVED***

function slice (args) ***REMOVED***
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
***REMOVED***
