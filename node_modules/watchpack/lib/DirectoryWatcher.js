/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var EventEmitter = require("events").EventEmitter;
var async = require("async");
var chokidar = require("chokidar");
var fs = require("graceful-fs");
var path = require("path");

var watcherManager = require("./watcherManager");

var FS_ACCURACY = 10000;


function withoutCase(str) ***REMOVED***
	return str.toLowerCase();
***REMOVED***


function Watcher(directoryWatcher, filePath, startTime) ***REMOVED***
	EventEmitter.call(this);
	this.directoryWatcher = directoryWatcher;
	this.path = filePath;
	this.startTime = startTime && +startTime;
	this.data = 0;
***REMOVED***

Watcher.prototype = Object.create(EventEmitter.prototype);
Watcher.prototype.constructor = Watcher;

Watcher.prototype.checkStartTime = function checkStartTime(mtime, initial) ***REMOVED***
	if(typeof this.startTime !== "number") return !initial;
	var startTime = this.startTime;
	return startTime <= mtime;
***REMOVED***;

Watcher.prototype.close = function close() ***REMOVED***
	this.emit("closed");
***REMOVED***;


function DirectoryWatcher(directoryPath, options) ***REMOVED***
	EventEmitter.call(this);
	this.options = options;
	this.path = directoryPath;
	this.files = Object.create(null);
	this.directories = Object.create(null);
	this.watcher = chokidar.watch(directoryPath, ***REMOVED***
		ignoreInitial: true,
		persistent: true,
		followSymlinks: false,
		depth: 0,
		atomic: false,
		alwaysStat: true,
		ignorePermissionErrors: true,
		ignored: options.ignored,
		usePolling: options.poll ? true : undefined,
		interval: typeof options.poll === "number" ? options.poll : undefined,
		disableGlobbing: true
	***REMOVED***);
	this.watcher.on("add", this.onFileAdded.bind(this));
	this.watcher.on("addDir", this.onDirectoryAdded.bind(this));
	this.watcher.on("change", this.onChange.bind(this));
	this.watcher.on("unlink", this.onFileUnlinked.bind(this));
	this.watcher.on("unlinkDir", this.onDirectoryUnlinked.bind(this));
	this.watcher.on("error", this.onWatcherError.bind(this));
	this.initialScan = true;
	this.nestedWatching = false;
	this.initialScanRemoved = [];
	this.doInitialScan();
	this.watchers = Object.create(null);
	this.refs = 0;
***REMOVED***
module.exports = DirectoryWatcher;

DirectoryWatcher.prototype = Object.create(EventEmitter.prototype);
DirectoryWatcher.prototype.constructor = DirectoryWatcher;

DirectoryWatcher.prototype.setFileTime = function setFileTime(filePath, mtime, initial, type) ***REMOVED***
	var now = Date.now();
	var old = this.files[filePath];

	this.files[filePath] = [initial ? Math.min(now, mtime) : now, mtime];

	// we add the fs accurency to reach the maximum possible mtime
	if(mtime)
		mtime = mtime + FS_ACCURACY;

	if(!old) ***REMOVED***
		if(mtime) ***REMOVED***
			if(this.watchers[withoutCase(filePath)]) ***REMOVED***
				this.watchers[withoutCase(filePath)].forEach(function(w) ***REMOVED***
					if(!initial || w.checkStartTime(mtime, initial)) ***REMOVED***
						w.emit("change", mtime, initial ? "initial" : type);
					***REMOVED***
				***REMOVED***);
			***REMOVED***
		***REMOVED***
	***REMOVED*** else if(!initial && mtime && type !== "add") ***REMOVED***
		if(this.watchers[withoutCase(filePath)]) ***REMOVED***
			this.watchers[withoutCase(filePath)].forEach(function(w) ***REMOVED***
				w.emit("change", mtime, type);
			***REMOVED***);
		***REMOVED***
	***REMOVED*** else if(!initial && !mtime) ***REMOVED***
		if(this.watchers[withoutCase(filePath)]) ***REMOVED***
			this.watchers[withoutCase(filePath)].forEach(function(w) ***REMOVED***
				w.emit("remove", type);
			***REMOVED***);
		***REMOVED***
	***REMOVED***
	if(this.watchers[withoutCase(this.path)]) ***REMOVED***
		this.watchers[withoutCase(this.path)].forEach(function(w) ***REMOVED***
			if(!initial || w.checkStartTime(mtime, initial)) ***REMOVED***
				w.emit("change", filePath, mtime, initial ? "initial" : type);
			***REMOVED***
		***REMOVED***);
	***REMOVED***
***REMOVED***;

DirectoryWatcher.prototype.setDirectory = function setDirectory(directoryPath, exist, initial, type) ***REMOVED***
	if(directoryPath === this.path) ***REMOVED***
		if(!initial && this.watchers[withoutCase(this.path)]) ***REMOVED***
			this.watchers[withoutCase(this.path)].forEach(function(w) ***REMOVED***
				w.emit("change", directoryPath, w.data, initial ? "initial" : type);
			***REMOVED***);
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		var old = this.directories[directoryPath];
		if(!old) ***REMOVED***
			if(exist) ***REMOVED***
				if(this.nestedWatching) ***REMOVED***
					this.createNestedWatcher(directoryPath);
				***REMOVED*** else ***REMOVED***
					this.directories[directoryPath] = true;
				***REMOVED***
				if(!initial && this.watchers[withoutCase(this.path)]) ***REMOVED***
					this.watchers[withoutCase(this.path)].forEach(function(w) ***REMOVED***
						w.emit("change", directoryPath, w.data, initial ? "initial" : type);
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			if(!exist) ***REMOVED***
				if(this.nestedWatching)
					this.directories[directoryPath].close();
				delete this.directories[directoryPath];
				if(!initial && this.watchers[withoutCase(this.path)]) ***REMOVED***
					this.watchers[withoutCase(this.path)].forEach(function(w) ***REMOVED***
						w.emit("change", directoryPath, w.data, initial ? "initial" : type);
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***;

DirectoryWatcher.prototype.createNestedWatcher = function(directoryPath) ***REMOVED***
	this.directories[directoryPath] = watcherManager.watchDirectory(directoryPath, this.options, 1);
	this.directories[directoryPath].on("change", function(filePath, mtime, type) ***REMOVED***
		if(this.watchers[withoutCase(this.path)]) ***REMOVED***
			this.watchers[withoutCase(this.path)].forEach(function(w) ***REMOVED***
				if(w.checkStartTime(mtime, false)) ***REMOVED***
					w.emit("change", filePath, mtime, type);
				***REMOVED***
			***REMOVED***);
		***REMOVED***
	***REMOVED***.bind(this));
***REMOVED***;

DirectoryWatcher.prototype.setNestedWatching = function(flag) ***REMOVED***
	if(this.nestedWatching !== !!flag) ***REMOVED***
		this.nestedWatching = !!flag;
		if(this.nestedWatching) ***REMOVED***
			Object.keys(this.directories).forEach(function(directory) ***REMOVED***
				this.createNestedWatcher(directory);
			***REMOVED***, this);
		***REMOVED*** else ***REMOVED***
			Object.keys(this.directories).forEach(function(directory) ***REMOVED***
				this.directories[directory].close();
				this.directories[directory] = true;
			***REMOVED***, this);
		***REMOVED***
	***REMOVED***
***REMOVED***;

DirectoryWatcher.prototype.watch = function watch(filePath, startTime) ***REMOVED***
	this.watchers[withoutCase(filePath)] = this.watchers[withoutCase(filePath)] || [];
	this.refs++;
	var watcher = new Watcher(this, filePath, startTime);
	watcher.on("closed", function() ***REMOVED***
		var idx = this.watchers[withoutCase(filePath)].indexOf(watcher);
		this.watchers[withoutCase(filePath)].splice(idx, 1);
		if(this.watchers[withoutCase(filePath)].length === 0) ***REMOVED***
			delete this.watchers[withoutCase(filePath)];
			if(this.path === filePath)
				this.setNestedWatching(false);
		***REMOVED***
		if(--this.refs <= 0)
			this.close();
	***REMOVED***.bind(this));
	this.watchers[withoutCase(filePath)].push(watcher);
	var data;
	if(filePath === this.path) ***REMOVED***
		this.setNestedWatching(true);
		data = false;
		Object.keys(this.files).forEach(function(file) ***REMOVED***
			var d = this.files[file];
			if(!data)
				data = d;
			else
				data = [Math.max(data[0], d[0]), Math.max(data[1], d[1])];
		***REMOVED***, this);
	***REMOVED*** else ***REMOVED***
		data = this.files[filePath];
	***REMOVED***
	process.nextTick(function() ***REMOVED***
		if(data) ***REMOVED***
			var ts = data[0] === data[1] ? data[0] + FS_ACCURACY : data[0];
			if(ts >= startTime)
				watcher.emit("change", data[1]);
		***REMOVED*** else if(this.initialScan && this.initialScanRemoved.indexOf(filePath) >= 0) ***REMOVED***
			watcher.emit("remove");
		***REMOVED***
	***REMOVED***.bind(this));
	return watcher;
***REMOVED***;

DirectoryWatcher.prototype.onFileAdded = function onFileAdded(filePath, stat) ***REMOVED***
	if(filePath.indexOf(this.path) !== 0) return;
	if(/[\\\/]/.test(filePath.substr(this.path.length + 1))) return;

	this.setFileTime(filePath, +stat.mtime, false, "add");
***REMOVED***;

DirectoryWatcher.prototype.onDirectoryAdded = function onDirectoryAdded(directoryPath /*, stat */) ***REMOVED***
	if(directoryPath.indexOf(this.path) !== 0) return;
	if(/[\\\/]/.test(directoryPath.substr(this.path.length + 1))) return;
	this.setDirectory(directoryPath, true, false, "add");
***REMOVED***;

DirectoryWatcher.prototype.onChange = function onChange(filePath, stat) ***REMOVED***
	if(filePath.indexOf(this.path) !== 0) return;
	if(/[\\\/]/.test(filePath.substr(this.path.length + 1))) return;
	var mtime = +stat.mtime;
	ensureFsAccuracy(mtime);
	this.setFileTime(filePath, mtime, false, "change");
***REMOVED***;

DirectoryWatcher.prototype.onFileUnlinked = function onFileUnlinked(filePath) ***REMOVED***
	if(filePath.indexOf(this.path) !== 0) return;
	if(/[\\\/]/.test(filePath.substr(this.path.length + 1))) return;
	this.setFileTime(filePath, null, false, "unlink");
	if(this.initialScan) ***REMOVED***
		this.initialScanRemoved.push(filePath);
	***REMOVED***
***REMOVED***;

DirectoryWatcher.prototype.onDirectoryUnlinked = function onDirectoryUnlinked(directoryPath) ***REMOVED***
	if(directoryPath.indexOf(this.path) !== 0) return;
	if(/[\\\/]/.test(directoryPath.substr(this.path.length + 1))) return;
	this.setDirectory(directoryPath, false, false, "unlink");
	if(this.initialScan) ***REMOVED***
		this.initialScanRemoved.push(directoryPath);
	***REMOVED***
***REMOVED***;

DirectoryWatcher.prototype.onWatcherError = function onWatcherError(/* err */) ***REMOVED***
***REMOVED***;

DirectoryWatcher.prototype.doInitialScan = function doInitialScan() ***REMOVED***
	fs.readdir(this.path, function(err, items) ***REMOVED***
		if(err) ***REMOVED***
			this.initialScan = false;
			return;
		***REMOVED***
		async.forEach(items, function(item, callback) ***REMOVED***
			var itemPath = path.join(this.path, item);
			fs.stat(itemPath, function(err2, stat) ***REMOVED***
				if(!this.initialScan) return;
				if(err2) ***REMOVED***
					callback();
					return;
				***REMOVED***
				if(stat.isFile()) ***REMOVED***
					if(!this.files[itemPath])
						this.setFileTime(itemPath, +stat.mtime, true);
				***REMOVED*** else if(stat.isDirectory()) ***REMOVED***
					if(!this.directories[itemPath])
						this.setDirectory(itemPath, true, true);
				***REMOVED***
				callback();
			***REMOVED***.bind(this));
		***REMOVED***.bind(this), function() ***REMOVED***
			this.initialScan = false;
			this.initialScanRemoved = null;
		***REMOVED***.bind(this));
	***REMOVED***.bind(this));
***REMOVED***;

DirectoryWatcher.prototype.getTimes = function() ***REMOVED***
	var obj = Object.create(null);
	var selfTime = 0;
	Object.keys(this.files).forEach(function(file) ***REMOVED***
		var data = this.files[file];
		var time;
		if(data[1]) ***REMOVED***
			time = Math.max(data[0], data[1] + FS_ACCURACY);
		***REMOVED*** else ***REMOVED***
			time = data[0];
		***REMOVED***
		obj[file] = time;
		if(time > selfTime)
			selfTime = time;
	***REMOVED***, this);
	if(this.nestedWatching) ***REMOVED***
		Object.keys(this.directories).forEach(function(dir) ***REMOVED***
			var w = this.directories[dir];
			var times = w.directoryWatcher.getTimes();
			Object.keys(times).forEach(function(file) ***REMOVED***
				var time = times[file];
				obj[file] = time;
				if(time > selfTime)
					selfTime = time;
			***REMOVED***);
		***REMOVED***, this);
		obj[this.path] = selfTime;
	***REMOVED***
	return obj;
***REMOVED***;

DirectoryWatcher.prototype.close = function() ***REMOVED***
	this.initialScan = false;
	this.watcher.close();
	if(this.nestedWatching) ***REMOVED***
		Object.keys(this.directories).forEach(function(dir) ***REMOVED***
			this.directories[dir].close();
		***REMOVED***, this);
	***REMOVED***
	this.emit("closed");
***REMOVED***;

function ensureFsAccuracy(mtime) ***REMOVED***
	if(!mtime) return;
	if(FS_ACCURACY > 1 && mtime % 1 !== 0)
		FS_ACCURACY = 1;
	else if(FS_ACCURACY > 10 && mtime % 10 !== 0)
		FS_ACCURACY = 10;
	else if(FS_ACCURACY > 100 && mtime % 100 !== 0)
		FS_ACCURACY = 100;
	else if(FS_ACCURACY > 1000 && mtime % 1000 !== 0)
		FS_ACCURACY = 1000;
	else if(FS_ACCURACY > 2000 && mtime % 2000 !== 0)
		FS_ACCURACY = 2000;
***REMOVED***
