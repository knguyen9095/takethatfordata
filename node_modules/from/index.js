
'use strict';

var Stream = require('stream')

// from
//
// a stream that reads from an source.
// source may be an array, or a function.
// from handles pause behaviour for you.

module.exports =
function from (source) ***REMOVED***
  if(Array.isArray(source)) ***REMOVED***
		var source_index = 0, source_len = source.length;
    return from (function (i) ***REMOVED***
      if(source_index < source_len)
        this.emit('data', source[source_index++])
      else
        this.emit('end')
      return true
    ***REMOVED***)
  ***REMOVED***
  var s = new Stream(), i = 0
  s.ended = false
  s.started = false
  s.readable = true
  s.writable = false
  s.paused = false
  s.ended = false
  s.pause = function () ***REMOVED***
    s.started = true
    s.paused = true
  ***REMOVED***
  function next () ***REMOVED***
    s.started = true
    if(s.ended) return
    while(!s.ended && !s.paused && source.call(s, i++, function () ***REMOVED***
      if(!s.ended && !s.paused)
          process.nextTick(next);
    ***REMOVED***))
      ;
  ***REMOVED***
  s.resume = function () ***REMOVED***
    s.started = true
    s.paused = false
    next()
  ***REMOVED***
  s.on('end', function () ***REMOVED***
    s.ended = true
    s.readable = false
    process.nextTick(s.destroy)
  ***REMOVED***)
  s.destroy = function () ***REMOVED***
    s.ended = true
    s.emit('close') 
  ***REMOVED***
  /*
    by default, the stream will start emitting at nextTick
    if you want, you can pause it, after pipeing.
    you can also resume before next tick, and that will also
    work.
  */
  process.nextTick(function () ***REMOVED***
    if(!s.started) s.resume()
  ***REMOVED***)
  return s
***REMOVED***
