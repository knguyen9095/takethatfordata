var from = require('..')
var spec = require('stream-spec')
var a = require('assertions')

function read(stream, callback) ***REMOVED***
  var actual = []
  stream.on('data', function (data) ***REMOVED***
    actual.push(data)
  ***REMOVED***)
  stream.once('end', function () ***REMOVED***
    callback(null, actual)
  ***REMOVED***)
  stream.once('error', function (err) ***REMOVED***
    callback(err)
  ***REMOVED***)
***REMOVED***

function pause(stream) ***REMOVED***
  stream.on('data', function () ***REMOVED***
    if(Math.random() > 0.1) return
    stream.pause()
    process.nextTick(function () ***REMOVED***
      stream.resume()
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***

exports['inc'] = function (test) ***REMOVED***

  var fs = from(function (i) ***REMOVED***
    this.emit('data', i)
    if(i >= 99)
      return this.emit('end')
    return true
  ***REMOVED***)

  spec(fs).readable().validateOnExit() 

  read(fs, function (err, arr) ***REMOVED***
    test.equal(arr.length, 100)
    test.done()
  ***REMOVED***)
***REMOVED***

exports['inc - async'] = function (test) ***REMOVED***

  var fs = from(function (i, next) ***REMOVED***
    this.emit('data', i)
    if(i >= 99)
      return this.emit('end')
		next();
  ***REMOVED***)

  spec(fs).readable().validateOnExit() 

  read(fs, function (err, arr) ***REMOVED***
    test.equal(arr.length, 100)
    test.done()
  ***REMOVED***)
***REMOVED***

exports['large stream - from an array'] = function (test) ***REMOVED***

  var l = 100000
    , expected = [] 

  while(l--) expected.push(l * Math.random())

  var fs = from(expected.slice())

  spec(fs).readable().validateOnExit() 

  read(fs, function (err, arr) ***REMOVED***
		a.deepEqual(arr, expected)
    test.done()
  ***REMOVED***)
***REMOVED***

exports['large stream - callback return true'] = function (test) ***REMOVED***

  var fs = from(function (i, next) ***REMOVED***
    this.emit('data', i)
    if(i >= 99999)
      return this.emit('end')
		return true;
  ***REMOVED***)

  spec(fs).readable().validateOnExit() 

  read(fs, function (err, arr) ***REMOVED***
    test.equal(arr.length, 100000)
    test.done()
  ***REMOVED***)
***REMOVED***

exports['large stream - callback call next()'] = function (test) ***REMOVED***

  var fs = from(function (i, next) ***REMOVED***
    this.emit('data', i)
    if(i >= 99999)
      return this.emit('end')
		next();
  ***REMOVED***)

  spec(fs).readable().validateOnExit() 

  read(fs, function (err, arr) ***REMOVED***
    test.equal(arr.length, 100000)
    test.done()
  ***REMOVED***)
***REMOVED***

exports['simple'] = function (test) ***REMOVED***

  var l = 1000
    , expected = [] 

  while(l--) expected.push(l * Math.random())

  var t = from(expected.slice())

  spec(t)
    .readable()
    .pausable(***REMOVED***strict: true***REMOVED***)
    .validateOnExit()

  read(t, function (err, actual) ***REMOVED***
    if(err) test.error(err) //fail
    a.deepEqual(actual, expected)
    test.done()
  ***REMOVED***)

***REMOVED***

exports['simple pausable'] = function (test) ***REMOVED***

  var l = 1000
    , expected = [] 

  while(l--) expected.push(l * Math.random())

  var t = from(expected.slice())

  spec(t)
    .readable()
    .pausable(***REMOVED***strict: true***REMOVED***)
    .validateOnExit()

  pause(t)

  read(t, function (err, actual) ***REMOVED***
    if(err) test.error(err) //fail
    a.deepEqual(actual, expected)
    test.done()
  ***REMOVED***)

***REMOVED***

exports['simple (not strictly pausable) setTimeout'] = function (test) ***REMOVED***

  var l = 10
    , expected = [] 
  while(l--) expected.push(l * Math.random())


  var _expected = expected.slice()
  var t = from(function (i, n) ***REMOVED***
    var self = this
    setTimeout(function () ***REMOVED***
      if(_expected.length)
        self.emit('data', _expected.shift())
      else
        if(!self.ended)
          self.emit('end')
      n()
    ***REMOVED***, 3)
  ***REMOVED***)

  /*
    using from in this way will not be strictly pausable.
    it could be extended to buffer outputs, but I think a better
    way would be to use a PauseStream that implements strict pause.
  */

  spec(t)
    .readable()
    .pausable(***REMOVED***strict: false ***REMOVED***)
    .validateOnExit()

  //pause(t)
  var paused = false
  var i = setInterval(function () ***REMOVED***
    if(!paused) t.pause()
    else t.resume()
    paused = !paused
  ***REMOVED***, 2)

  t.on('end', function () ***REMOVED***
    clearInterval(i)
  ***REMOVED***)

  read(t, function (err, actual) ***REMOVED***
    if(err) test.error(err) //fail
    a.deepEqual(actual, expected)
    test.done()
  ***REMOVED***)

***REMOVED***


