var stream = require('readable-stream')
var eos = require('end-of-stream')
var inherits = require('inherits')
var shift = require('stream-shift')

var SIGNAL_FLUSH = new Buffer([0])

var onuncork = function(self, fn) ***REMOVED***
  if (self._corked) self.once('uncork', fn)
  else fn()
***REMOVED***

var destroyer = function(self, end) ***REMOVED***
  return function(err) ***REMOVED***
    if (err) self._destroyInterval(err)
    else if (end && !self._ended) self.end()
  ***REMOVED***
***REMOVED***

var end = function(ws, fn) ***REMOVED***
  if (!ws) return fn()
  if (ws._writableState && ws._writableState.finished) return fn()
  if (ws._writableState) return ws.end(fn)
  ws.end()
  fn()
***REMOVED***

var toStreams2 = function(rs) ***REMOVED***
  return new (stream.Readable)(***REMOVED***objectMode:true, highWaterMark:16***REMOVED***).wrap(rs)
***REMOVED***

var Duplexify = function(writable, readable, opts) ***REMOVED***
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
  stream.Duplex.call(this, opts)

  this._writable = null
  this._readable = null
  this._readable2 = null

  this._forwardDestroy = !opts || opts.destroy !== false
  this._forwardEnd = !opts || opts.end !== false
  this._corked = 1 // start corked
  this._ondrain = null
  this._drained = false
  this._forwarding = false
  this._unwrite = null
  this._unread = null
  this._ended = false
  this._error = null
  this._preferError = false

  this.destroyed = false

  if (writable) this.setWritable(writable)
  if (readable) this.setReadable(readable)
***REMOVED***

inherits(Duplexify, stream.Duplex)

Duplexify.obj = function(writable, readable, opts) ***REMOVED***
  if (!opts) opts = ***REMOVED******REMOVED***
  opts.objectMode = true
  opts.highWaterMark = 16
  return new Duplexify(writable, readable, opts)
***REMOVED***

Duplexify.prototype.cork = function() ***REMOVED***
  if (++this._corked === 1) this.emit('cork')
***REMOVED***

Duplexify.prototype.uncork = function() ***REMOVED***
  if (this._corked && --this._corked === 0) this.emit('uncork')
***REMOVED***

Duplexify.prototype.setWritable = function(writable) ***REMOVED***
  if (this._unwrite) this._unwrite()

  if (this.destroyed) ***REMOVED***
    if (writable && writable.destroy) writable.destroy()
    return
  ***REMOVED***

  if (writable === null || writable === false) ***REMOVED***
    this.end()
    return
  ***REMOVED***

  var self = this
  var unend = eos(writable, ***REMOVED***writable:true, readable:false***REMOVED***, destroyer(this, this._forwardEnd))

  var ondrain = function() ***REMOVED***
    var ondrain = self._ondrain
    self._ondrain = null
    if (ondrain) ondrain()
  ***REMOVED***

  var clear = function() ***REMOVED***
    self._writable.removeListener('drain', ondrain)
    unend()
  ***REMOVED***

  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks

  this._writable = writable
  this._writable.on('drain', ondrain)
  this._unwrite = clear

  this.uncork() // always uncork setWritable
***REMOVED***

Duplexify.prototype.setReadable = function(readable) ***REMOVED***
  if (this._unread) this._unread()

  if (this.destroyed) ***REMOVED***
    if (readable && readable.destroy) readable.destroy()
    return
  ***REMOVED***

  if (readable === null || readable === false) ***REMOVED***
    this.push(null)
    this.resume()
    return
  ***REMOVED***

  var self = this
  var unend = eos(readable, ***REMOVED***writable:false, readable:true***REMOVED***, destroyer(this))

  var onreadable = function() ***REMOVED***
    self._forward()
  ***REMOVED***

  var onend = function() ***REMOVED***
    self.push(null)
  ***REMOVED***

  var clear = function() ***REMOVED***
    self._readable2.removeListener('readable', onreadable)
    self._readable2.removeListener('end', onend)
    unend()
  ***REMOVED***

  this._drained = true
  this._readable = readable
  this._readable2 = readable._readableState ? readable : toStreams2(readable)
  this._readable2.on('readable', onreadable)
  this._readable2.on('end', onend)
  this._unread = clear

  this._forward()
***REMOVED***

Duplexify.prototype._read = function() ***REMOVED***
  this._drained = true
  this._forward()
***REMOVED***

Duplexify.prototype._forward = function() ***REMOVED***
  if (this._forwarding || !this._readable2 || !this._drained) return
  this._forwarding = true

  var data

  while (this._drained && (data = shift(this._readable2)) !== null) ***REMOVED***
    if (this.destroyed) continue
    this._drained = this.push(data)
  ***REMOVED***

  this._forwarding = false
***REMOVED***

Duplexify.prototype.destroy = function(err) ***REMOVED***
  if (this._preferError && !this._error && err) this._error = err

  if (this.destroyed) return
  this.destroyed = true

  var self = this
  process.nextTick(function() ***REMOVED***
    self._destroy(self._preferError ? self._error : err)
  ***REMOVED***)
***REMOVED***

Duplexify.prototype._destroyInterval = function(err) ***REMOVED***
  if (this.destroyed) return
  if (err.message !== 'premature close') return this.destroy(err)
  this._preferError = true
  this.destroy(null)
***REMOVED***

Duplexify.prototype._destroy = function(err) ***REMOVED***
  if (err) ***REMOVED***
    var ondrain = this._ondrain
    this._ondrain = null
    if (ondrain) ondrain(err)
    else this.emit('error', err)
  ***REMOVED***

  if (this._forwardDestroy) ***REMOVED***
    if (this._readable && this._readable.destroy) this._readable.destroy()
    if (this._writable && this._writable.destroy) this._writable.destroy()
  ***REMOVED***

  this.emit('close')
***REMOVED***

Duplexify.prototype._write = function(data, enc, cb) ***REMOVED***
  if (this.destroyed) return cb()
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
  if (data === SIGNAL_FLUSH) return this._finish(cb)
  if (!this._writable) return cb()

  if (this._writable.write(data) === false) this._ondrain = cb
  else cb()
***REMOVED***


Duplexify.prototype._finish = function(cb) ***REMOVED***
  var self = this
  this.emit('preend')
  onuncork(this, function() ***REMOVED***
    end(self._forwardEnd && self._writable, function() ***REMOVED***
      // haxx to not emit prefinish twice
      if (self._writableState.prefinished === false) self._writableState.prefinished = true
      self.emit('prefinish')
      onuncork(self, cb)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***

Duplexify.prototype.end = function(data, enc, cb) ***REMOVED***
  if (typeof data === 'function') return this.end(null, null, data)
  if (typeof enc === 'function') return this.end(data, null, enc)
  this._ended = true
  if (data) this.write(data)
  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
  return stream.Writable.prototype.end.call(this, cb)
***REMOVED***

module.exports = Duplexify
