'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () ***REMOVED*** /* empty */ ***REMOVED***;
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () ***REMOVED***
  try ***REMOVED***
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = ***REMOVED******REMOVED***)[require('./_wks')('species')] = function (exec) ***REMOVED***
      exec(empty, empty);
    ***REMOVED***;
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  ***REMOVED*** catch (e) ***REMOVED*** /* empty */ ***REMOVED***
***REMOVED***();

// helpers
var isThenable = function (it) ***REMOVED***
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
***REMOVED***;
var notify = function (promise, isReject) ***REMOVED***
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () ***REMOVED***
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) ***REMOVED***
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try ***REMOVED***
        if (handler) ***REMOVED***
          if (!ok) ***REMOVED***
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          ***REMOVED***
          if (handler === true) result = value;
          else ***REMOVED***
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          ***REMOVED***
          if (result === reaction.promise) ***REMOVED***
            reject(TypeError('Promise-chain cycle'));
          ***REMOVED*** else if (then = isThenable(result)) ***REMOVED***
            then.call(result, resolve, reject);
          ***REMOVED*** else resolve(result);
        ***REMOVED*** else reject(value);
      ***REMOVED*** catch (e) ***REMOVED***
        reject(e);
      ***REMOVED***
    ***REMOVED***;
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  ***REMOVED***);
***REMOVED***;
var onUnhandled = function (promise) ***REMOVED***
  task.call(global, function () ***REMOVED***
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) ***REMOVED***
      result = perform(function () ***REMOVED***
        if (isNode) ***REMOVED***
          process.emit('unhandledRejection', value, promise);
        ***REMOVED*** else if (handler = global.onunhandledrejection) ***REMOVED***
          handler(***REMOVED*** promise: promise, reason: value ***REMOVED***);
        ***REMOVED*** else if ((console = global.console) && console.error) ***REMOVED***
          console.error('Unhandled promise rejection', value);
        ***REMOVED***
      ***REMOVED***);
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    ***REMOVED*** promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  ***REMOVED***);
***REMOVED***;
var isUnhandled = function (promise) ***REMOVED***
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
***REMOVED***;
var onHandleUnhandled = function (promise) ***REMOVED***
  task.call(global, function () ***REMOVED***
    var handler;
    if (isNode) ***REMOVED***
      process.emit('rejectionHandled', promise);
    ***REMOVED*** else if (handler = global.onrejectionhandled) ***REMOVED***
      handler(***REMOVED*** promise: promise, reason: promise._v ***REMOVED***);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;
var $reject = function (value) ***REMOVED***
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
***REMOVED***;
var $resolve = function (value) ***REMOVED***
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try ***REMOVED***
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) ***REMOVED***
      microtask(function () ***REMOVED***
        var wrapper = ***REMOVED*** _w: promise, _d: false ***REMOVED***; // wrap
        try ***REMOVED***
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        ***REMOVED*** catch (e) ***REMOVED***
          $reject.call(wrapper, e);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    ***REMOVED***
  ***REMOVED*** catch (e) ***REMOVED***
    $reject.call(***REMOVED*** _w: promise, _d: false ***REMOVED***, e); // wrap
  ***REMOVED***
***REMOVED***;

// constructor polyfill
if (!USE_NATIVE) ***REMOVED***
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) ***REMOVED***
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try ***REMOVED***
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    ***REMOVED*** catch (err) ***REMOVED***
      $reject.call(this, err);
    ***REMOVED***
  ***REMOVED***;
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) ***REMOVED***
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  ***REMOVED***;
  Internal.prototype = require('./_redefine-all')($Promise.prototype, ***REMOVED***
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) ***REMOVED***
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    ***REMOVED***,
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) ***REMOVED***
      return this.then(undefined, onRejected);
    ***REMOVED***
  ***REMOVED***);
  OwnPromiseCapability = function () ***REMOVED***
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  ***REMOVED***;
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) ***REMOVED***
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  ***REMOVED***;
***REMOVED***

$export($export.G + $export.W + $export.F * !USE_NATIVE, ***REMOVED*** Promise: $Promise ***REMOVED***);
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, ***REMOVED***
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) ***REMOVED***
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  ***REMOVED***
***REMOVED***);
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, ***REMOVED***
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) ***REMOVED***
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  ***REMOVED***
***REMOVED***);
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) ***REMOVED***
  $Promise.all(iter)['catch'](empty);
***REMOVED***)), PROMISE, ***REMOVED***
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) ***REMOVED***
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () ***REMOVED***
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) ***REMOVED***
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) ***REMOVED***
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        ***REMOVED***, reject);
      ***REMOVED***);
      --remaining || resolve(values);
    ***REMOVED***);
    if (result.e) reject(result.v);
    return capability.promise;
  ***REMOVED***,
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) ***REMOVED***
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () ***REMOVED***
      forOf(iterable, false, function (promise) ***REMOVED***
        C.resolve(promise).then(capability.resolve, reject);
      ***REMOVED***);
    ***REMOVED***);
    if (result.e) reject(result.v);
    return capability.promise;
  ***REMOVED***
***REMOVED***);
