'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var has = require('./_has');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () ***REMOVED*** return this; ***REMOVED***;

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) ***REMOVED***
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) ***REMOVED***
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) ***REMOVED***
      case KEYS: return function keys() ***REMOVED*** return new Constructor(this, kind); ***REMOVED***;
      case VALUES: return function values() ***REMOVED*** return new Constructor(this, kind); ***REMOVED***;
    ***REMOVED*** return function entries() ***REMOVED*** return new Constructor(this, kind); ***REMOVED***;
  ***REMOVED***;
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) ***REMOVED***
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) ***REMOVED***
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    ***REMOVED***
  ***REMOVED***
  // fix Array#***REMOVED***values, @@iterator***REMOVED***.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) ***REMOVED***
    VALUES_BUG = true;
    $default = function values() ***REMOVED*** return $native.call(this); ***REMOVED***;
  ***REMOVED***
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) ***REMOVED***
    hide(proto, ITERATOR, $default);
  ***REMOVED***
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) ***REMOVED***
    methods = ***REMOVED***
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    ***REMOVED***;
    if (FORCED) for (key in methods) ***REMOVED***
      if (!(key in proto)) redefine(proto, key, methods[key]);
    ***REMOVED*** else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  ***REMOVED***
  return methods;
***REMOVED***;
