'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) ***REMOVED***
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = ***REMOVED******REMOVED***;
  var fixMethod = function (KEY) ***REMOVED***
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) ***REMOVED***
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      ***REMOVED*** : KEY == 'has' ? function has(a) ***REMOVED***
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      ***REMOVED*** : KEY == 'get' ? function get(a) ***REMOVED***
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      ***REMOVED*** : KEY == 'add' ? function add(a) ***REMOVED*** fn.call(this, a === 0 ? 0 : a); return this; ***REMOVED***
        : function set(a, b) ***REMOVED*** fn.call(this, a === 0 ? 0 : a, b); return this; ***REMOVED***
    );
  ***REMOVED***;
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () ***REMOVED***
    new C().entries().next();
  ***REMOVED***))) ***REMOVED***
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  ***REMOVED*** else ***REMOVED***
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? ***REMOVED******REMOVED*** : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () ***REMOVED*** instance.has(1); ***REMOVED***);
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) ***REMOVED*** new C(iter); ***REMOVED***); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () ***REMOVED***
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    ***REMOVED***);
    if (!ACCEPT_ITERABLES) ***REMOVED***
      C = wrapper(function (target, iterable) ***REMOVED***
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      ***REMOVED***);
      C.prototype = proto;
      proto.constructor = C;
    ***REMOVED***
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) ***REMOVED***
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    ***REMOVED***
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  ***REMOVED***

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
***REMOVED***;
