'use strict';

var use = require('use');
var util = require('util');
var Cache = require('map-cache');
var define = require('define-property');
var debug = require('debug')('snapdragon:parser');
var Position = require('./position');
var utils = require('./utils');

/**
 * Create a new `Parser` with the given `input` and `options`.
 * @param ***REMOVED***String***REMOVED*** `input`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @api public
 */

function Parser(options) ***REMOVED***
  debug('initializing', __filename);
  this.options = utils.extend(***REMOVED***source: 'string'***REMOVED***, options);
  this.init(this.options);
  use(this);
***REMOVED***

/**
 * Prototype methods
 */

Parser.prototype = ***REMOVED***
  constructor: Parser,

  init: function(options) ***REMOVED***
    this.orig = '';
    this.input = '';
    this.parsed = '';

    this.column = 1;
    this.line = 1;

    this.regex = new Cache();
    this.errors = this.errors || [];
    this.parsers = this.parsers || ***REMOVED******REMOVED***;
    this.types = this.types || [];
    this.sets = this.sets || ***REMOVED******REMOVED***;
    this.fns = this.fns || [];
    this.currentType = 'root';

    var pos = this.position();
    this.bos = pos(***REMOVED***type: 'bos', val: ''***REMOVED***);

    this.ast = ***REMOVED***
      type: 'root',
      errors: this.errors,
      nodes: [this.bos]
    ***REMOVED***;

    define(this.bos, 'parent', this.ast);
    this.nodes = [this.ast];

    this.count = 0;
    this.setCount = 0;
    this.stack = [];
  ***REMOVED***,

  /**
   * Throw a formatted error with the cursor column and `msg`.
   * @param ***REMOVED***String***REMOVED*** `msg` Message to use in the Error.
   */

  error: function(msg, node) ***REMOVED***
    var pos = node.position || ***REMOVED***start: ***REMOVED***column: 0, line: 0***REMOVED******REMOVED***;
    var line = pos.start.line;
    var column = pos.start.column;
    var source = this.options.source;

    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;
    var err = new Error(message);
    err.source = source;
    err.reason = msg;
    err.pos = pos;

    if (this.options.silent) ***REMOVED***
      this.errors.push(err);
    ***REMOVED*** else ***REMOVED***
      throw err;
    ***REMOVED***
  ***REMOVED***,

  /**
   * Define a non-enumberable property on the `Parser` instance.
   *
   * ```js
   * parser.define('foo', 'bar');
   * ```
   * @name .define
   * @param ***REMOVED***String***REMOVED*** `key` propery name
   * @param ***REMOVED***any***REMOVED*** `val` property value
   * @return ***REMOVED***Object***REMOVED*** Returns the Parser instance for chaining.
   * @api public
   */

  define: function(key, val) ***REMOVED***
    define(this, key, val);
    return this;
  ***REMOVED***,

  /**
   * Mark position and patch `node.position`.
   */

  position: function() ***REMOVED***
    var start = ***REMOVED*** line: this.line, column: this.column ***REMOVED***;
    var self = this;

    return function(node) ***REMOVED***
      define(node, 'position', new Position(start, self));
      return node;
    ***REMOVED***;
  ***REMOVED***,

  /**
   * Set parser `name` with the given `fn`
   * @param ***REMOVED***String***REMOVED*** `name`
   * @param ***REMOVED***Function***REMOVED*** `fn`
   * @api public
   */

  set: function(type, fn) ***REMOVED***
    if (this.types.indexOf(type) === -1) ***REMOVED***
      this.types.push(type);
    ***REMOVED***
    this.parsers[type] = fn.bind(this);
    return this;
  ***REMOVED***,

  /**
   * Get parser `name`
   * @param ***REMOVED***String***REMOVED*** `name`
   * @api public
   */

  get: function(name) ***REMOVED***
    return this.parsers[name];
  ***REMOVED***,

  /**
   * Push a `token` onto the `type` stack.
   *
   * @param ***REMOVED***String***REMOVED*** `type`
   * @return ***REMOVED***Object***REMOVED*** `token`
   * @api public
   */

  push: function(type, token) ***REMOVED***
    this.sets[type] = this.sets[type] || [];
    this.count++;
    this.stack.push(token);
    return this.sets[type].push(token);
  ***REMOVED***,

  /**
   * Pop a token off of the `type` stack
   * @param ***REMOVED***String***REMOVED*** `type`
   * @returns ***REMOVED***Object***REMOVED*** Returns a token
   * @api public
   */

  pop: function(type) ***REMOVED***
    this.sets[type] = this.sets[type] || [];
    this.count--;
    this.stack.pop();
    return this.sets[type].pop();
  ***REMOVED***,

  /**
   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.
   *
   * @param ***REMOVED***String***REMOVED*** `type`
   * @return ***REMOVED***Boolean***REMOVED***
   * @api public
   */

  isInside: function(type) ***REMOVED***
    this.sets[type] = this.sets[type] || [];
    return this.sets[type].length > 0;
  ***REMOVED***,

  /**
   * Return true if `node` is the given `type`.
   *
   * ```js
   * parser.isType(node, 'brace');
   * ```
   * @param ***REMOVED***Object***REMOVED*** `node`
   * @param ***REMOVED***String***REMOVED*** `type`
   * @return ***REMOVED***Boolean***REMOVED***
   * @api public
   */

  isType: function(node, type) ***REMOVED***
    return node && node.type === type;
  ***REMOVED***,

  /**
   * Get the previous AST node
   * @return ***REMOVED***Object***REMOVED***
   */

  prev: function(n) ***REMOVED***
    return this.stack.length > 0
      ? utils.last(this.stack, n)
      : utils.last(this.nodes, n);
  ***REMOVED***,

  /**
   * Update line and column based on `str`.
   */

  consume: function(len) ***REMOVED***
    this.input = this.input.substr(len);
  ***REMOVED***,

  /**
   * Update column based on `str`.
   */

  updatePosition: function(str, len) ***REMOVED***
    var lines = str.match(/\n/g);
    if (lines) this.line += lines.length;
    var i = str.lastIndexOf('\n');
    this.column = ~i ? len - i : this.column + len;
    this.parsed += str;
    this.consume(len);
  ***REMOVED***,

  /**
   * Match `regex`, return captures, and update the cursor position by `match[0]` length.
   * @param ***REMOVED***RegExp***REMOVED*** `regex`
   * @return ***REMOVED***Object***REMOVED***
   */

  match: function(regex) ***REMOVED***
    var m = regex.exec(this.input);
    if (m) ***REMOVED***
      this.updatePosition(m[0], m[0].length);
      return m;
    ***REMOVED***
  ***REMOVED***,

  /**
   * Capture `type` with the given regex.
   * @param ***REMOVED***String***REMOVED*** `type`
   * @param ***REMOVED***RegExp***REMOVED*** `regex`
   * @return ***REMOVED***Function***REMOVED***
   */

  capture: function(type, regex) ***REMOVED***
    if (typeof regex === 'function') ***REMOVED***
      return this.set.apply(this, arguments);
    ***REMOVED***

    this.regex.set(type, regex);
    this.set(type, function() ***REMOVED***
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(regex);
      if (!m || !m[0]) return;

      var prev = this.prev();
      var node = pos(***REMOVED***
        type: type,
        val: m[0],
        parsed: parsed,
        rest: this.input
      ***REMOVED***);

      if (m[1]) ***REMOVED***
        node.inner = m[1];
      ***REMOVED***

      define(node, 'inside', this.stack.length > 0);
      define(node, 'parent', prev);
      prev.nodes.push(node);
    ***REMOVED***.bind(this));
    return this;
  ***REMOVED***,

  /**
   * Create a parser with open and close for parens,
   * brackets or braces
   */

  capturePair: function(type, openRegex, closeRegex, fn) ***REMOVED***
    this.sets[type] = this.sets[type] || [];

    /**
     * Open
     */

    this.set(type + '.open', function() ***REMOVED***
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(openRegex);
      if (!m || !m[0]) return;

      var val = m[0];
      this.setCount++;
      this.specialChars = true;
      var open = pos(***REMOVED***
        type: type + '.open',
        val: val,
        rest: this.input
      ***REMOVED***);

      if (typeof m[1] !== 'undefined') ***REMOVED***
        open.inner = m[1];
      ***REMOVED***

      var prev = this.prev();
      var node = pos(***REMOVED***
        type: type,
        nodes: [open]
      ***REMOVED***);

      define(node, 'rest', this.input);
      define(node, 'parsed', parsed);
      define(node, 'prefix', m[1]);
      define(node, 'parent', prev);
      define(open, 'parent', node);

      if (typeof fn === 'function') ***REMOVED***
        fn.call(this, open, node);
      ***REMOVED***

      this.push(type, node);
      prev.nodes.push(node);
    ***REMOVED***);

    /**
     * Close
     */

    this.set(type + '.close', function() ***REMOVED***
      var pos = this.position();
      var m = this.match(closeRegex);
      if (!m || !m[0]) return;

      var parent = this.pop(type);
      var node = pos(***REMOVED***
        type: type + '.close',
        rest: this.input,
        suffix: m[1],
        val: m[0]
      ***REMOVED***);

      if (!this.isType(parent, type)) ***REMOVED***
        if (this.options.strict) ***REMOVED***
          throw new Error('missing opening "' + type + '"');
        ***REMOVED***

        this.setCount--;
        node.escaped = true;
        return node;
      ***REMOVED***

      if (node.suffix === '\\') ***REMOVED***
        parent.escaped = true;
        node.escaped = true;
      ***REMOVED***

      parent.nodes.push(node);
      define(node, 'parent', parent);
    ***REMOVED***);

    return this;
  ***REMOVED***,

  /**
   * Capture end-of-string
   */

  eos: function() ***REMOVED***
    var pos = this.position();
    if (this.input) return;
    var prev = this.prev();

    while (prev.type !== 'root' && !prev.visited) ***REMOVED***
      if (this.options.strict === true) ***REMOVED***
        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));
      ***REMOVED***

      if (!hasDelims(prev)) ***REMOVED***
        prev.parent.escaped = true;
        prev.escaped = true;
      ***REMOVED***

      visit(prev, function(node) ***REMOVED***
        if (!hasDelims(node.parent)) ***REMOVED***
          node.parent.escaped = true;
          node.escaped = true;
        ***REMOVED***
      ***REMOVED***);

      prev = prev.parent;
    ***REMOVED***

    var tok = pos(***REMOVED***
      type: 'eos',
      val: this.append || ''
    ***REMOVED***);

    define(tok, 'parent', this.ast);
    return tok;
  ***REMOVED***,

  /**
   * Run parsers to advance the cursor position
   */

  next: function() ***REMOVED***
    var parsed = this.parsed;
    var len = this.types.length;
    var idx = -1;
    var tok;

    while (++idx < len) ***REMOVED***
      if ((tok = this.parsers[this.types[idx]].call(this))) ***REMOVED***
        define(tok, 'rest', this.input);
        define(tok, 'parsed', parsed);
        this.last = tok;
        return tok;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,

  /**
   * Parse the given string.
   * @return ***REMOVED***Array***REMOVED***
   */

  parse: function(input) ***REMOVED***
    if (typeof input !== 'string') ***REMOVED***
      throw new TypeError('expected a string');
    ***REMOVED***

    this.init(this.options);
    this.orig = input;
    this.input = input;
    var self = this;

    function parse() ***REMOVED***
      // check input before calling `.next()`
      input = self.input;

      // get the next AST ndoe
      var node = self.next();
      if (node) ***REMOVED***
        var prev = self.prev();
        if (prev) ***REMOVED***
          define(node, 'parent', prev);
          if (prev.nodes) ***REMOVED***
            prev.nodes.push(node);
          ***REMOVED***
        ***REMOVED***

        if (self.sets.hasOwnProperty(prev.type)) ***REMOVED***
          self.currentType = prev.type;
        ***REMOVED***
      ***REMOVED***

      // if we got here but input is not changed, throw an error
      if (self.input && input === self.input) ***REMOVED***
        throw new Error('no parsers registered for: "' + self.input.slice(0, 5) + '"');
      ***REMOVED***
    ***REMOVED***

    while (this.input) parse();
    if (this.stack.length && this.options.strict) ***REMOVED***
      var node = this.stack.pop();
      throw this.error('missing opening ' + node.type + ': "' + this.orig + '"');
    ***REMOVED***

    var eos = this.eos();
    var tok = this.prev();
    if (tok.type !== 'eos') ***REMOVED***
      this.ast.nodes.push(eos);
    ***REMOVED***

    return this.ast;
  ***REMOVED***
***REMOVED***;

/**
 * Visit `node` with the given `fn`
 */

function visit(node, fn) ***REMOVED***
  if (!node.visited) ***REMOVED***
    define(node, 'visited', true);
    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
  ***REMOVED***
  return node;
***REMOVED***

/**
 * Map visit over array of `nodes`.
 */

function mapVisit(nodes, fn) ***REMOVED***
  var len = nodes.length;
  var idx = -1;
  while (++idx < len) ***REMOVED***
    visit(nodes[idx], fn);
  ***REMOVED***
***REMOVED***

function hasOpen(node) ***REMOVED***
  return node.nodes && node.nodes[0].type === (node.type + '.open');
***REMOVED***

function hasClose(node) ***REMOVED***
  return node.nodes && utils.last(node.nodes).type === (node.type + '.close');
***REMOVED***

function hasDelims(node) ***REMOVED***
  return hasOpen(node) && hasClose(node);
***REMOVED***

/**
 * Expose `Parser`
 */

module.exports = Parser;
