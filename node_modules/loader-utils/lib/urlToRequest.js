"use strict";

// we can't use path.win32.isAbsolute because it also matches paths starting with a forward slash
const matchNativeWin32Path = /^[A-Z]:[/\\]|^\\\\/i;

function urlToRequest(url, root) ***REMOVED***
	const moduleRequestRegex = /^[^?]*~/;
	let request;

	if(matchNativeWin32Path.test(url)) ***REMOVED***
		// absolute windows path, keep it
		request = url;
	***REMOVED*** else if(root !== undefined && root !== false && /^\//.test(url)) ***REMOVED***
		// if root is set and the url is root-relative
		switch(typeof root) ***REMOVED***
			// 1. root is a string: root is prefixed to the url
			case "string":
				// special case: `~` roots convert to module request
				if(moduleRequestRegex.test(root)) ***REMOVED***
					request = root.replace(/([^~\/])$/, "$1/") + url.slice(1);
				***REMOVED*** else ***REMOVED***
					request = root + url;
				***REMOVED***
				break;
			// 2. root is `true`: absolute paths are allowed
			//    *nix only, windows-style absolute paths are always allowed as they doesn't start with a `/`
			case "boolean":
				request = url;
				break;
			default:
				throw new Error("Unexpected parameters to loader-utils 'urlToRequest': url = " + url + ", root = " + root + ".");
		***REMOVED***
	***REMOVED*** else if(/^\.\.?\//.test(url)) ***REMOVED***
		// A relative url stays
		request = url;
	***REMOVED*** else ***REMOVED***
		// every other url is threaded like a relative url
		request = "./" + url;
	***REMOVED***

	// A `~` makes the url an module
	if(moduleRequestRegex.test(request)) ***REMOVED***
		request = request.replace(moduleRequestRegex, "");
	***REMOVED***

	return request;
***REMOVED***

module.exports = urlToRequest;
