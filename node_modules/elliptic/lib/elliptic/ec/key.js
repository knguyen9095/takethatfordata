'use strict';

var BN = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) ***REMOVED***
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, ***REMOVED*** priv: ..., pub: ... ***REMOVED***)
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
***REMOVED***
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) ***REMOVED***
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, ***REMOVED***
    pub: pub,
    pubEnc: enc
  ***REMOVED***);
***REMOVED***;

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) ***REMOVED***
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, ***REMOVED***
    priv: priv,
    privEnc: enc
  ***REMOVED***);
***REMOVED***;

KeyPair.prototype.validate = function validate() ***REMOVED***
  var pub = this.getPublic();

  if (pub.isInfinity())
    return ***REMOVED*** result: false, reason: 'Invalid public key' ***REMOVED***;
  if (!pub.validate())
    return ***REMOVED*** result: false, reason: 'Public key is not a point' ***REMOVED***;
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return ***REMOVED*** result: false, reason: 'Public key * N != O' ***REMOVED***;

  return ***REMOVED*** result: true, reason: null ***REMOVED***;
***REMOVED***;

KeyPair.prototype.getPublic = function getPublic(compact, enc) ***REMOVED***
  // compact is optional argument
  if (typeof compact === 'string') ***REMOVED***
    enc = compact;
    compact = null;
  ***REMOVED***

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
***REMOVED***;

KeyPair.prototype.getPrivate = function getPrivate(enc) ***REMOVED***
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
***REMOVED***;

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) ***REMOVED***
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
***REMOVED***;

KeyPair.prototype._importPublic = function _importPublic(key, enc) ***REMOVED***
  if (key.x || key.y) ***REMOVED***
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') ***REMOVED***
      assert(key.x, 'Need x coordinate');
    ***REMOVED*** else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') ***REMOVED***
      assert(key.x && key.y, 'Need both x and y coordinate');
    ***REMOVED***
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  ***REMOVED***
  this.pub = this.ec.curve.decodePoint(key, enc);
***REMOVED***;

// ECDH
KeyPair.prototype.derive = function derive(pub) ***REMOVED***
  return pub.mul(this.priv).getX();
***REMOVED***;

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) ***REMOVED***
  return this.ec.sign(msg, this, enc, options);
***REMOVED***;

KeyPair.prototype.verify = function verify(msg, signature) ***REMOVED***
  return this.ec.verify(msg, signature, this);
***REMOVED***;

KeyPair.prototype.inspect = function inspect() ***REMOVED***
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
***REMOVED***;
