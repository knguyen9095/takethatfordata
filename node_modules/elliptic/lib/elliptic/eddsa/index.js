'use strict';

var hash = require('hash.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) ***REMOVED***
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
***REMOVED***

module.exports = EDDSA;

/**
* @param ***REMOVED***Array|String***REMOVED*** message - message bytes
* @param ***REMOVED***Array|String|KeyPair***REMOVED*** secret - secret bytes or a keypair
* @returns ***REMOVED***Signature***REMOVED*** - signature
*/
EDDSA.prototype.sign = function sign(message, secret) ***REMOVED***
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature(***REMOVED*** R: R, S: S, Rencoded: Rencoded ***REMOVED***);
***REMOVED***;

/**
* @param ***REMOVED***Array***REMOVED*** message - message bytes
* @param ***REMOVED***Array|String|Signature***REMOVED*** sig - sig bytes
* @param ***REMOVED***Array|String|Point|KeyPair***REMOVED*** pub - public key
* @returns ***REMOVED***Boolean***REMOVED*** - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) ***REMOVED***
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
***REMOVED***;

EDDSA.prototype.hashInt = function hashInt() ***REMOVED***
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
***REMOVED***;

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) ***REMOVED***
  return KeyPair.fromPublic(this, pub);
***REMOVED***;

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) ***REMOVED***
  return KeyPair.fromSecret(this, secret);
***REMOVED***;

EDDSA.prototype.makeSignature = function makeSignature(sig) ***REMOVED***
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
***REMOVED***;

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) ***REMOVED***
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
***REMOVED***;

EDDSA.prototype.decodePoint = function decodePoint(bytes) ***REMOVED***
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
***REMOVED***;

EDDSA.prototype.encodeInt = function encodeInt(num) ***REMOVED***
  return num.toArray('le', this.encodingLength);
***REMOVED***;

EDDSA.prototype.decodeInt = function decodeInt(bytes) ***REMOVED***
  return utils.intFromLE(bytes);
***REMOVED***;

EDDSA.prototype.isPoint = function isPoint(val) ***REMOVED***
  return val instanceof this.pointClass;
***REMOVED***;
