'use strict';

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param ***REMOVED***EDDSA***REMOVED*** eddsa - instance
* @param ***REMOVED***Object***REMOVED*** params - public/private key parameters
*
* @param ***REMOVED***Array<Byte>***REMOVED*** [params.secret] - secret seed bytes
* @param ***REMOVED***Point***REMOVED*** [params.pub] - public key point (aka `A` in eddsa terms)
* @param ***REMOVED***Array<Byte>***REMOVED*** [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) ***REMOVED***
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
***REMOVED***

KeyPair.fromPublic = function fromPublic(eddsa, pub) ***REMOVED***
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, ***REMOVED*** pub: pub ***REMOVED***);
***REMOVED***;

KeyPair.fromSecret = function fromSecret(eddsa, secret) ***REMOVED***
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, ***REMOVED*** secret: secret ***REMOVED***);
***REMOVED***;

KeyPair.prototype.secret = function secret() ***REMOVED***
  return this._secret;
***REMOVED***;

cachedProperty(KeyPair, 'pubBytes', function pubBytes() ***REMOVED***
  return this.eddsa.encodePoint(this.pub());
***REMOVED***);

cachedProperty(KeyPair, 'pub', function pub() ***REMOVED***
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
***REMOVED***);

cachedProperty(KeyPair, 'privBytes', function privBytes() ***REMOVED***
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
***REMOVED***);

cachedProperty(KeyPair, 'priv', function priv() ***REMOVED***
  return this.eddsa.decodeInt(this.privBytes());
***REMOVED***);

cachedProperty(KeyPair, 'hash', function hash() ***REMOVED***
  return this.eddsa.hash().update(this.secret()).digest();
***REMOVED***);

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() ***REMOVED***
  return this.hash().slice(this.eddsa.encodingLength);
***REMOVED***);

KeyPair.prototype.sign = function sign(message) ***REMOVED***
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
***REMOVED***;

KeyPair.prototype.verify = function verify(message, sig) ***REMOVED***
  return this.eddsa.verify(message, sig, this);
***REMOVED***;

KeyPair.prototype.getSecret = function getSecret(enc) ***REMOVED***
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
***REMOVED***;

KeyPair.prototype.getPublic = function getPublic(enc) ***REMOVED***
  return utils.encode(this.pubBytes(), enc);
***REMOVED***;

module.exports = KeyPair;
