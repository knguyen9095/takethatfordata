'use strict'

var bufferEqual = require('buffer-equal')
var ConfigStore = require('configstore')
var crypto = require('crypto')
var googleAuth = require('google-auto-auth')
var Pumpify = require('pumpify')
var request = require('request').defaults(***REMOVED***
  json: true,
  pool: ***REMOVED***
    maxSockets: Infinity
  ***REMOVED***
***REMOVED***)
var StreamEvents = require('stream-events')
var through = require('through2')
var util = require('util')

var BASE_URI = 'https://www.googleapis.com/upload/storage/v1/b'
var TERMINATED_UPLOAD_STATUS_CODE = 410
var RESUMABLE_INCOMPLETE_STATUS_CODE = 308
var RETRY_LIMIT = 5

var wrapError = function (message, err) ***REMOVED***
  return new Error([message, err.message].join('\n'))
***REMOVED***

function Upload (cfg) ***REMOVED***
  if (!(this instanceof Upload)) return new Upload(cfg)

  Pumpify.call(this)
  StreamEvents.call(this)

  var self = this
  cfg = cfg || ***REMOVED******REMOVED***

  if (!cfg.bucket || !cfg.file) ***REMOVED***
    throw new Error('A bucket and file name are required')
  ***REMOVED***

  cfg.authConfig = cfg.authConfig || ***REMOVED******REMOVED***
  cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control']
  this.authClient = cfg.authClient || googleAuth(cfg.authConfig)

  this.bucket = cfg.bucket
  this.file = cfg.file
  this.generation = cfg.generation
  this.metadata = cfg.metadata || ***REMOVED******REMOVED***
  this.offset = cfg.offset
  this.origin = cfg.origin
  this.userProject = cfg.userProject

  if (cfg.key) ***REMOVED***
    var base64Key = Buffer.from(cfg.key).toString('base64')
    this.encryption = ***REMOVED***
      key: base64Key,
      hash: crypto.createHash('sha256').update(base64Key, 'base64').digest('base64')
    ***REMOVED***
  ***REMOVED***

  this.predefinedAcl = cfg.predefinedAcl
  if (cfg.private) this.predefinedAcl = 'private'
  if (cfg.public) this.predefinedAcl = 'publicRead'

  this.configStore = new ConfigStore('gcs-resumable-upload')
  this.uriProvidedManually = !!cfg.uri
  this.uri = cfg.uri || this.get('uri')
  this.numBytesWritten = 0
  this.numRetries = 0

  var contentLength = cfg.metadata ? parseInt(cfg.metadata.contentLength, 10) : NaN
  this.contentLength = isNaN(contentLength) ? '*' : contentLength

  this.once('writing', function () ***REMOVED***
    if (self.uri) ***REMOVED***
      self.continueUploading()
    ***REMOVED*** else ***REMOVED***
      self.createURI(function (err) ***REMOVED***
        if (err) return self.destroy(err)
        self.startUploading()
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***

util.inherits(Upload, Pumpify)

Upload.createURI = function (cfg, callback) ***REMOVED***
  var up = new Upload(cfg)
  up.createURI(callback)
***REMOVED***

Upload.prototype.createURI = function (callback) ***REMOVED***
  var self = this
  var metadata = this.metadata

  var reqOpts = ***REMOVED***
    method: 'POST',
    uri: [BASE_URI, this.bucket, 'o'].join('/'),
    qs: ***REMOVED***
      name: this.file,
      uploadType: 'resumable'
    ***REMOVED***,
    json: metadata,
    headers: ***REMOVED******REMOVED***
  ***REMOVED***

  if (metadata.contentLength) ***REMOVED***
    reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength
  ***REMOVED***

  if (metadata.contentType) ***REMOVED***
    reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType
  ***REMOVED***

  if (typeof this.generation !== 'undefined') ***REMOVED***
    reqOpts.qs.ifGenerationMatch = this.generation
  ***REMOVED***

  if (this.predefinedAcl) ***REMOVED***
    reqOpts.qs.predefinedAcl = this.predefinedAcl
  ***REMOVED***

  if (this.origin) ***REMOVED***
    reqOpts.headers.Origin = this.origin
  ***REMOVED***

  this.makeRequest(reqOpts, function (err, resp) ***REMOVED***
    if (err) return callback(err)

    var uri = resp.headers.location
    self.uri = uri
    self.set(***REMOVED*** uri: uri ***REMOVED***)
    self.offset = 0

    callback(null, uri)
  ***REMOVED***)
***REMOVED***

Upload.prototype.continueUploading = function () ***REMOVED***
  if (typeof this.offset === 'number') return this.startUploading()
  this.getAndSetOffset(this.startUploading.bind(this))
***REMOVED***

Upload.prototype.startUploading = function () ***REMOVED***
  var self = this

  var reqOpts = ***REMOVED***
    method: 'PUT',
    uri: this.uri,
    headers: ***REMOVED***
      'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength
    ***REMOVED***
  ***REMOVED***

  var bufferStream = this.bufferStream = through()
  var offsetStream = this.offsetStream = through(this.onChunk.bind(this))
  var delayStream = through()

  this.getRequestStream(reqOpts, function (requestStream) ***REMOVED***
    self.setPipeline(bufferStream, offsetStream, requestStream, delayStream)

    // wait for "complete" from request before letting the stream finish
    delayStream.on('prefinish', function () ***REMOVED*** self.cork() ***REMOVED***)

    requestStream.on('complete', function (resp) ***REMOVED***
      if (resp.statusCode < 200 || resp.statusCode > 299) ***REMOVED***
        self.destroy(new Error('Upload failed'))
        return
      ***REMOVED***

      self.emit('metadata', resp.body)

      self.deleteConfig()
      self.uncork()
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***

Upload.prototype.onChunk = function (chunk, enc, next) ***REMOVED***
  var offset = this.offset
  var numBytesWritten = this.numBytesWritten

  // check if this is the same content uploaded previously. this caches a slice
  // of the first chunk, then compares it with the first byte of incoming data
  if (numBytesWritten === 0) ***REMOVED***
    var cachedFirstChunk = this.get('firstChunk')
    var firstChunk = chunk.slice(0, 16).valueOf()

    if (!cachedFirstChunk) ***REMOVED***
      // This is a new upload. Cache the first chunk.
      this.set(***REMOVED***
        uri: this.uri,
        firstChunk: firstChunk
      ***REMOVED***)
    ***REMOVED*** else ***REMOVED***
      // this continues an upload in progress. check if the bytes are the same
      cachedFirstChunk = Buffer.from(cachedFirstChunk)
      firstChunk = Buffer.from(firstChunk)

      if (!bufferEqual(cachedFirstChunk, firstChunk)) ***REMOVED***
        // this data is not the same. start a new upload
        this.bufferStream.unshift(chunk)
        this.bufferStream.unpipe(this.offsetStream)
        this.restart()
        return
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  var length = chunk.length

  if (typeof chunk === 'string') length = Buffer.byteLength(chunk, enc)
  if (numBytesWritten < offset) chunk = chunk.slice(offset - numBytesWritten)

  this.numBytesWritten += length

  // only push data from the byte after the one we left off on
  next(null, this.numBytesWritten > offset ? chunk : undefined)
***REMOVED***

Upload.prototype.getAndSetOffset = function (callback) ***REMOVED***
  var self = this

  this.makeRequest(***REMOVED***
    method: 'PUT',
    uri: this.uri,
    headers: ***REMOVED***
      'Content-Length': 0,
      'Content-Range': 'bytes */*'
    ***REMOVED***
  ***REMOVED***, function (err, resp) ***REMOVED***
    if (err) ***REMOVED***
      // we don't return a 404 to the user if they provided the resumable URI.
      // if we're just using the configstore file to tell us that this file
      // exists, and it turns out that it doesn't (the 404), that's probably
      // stale config data.
      if (resp && resp.statusCode === 404 && !self.uriProvidedManually) return self.restart()

      // this resumable upload is unrecoverable (bad data or service error).
      //  - https://github.com/stephenplusplus/gcs-resumable-upload/issues/15
      //  - https://github.com/stephenplusplus/gcs-resumable-upload/pull/16#discussion_r80363774
      if (resp && resp.statusCode === TERMINATED_UPLOAD_STATUS_CODE) return self.restart()

      return self.destroy(err)
    ***REMOVED***

    if (resp.statusCode === RESUMABLE_INCOMPLETE_STATUS_CODE) ***REMOVED***
      if (resp.headers.range) ***REMOVED***
        self.offset = parseInt(resp.headers.range.split('-')[1], 10) + 1
        callback()
        return
      ***REMOVED***
    ***REMOVED***

    self.offset = 0
    callback()
  ***REMOVED***)
***REMOVED***

Upload.prototype.makeRequest = function (reqOpts, callback) ***REMOVED***
  if (this.encryption) ***REMOVED***
    reqOpts.headers = reqOpts.headers || ***REMOVED******REMOVED***
    reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256'
    reqOpts.headers['x-goog-encryption-key'] = this.encryption.key
    reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash
  ***REMOVED***

  if (this.userProject) ***REMOVED***
    reqOpts.qs = reqOpts.qs || ***REMOVED******REMOVED***
    reqOpts.qs.userProject = this.userProject
  ***REMOVED***

  this.authClient.authorizeRequest(reqOpts, function (err, authorizedReqOpts) ***REMOVED***
    if (err) return callback(wrapError('Could not authenticate request', err))

    request(authorizedReqOpts, function (err, resp, body) ***REMOVED***
      if (err) return callback(err, resp)

      if (body && body.error) return callback(body.error, resp)

      var nonSuccess = Math.floor(resp.statusCode / 100) !== 2 // 200-299 status code
      if (nonSuccess && resp.statusCode !== RESUMABLE_INCOMPLETE_STATUS_CODE) ***REMOVED***
        return callback(new Error(body))
      ***REMOVED***

      callback(null, resp, body)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***

Upload.prototype.getRequestStream = function (reqOpts, callback) ***REMOVED***
  var self = this

  if (this.userProject) ***REMOVED***
    reqOpts.qs = reqOpts.qs || ***REMOVED******REMOVED***
    reqOpts.qs.userProject = this.userProject
  ***REMOVED***

  this.authClient.authorizeRequest(reqOpts, function (err, authorizedReqOpts) ***REMOVED***
    if (err) return self.destroy(wrapError('Could not authenticate request', err))

    var requestStream = request(authorizedReqOpts)
    requestStream.on('error', self.destroy.bind(self))
    requestStream.on('response', self.onResponse.bind(self))
    requestStream.on('complete', function (resp) ***REMOVED***
      var body = resp.body
      if (body && body.error) self.destroy(body.error)
    ***REMOVED***)

    // this makes the response body come back in the response (weird?)
    requestStream.callback = function () ***REMOVED******REMOVED***

    callback(requestStream)
  ***REMOVED***)
***REMOVED***

Upload.prototype.restart = function () ***REMOVED***
  var self = this
  this.numBytesWritten = 0
  this.deleteConfig()
  this.createURI(function (err) ***REMOVED***
    if (err) return self.destroy(err)
    self.startUploading()
  ***REMOVED***)
***REMOVED***

Upload.prototype.get = function (prop) ***REMOVED***
  var store = this.configStore.get([this.bucket, this.file].join('/'))
  return store && store[prop]
***REMOVED***

Upload.prototype.set = function (props) ***REMOVED***
  this.configStore.set([this.bucket, this.file].join('/'), props)
***REMOVED***

Upload.prototype.deleteConfig = function () ***REMOVED***
  this.configStore.delete([this.bucket, this.file].join('/'))
***REMOVED***

/**
 * @return ***REMOVED***bool***REMOVED*** is the request good?
 */
Upload.prototype.onResponse = function (resp) ***REMOVED***
  if (resp.statusCode === 404) ***REMOVED***
    if (this.numRetries < RETRY_LIMIT) ***REMOVED***
      this.numRetries++
      this.startUploading()
    ***REMOVED*** else ***REMOVED***
      this.destroy(new Error('Retry limit exceeded'))
    ***REMOVED***
    return false
  ***REMOVED***

  if (resp.statusCode > 499 && resp.statusCode < 600) ***REMOVED***
    if (this.numRetries < RETRY_LIMIT) ***REMOVED***
      var randomMs = Math.round(Math.random() * 1000)
      var waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs

      this.numRetries++
      setTimeout(this.continueUploading.bind(this), waitTime)
    ***REMOVED*** else ***REMOVED***
      this.destroy(new Error('Retry limit exceeded'))
    ***REMOVED***
    return false
  ***REMOVED***

  this.emit('response', resp)

  return true
***REMOVED***

module.exports = Upload
