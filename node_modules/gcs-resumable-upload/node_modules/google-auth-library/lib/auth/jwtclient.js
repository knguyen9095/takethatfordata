/**
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

var Auth2Client = require('./oauth2client.js');
var gToken = require('gtoken');
var JWTAccess = require('./jwtaccess.js');
var noop = require('lodash.noop');
var util = require('util');


/**
 * JWT service account credentials.
 *
 * Retrieve access token using gtoken.
 *
 * @param ***REMOVED***string=***REMOVED*** email service account email address.
 * @param ***REMOVED***string=***REMOVED*** keyFile path to private key file.
 * @param ***REMOVED***string=***REMOVED*** key value of key
 * @param ***REMOVED***(string|array)=***REMOVED*** scopes list of requested scopes or a single scope.
 * @param ***REMOVED***string=***REMOVED*** subject impersonated account's email address.
 * @constructor
 */
function JWT(email, keyFile, key, scopes, subject) ***REMOVED***
  JWT.super_.call(this);
  this.email = email;
  this.keyFile = keyFile;
  this.key = key;
  this.scopes = scopes;
  this.subject = subject;
  this.gToken = gToken;

  this.credentials = ***REMOVED***
    refresh_token: 'jwt-placeholder',
    expiry_date: 1
  ***REMOVED***;
***REMOVED***

/**
 * Inherit from Auth2Client.
 */
util.inherits(JWT, Auth2Client);

/**
 * Creates a copy of the credential with the specified scopes.
 * @param ***REMOVED***(string|array)=***REMOVED*** scopes List of requested scopes or a single scope.
 * @return ***REMOVED***object***REMOVED*** The cloned instance.
 */
JWT.prototype.createScoped = function(scopes) ***REMOVED***
  return new JWT(this.email, this.keyFile, this.key, scopes, this.subject);
***REMOVED***;

/**
 * Obtains the metadata to be sent with the request.
 *
 * @param ***REMOVED***string***REMOVED*** opt_uri the URI being authorized.
 * @param ***REMOVED***function***REMOVED*** metadataCb
 */
JWT.prototype.getRequestMetadata = function(opt_uri, metadataCb) ***REMOVED***
  if (this.createScopedRequired() && opt_uri) ***REMOVED***
    // no scopes have been set, but a uri has been provided.  Use JWTAccess credentials.
    var alt = new JWTAccess(this.email, this.key);
    return alt.getRequestMetadata(opt_uri, metadataCb);
  ***REMOVED*** else ***REMOVED***
    return JWT.super_.prototype.getRequestMetadata.call(
        this, opt_uri, metadataCb);
  ***REMOVED***
***REMOVED***;

/**
 * Indicates whether the credential requires scopes to be created by calling createdScoped before
 * use.
 * @return ***REMOVED***boolean***REMOVED*** false if createScoped does not need to be called.
 */
JWT.prototype.createScopedRequired = function() ***REMOVED***
  // If scopes is null, always return true.
  if (this.scopes) ***REMOVED***
    // For arrays, check the array length.
    if (this.scopes instanceof Array) ***REMOVED***
      return this.scopes.length === 0;
    ***REMOVED***

    // For others, convert to a string and check the length.
    return String(this.scopes).length === 0;
  ***REMOVED***

  return true;
***REMOVED***;

/**
 * Get the initial access token using gToken.
 * @param ***REMOVED***function=***REMOVED*** opt_callback Optional callback.
 */
JWT.prototype.authorize = function(opt_callback) ***REMOVED***
  var that = this;
  var done = opt_callback || noop;

  that.refreshToken_(null, function(err, result) ***REMOVED***
    if (!err) ***REMOVED***
      that.credentials = result;
      that.credentials.refresh_token = 'jwt-placeholder';
      that.key = that.gtoken.key;
      that.email = that.gtoken.iss;
    ***REMOVED***
    done(err, result);
  ***REMOVED***);
***REMOVED***;


/**
 * Refreshes the access token.
 * @param ***REMOVED***object=***REMOVED*** ignored_
 * @param ***REMOVED***function=***REMOVED*** opt_callback Optional callback.
 * @private
 */
JWT.prototype.refreshToken_ = function(ignored_, opt_callback) ***REMOVED***
  var done = opt_callback || noop;

  return this._createGToken(function(err, gToken) ***REMOVED***
    if (err) ***REMOVED***
      return done(err);
    ***REMOVED*** else ***REMOVED***
      return gToken.getToken(function (err, token) ***REMOVED***
        return done(err, ***REMOVED***
          access_token: token,
          token_type: 'Bearer',
          expiry_date: gToken.expires_at
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;


/**
 * Create a JWT credentials instance using the given input options.
 * @param ***REMOVED***object=***REMOVED*** json The input object.
 * @param ***REMOVED***function=***REMOVED*** opt_callback Optional callback.
 */
JWT.prototype.fromJSON = function(json, opt_callback) ***REMOVED***
  var that = this;
  var done = opt_callback || noop;
  if (!json) ***REMOVED***
    done(new Error(
      'Must pass in a JSON object containing the service account auth settings.'));
    return;
  ***REMOVED***
  if (!json.client_email) ***REMOVED***
    done(new Error(
      'The incoming JSON object does not contain a client_email field'));
    return;
  ***REMOVED***
  if (!json.private_key) ***REMOVED***
    done(new Error(
      'The incoming JSON object does not contain a private_key field'));
    return;
  ***REMOVED***
  // Extract the relevant information from the json key file.
  that.email = json.client_email;
  that.key = json.private_key;
  that.projectId = json.project_id;
  done();
***REMOVED***;

/**
 * Create a JWT credentials instance using the given input stream.
 * @param ***REMOVED***object=***REMOVED*** stream The input stream.
 * @param ***REMOVED***function=***REMOVED*** opt_callback Optional callback.
 */
JWT.prototype.fromStream = function(stream, opt_callback) ***REMOVED***
  var that = this;
  var done = opt_callback || noop;

  if (!stream) ***REMOVED***
    process.nextTick(function() ***REMOVED***
      done(
        new Error('Must pass in a stream containing the service account auth settings.'));
    ***REMOVED***);
    return;
  ***REMOVED***
  var s = '';
  stream.setEncoding('utf8');
  stream.on('data', function (chunk) ***REMOVED***
    s += chunk;
  ***REMOVED***);
  stream.on('end', function () ***REMOVED***
    try ***REMOVED***
      var data = JSON.parse(s);
      that.fromJSON(data, opt_callback);
    ***REMOVED*** catch (err) ***REMOVED***
      done(err);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Creates the gToken instance if it has not been created already.
 * @param ***REMOVED***function=***REMOVED*** callback Callback.
 * @private
 */
JWT.prototype._createGToken = function(callback) ***REMOVED***
  if (this.gtoken) ***REMOVED***
    return callback(null, this.gtoken);
  ***REMOVED*** else ***REMOVED***
    this.gtoken = this.gToken(***REMOVED***
      iss: this.email,
      sub: this.subject,
      scope: this.scopes,
      keyFile: this.keyFile,
      key: this.key
    ***REMOVED***);
    return callback(null, this.gtoken);
  ***REMOVED***
***REMOVED***;

/**
 * Export JWT.
 */
module.exports = JWT;
