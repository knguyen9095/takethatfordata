/**
 * Copyright 2012 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

var AuthClient = require('./authclient.js');
var LoginTicket = require('./loginticket.js');
var noop = require('lodash.noop');
var PemVerifier = require('./../pemverifier.js');
var querystring = require('querystring');
var util = require('util');

var certificateCache = null;
var certificateExpiry = null;

/**
 * Handles OAuth2 flow for Google APIs.
 *
 * @param ***REMOVED***string***REMOVED*** clientId The authentication client ID.
 * @param ***REMOVED***string***REMOVED*** clientSecret The authentication client secret.
 * @param ***REMOVED***string***REMOVED*** redirectUri The URI to redirect to after completing the auth request.
 * @param ***REMOVED***Object***REMOVED*** opt_opts optional options for overriding the given parameters.
 * @constructor
 */
function OAuth2Client(clientId, clientSecret, redirectUri, opt_opts) ***REMOVED***
  OAuth2Client.super_.call(this);

  this.clientId_ = clientId;
  this.clientSecret_ = clientSecret;
  this.redirectUri_ = redirectUri;
  this.opts = opt_opts || ***REMOVED******REMOVED***;
  this.credentials = ***REMOVED******REMOVED***;
***REMOVED***

/**
 * Inherit from AuthClient.
 */
util.inherits(OAuth2Client, AuthClient);

/**
 * The base URL for auth endpoints.
 * @const
 * @private
 */
OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ =
  'https://accounts.google.com/o/oauth2/auth';

/**
 * The base endpoint for token retrieval.
 * @const
 * @private
 */
OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ =
  'https://accounts.google.com/o/oauth2/token';

/**
 * The base endpoint to revoke tokens.
 * @const
 * @private
 */
OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ =
  'https://accounts.google.com/o/oauth2/revoke';

/**
 * Google Sign on certificates.
 * @const
 * @private
 */
OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =
  'https://www.googleapis.com/oauth2/v1/certs';

/**
 * Clock skew - five minutes in seconds
 * @const
 * @private
 */
OAuth2Client.CLOCK_SKEW_SECS_ = 300;

/**
 * Max Token Lifetime is one day in seconds
 * @const
 * @private
 */
OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;

/**
 * The allowed oauth token issuers.
 * @const
 * @private
 */
OAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];

/**
 * Generates URL for consent page landing.
 * @param ***REMOVED***object=***REMOVED*** opt_opts Options.
 * @return ***REMOVED***string***REMOVED*** URL to consent page.
 */
OAuth2Client.prototype.generateAuthUrl = function(opt_opts) ***REMOVED***
  var opts = opt_opts || ***REMOVED******REMOVED***;
  opts.response_type = opts.response_type || 'code';
  opts.client_id = opts.client_id || this.clientId_;
  opts.redirect_uri = opts.redirect_uri || this.redirectUri_;

  // Allow scopes to be passed either as array or a string
  if (opts.scope instanceof Array) ***REMOVED***
    opts.scope = opts.scope.join(' ');
  ***REMOVED***

  var rootUrl = this.opts.authBaseUrl ||
    OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;

  return rootUrl + '?' + querystring.stringify(opts);
***REMOVED***;

/**
 * Gets the access token for the given code.
 * @param ***REMOVED***string***REMOVED*** code The authorization code.
 * @param ***REMOVED***function=***REMOVED*** opt_callback Optional callback fn.
 */
OAuth2Client.prototype.getToken = function(code, opt_callback) ***REMOVED***
  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
  var values = ***REMOVED***
    code: code,
    client_id: this.clientId_,
    client_secret: this.clientSecret_,
    redirect_uri: this.redirectUri_,
    grant_type: 'authorization_code'
  ***REMOVED***;

  this.transporter.request(***REMOVED***
    method: 'POST',
    uri: uri,
    form: values,
    json: true
  ***REMOVED***, function(err, tokens, response) ***REMOVED***
    if (!err && tokens && tokens.expires_in) ***REMOVED***
      tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));
      delete tokens.expires_in;
    ***REMOVED***
    var done = opt_callback || noop;
    done(err, tokens, response);
  ***REMOVED***);
***REMOVED***;

/**
 * Refreshes the access token.
 * @param ***REMOVED***string***REMOVED*** refresh_token Existing refresh token.
 * @param ***REMOVED***function=***REMOVED*** opt_callback Optional callback.
 * @private
 */
OAuth2Client.prototype.refreshToken_ = function(refresh_token, opt_callback) ***REMOVED***
  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
  var values = ***REMOVED***
    refresh_token: refresh_token,
    client_id: this.clientId_,
    client_secret: this.clientSecret_,
    grant_type: 'refresh_token'
  ***REMOVED***;

  // request for new token
  return this.transporter.request(***REMOVED***
    method: 'POST',
    uri: uri,
    form: values,
    json: true
  ***REMOVED***, function(err, tokens, response) ***REMOVED***
    if (!err && tokens && tokens.expires_in) ***REMOVED***
      tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));
      delete tokens.expires_in;
    ***REMOVED***
    var done = opt_callback || noop;
    done(err, tokens, response);
  ***REMOVED***);
***REMOVED***;

/**
 * Retrieves the access token using refresh token
 *
 * @deprecated use getRequestMetadata instead.
 * @param ***REMOVED***function***REMOVED*** callback callback
 */
OAuth2Client.prototype.refreshAccessToken = function(callback) ***REMOVED***
  var that = this;

  if (!this.credentials.refresh_token) ***REMOVED***
    callback(new Error('No refresh token is set.'), null);
    return;
  ***REMOVED***

  this.refreshToken_(this.credentials.refresh_token, function(err, result, response) ***REMOVED***
    if (err) ***REMOVED***
      callback(err, null, response);
    ***REMOVED*** else ***REMOVED***
      var tokens = result;
      tokens.refresh_token = that.credentials.refresh_token;
      that.credentials = tokens;
      callback(null, that.credentials, response);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Get a non-expired access token, after refreshing if necessary
 *
 * @param ***REMOVED***function***REMOVED*** callback Callback to call with the access token
 */
OAuth2Client.prototype.getAccessToken = function(callback) ***REMOVED***
  var credentials = this.credentials;
  var expiryDate = credentials.expiry_date;

  // if no expiry time, assume it's not expired
  var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;

  if (!credentials.access_token && !credentials.refresh_token) ***REMOVED***
    return callback(new Error('No access or refresh token is set.'), null);
  ***REMOVED***

  var shouldRefresh = !credentials.access_token || isTokenExpired;
  if (shouldRefresh && credentials.refresh_token) ***REMOVED***
    if (!this.credentials.refresh_token) ***REMOVED***
      return callback(new Error('No refresh token is set.'), null);
    ***REMOVED***

    this.refreshAccessToken(function(err, tokens, response) ***REMOVED***
      if (err) ***REMOVED***
        return callback(err, null, response);
      ***REMOVED***
      if (!tokens || (tokens && !tokens.access_token)) ***REMOVED***
        return callback(new Error('Could not refresh access token.'), null, response);
      ***REMOVED***
      return callback(null, tokens.access_token, response);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    return callback(null, credentials.access_token, null);
  ***REMOVED***
***REMOVED***;

/**
 * getRequestMetadata obtains auth metadata to be used by requests.
 *
 * getRequestMetadata is the main authentication interface.  It takes an
 * optional uri which when present is the endpoint being accessed, and a
 * callback func(err, metadata_obj, response) where metadata_obj contains
 * authorization metadata fields and response is an optional response object.
 *
 * In OAuth2Client, metadata_obj has the form.
 *
 * ***REMOVED***Authorization: 'Bearer <access_token_value>'***REMOVED***
 *
 * @param ***REMOVED***string***REMOVED*** opt_uri the Uri being authorized
 * @param ***REMOVED***function***REMOVED*** metadataCb the func described above
 */
OAuth2Client.prototype.getRequestMetadata = function(opt_uri, metadataCb) ***REMOVED***
  var that = this;
  var thisCreds = this.credentials;

  if (!thisCreds.access_token && !thisCreds.refresh_token) ***REMOVED***
    return metadataCb(new Error('No access or refresh token is set.'), null);
  ***REMOVED***

  // if no expiry time, assume it's not expired
  var expiryDate = thisCreds.expiry_date;
  var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;

  if (thisCreds.access_token && !isTokenExpired) ***REMOVED***
    thisCreds.token_type = thisCreds.token_type || 'Bearer';
    var headers = ***REMOVED***'Authorization': thisCreds.token_type + ' ' + thisCreds.access_token ***REMOVED***;
    return metadataCb(null, headers , null);
  ***REMOVED***

  return this.refreshToken_(thisCreds.refresh_token, function(err, tokens, response) ***REMOVED***
    if (err) ***REMOVED***
      return metadataCb(err, null, response);
    ***REMOVED*** else ***REMOVED***
      if (!tokens || (tokens && !tokens.access_token)) ***REMOVED***
        return metadataCb(new Error('Could not refresh access token.'), null, response);
      ***REMOVED***

      var credentials = that.credentials;
      credentials.token_type = credentials.token_type || 'Bearer';
      tokens.refresh_token = credentials.refresh_token;
      that.credentials = tokens;
      var headers = ***REMOVED***'Authorization': credentials.token_type + ' ' + tokens.access_token ***REMOVED***;
      return metadataCb(err, headers , response);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Revokes the access given to token.
 * @param ***REMOVED***string***REMOVED*** token The existing token to be revoked.
 * @param ***REMOVED***function=***REMOVED*** opt_callback Optional callback fn.
 */
OAuth2Client.prototype.revokeToken = function(token, opt_callback) ***REMOVED***
  this.transporter.request(***REMOVED***
    uri: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ +
      '?' + querystring.stringify(***REMOVED*** token: token ***REMOVED***),
    json: true
  ***REMOVED***, opt_callback);
***REMOVED***;

/**
 * Revokes access token and clears the credentials object
 * @param  ***REMOVED***Function=***REMOVED*** callback callback
 */
OAuth2Client.prototype.revokeCredentials = function(callback) ***REMOVED***
  var token = this.credentials.access_token;
  this.credentials = ***REMOVED******REMOVED***;
  if (token) ***REMOVED***
    this.revokeToken(token, callback);
  ***REMOVED*** else ***REMOVED***
    callback(new Error('No access token to revoke.'), null);
  ***REMOVED***
***REMOVED***;

/**
 * Provides a request implementation with OAuth 2.0 flow.
 * If credentials have a refresh_token, in cases of HTTP
 * 401 and 403 responses, it automatically asks for a new
 * access token and replays the unsuccessful request.
 * @param ***REMOVED***object***REMOVED*** opts Request options.
 * @param ***REMOVED***function***REMOVED*** callback callback.
 * @return ***REMOVED***Request***REMOVED*** Request object
 */
OAuth2Client.prototype.request = function(opts, callback) ***REMOVED***
  /* jshint latedef:false */
  var that = this;

  // Callbacks will close over this to ensure that we only retry once
  var retry = true;

  // Hook the callback routine to call the _postRequest method.
  var postRequestCb = function(err, body, resp) ***REMOVED***
    var statusCode = resp && resp.statusCode;
    // Automatically retry 401 and 403 responses
    // if err is set and is unrelated to response
    // then getting credentials failed, and retrying won't help
    if (retry && (statusCode === 401 || statusCode === 403) &&
        (!err || err.code === statusCode)) ***REMOVED***
      /* It only makes sense to retry once, because the retry is intended to
       * handle expiration-related failures. If refreshing the token does not
       * fix the failure, then refreshing again probably won't help */
      retry = false;
      // Force token refresh
      that.refreshAccessToken(function() ***REMOVED***
        that.getRequestMetadata(unusedUri, authCb);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      that._postRequest(err, body, resp, callback);
    ***REMOVED***
  ***REMOVED***;

  var authCb = function(err, headers, response) ***REMOVED***
    if (err) ***REMOVED***
      postRequestCb(err, null, response);
    ***REMOVED*** else ***REMOVED***
      if (headers) ***REMOVED***
        opts.headers = opts.headers || ***REMOVED******REMOVED***;
        opts.headers.Authorization = headers.Authorization;
      ***REMOVED***
      return that._makeRequest(opts, postRequestCb);
    ***REMOVED***
  ***REMOVED***;

  var unusedUri = null;
  return this.getRequestMetadata(unusedUri, authCb);
***REMOVED***;

/**
 * Makes a request without paying attention to refreshing or anything
 * Assumes that all credentials are set correctly.
 * @param  ***REMOVED***object***REMOVED***   opts     Options for request
 * @param  ***REMOVED***Function***REMOVED*** callback callback function
 * @return ***REMOVED***Request***REMOVED***           The request object created
 */
OAuth2Client.prototype._makeRequest = function(opts, callback) ***REMOVED***
  return this.transporter.request(opts, callback);
***REMOVED***;

/**
 * Allows inheriting classes to inspect and alter the request result.
 * @param ***REMOVED***object***REMOVED*** err Error result.
 * @param ***REMOVED***object***REMOVED*** result The result.
 * @param ***REMOVED***object***REMOVED*** result The HTTP response.
 * @param ***REMOVED***Function***REMOVED*** callback The callback.
 * @private
 */
OAuth2Client.prototype._postRequest = function(err, result, response, callback) ***REMOVED***
  callback(err, result, response);
***REMOVED***;

/**
 * Verify id token is token by checking the certs and audience
 * @param ***REMOVED***string***REMOVED*** idToken ID Token.
 * @param ***REMOVED***(string|Array.<string>)***REMOVED*** audience The audience to verify against the ID Token
 * @param ***REMOVED***function=***REMOVED*** callback Callback supplying GoogleLogin if successful
 */
OAuth2Client.prototype.verifyIdToken = function(idToken, audience, callback) ***REMOVED***
  if (!idToken || !callback) ***REMOVED***
    throw new Error('The verifyIdToken method requires both ' +
      'an ID Token and a callback method');
  ***REMOVED***

  this.getFederatedSignonCerts(function(err, certs) ***REMOVED***
    if (err) ***REMOVED***
      callback(err, null);
    ***REMOVED***
    var login;
    try ***REMOVED***
      login = this.verifySignedJwtWithCerts(idToken, certs, audience,
        OAuth2Client.ISSUERS_);
    ***REMOVED*** catch (err) ***REMOVED***
      callback(err);
      return;
    ***REMOVED***

    callback(null, login);
  ***REMOVED***.bind(this));
***REMOVED***;

/**
 * Gets federated sign-on certificates to use for verifying identity tokens.
 * Returns certs as array structure, where keys are key ids, and values
 * are PEM encoded certificates.
 * @param ***REMOVED***function=***REMOVED*** callback Callback supplying the certificates
 */
OAuth2Client.prototype.getFederatedSignonCerts = function(callback) ***REMOVED***
  var nowTime = (new Date()).getTime();
  if (certificateExpiry && (nowTime < certificateExpiry.getTime())) ***REMOVED***
    callback(null, certificateCache);
    return;
  ***REMOVED***

  this.transporter.request(***REMOVED***
    method: 'GET',
    uri: OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_,
    json: true
  ***REMOVED***, function(err, body, response) ***REMOVED***
    if (err) ***REMOVED***
      callback('Failed to retrieve verification certificates: ' + err, null, response);
      return;
    ***REMOVED***

    var cacheControl = response.headers['cache-control'];
    var cacheAge = -1;
    if (cacheControl) ***REMOVED***
      var pattern = new RegExp('max-age=([0-9]*)');
      var regexResult = pattern.exec(cacheControl);
      if (regexResult.length === 2) ***REMOVED***
        // Cache results with max-age (in seconds)
        cacheAge = regexResult[1] * 1000; // milliseconds
      ***REMOVED***
    ***REMOVED***

    var now = new Date();
    certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
    certificateCache = body;
    callback(null, body, response);
  ***REMOVED***);
***REMOVED***;

/**
 * Verify the id token is signed with the correct certificate
 * and is from the correct audience.
 * @param ***REMOVED***string***REMOVED*** jwt The jwt to verify (The ID Token in this case).
 * @param ***REMOVED***array***REMOVED*** certs The array of certs to test the jwt against.
 * @param ***REMOVED***(string|Array.<string>)***REMOVED*** requiredAudience The audience to test the jwt against.
 * @param ***REMOVED***array***REMOVED*** issuers The allowed issuers of the jwt (Optional).
 * @param ***REMOVED***string***REMOVED*** maxExpiry The max expiry the certificate can be (Optional).
 * @return ***REMOVED***LoginTicket***REMOVED*** Returns a LoginTicket on verification.
 */
OAuth2Client.prototype.verifySignedJwtWithCerts =
  function(jwt, certs, requiredAudience, issuers, maxExpiry) ***REMOVED***

    if (!maxExpiry) ***REMOVED***
      maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;
    ***REMOVED***

    var segments = jwt.split('.');
    if (segments.length !== 3) ***REMOVED***
      throw new Error('Wrong number of segments in token: ' + jwt);
    ***REMOVED***
    var signed = segments[0] + '.' + segments[1];

    var signature = segments[2];

    var envelope, payload;
    try ***REMOVED***
      envelope = JSON.parse(this.decodeBase64(segments[0]));
    ***REMOVED*** catch (err) ***REMOVED*** ***REMOVED***

    if (!envelope) ***REMOVED***
      throw new Error('Can\'t parse token envelope: ' + segments[0]);
    ***REMOVED***

    try ***REMOVED***
      payload = JSON.parse(this.decodeBase64(segments[1]));
    ***REMOVED*** catch (err) ***REMOVED*** ***REMOVED***
    if (!payload) ***REMOVED***
      throw new Error('Can\'t parse token payload: ' + segments[1]);
    ***REMOVED***

    if (!certs.hasOwnProperty(envelope.kid)) ***REMOVED***
      // If this is not present, then there's no reason to attempt verification
      throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));
    ***REMOVED***
    var pem = certs[envelope.kid];
    var pemVerifier = new PemVerifier();
    var verified = pemVerifier.verify(pem, signed, signature, 'base64');

    if (!verified) ***REMOVED***
      throw new Error('Invalid token signature: ' + jwt);
    ***REMOVED***

    if (!payload.iat) ***REMOVED***
      throw new Error('No issue time in token: ' + JSON.stringify(payload));
    ***REMOVED***

    if (!payload.exp) ***REMOVED***
      throw new Error('No expiration time in token: ' + JSON.stringify(payload));
    ***REMOVED***

    var iat = parseInt(payload.iat, 10);
    var exp = parseInt(payload.exp, 10);
    var now = new Date().getTime() / 1000;

    if (exp >= now + maxExpiry) ***REMOVED***
      throw new Error('Expiration time too far in future: ' +
        JSON.stringify(payload));
    ***REMOVED***

    var earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;
    var latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;

    if (now < earliest) ***REMOVED***
      throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' +
        JSON.stringify(payload));
    ***REMOVED***

    if (now > latest) ***REMOVED***
      throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' +
        JSON.stringify(payload));
    ***REMOVED***

    if (issuers && issuers.indexOf(payload.iss) < 0) ***REMOVED***
      throw new Error('Invalid issuer, expected one of [' + issuers +
          '], but got ' + payload.iss);
    ***REMOVED***

    // Check the audience matches if we have one
    if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) ***REMOVED***
      var aud = payload.aud;
      var audVerified = false;
      //If the requiredAudience is an array, check if it contains token audience
      if(requiredAudience.constructor === Array)
      ***REMOVED***
          audVerified = (requiredAudience.indexOf(aud) > -1);
      ***REMOVED***
      else***REMOVED***
          audVerified = (aud === requiredAudience);
      ***REMOVED***
      if (!audVerified) ***REMOVED***
         throw new Error('Wrong recipient, payload audience != requiredAudience');
      ***REMOVED***
    ***REMOVED***

    return new LoginTicket(envelope, payload);
  ***REMOVED***;

/**
 * This is a utils method to decode a base64 string
 * @param ***REMOVED***string***REMOVED*** b64String The string to base64 decode
 * @return ***REMOVED***string***REMOVED*** The decoded string
 */
OAuth2Client.prototype.decodeBase64 = function(b64String) ***REMOVED***
  var buffer = new Buffer(b64String, 'base64');
  return buffer.toString('utf8');
***REMOVED***;

/**
 * Export OAuth2Client.
 */
module.exports = OAuth2Client;
