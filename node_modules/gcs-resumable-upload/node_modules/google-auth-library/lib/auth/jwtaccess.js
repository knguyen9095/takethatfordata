/**
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

var jws = require('jws');
var noop = require('lodash.noop');

/**
 * JWTAccess service account credentials.
 *
 * Create a new access token by using the credential to create a new JWT token
 * that's recognized as the access token.
 *
 * @param ***REMOVED***string=***REMOVED*** email the service account email address.
 * @param ***REMOVED***string=***REMOVED*** key the private key that will be used to sign the token.
 * @constructor
 */
function JWTAccess(email, key) ***REMOVED***
  this.email = email;
  this.key = key;
***REMOVED***

/**
 * Indicates whether the credential requires scopes to be created by calling
 * createdScoped before use.
 *
 * @return ***REMOVED***boolean***REMOVED*** always false
 */
JWTAccess.prototype.createScopedRequired = function() ***REMOVED***
  // JWT Header authentication does not use scopes.
  return false;
***REMOVED***;

/**
 * Get a non-expired access token, after refreshing if necessary
 *
 * @param ***REMOVED***string***REMOVED*** authURI the URI being authorized
 * @param ***REMOVED***function***REMOVED*** metadataCb a callback invoked with the jwt
 *                   request metadata.
 */
JWTAccess.prototype.getRequestMetadata = function(authURI, metadataCb) ***REMOVED***
  var iat = Math.floor(new Date().getTime() / 1000);
  var exp = iat + 3600; // 3600 seconds = 1 hour

  // The payload used for signed JWT headers has:
  // iss == sub == <client email>
  // aud == <the authorization uri>
  var payload = ***REMOVED***
    iss: this.email,
    sub: this.email,
    aud: authURI,
    exp: exp,
    iat: iat
  ***REMOVED***;
  var assertion = ***REMOVED***
    header: ***REMOVED***
      alg: 'RS256',
      typ: 'JWT'
    ***REMOVED***,
    payload: payload,
    secret: this.key
  ***REMOVED***;

  // Sign the jwt and invoke metadataCb with it.
  return this._signJWT(assertion, function(err, signedJWT) ***REMOVED***
    if (!err) ***REMOVED***
      return metadataCb(null, ***REMOVED***'Authorization': 'Bearer ' + signedJWT***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      return metadataCb(err, null);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Create a JWTAccess credentials instance using the given input options.
 * @param ***REMOVED***object=***REMOVED*** json The input object.
 * @param ***REMOVED***function=***REMOVED*** opt_callback Optional callback.
 */
JWTAccess.prototype.fromJSON = function(json, opt_callback) ***REMOVED***
  var that = this;
  var done = opt_callback || noop;
  if (!json) ***REMOVED***
    done(new Error(
      'Must pass in a JSON object containing the service account auth settings.'));
    return;
  ***REMOVED***
  if (!json.client_email) ***REMOVED***
    done(new Error(
      'The incoming JSON object does not contain a client_email field'));
    return;
  ***REMOVED***
  if (!json.private_key) ***REMOVED***
    done(new Error(
      'The incoming JSON object does not contain a private_key field'));
    return;
  ***REMOVED***
  // Extract the relevant information from the json key file.
  that.email = json.client_email;
  that.key = json.private_key;
  that.projectId = json.project_id;
  done();
***REMOVED***;

/**
 * Create a JWTAccess credentials instance using the given input stream.
 * @param ***REMOVED***object=***REMOVED*** stream The input stream.
 * @param ***REMOVED***function=***REMOVED*** opt_callback Optional callback.
 */
JWTAccess.prototype.fromStream = function(stream, opt_callback) ***REMOVED***
  var that = this;
  var done = opt_callback || noop;
  if (!stream) ***REMOVED***
    process.nextTick(function() ***REMOVED***
        done(
            new Error('Must pass in a stream containing the service account auth settings.'));
    ***REMOVED***);
    return;
  ***REMOVED***
  var s = '';
  stream.setEncoding('utf8');
  stream.on('data', function (chunk) ***REMOVED***
    s += chunk;
  ***REMOVED***);
  stream.on('end', function () ***REMOVED***
    try ***REMOVED***
      var data = JSON.parse(s);
      that.fromJSON(data, opt_callback);
    ***REMOVED*** catch (err) ***REMOVED***
      done(err);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Sign the JWT object, returning any errors in the callback.
 *
 * signedJwtFn is a callback function(err, signedJWT); it is called with an
 * error if there is an exception during signing.
 *
 * @param  ***REMOVED***object***REMOVED***   assertion   The assertion to sign
 * @param  ***REMOVED***Function***REMOVED*** signedJwtFn  fn(err, signedJWT)
 */
JWTAccess.prototype._signJWT = function(assertion, signedJwtFn) ***REMOVED***
  try ***REMOVED***
    return signedJwtFn(null, jws.sign(assertion));
  ***REMOVED*** catch (err) ***REMOVED***
    return signedJwtFn(err);
  ***REMOVED***
***REMOVED***;

/**
 * Export JWTAccess.
 */
module.exports = JWTAccess;
