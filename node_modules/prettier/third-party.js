'use strict';

function _interopDefault (ex) ***REMOVED*** return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; ***REMOVED***

var stream = _interopDefault(require('stream'));
var os = _interopDefault(require('os'));
var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs'));
var util = _interopDefault(require('util'));
var module$1 = _interopDefault(require('module'));

function commonjsRequire () ***REMOVED***
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
***REMOVED***



function createCommonjsModule(fn, module) ***REMOVED***
	return module = ***REMOVED*** exports: ***REMOVED******REMOVED*** ***REMOVED***, fn(module, module.exports), module.exports;
***REMOVED***

var bufferStream = createCommonjsModule(function (module) ***REMOVED***
'use strict';
const PassThrough = stream.PassThrough;

module.exports = opts => ***REMOVED***
	opts = Object.assign(***REMOVED******REMOVED***, opts);

	const array = opts.array;
	let encoding = opts.encoding;
	const buffer = encoding === 'buffer';
	let objectMode = false;

	if (array) ***REMOVED***
		objectMode = !(encoding || buffer);
	***REMOVED*** else ***REMOVED***
		encoding = encoding || 'utf8';
	***REMOVED***

	if (buffer) ***REMOVED***
		encoding = null;
	***REMOVED***

	let len = 0;
	const ret = [];
	const stream$$1 = new PassThrough(***REMOVED***objectMode***REMOVED***);

	if (encoding) ***REMOVED***
		stream$$1.setEncoding(encoding);
	***REMOVED***

	stream$$1.on('data', chunk => ***REMOVED***
		ret.push(chunk);

		if (objectMode) ***REMOVED***
			len = ret.length;
		***REMOVED*** else ***REMOVED***
			len += chunk.length;
		***REMOVED***
	***REMOVED***);

	stream$$1.getBufferedValue = () => ***REMOVED***
		if (array) ***REMOVED***
			return ret;
		***REMOVED***

		return buffer ? Buffer.concat(ret, len) : ret.join('');
	***REMOVED***;

	stream$$1.getBufferedLength = () => len;

	return stream$$1;
***REMOVED***;
***REMOVED***);

function getStream(inputStream, opts) ***REMOVED***
	if (!inputStream) ***REMOVED***
		return Promise.reject(new Error('Expected a stream'));
	***REMOVED***

	opts = Object.assign(***REMOVED***maxBuffer: Infinity***REMOVED***, opts);

	const maxBuffer = opts.maxBuffer;
	let stream$$1;
	let clean;

	const p = new Promise((resolve, reject) => ***REMOVED***
		const error = err => ***REMOVED***
			if (err) ***REMOVED*** // null check
				err.bufferedData = stream$$1.getBufferedValue();
			***REMOVED***

			reject(err);
		***REMOVED***;

		stream$$1 = bufferStream(opts);
		inputStream.once('error', error);
		inputStream.pipe(stream$$1);

		stream$$1.on('data', () => ***REMOVED***
			if (stream$$1.getBufferedLength() > maxBuffer) ***REMOVED***
				reject(new Error('maxBuffer exceeded'));
			***REMOVED***
		***REMOVED***);
		stream$$1.once('error', error);
		stream$$1.on('end', resolve);

		clean = () => ***REMOVED***
			// some streams doesn't implement the `stream.Readable` interface correctly
			if (inputStream.unpipe) ***REMOVED***
				inputStream.unpipe(stream$$1);
			***REMOVED***
		***REMOVED***;
	***REMOVED***);

	p.then(clean, clean);

	return p.then(() => stream$$1.getBufferedValue());
***REMOVED***

var getStream_1 = getStream;
var buffer = (stream$$1, opts) => getStream(stream$$1, Object.assign(***REMOVED******REMOVED***, opts, ***REMOVED***encoding: 'buffer'***REMOVED***));
var array = (stream$$1, opts) => getStream(stream$$1, Object.assign(***REMOVED******REMOVED***, opts, ***REMOVED***array: true***REMOVED***));

getStream_1.buffer = buffer;
getStream_1.array = array;

function readFile(filepath        , options          )                   ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  const throwNotFound = options.throwNotFound || false;

  return new Promise((resolve, reject) => ***REMOVED***
    fs.readFile(filepath, 'utf8', (err, content) => ***REMOVED***
      if (err && err.code === 'ENOENT' && !throwNotFound) ***REMOVED***
        return resolve(null);
      ***REMOVED***
      if (err) return reject(err);
      resolve(content);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

readFile.sync = function readFileSync(
  filepath        ,
  options          
)          ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  const throwNotFound = options.throwNotFound || false;

  try ***REMOVED***
    return fs.readFileSync(filepath, 'utf8');
  ***REMOVED*** catch (err) ***REMOVED***
    if (err.code === 'ENOENT' && !throwNotFound) ***REMOVED***
      return null;
    ***REMOVED***
    throw err;
  ***REMOVED***
***REMOVED***;

var readFile_1 = readFile;

var isArrayish = function isArrayish(obj) ***REMOVED***
	if (!obj) ***REMOVED***
		return false;
	***REMOVED***

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && obj.splice instanceof Function);
***REMOVED***;

var errorEx = function errorEx(name, properties) ***REMOVED***
	if (!name || name.constructor !== String) ***REMOVED***
		properties = name || ***REMOVED******REMOVED***;
		name = Error.name;
	***REMOVED***

	var errorExError = function ErrorEXError(message) ***REMOVED***
		if (!this) ***REMOVED***
			return new ErrorEXError(message);
		***REMOVED***

		message = message instanceof Error
			? message.message
			: (message || this.message);

		Error.call(this, message);
		Error.captureStackTrace(this, errorExError);

		this.name = name;

		Object.defineProperty(this, 'message', ***REMOVED***
			configurable: true,
			enumerable: false,
			get: function () ***REMOVED***
				var newMessage = message.split(/\r?\n/g);

				for (var key in properties) ***REMOVED***
					if (!properties.hasOwnProperty(key)) ***REMOVED***
						continue;
					***REMOVED***

					var modifier = properties[key];

					if ('message' in modifier) ***REMOVED***
						newMessage = modifier.message(this[key], newMessage) || newMessage;
						if (!isArrayish(newMessage)) ***REMOVED***
							newMessage = [newMessage];
						***REMOVED***
					***REMOVED***
				***REMOVED***

				return newMessage.join('\n');
			***REMOVED***,
			set: function (v) ***REMOVED***
				message = v;
			***REMOVED***
		***REMOVED***);

		var stackDescriptor = Object.getOwnPropertyDescriptor(this, 'stack');
		var stackGetter = stackDescriptor.get;
		var stackValue = stackDescriptor.value;
		delete stackDescriptor.value;
		delete stackDescriptor.writable;

		stackDescriptor.get = function () ***REMOVED***
			var stack = (stackGetter)
				? stackGetter.call(this).split(/\r?\n+/g)
				: stackValue.split(/\r?\n+/g);

			// starting in Node 7, the stack builder caches the message.
			// just replace it.
			stack[0] = this.name + ': ' + this.message;

			var lineCount = 1;
			for (var key in properties) ***REMOVED***
				if (!properties.hasOwnProperty(key)) ***REMOVED***
					continue;
				***REMOVED***

				var modifier = properties[key];

				if ('line' in modifier) ***REMOVED***
					var line = modifier.line(this[key]);
					if (line) ***REMOVED***
						stack.splice(lineCount++, 0, '    ' + line);
					***REMOVED***
				***REMOVED***

				if ('stack' in modifier) ***REMOVED***
					modifier.stack(this[key], stack);
				***REMOVED***
			***REMOVED***

			return stack.join('\n');
		***REMOVED***;

		Object.defineProperty(this, 'stack', stackDescriptor);
	***REMOVED***;

	if (Object.setPrototypeOf) ***REMOVED***
		Object.setPrototypeOf(errorExError.prototype, Error.prototype);
		Object.setPrototypeOf(errorExError, Error);
	***REMOVED*** else ***REMOVED***
		util.inherits(errorExError, Error);
	***REMOVED***

	return errorExError;
***REMOVED***;

errorEx.append = function (str, def) ***REMOVED***
	return ***REMOVED***
		message: function (v, message) ***REMOVED***
			v = v || def;

			if (v) ***REMOVED***
				message[0] += ' ' + str.replace('%s', v.toString());
			***REMOVED***

			return message;
		***REMOVED***
	***REMOVED***;
***REMOVED***;

errorEx.line = function (str, def) ***REMOVED***
	return ***REMOVED***
		line: function (v) ***REMOVED***
			v = v || def;

			if (v) ***REMOVED***
				return str.replace('%s', v.toString());
			***REMOVED***

			return null;
		***REMOVED***
	***REMOVED***;
***REMOVED***;

var errorEx_1 = errorEx;

var unicode = createCommonjsModule(function (module) ***REMOVED***
// This is autogenerated with esprima tools, see:
// https://github.com/ariya/esprima/blob/master/esprima.js
//
// PS: oh God, I hate Unicode

// ECMAScript 5.1/Unicode v6.3.0 NonAsciiIdentifierStart:

var Uni = module.exports;

module.exports.isWhiteSpace = function isWhiteSpace(x) ***REMOVED***
  // section 7.2, table 2
  return x === '\u0020'
      || x === '\u00A0'
      || x === '\uFEFF' // <-- this is not a Unicode WS, only a JS one
      || (x >= '\u0009' && x <= '\u000D') // 9 A B C D

      // + whitespace characters from unicode, category Zs
      || x === '\u1680'
      || x === '\u180E'
      || (x >= '\u2000' && x <= '\u200A') // 0 1 2 3 4 5 6 7 8 9 A
      || x === '\u2028'
      || x === '\u2029'
      || x === '\u202F'
      || x === '\u205F'
      || x === '\u3000'
***REMOVED***;

module.exports.isWhiteSpaceJSON = function isWhiteSpaceJSON(x) ***REMOVED***
  return x === '\u0020'
      || x === '\u0009'
      || x === '\u000A'
      || x === '\u000D'
***REMOVED***;

module.exports.isLineTerminator = function isLineTerminator(x) ***REMOVED***
  // ok, here is the part when JSON is wrong
  // section 7.3, table 3
  return x === '\u000A'
      || x === '\u000D'
      || x === '\u2028'
      || x === '\u2029'
***REMOVED***;

module.exports.isLineTerminatorJSON = function isLineTerminatorJSON(x) ***REMOVED***
  return x === '\u000A'
      || x === '\u000D'
***REMOVED***;

module.exports.isIdentifierStart = function isIdentifierStart(x) ***REMOVED***
  return x === '$'
      || x === '_'
      || (x >= 'A' && x <= 'Z')
      || (x >= 'a' && x <= 'z')
      || (x >= '\u0080' && Uni.NonAsciiIdentifierStart.test(x))
***REMOVED***;

module.exports.isIdentifierPart = function isIdentifierPart(x) ***REMOVED***
  return x === '$'
      || x === '_'
      || (x >= 'A' && x <= 'Z')
      || (x >= 'a' && x <= 'z')
      || (x >= '0' && x <= '9') // <-- addition to Start
      || (x >= '\u0080' && Uni.NonAsciiIdentifierPart.test(x))
***REMOVED***;

module.exports.NonAsciiIdentifierStart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;

// ECMAScript 5.1/Unicode v6.3.0 NonAsciiIdentifierPart:

module.exports.NonAsciiIdentifierPart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
***REMOVED***);

var parse_1 = createCommonjsModule(function (module) ***REMOVED***
/*
 * Author: Alex Kocharin <alex@kocharin.ru>
 * GIT: https://github.com/rlidwka/jju
 * License: WTFPL, grab your copy here: http://www.wtfpl.net/txt/copying/
 */

// RTFM: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf



function isHexDigit(x) ***REMOVED***
  return (x >= '0' && x <= '9')
      || (x >= 'A' && x <= 'F')
      || (x >= 'a' && x <= 'f')
***REMOVED***

function isOctDigit(x) ***REMOVED***
  return x >= '0' && x <= '7'
***REMOVED***

function isDecDigit(x) ***REMOVED***
  return x >= '0' && x <= '9'
***REMOVED***

var unescapeMap = ***REMOVED***
  '\'': '\'',
  '"' : '"',
  '\\': '\\',
  'b' : '\b',
  'f' : '\f',
  'n' : '\n',
  'r' : '\r',
  't' : '\t',
  'v' : '\v',
  '/' : '/',
***REMOVED***;

function formatError(input, msg, position, lineno, column, json5) ***REMOVED***
  var result = msg + ' at ' + (lineno + 1) + ':' + (column + 1)
    , tmppos = position - column - 1
    , srcline = ''
    , underline = '';

  var isLineTerminator = json5 ? unicode.isLineTerminator : unicode.isLineTerminatorJSON;

  // output no more than 70 characters before the wrong ones
  if (tmppos < position - 70) ***REMOVED***
    tmppos = position - 70;
  ***REMOVED***

  while (1) ***REMOVED***
    var chr = input[++tmppos];

    if (isLineTerminator(chr) || tmppos === input.length) ***REMOVED***
      if (position >= tmppos) ***REMOVED***
        // ending line error, so show it after the last char
        underline += '^';
      ***REMOVED***
      break
    ***REMOVED***
    srcline += chr;

    if (position === tmppos) ***REMOVED***
      underline += '^';
    ***REMOVED*** else if (position > tmppos) ***REMOVED***
      underline += input[tmppos] === '\t' ? '\t' : ' ';
    ***REMOVED***

    // output no more than 78 characters on the string
    if (srcline.length > 78) break
  ***REMOVED***

  return result + '\n' + srcline + '\n' + underline
***REMOVED***

function parse(input, options) ***REMOVED***
  // parse as a standard JSON mode
  var json5 = !(options.mode === 'json' || options.legacy);
  var isLineTerminator = json5 ? unicode.isLineTerminator : unicode.isLineTerminatorJSON;
  var isWhiteSpace = json5 ? unicode.isWhiteSpace : unicode.isWhiteSpaceJSON;

  var length = input.length
    , lineno = 0
    , linestart = 0
    , position = 0
    , stack = [];

  var tokenStart = function() ***REMOVED******REMOVED***;
  var tokenEnd = function(v) ***REMOVED***return v***REMOVED***;

  /* tokenize(***REMOVED***
       raw: '...',
       type: 'whitespace'|'comment'|'key'|'literal'|'separator'|'newline',
       value: 'number'|'string'|'whatever',
       path: [...],
     ***REMOVED***)
  */
  if (options._tokenize) ***REMOVED***
    (function() ***REMOVED***
      var start = null;
      tokenStart = function() ***REMOVED***
        if (start !== null) throw Error('internal error, token overlap')
        start = position;
      ***REMOVED***;

      tokenEnd = function(v, type) ***REMOVED***
        if (start != position) ***REMOVED***
          var hash = ***REMOVED***
            raw: input.substr(start, position-start),
            type: type,
            stack: stack.slice(0),
          ***REMOVED***;
          if (v !== undefined) hash.value = v;
          options._tokenize.call(null, hash);
        ***REMOVED***
        start = null;
        return v
      ***REMOVED***;
    ***REMOVED***)();
  ***REMOVED***

  function fail(msg) ***REMOVED***
    var column = position - linestart;

    if (!msg) ***REMOVED***
      if (position < length) ***REMOVED***
        var token = '\'' +
          JSON
            .stringify(input[position])
            .replace(/^"|"$/g, '')
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"')
          + '\'';

        if (!msg) msg = 'Unexpected token ' + token;
      ***REMOVED*** else ***REMOVED***
        if (!msg) msg = 'Unexpected end of input';
      ***REMOVED***
    ***REMOVED***

    var error = SyntaxError(formatError(input, msg, position, lineno, column, json5));
    error.row = lineno + 1;
    error.column = column + 1;
    throw error
  ***REMOVED***

  function newline(chr) ***REMOVED***
    // account for <cr><lf>
    if (chr === '\r' && input[position] === '\n') position++;
    linestart = position;
    lineno++;
  ***REMOVED***

  function parseGeneric() ***REMOVED***
    var result;

    while (position < length) ***REMOVED***
      tokenStart();
      var chr = input[position++];

      if (chr === '"' || (chr === '\'' && json5)) ***REMOVED***
        return tokenEnd(parseString(chr), 'literal')

      ***REMOVED*** else if (chr === '***REMOVED***') ***REMOVED***
        tokenEnd(undefined, 'separator');
        return parseObject()

      ***REMOVED*** else if (chr === '[') ***REMOVED***
        tokenEnd(undefined, 'separator');
        return parseArray()

      ***REMOVED*** else if (chr === '-'
             ||  chr === '.'
             ||  isDecDigit(chr)
                 //           + number       Infinity          NaN
             ||  (json5 && (chr === '+' || chr === 'I' || chr === 'N'))
      ) ***REMOVED***
        return tokenEnd(parseNumber(), 'literal')

      ***REMOVED*** else if (chr === 'n') ***REMOVED***
        parseKeyword('null');
        return tokenEnd(null, 'literal')

      ***REMOVED*** else if (chr === 't') ***REMOVED***
        parseKeyword('true');
        return tokenEnd(true, 'literal')

      ***REMOVED*** else if (chr === 'f') ***REMOVED***
        parseKeyword('false');
        return tokenEnd(false, 'literal')

      ***REMOVED*** else ***REMOVED***
        position--;
        return tokenEnd(undefined)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function parseKey() ***REMOVED***
    var result;

    while (position < length) ***REMOVED***
      tokenStart();
      var chr = input[position++];

      if (chr === '"' || (chr === '\'' && json5)) ***REMOVED***
        return tokenEnd(parseString(chr), 'key')

      ***REMOVED*** else if (chr === '***REMOVED***') ***REMOVED***
        tokenEnd(undefined, 'separator');
        return parseObject()

      ***REMOVED*** else if (chr === '[') ***REMOVED***
        tokenEnd(undefined, 'separator');
        return parseArray()

      ***REMOVED*** else if (chr === '.'
             ||  isDecDigit(chr)
      ) ***REMOVED***
        return tokenEnd(parseNumber(true), 'key')

      ***REMOVED*** else if (json5
             &&  unicode.isIdentifierStart(chr) || (chr === '\\' && input[position] === 'u')) ***REMOVED***
        // unicode char or a unicode sequence
        var rollback = position - 1;
        var result = parseIdentifier();

        if (result === undefined) ***REMOVED***
          position = rollback;
          return tokenEnd(undefined)
        ***REMOVED*** else ***REMOVED***
          return tokenEnd(result, 'key')
        ***REMOVED***

      ***REMOVED*** else ***REMOVED***
        position--;
        return tokenEnd(undefined)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function skipWhiteSpace() ***REMOVED***
    tokenStart();
    while (position < length) ***REMOVED***
      var chr = input[position++];

      if (isLineTerminator(chr)) ***REMOVED***
        position--;
        tokenEnd(undefined, 'whitespace');
        tokenStart();
        position++;
        newline(chr);
        tokenEnd(undefined, 'newline');
        tokenStart();

      ***REMOVED*** else if (isWhiteSpace(chr)) ***REMOVED***
        // nothing

      ***REMOVED*** else if (chr === '/'
             && json5
             && (input[position] === '/' || input[position] === '*')
      ) ***REMOVED***
        position--;
        tokenEnd(undefined, 'whitespace');
        tokenStart();
        position++;
        skipComment(input[position++] === '*');
        tokenEnd(undefined, 'comment');
        tokenStart();

      ***REMOVED*** else ***REMOVED***
        position--;
        break
      ***REMOVED***
    ***REMOVED***
    return tokenEnd(undefined, 'whitespace')
  ***REMOVED***

  function skipComment(multi) ***REMOVED***
    while (position < length) ***REMOVED***
      var chr = input[position++];

      if (isLineTerminator(chr)) ***REMOVED***
        // LineTerminator is an end of singleline comment
        if (!multi) ***REMOVED***
          // let parent function deal with newline
          position--;
          return
        ***REMOVED***

        newline(chr);

      ***REMOVED*** else if (chr === '*' && multi) ***REMOVED***
        // end of multiline comment
        if (input[position] === '/') ***REMOVED***
          position++;
          return
        ***REMOVED***

      ***REMOVED*** else ***REMOVED***
        // nothing
      ***REMOVED***
    ***REMOVED***

    if (multi) ***REMOVED***
      fail('Unclosed multiline comment');
    ***REMOVED***
  ***REMOVED***

  function parseKeyword(keyword) ***REMOVED***
    // keyword[0] is not checked because it should've checked earlier
    var _pos = position;
    var len = keyword.length;
    for (var i=1; i<len; i++) ***REMOVED***
      if (position >= length || keyword[i] != input[position]) ***REMOVED***
        position = _pos-1;
        fail();
      ***REMOVED***
      position++;
    ***REMOVED***
  ***REMOVED***

  function parseObject() ***REMOVED***
    var result = options.null_prototype ? Object.create(null) : ***REMOVED******REMOVED***
      , empty_object = ***REMOVED******REMOVED***
      , is_non_empty = false;

    while (position < length) ***REMOVED***
      skipWhiteSpace();
      var item1 = parseKey();
      skipWhiteSpace();
      tokenStart();
      var chr = input[position++];
      tokenEnd(undefined, 'separator');

      if (chr === '***REMOVED***' && item1 === undefined) ***REMOVED***
        if (!json5 && is_non_empty) ***REMOVED***
          position--;
          fail('Trailing comma in object');
        ***REMOVED***
        return result

      ***REMOVED*** else if (chr === ':' && item1 !== undefined) ***REMOVED***
        skipWhiteSpace();
        stack.push(item1);
        var item2 = parseGeneric();
        stack.pop();

        if (item2 === undefined) fail('No value found for key ' + item1);
        if (typeof(item1) !== 'string') ***REMOVED***
          if (!json5 || typeof(item1) !== 'number') ***REMOVED***
            fail('Wrong key type: ' + item1);
          ***REMOVED***
        ***REMOVED***

        if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== 'replace') ***REMOVED***
          if (options.reserved_keys === 'throw') ***REMOVED***
            fail('Reserved key: ' + item1);
          ***REMOVED*** else ***REMOVED***
            // silently ignore it
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          if (typeof(options.reviver) === 'function') ***REMOVED***
            item2 = options.reviver.call(null, item1, item2);
          ***REMOVED***

          if (item2 !== undefined) ***REMOVED***
            is_non_empty = true;
            Object.defineProperty(result, item1, ***REMOVED***
              value: item2,
              enumerable: true,
              configurable: true,
              writable: true,
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***

        skipWhiteSpace();

        tokenStart();
        var chr = input[position++];
        tokenEnd(undefined, 'separator');

        if (chr === ',') ***REMOVED***
          continue

        ***REMOVED*** else if (chr === '***REMOVED***') ***REMOVED***
          return result

        ***REMOVED*** else ***REMOVED***
          fail();
        ***REMOVED***

      ***REMOVED*** else ***REMOVED***
        position--;
        fail();
      ***REMOVED***
    ***REMOVED***

    fail();
  ***REMOVED***

  function parseArray() ***REMOVED***
    var result = [];

    while (position < length) ***REMOVED***
      skipWhiteSpace();
      stack.push(result.length);
      var item = parseGeneric();
      stack.pop();
      skipWhiteSpace();
      tokenStart();
      var chr = input[position++];
      tokenEnd(undefined, 'separator');

      if (item !== undefined) ***REMOVED***
        if (typeof(options.reviver) === 'function') ***REMOVED***
          item = options.reviver.call(null, String(result.length), item);
        ***REMOVED***
        if (item === undefined) ***REMOVED***
          result.length++;
          item = true; // hack for check below, not included into result
        ***REMOVED*** else ***REMOVED***
          result.push(item);
        ***REMOVED***
      ***REMOVED***

      if (chr === ',') ***REMOVED***
        if (item === undefined) ***REMOVED***
          fail('Elisions are not supported');
        ***REMOVED***

      ***REMOVED*** else if (chr === ']') ***REMOVED***
        if (!json5 && item === undefined && result.length) ***REMOVED***
          position--;
          fail('Trailing comma in array');
        ***REMOVED***
        return result

      ***REMOVED*** else ***REMOVED***
        position--;
        fail();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function parseNumber() ***REMOVED***
    // rewind because we don't know first char
    position--;

    var start = position
      , chr = input[position++]
      , t;

    var to_num = function(is_octal) ***REMOVED***
      var str = input.substr(start, position - start);

      if (is_octal) ***REMOVED***
        var result = parseInt(str.replace(/^0o?/, ''), 8);
      ***REMOVED*** else ***REMOVED***
        var result = Number(str);
      ***REMOVED***

      if (Number.isNaN(result)) ***REMOVED***
        position--;
        fail('Bad numeric literal - "' + input.substr(start, position - start + 1) + '"');
      ***REMOVED*** else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) ***REMOVED***
        // additional restrictions imposed by json
        position--;
        fail('Non-json numeric literal - "' + input.substr(start, position - start + 1) + '"');
      ***REMOVED*** else ***REMOVED***
        return result
      ***REMOVED***
    ***REMOVED***;

    // ex: -5982475.249875e+29384
    //     ^ skipping this
    if (chr === '-' || (chr === '+' && json5)) chr = input[position++];

    if (chr === 'N' && json5) ***REMOVED***
      parseKeyword('NaN');
      return NaN
    ***REMOVED***

    if (chr === 'I' && json5) ***REMOVED***
      parseKeyword('Infinity');

      // returning +inf or -inf
      return to_num()
    ***REMOVED***

    if (chr >= '1' && chr <= '9') ***REMOVED***
      // ex: -5982475.249875e+29384
      //        ^^^ skipping these
      while (position < length && isDecDigit(input[position])) position++;
      chr = input[position++];
    ***REMOVED***

    // special case for leading zero: 0.123456
    if (chr === '0') ***REMOVED***
      chr = input[position++];

      //             new syntax, "0o777"           old syntax, "0777"
      var is_octal = chr === 'o' || chr === 'O' || isOctDigit(chr);
      var is_hex = chr === 'x' || chr === 'X';

      if (json5 && (is_octal || is_hex)) ***REMOVED***
        while (position < length
           &&  (is_hex ? isHexDigit : isOctDigit)( input[position] )
        ) position++;

        var sign = 1;
        if (input[start] === '-') ***REMOVED***
          sign = -1;
          start++;
        ***REMOVED*** else if (input[start] === '+') ***REMOVED***
          start++;
        ***REMOVED***

        return sign * to_num(is_octal)
      ***REMOVED***
    ***REMOVED***

    if (chr === '.') ***REMOVED***
      // ex: -5982475.249875e+29384
      //                ^^^ skipping these
      while (position < length && isDecDigit(input[position])) position++;
      chr = input[position++];
    ***REMOVED***

    if (chr === 'e' || chr === 'E') ***REMOVED***
      chr = input[position++];
      if (chr === '-' || chr === '+') position++;
      // ex: -5982475.249875e+29384
      //                       ^^^ skipping these
      while (position < length && isDecDigit(input[position])) position++;
      chr = input[position++];
    ***REMOVED***

    // we have char in the buffer, so count for it
    position--;
    return to_num()
  ***REMOVED***

  function parseIdentifier() ***REMOVED***
    // rewind because we don't know first char
    position--;

    var result = '';

    while (position < length) ***REMOVED***
      var chr = input[position++];

      if (chr === '\\'
      &&  input[position] === 'u'
      &&  isHexDigit(input[position+1])
      &&  isHexDigit(input[position+2])
      &&  isHexDigit(input[position+3])
      &&  isHexDigit(input[position+4])
      ) ***REMOVED***
        // UnicodeEscapeSequence
        chr = String.fromCharCode(parseInt(input.substr(position+1, 4), 16));
        position += 5;
      ***REMOVED***

      if (result.length) ***REMOVED***
        // identifier started
        if (unicode.isIdentifierPart(chr)) ***REMOVED***
          result += chr;
        ***REMOVED*** else ***REMOVED***
          position--;
          return result
        ***REMOVED***

      ***REMOVED*** else ***REMOVED***
        if (unicode.isIdentifierStart(chr)) ***REMOVED***
          result += chr;
        ***REMOVED*** else ***REMOVED***
          return undefined
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    fail();
  ***REMOVED***

  function parseString(endChar) ***REMOVED***
    // 7.8.4 of ES262 spec
    var result = '';

    while (position < length) ***REMOVED***
      var chr = input[position++];

      if (chr === endChar) ***REMOVED***
        return result

      ***REMOVED*** else if (chr === '\\') ***REMOVED***
        if (position >= length) fail();
        chr = input[position++];

        if (unescapeMap[chr] && (json5 || (chr != 'v' && chr != "'"))) ***REMOVED***
          result += unescapeMap[chr];

        ***REMOVED*** else if (json5 && isLineTerminator(chr)) ***REMOVED***
          // line continuation
          newline(chr);

        ***REMOVED*** else if (chr === 'u' || (chr === 'x' && json5)) ***REMOVED***
          // unicode/character escape sequence
          var off = chr === 'u' ? 4 : 2;

          // validation for \uXXXX
          for (var i=0; i<off; i++) ***REMOVED***
            if (position >= length) fail();
            if (!isHexDigit(input[position])) fail('Bad escape sequence');
            position++;
          ***REMOVED***

          result += String.fromCharCode(parseInt(input.substr(position-off, off), 16));
        ***REMOVED*** else if (json5 && isOctDigit(chr)) ***REMOVED***
          if (chr < '4' && isOctDigit(input[position]) && isOctDigit(input[position+1])) ***REMOVED***
            // three-digit octal
            var digits = 3;
          ***REMOVED*** else if (isOctDigit(input[position])) ***REMOVED***
            // two-digit octal
            var digits = 2;
          ***REMOVED*** else ***REMOVED***
            var digits = 1;
          ***REMOVED***
          position += digits - 1;
          result += String.fromCharCode(parseInt(input.substr(position-digits, digits), 8));
          /*if (!isOctDigit(input[position])) ***REMOVED***
            // \0 is allowed still
            result += '\0'
          ***REMOVED*** else ***REMOVED***
            fail('Octal literals are not supported')
          ***REMOVED****/

        ***REMOVED*** else if (json5) ***REMOVED***
          // \X -> x
          result += chr;

        ***REMOVED*** else ***REMOVED***
          position--;
          fail();
        ***REMOVED***

      ***REMOVED*** else if (isLineTerminator(chr)) ***REMOVED***
        fail();

      ***REMOVED*** else ***REMOVED***
        if (!json5 && chr.charCodeAt(0) < 32) ***REMOVED***
          position--;
          fail('Unexpected control character');
        ***REMOVED***

        // SourceCharacter but not one of " or \ or LineTerminator
        result += chr;
      ***REMOVED***
    ***REMOVED***

    fail();
  ***REMOVED***

  skipWhiteSpace();
  var return_value = parseGeneric();
  if (return_value !== undefined || position < length) ***REMOVED***
    skipWhiteSpace();

    if (position >= length) ***REMOVED***
      if (typeof(options.reviver) === 'function') ***REMOVED***
        return_value = options.reviver.call(null, '', return_value);
      ***REMOVED***
      return return_value
    ***REMOVED*** else ***REMOVED***
      fail();
    ***REMOVED***

  ***REMOVED*** else ***REMOVED***
    if (position) ***REMOVED***
      fail('No data, only a whitespace');
    ***REMOVED*** else ***REMOVED***
      fail('No data, empty input');
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/*
 * parse(text, options)
 * or
 * parse(text, reviver)
 *
 * where:
 * text - string
 * options - object
 * reviver - function
 */
module.exports.parse = function parseJSON(input, options) ***REMOVED***
  // support legacy functions
  if (typeof(options) === 'function') ***REMOVED***
    options = ***REMOVED***
      reviver: options
    ***REMOVED***;
  ***REMOVED***

  if (input === undefined) ***REMOVED***
    // parse(stringify(x)) should be equal x
    // with JSON functions it is not 'cause of undefined
    // so we're fixing it
    return undefined
  ***REMOVED***

  // JSON.parse compat
  if (typeof(input) !== 'string') input = String(input);
  if (options == null) options = ***REMOVED******REMOVED***;
  if (options.reserved_keys == null) options.reserved_keys = 'ignore';

  if (options.reserved_keys === 'throw' || options.reserved_keys === 'ignore') ***REMOVED***
    if (options.null_prototype == null) ***REMOVED***
      options.null_prototype = true;
    ***REMOVED***
  ***REMOVED***

  try ***REMOVED***
    return parse(input, options)
  ***REMOVED*** catch(err) ***REMOVED***
    // jju is a recursive parser, so JSON.parse("***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***") could blow up the stack
    //
    // this catch is used to skip all those internal calls
    if (err instanceof SyntaxError && err.row != null && err.column != null) ***REMOVED***
      var old_err = err;
      err = SyntaxError(old_err.message);
      err.column = old_err.column;
      err.row = old_err.row;
    ***REMOVED***
    throw err
  ***REMOVED***
***REMOVED***;

module.exports.tokenize = function tokenizeJSON(input, options) ***REMOVED***
  if (options == null) options = ***REMOVED******REMOVED***;

  options._tokenize = function(smth) ***REMOVED***
    if (options._addstack) smth.stack.unshift.apply(smth.stack, options._addstack);
    tokens.push(smth);
  ***REMOVED***;

  var tokens = [];
  tokens.data = module.exports.parse(input, options);
  return tokens
***REMOVED***;
***REMOVED***);

var parseJson = createCommonjsModule(function (module) ***REMOVED***
'use strict';



function appendPosition(message) ***REMOVED***
	const posRe = / at (\d+:\d+) in/;
	const numbers = posRe.exec(message);
	return message.replace(posRe, ' in') + ':' + numbers[1];
***REMOVED***

const JSONError = errorEx_1('JSONError', ***REMOVED***
	fileName: errorEx_1.append('in %s'),
	appendPosition: ***REMOVED***
		message: (shouldAppend, original) => ***REMOVED***
			if (shouldAppend) ***REMOVED***
				original[0] = appendPosition(original[0]);
			***REMOVED***
			return original;
		***REMOVED***
	***REMOVED***
***REMOVED***);

module.exports = (input, reviver, filename) => ***REMOVED***
	if (typeof reviver === 'string') ***REMOVED***
		filename = reviver;
		reviver = null;
	***REMOVED***

	try ***REMOVED***
		try ***REMOVED***
			return JSON.parse(input, reviver);
		***REMOVED*** catch (err) ***REMOVED***
			parse_1.parse(input, ***REMOVED***
				mode: 'json',
				reviver
			***REMOVED***);

			throw err;
		***REMOVED***
	***REMOVED*** catch (err) ***REMOVED***
		const jsonErr = new JSONError(err);

		if (filename) ***REMOVED***
			jsonErr.fileName = filename;
			jsonErr.appendPosition = true;
		***REMOVED***

		throw jsonErr;
	***REMOVED***
***REMOVED***;
***REMOVED***);

var parseJson_1 = function parseJsonWrapper(
  json        ,
  filepath        
)         ***REMOVED***
  try ***REMOVED***
    return parseJson(json);
  ***REMOVED*** catch (err) ***REMOVED***
    err.message = `JSON Error in $***REMOVED***filepath***REMOVED***:\n$***REMOVED***err.message***REMOVED***`;
    throw err;
  ***REMOVED***
***REMOVED***;

var loadPackageProp = function loadPackageProp(
  packageDir        ,
  options   
                        
                   
   
)                                                     ***REMOVED***
  const packagePath = path.join(packageDir, 'package.json');

  function parseContent(content         )                      ***REMOVED***
    if (!content) return null;
    const parsedContent = parseJson_1(content, packagePath);
    const packagePropValue = parsedContent[options.packageProp];
    if (!packagePropValue) return null;

    return ***REMOVED***
      config: packagePropValue,
      filepath: packagePath,
    ***REMOVED***;
  ***REMOVED***

  return !options.sync
    ? readFile_1(packagePath).then(parseContent)
    : parseContent(readFile_1.sync(packagePath));
***REMOVED***;

function isNothing(subject) ***REMOVED***
  return (typeof subject === 'undefined') || (subject === null);
***REMOVED***


function isObject(subject) ***REMOVED***
  return (typeof subject === 'object') && (subject !== null);
***REMOVED***


function toArray(sequence) ***REMOVED***
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
***REMOVED***


function extend(target, source) ***REMOVED***
  var index, length, key, sourceKeys;

  if (source) ***REMOVED***
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) ***REMOVED***
      key = sourceKeys[index];
      target[key] = source[key];
    ***REMOVED***
  ***REMOVED***

  return target;
***REMOVED***


function repeat(string, count) ***REMOVED***
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) ***REMOVED***
    result += string;
  ***REMOVED***

  return result;
***REMOVED***


function isNegativeZero(number) ***REMOVED***
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
***REMOVED***


var isNothing_1      = isNothing;
var isObject_1       = isObject;
var toArray_1        = toArray;
var repeat_1         = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1         = extend;

var common = ***REMOVED***
	isNothing: isNothing_1,
	isObject: isObject_1,
	toArray: toArray_1,
	repeat: repeat_1,
	isNegativeZero: isNegativeZero_1,
	extend: extend_1
***REMOVED***;

// YAML error class. http://stackoverflow.com/questions/8458984
//
function YAMLException$1(reason, mark) ***REMOVED***
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) ***REMOVED***
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  ***REMOVED*** else ***REMOVED***
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  ***REMOVED***
***REMOVED***


// Inherit from Error
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;


YAMLException$1.prototype.toString = function toString(compact) ***REMOVED***
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) ***REMOVED***
    result += ' ' + this.mark.toString();
  ***REMOVED***

  return result;
***REMOVED***;


var exception = YAMLException$1;

function Mark(name, buffer, position, line, column) ***REMOVED***
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
***REMOVED***


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) ***REMOVED***
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) ***REMOVED***
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) ***REMOVED***
      head = ' ... ';
      start += 5;
      break;
    ***REMOVED***
  ***REMOVED***

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) ***REMOVED***
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) ***REMOVED***
      tail = ' ... ';
      end -= 5;
      break;
    ***REMOVED***
  ***REMOVED***

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
***REMOVED***;


Mark.prototype.toString = function toString(compact) ***REMOVED***
  var snippet, where = '';

  if (this.name) ***REMOVED***
    where += 'in "' + this.name + '" ';
  ***REMOVED***

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) ***REMOVED***
    snippet = this.getSnippet();

    if (snippet) ***REMOVED***
      where += ':\n' + snippet;
    ***REMOVED***
  ***REMOVED***

  return where;
***REMOVED***;


var mark = Mark;

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) ***REMOVED***
  var result = ***REMOVED******REMOVED***;

  if (map !== null) ***REMOVED***
    Object.keys(map).forEach(function (style) ***REMOVED***
      map[style].forEach(function (alias) ***REMOVED***
        result[String(alias)] = style;
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  return result;
***REMOVED***

function Type$1(tag, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  Object.keys(options).forEach(function (name) ***REMOVED***
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) ***REMOVED***
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    ***REMOVED***
  ***REMOVED***);

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () ***REMOVED*** return true; ***REMOVED***;
  this.construct    = options['construct']    || function (data) ***REMOVED*** return data; ***REMOVED***;
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) ***REMOVED***
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  ***REMOVED***
***REMOVED***

var type = Type$1;

/*eslint-disable max-len*/






function compileList(schema, name, result) ***REMOVED***
  var exclude = [];

  schema.include.forEach(function (includedSchema) ***REMOVED***
    result = compileList(includedSchema, name, result);
  ***REMOVED***);

  schema[name].forEach(function (currentType) ***REMOVED***
    result.forEach(function (previousType, previousIndex) ***REMOVED***
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) ***REMOVED***
        exclude.push(previousIndex);
      ***REMOVED***
    ***REMOVED***);

    result.push(currentType);
  ***REMOVED***);

  return result.filter(function (type$$1, index) ***REMOVED***
    return exclude.indexOf(index) === -1;
  ***REMOVED***);
***REMOVED***


function compileMap(/* lists... */) ***REMOVED***
  var result = ***REMOVED***
        scalar: ***REMOVED******REMOVED***,
        sequence: ***REMOVED******REMOVED***,
        mapping: ***REMOVED******REMOVED***,
        fallback: ***REMOVED******REMOVED***
      ***REMOVED***, index, length;

  function collectType(type$$1) ***REMOVED***
    result[type$$1.kind][type$$1.tag] = result['fallback'][type$$1.tag] = type$$1;
  ***REMOVED***

  for (index = 0, length = arguments.length; index < length; index += 1) ***REMOVED***
    arguments[index].forEach(collectType);
  ***REMOVED***
  return result;
***REMOVED***


function Schema$1(definition) ***REMOVED***
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type$$1) ***REMOVED***
    if (type$$1.loadKind && type$$1.loadKind !== 'scalar') ***REMOVED***
      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    ***REMOVED***
  ***REMOVED***);

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
***REMOVED***


Schema$1.DEFAULT = null;


Schema$1.create = function createSchema() ***REMOVED***
  var schemas, types;

  switch (arguments.length) ***REMOVED***
    case 1:
      schemas = Schema$1.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new exception('Wrong number of arguments for Schema.create function');
  ***REMOVED***

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) ***REMOVED*** return schema instanceof Schema$1; ***REMOVED***)) ***REMOVED***
    throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  ***REMOVED***

  if (!types.every(function (type$$1) ***REMOVED*** return type$$1 instanceof type; ***REMOVED***)) ***REMOVED***
    throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  ***REMOVED***

  return new Schema$1(***REMOVED***
    include: schemas,
    explicit: types
  ***REMOVED***);
***REMOVED***;


var schema = Schema$1;

var str = new type('tag:yaml.org,2002:str', ***REMOVED***
  kind: 'scalar',
  construct: function (data) ***REMOVED*** return data !== null ? data : ''; ***REMOVED***
***REMOVED***);

var seq = new type('tag:yaml.org,2002:seq', ***REMOVED***
  kind: 'sequence',
  construct: function (data) ***REMOVED*** return data !== null ? data : []; ***REMOVED***
***REMOVED***);

var map = new type('tag:yaml.org,2002:map', ***REMOVED***
  kind: 'mapping',
  construct: function (data) ***REMOVED*** return data !== null ? data : ***REMOVED******REMOVED***; ***REMOVED***
***REMOVED***);

var failsafe = new schema(***REMOVED***
  explicit: [
    str,
    seq,
    map
  ]
***REMOVED***);

function resolveYamlNull(data) ***REMOVED***
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
***REMOVED***

function constructYamlNull() ***REMOVED***
  return null;
***REMOVED***

function isNull(object) ***REMOVED***
  return object === null;
***REMOVED***

var _null = new type('tag:yaml.org,2002:null', ***REMOVED***
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: ***REMOVED***
    canonical: function () ***REMOVED*** return '~';    ***REMOVED***,
    lowercase: function () ***REMOVED*** return 'null'; ***REMOVED***,
    uppercase: function () ***REMOVED*** return 'NULL'; ***REMOVED***,
    camelcase: function () ***REMOVED*** return 'Null'; ***REMOVED***
  ***REMOVED***,
  defaultStyle: 'lowercase'
***REMOVED***);

function resolveYamlBoolean(data) ***REMOVED***
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
***REMOVED***

function constructYamlBoolean(data) ***REMOVED***
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
***REMOVED***

function isBoolean(object) ***REMOVED***
  return Object.prototype.toString.call(object) === '[object Boolean]';
***REMOVED***

var bool = new type('tag:yaml.org,2002:bool', ***REMOVED***
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: ***REMOVED***
    lowercase: function (object) ***REMOVED*** return object ? 'true' : 'false'; ***REMOVED***,
    uppercase: function (object) ***REMOVED*** return object ? 'TRUE' : 'FALSE'; ***REMOVED***,
    camelcase: function (object) ***REMOVED*** return object ? 'True' : 'False'; ***REMOVED***
  ***REMOVED***,
  defaultStyle: 'lowercase'
***REMOVED***);

function isHexCode(c) ***REMOVED***
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
***REMOVED***

function isOctCode(c) ***REMOVED***
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
***REMOVED***

function isDecCode(c) ***REMOVED***
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
***REMOVED***

function resolveYamlInteger(data) ***REMOVED***
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') ***REMOVED***
    ch = data[++index];
  ***REMOVED***

  if (ch === '0') ***REMOVED***
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') ***REMOVED***
      // base 2
      index++;

      for (; index < max; index++) ***REMOVED***
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      ***REMOVED***
      return hasDigits && ch !== '_';
    ***REMOVED***


    if (ch === 'x') ***REMOVED***
      // base 16
      index++;

      for (; index < max; index++) ***REMOVED***
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      ***REMOVED***
      return hasDigits && ch !== '_';
    ***REMOVED***

    // base 8
    for (; index < max; index++) ***REMOVED***
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    ***REMOVED***
    return hasDigits && ch !== '_';
  ***REMOVED***

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) ***REMOVED***
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) ***REMOVED***
      return false;
    ***REMOVED***
    hasDigits = true;
  ***REMOVED***

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
***REMOVED***

function constructYamlInteger(data) ***REMOVED***
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) ***REMOVED***
    value = value.replace(/_/g, '');
  ***REMOVED***

  ch = value[0];

  if (ch === '-' || ch === '+') ***REMOVED***
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  ***REMOVED***

  if (value === '0') return 0;

  if (ch === '0') ***REMOVED***
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  ***REMOVED***

  if (value.indexOf(':') !== -1) ***REMOVED***
    value.split(':').forEach(function (v) ***REMOVED***
      digits.unshift(parseInt(v, 10));
    ***REMOVED***);

    value = 0;
    base = 1;

    digits.forEach(function (d) ***REMOVED***
      value += (d * base);
      base *= 60;
    ***REMOVED***);

    return sign * value;

  ***REMOVED***

  return sign * parseInt(value, 10);
***REMOVED***

function isInteger(object) ***REMOVED***
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
***REMOVED***

var int_1 = new type('tag:yaml.org,2002:int', ***REMOVED***
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: ***REMOVED***
    binary:      function (object) ***REMOVED*** return '0b' + object.toString(2); ***REMOVED***,
    octal:       function (object) ***REMOVED*** return '0'  + object.toString(8); ***REMOVED***,
    decimal:     function (object) ***REMOVED*** return        object.toString(10); ***REMOVED***,
    hexadecimal: function (object) ***REMOVED*** return '0x' + object.toString(16).toUpperCase(); ***REMOVED***
  ***REMOVED***,
  defaultStyle: 'decimal',
  styleAliases: ***REMOVED***
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  ***REMOVED***
***REMOVED***);

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) ***REMOVED***
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') ***REMOVED***
    return false;
  ***REMOVED***

  return true;
***REMOVED***

function constructYamlFloat(data) ***REMOVED***
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) ***REMOVED***
    value = value.slice(1);
  ***REMOVED***

  if (value === '.inf') ***REMOVED***
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  ***REMOVED*** else if (value === '.nan') ***REMOVED***
    return NaN;

  ***REMOVED*** else if (value.indexOf(':') >= 0) ***REMOVED***
    value.split(':').forEach(function (v) ***REMOVED***
      digits.unshift(parseFloat(v, 10));
    ***REMOVED***);

    value = 0.0;
    base = 1;

    digits.forEach(function (d) ***REMOVED***
      value += d * base;
      base *= 60;
    ***REMOVED***);

    return sign * value;

  ***REMOVED***
  return sign * parseFloat(value, 10);
***REMOVED***


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) ***REMOVED***
  var res;

  if (isNaN(object)) ***REMOVED***
    switch (style) ***REMOVED***
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    ***REMOVED***
  ***REMOVED*** else if (Number.POSITIVE_INFINITY === object) ***REMOVED***
    switch (style) ***REMOVED***
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    ***REMOVED***
  ***REMOVED*** else if (Number.NEGATIVE_INFINITY === object) ***REMOVED***
    switch (style) ***REMOVED***
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    ***REMOVED***
  ***REMOVED*** else if (common.isNegativeZero(object)) ***REMOVED***
    return '-0.0';
  ***REMOVED***

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
***REMOVED***

function isFloat(object) ***REMOVED***
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
***REMOVED***

var float_1 = new type('tag:yaml.org,2002:float', ***REMOVED***
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
***REMOVED***);

var json = new schema(***REMOVED***
  include: [
    failsafe
  ],
  implicit: [
    _null,
    bool,
    int_1,
    float_1
  ]
***REMOVED***);

var core = new schema(***REMOVED***
  include: [
    json
  ]
***REMOVED***);

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) ***REMOVED***
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
***REMOVED***

function constructYamlTimestamp(data) ***REMOVED***
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) ***REMOVED*** // no hour
    return new Date(Date.UTC(year, month, day));
  ***REMOVED***

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) ***REMOVED***
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) ***REMOVED*** // milli-seconds
      fraction += '0';
    ***REMOVED***
    fraction = +fraction;
  ***REMOVED***

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) ***REMOVED***
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  ***REMOVED***

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
***REMOVED***

function representYamlTimestamp(object /*, style*/) ***REMOVED***
  return object.toISOString();
***REMOVED***

var timestamp = new type('tag:yaml.org,2002:timestamp', ***REMOVED***
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
***REMOVED***);

function resolveYamlMerge(data) ***REMOVED***
  return data === '<<' || data === null;
***REMOVED***

var merge = new type('tag:yaml.org,2002:merge', ***REMOVED***
  kind: 'scalar',
  resolve: resolveYamlMerge
***REMOVED***);

/*eslint-disable no-bitwise*/

var NodeBuffer;

try ***REMOVED***
  // A trick for browserified version, to not include `Buffer` shim
  var _require = commonjsRequire;
  NodeBuffer = _require('buffer').Buffer;
***REMOVED*** catch (__) ***REMOVED******REMOVED***




// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) ***REMOVED***
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) ***REMOVED***
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  ***REMOVED***

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
***REMOVED***

function constructYamlBinary(data) ***REMOVED***
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) ***REMOVED***
    if ((idx % 4 === 0) && idx) ***REMOVED***
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    ***REMOVED***

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  ***REMOVED***

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) ***REMOVED***
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  ***REMOVED*** else if (tailbits === 18) ***REMOVED***
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  ***REMOVED*** else if (tailbits === 12) ***REMOVED***
    result.push((bits >> 4) & 0xFF);
  ***REMOVED***

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) ***REMOVED***
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  ***REMOVED***

  return result;
***REMOVED***

function representYamlBinary(object /*, style*/) ***REMOVED***
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) ***REMOVED***
    if ((idx % 3 === 0) && idx) ***REMOVED***
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    ***REMOVED***

    bits = (bits << 8) + object[idx];
  ***REMOVED***

  // Dump tail

  tail = max % 3;

  if (tail === 0) ***REMOVED***
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  ***REMOVED*** else if (tail === 2) ***REMOVED***
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  ***REMOVED*** else if (tail === 1) ***REMOVED***
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  ***REMOVED***

  return result;
***REMOVED***

function isBinary(object) ***REMOVED***
  return NodeBuffer && NodeBuffer.isBuffer(object);
***REMOVED***

var binary = new type('tag:yaml.org,2002:binary', ***REMOVED***
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
***REMOVED***);

var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) ***REMOVED***
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) ***REMOVED***
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) ***REMOVED***
      if (_hasOwnProperty$1.call(pair, pairKey)) ***REMOVED***
        if (!pairHasKey) pairHasKey = true;
        else return false;
      ***REMOVED***
    ***REMOVED***

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  ***REMOVED***

  return true;
***REMOVED***

function constructYamlOmap(data) ***REMOVED***
  return data !== null ? data : [];
***REMOVED***

var omap = new type('tag:yaml.org,2002:omap', ***REMOVED***
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
***REMOVED***);

var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) ***REMOVED***
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) ***REMOVED***
    pair = object[index];

    if (_toString$1.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  ***REMOVED***

  return true;
***REMOVED***

function constructYamlPairs(data) ***REMOVED***
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) ***REMOVED***
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  ***REMOVED***

  return result;
***REMOVED***

var pairs = new type('tag:yaml.org,2002:pairs', ***REMOVED***
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
***REMOVED***);

var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) ***REMOVED***
  if (data === null) return true;

  var key, object = data;

  for (key in object) ***REMOVED***
    if (_hasOwnProperty$2.call(object, key)) ***REMOVED***
      if (object[key] !== null) return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***

function constructYamlSet(data) ***REMOVED***
  return data !== null ? data : ***REMOVED******REMOVED***;
***REMOVED***

var set = new type('tag:yaml.org,2002:set', ***REMOVED***
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
***REMOVED***);

var default_safe = new schema(***REMOVED***
  include: [
    core
  ],
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
***REMOVED***);

function resolveJavascriptUndefined() ***REMOVED***
  return true;
***REMOVED***

function constructJavascriptUndefined() ***REMOVED***
  /*eslint-disable no-undefined*/
  return undefined;
***REMOVED***

function representJavascriptUndefined() ***REMOVED***
  return '';
***REMOVED***

function isUndefined(object) ***REMOVED***
  return typeof object === 'undefined';
***REMOVED***

var _undefined = new type('tag:yaml.org,2002:js/undefined', ***REMOVED***
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
***REMOVED***);

function resolveJavascriptRegExp(data) ***REMOVED***
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') ***REMOVED***
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  ***REMOVED***

  return true;
***REMOVED***

function constructJavascriptRegExp(data) ***REMOVED***
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') ***REMOVED***
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  ***REMOVED***

  return new RegExp(regexp, modifiers);
***REMOVED***

function representJavascriptRegExp(object /*, style*/) ***REMOVED***
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
***REMOVED***

function isRegExp(object) ***REMOVED***
  return Object.prototype.toString.call(object) === '[object RegExp]';
***REMOVED***

var regexp = new type('tag:yaml.org,2002:js/regexp', ***REMOVED***
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
***REMOVED***);

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try ***REMOVED***
  // workaround to exclude package from browserify list.
  var _require$1 = commonjsRequire;
  esprima = _require$1('esprima');
***REMOVED*** catch (_) ***REMOVED***
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
***REMOVED***



function resolveJavascriptFunction(data) ***REMOVED***
  if (data === null) return false;

  try ***REMOVED***
    var source = '(' + data + ')',
        ast    = esprima.parse(source, ***REMOVED*** range: true ***REMOVED***);

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        ast.body[0].expression.type !== 'FunctionExpression') ***REMOVED***
      return false;
    ***REMOVED***

    return true;
  ***REMOVED*** catch (err) ***REMOVED***
    return false;
  ***REMOVED***
***REMOVED***

function constructJavascriptFunction(data) ***REMOVED***
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, ***REMOVED*** range: true ***REMOVED***),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      ast.body[0].expression.type !== 'FunctionExpression') ***REMOVED***
    throw new Error('Failed to resolve function');
  ***REMOVED***

  ast.body[0].expression.params.forEach(function (param) ***REMOVED***
    params.push(param.name);
  ***REMOVED***);

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '***REMOVED***' and the last '***REMOVED***' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
***REMOVED***

function representJavascriptFunction(object /*, style*/) ***REMOVED***
  return object.toString();
***REMOVED***

function isFunction(object) ***REMOVED***
  return Object.prototype.toString.call(object) === '[object Function]';
***REMOVED***

var _function = new type('tag:yaml.org,2002:js/function', ***REMOVED***
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
***REMOVED***);

var default_full = schema.DEFAULT = new schema(***REMOVED***
  include: [
    default_safe
  ],
  explicit: [
    _undefined,
    regexp,
    _function
  ]
***REMOVED***);

/*eslint-disable max-len,no-use-before-define*/








var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\***REMOVED***\***REMOVED***]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\***REMOVED***\***REMOVED***])(?:%[0-9a-f]***REMOVED***2***REMOVED***|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) ***REMOVED***
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
***REMOVED***

function is_WHITE_SPACE(c) ***REMOVED***
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
***REMOVED***

function is_WS_OR_EOL(c) ***REMOVED***
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
***REMOVED***

function is_FLOW_INDICATOR(c) ***REMOVED***
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* ***REMOVED*** */ ||
         c === 0x7D/* ***REMOVED*** */;
***REMOVED***

function fromHexCode(c) ***REMOVED***
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ***REMOVED***
    return c - 0x30;
  ***REMOVED***

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) ***REMOVED***
    return lc - 0x61 + 10;
  ***REMOVED***

  return -1;
***REMOVED***

function escapedHexLen(c) ***REMOVED***
  if (c === 0x78/* x */) ***REMOVED*** return 2; ***REMOVED***
  if (c === 0x75/* u */) ***REMOVED*** return 4; ***REMOVED***
  if (c === 0x55/* U */) ***REMOVED*** return 8; ***REMOVED***
  return 0;
***REMOVED***

function fromDecimalCode(c) ***REMOVED***
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ***REMOVED***
    return c - 0x30;
  ***REMOVED***

  return -1;
***REMOVED***

function simpleEscapeSequence(c) ***REMOVED***
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
***REMOVED***

function charFromCodepoint(c) ***REMOVED***
  if (c <= 0xFFFF) ***REMOVED***
    return String.fromCharCode(c);
  ***REMOVED***
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
***REMOVED***

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) ***REMOVED***
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
***REMOVED***


function State(input, options) ***REMOVED***
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || default_full;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

***REMOVED***


function generateError(state, message) ***REMOVED***
  return new exception(
    message,
    new mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
***REMOVED***

function throwError(state, message) ***REMOVED***
  throw generateError(state, message);
***REMOVED***

function throwWarning(state, message) ***REMOVED***
  if (state.onWarning) ***REMOVED***
    state.onWarning.call(null, generateError(state, message));
  ***REMOVED***
***REMOVED***


var directiveHandlers = ***REMOVED***

  YAML: function handleYamlDirective(state, name, args) ***REMOVED***

    var match, major, minor;

    if (state.version !== null) ***REMOVED***
      throwError(state, 'duplication of %YAML directive');
    ***REMOVED***

    if (args.length !== 1) ***REMOVED***
      throwError(state, 'YAML directive accepts exactly one argument');
    ***REMOVED***

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) ***REMOVED***
      throwError(state, 'ill-formed argument of the YAML directive');
    ***REMOVED***

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) ***REMOVED***
      throwError(state, 'unacceptable YAML version of the document');
    ***REMOVED***

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) ***REMOVED***
      throwWarning(state, 'unsupported YAML version of the document');
    ***REMOVED***
  ***REMOVED***,

  TAG: function handleTagDirective(state, name, args) ***REMOVED***

    var handle, prefix;

    if (args.length !== 2) ***REMOVED***
      throwError(state, 'TAG directive accepts exactly two arguments');
    ***REMOVED***

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) ***REMOVED***
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    ***REMOVED***

    if (_hasOwnProperty.call(state.tagMap, handle)) ***REMOVED***
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    ***REMOVED***

    if (!PATTERN_TAG_URI.test(prefix)) ***REMOVED***
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    ***REMOVED***

    state.tagMap[handle] = prefix;
  ***REMOVED***
***REMOVED***;


function captureSegment(state, start, end, checkJson) ***REMOVED***
  var _position, _length, _character, _result;

  if (start < end) ***REMOVED***
    _result = state.input.slice(start, end);

    if (checkJson) ***REMOVED***
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) ***REMOVED***
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) ***REMOVED***
          throwError(state, 'expected valid JSON character');
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if (PATTERN_NON_PRINTABLE.test(_result)) ***REMOVED***
      throwError(state, 'the stream contains non-printable characters');
    ***REMOVED***

    state.result += _result;
  ***REMOVED***
***REMOVED***

function mergeMappings(state, destination, source, overridableKeys) ***REMOVED***
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) ***REMOVED***
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  ***REMOVED***

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) ***REMOVED***
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) ***REMOVED***
      destination[key] = source[key];
      overridableKeys[key] = true;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) ***REMOVED***
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) ***REMOVED***
    _result = ***REMOVED******REMOVED***;
  ***REMOVED***

  if (keyTag === 'tag:yaml.org,2002:merge') ***REMOVED***
    if (Array.isArray(valueNode)) ***REMOVED***
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) ***REMOVED***
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      mergeMappings(state, _result, valueNode, overridableKeys);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) ***REMOVED***
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    ***REMOVED***
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  ***REMOVED***

  return _result;
***REMOVED***

function readLineBreak(state) ***REMOVED***
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) ***REMOVED***
    state.position++;
  ***REMOVED*** else if (ch === 0x0D/* CR */) ***REMOVED***
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) ***REMOVED***
      state.position++;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    throwError(state, 'a line break is expected');
  ***REMOVED***

  state.line += 1;
  state.lineStart = state.position;
***REMOVED***

function skipSeparationSpace(state, allowComments, checkIndent) ***REMOVED***
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) ***REMOVED***
    while (is_WHITE_SPACE(ch)) ***REMOVED***
      ch = state.input.charCodeAt(++state.position);
    ***REMOVED***

    if (allowComments && ch === 0x23/* # */) ***REMOVED***
      do ***REMOVED***
        ch = state.input.charCodeAt(++state.position);
      ***REMOVED*** while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    ***REMOVED***

    if (is_EOL(ch)) ***REMOVED***
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) ***REMOVED***
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      break;
    ***REMOVED***
  ***REMOVED***

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) ***REMOVED***
    throwWarning(state, 'deficient indentation');
  ***REMOVED***

  return lineBreaks;
***REMOVED***

function testDocumentSeparator(state) ***REMOVED***
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) ***REMOVED***

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***

function writeFoldedLines(state, count) ***REMOVED***
  if (count === 1) ***REMOVED***
    state.result += ' ';
  ***REMOVED*** else if (count > 1) ***REMOVED***
    state.result += common.repeat('\n', count - 1);
  ***REMOVED***
***REMOVED***


function readPlainScalar(state, nodeIndent, withinFlowCollection) ***REMOVED***
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) ***REMOVED***
    return false;
  ***REMOVED***

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) ***REMOVED***
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) ***REMOVED***
    if (ch === 0x3A/* : */) ***REMOVED***
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) ***REMOVED***
        break;
      ***REMOVED***

    ***REMOVED*** else if (ch === 0x23/* # */) ***REMOVED***
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) ***REMOVED***
        break;
      ***REMOVED***

    ***REMOVED*** else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) ***REMOVED***
      break;

    ***REMOVED*** else if (is_EOL(ch)) ***REMOVED***
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) ***REMOVED***
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      ***REMOVED*** else ***REMOVED***
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      ***REMOVED***
    ***REMOVED***

    if (hasPendingContent) ***REMOVED***
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    ***REMOVED***

    if (!is_WHITE_SPACE(ch)) ***REMOVED***
      captureEnd = state.position + 1;
    ***REMOVED***

    ch = state.input.charCodeAt(++state.position);
  ***REMOVED***

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) ***REMOVED***
    return true;
  ***REMOVED***

  state.kind = _kind;
  state.result = _result;
  return false;
***REMOVED***

function readSingleQuotedScalar(state, nodeIndent) ***REMOVED***
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) ***REMOVED***
    return false;
  ***REMOVED***

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) ***REMOVED***
    if (ch === 0x27/* ' */) ***REMOVED***
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) ***REMOVED***
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      ***REMOVED*** else ***REMOVED***
        return true;
      ***REMOVED***

    ***REMOVED*** else if (is_EOL(ch)) ***REMOVED***
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    ***REMOVED*** else if (state.position === state.lineStart && testDocumentSeparator(state)) ***REMOVED***
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    ***REMOVED*** else ***REMOVED***
      state.position++;
      captureEnd = state.position;
    ***REMOVED***
  ***REMOVED***

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
***REMOVED***

function readDoubleQuotedScalar(state, nodeIndent) ***REMOVED***
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) ***REMOVED***
    return false;
  ***REMOVED***

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) ***REMOVED***
    if (ch === 0x22/* " */) ***REMOVED***
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    ***REMOVED*** else if (ch === 0x5C/* \ */) ***REMOVED***
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) ***REMOVED***
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      ***REMOVED*** else if (ch < 256 && simpleEscapeCheck[ch]) ***REMOVED***
        state.result += simpleEscapeMap[ch];
        state.position++;

      ***REMOVED*** else if ((tmp = escapedHexLen(ch)) > 0) ***REMOVED***
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) ***REMOVED***
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) ***REMOVED***
            hexResult = (hexResult << 4) + tmp;

          ***REMOVED*** else ***REMOVED***
            throwError(state, 'expected hexadecimal character');
          ***REMOVED***
        ***REMOVED***

        state.result += charFromCodepoint(hexResult);

        state.position++;

      ***REMOVED*** else ***REMOVED***
        throwError(state, 'unknown escape sequence');
      ***REMOVED***

      captureStart = captureEnd = state.position;

    ***REMOVED*** else if (is_EOL(ch)) ***REMOVED***
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    ***REMOVED*** else if (state.position === state.lineStart && testDocumentSeparator(state)) ***REMOVED***
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    ***REMOVED*** else ***REMOVED***
      state.position++;
      captureEnd = state.position;
    ***REMOVED***
  ***REMOVED***

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
***REMOVED***

function readFlowCollection(state, nodeIndent) ***REMOVED***
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = ***REMOVED******REMOVED***,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) ***REMOVED***
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  ***REMOVED*** else if (ch === 0x7B/* ***REMOVED*** */) ***REMOVED***
    terminator = 0x7D;/* ***REMOVED*** */
    isMapping = true;
    _result = ***REMOVED******REMOVED***;
  ***REMOVED*** else ***REMOVED***
    return false;
  ***REMOVED***

  if (state.anchor !== null) ***REMOVED***
    state.anchorMap[state.anchor] = _result;
  ***REMOVED***

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) ***REMOVED***
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) ***REMOVED***
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    ***REMOVED*** else if (!readNext) ***REMOVED***
      throwError(state, 'missed comma between flow collection entries');
    ***REMOVED***

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) ***REMOVED***
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) ***REMOVED***
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      ***REMOVED***
    ***REMOVED***

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) ***REMOVED***
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    ***REMOVED***

    if (isMapping) ***REMOVED***
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    ***REMOVED*** else if (isPair) ***REMOVED***
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    ***REMOVED*** else ***REMOVED***
      _result.push(keyNode);
    ***REMOVED***

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) ***REMOVED***
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    ***REMOVED*** else ***REMOVED***
      readNext = false;
    ***REMOVED***
  ***REMOVED***

  throwError(state, 'unexpected end of the stream within a flow collection');
***REMOVED***

function readBlockScalar(state, nodeIndent) ***REMOVED***
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) ***REMOVED***
    folding = false;
  ***REMOVED*** else if (ch === 0x3E/* > */) ***REMOVED***
    folding = true;
  ***REMOVED*** else ***REMOVED***
    return false;
  ***REMOVED***

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) ***REMOVED***
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) ***REMOVED***
      if (CHOMPING_CLIP === chomping) ***REMOVED***
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      ***REMOVED*** else ***REMOVED***
        throwError(state, 'repeat of a chomping mode identifier');
      ***REMOVED***

    ***REMOVED*** else if ((tmp = fromDecimalCode(ch)) >= 0) ***REMOVED***
      if (tmp === 0) ***REMOVED***
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      ***REMOVED*** else if (!detectedIndent) ***REMOVED***
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      ***REMOVED*** else ***REMOVED***
        throwError(state, 'repeat of an indentation width identifier');
      ***REMOVED***

    ***REMOVED*** else ***REMOVED***
      break;
    ***REMOVED***
  ***REMOVED***

  if (is_WHITE_SPACE(ch)) ***REMOVED***
    do ***REMOVED*** ch = state.input.charCodeAt(++state.position); ***REMOVED***
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) ***REMOVED***
      do ***REMOVED*** ch = state.input.charCodeAt(++state.position); ***REMOVED***
      while (!is_EOL(ch) && (ch !== 0));
    ***REMOVED***
  ***REMOVED***

  while (ch !== 0) ***REMOVED***
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) ***REMOVED***
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    ***REMOVED***

    if (!detectedIndent && state.lineIndent > textIndent) ***REMOVED***
      textIndent = state.lineIndent;
    ***REMOVED***

    if (is_EOL(ch)) ***REMOVED***
      emptyLines++;
      continue;
    ***REMOVED***

    // End of the scalar.
    if (state.lineIndent < textIndent) ***REMOVED***

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) ***REMOVED***
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      ***REMOVED*** else if (chomping === CHOMPING_CLIP) ***REMOVED***
        if (didReadContent) ***REMOVED*** // i.e. only if the scalar is not empty.
          state.result += '\n';
        ***REMOVED***
      ***REMOVED***

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    ***REMOVED***

    // Folded style: use fancy rules to handle line breaks.
    if (folding) ***REMOVED***

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) ***REMOVED***
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      ***REMOVED*** else if (atMoreIndented) ***REMOVED***
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      ***REMOVED*** else if (emptyLines === 0) ***REMOVED***
        if (didReadContent) ***REMOVED*** // i.e. only if we have already read some scalar content.
          state.result += ' ';
        ***REMOVED***

      // Several line breaks - perceive as different lines.
      ***REMOVED*** else ***REMOVED***
        state.result += common.repeat('\n', emptyLines);
      ***REMOVED***

    // Literal style: just add exact number of line breaks between content lines.
    ***REMOVED*** else ***REMOVED***
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    ***REMOVED***

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) ***REMOVED***
      ch = state.input.charCodeAt(++state.position);
    ***REMOVED***

    captureSegment(state, captureStart, state.position, false);
  ***REMOVED***

  return true;
***REMOVED***

function readBlockSequence(state, nodeIndent) ***REMOVED***
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) ***REMOVED***
    state.anchorMap[state.anchor] = _result;
  ***REMOVED***

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) ***REMOVED***

    if (ch !== 0x2D/* - */) ***REMOVED***
      break;
    ***REMOVED***

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) ***REMOVED***
      break;
    ***REMOVED***

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) ***REMOVED***
      if (state.lineIndent <= nodeIndent) ***REMOVED***
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      ***REMOVED***
    ***REMOVED***

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) ***REMOVED***
      throwError(state, 'bad indentation of a sequence entry');
    ***REMOVED*** else if (state.lineIndent < nodeIndent) ***REMOVED***
      break;
    ***REMOVED***
  ***REMOVED***

  if (detected) ***REMOVED***
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  ***REMOVED***
  return false;
***REMOVED***

function readBlockMapping(state, nodeIndent, flowIndent) ***REMOVED***
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = ***REMOVED******REMOVED***,
      overridableKeys = ***REMOVED******REMOVED***,
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) ***REMOVED***
    state.anchorMap[state.anchor] = _result;
  ***REMOVED***

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) ***REMOVED***
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) ***REMOVED***

      if (ch === 0x3F/* ? */) ***REMOVED***
        if (atExplicitKey) ***REMOVED***
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        ***REMOVED***

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      ***REMOVED*** else if (atExplicitKey) ***REMOVED***
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      ***REMOVED*** else ***REMOVED***
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      ***REMOVED***

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    ***REMOVED*** else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) ***REMOVED***

      if (state.line === _line) ***REMOVED***
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) ***REMOVED***
          ch = state.input.charCodeAt(++state.position);
        ***REMOVED***

        if (ch === 0x3A/* : */) ***REMOVED***
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) ***REMOVED***
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          ***REMOVED***

          if (atExplicitKey) ***REMOVED***
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          ***REMOVED***

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        ***REMOVED*** else if (detected) ***REMOVED***
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        ***REMOVED*** else ***REMOVED***
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        ***REMOVED***

      ***REMOVED*** else if (detected) ***REMOVED***
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      ***REMOVED*** else ***REMOVED***
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      ***REMOVED***

    ***REMOVED*** else ***REMOVED***
      break; // Reading is done. Go to the epilogue.
    ***REMOVED***

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) ***REMOVED***
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) ***REMOVED***
        if (atExplicitKey) ***REMOVED***
          keyNode = state.result;
        ***REMOVED*** else ***REMOVED***
          valueNode = state.result;
        ***REMOVED***
      ***REMOVED***

      if (!atExplicitKey) ***REMOVED***
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      ***REMOVED***

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    ***REMOVED***

    if (state.lineIndent > nodeIndent && (ch !== 0)) ***REMOVED***
      throwError(state, 'bad indentation of a mapping entry');
    ***REMOVED*** else if (state.lineIndent < nodeIndent) ***REMOVED***
      break;
    ***REMOVED***
  ***REMOVED***

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) ***REMOVED***
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  ***REMOVED***

  // Expose the resulting mapping.
  if (detected) ***REMOVED***
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  ***REMOVED***

  return detected;
***REMOVED***

function readTagProperty(state) ***REMOVED***
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) ***REMOVED***
    throwError(state, 'duplication of a tag property');
  ***REMOVED***

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) ***REMOVED***
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  ***REMOVED*** else if (ch === 0x21/* ! */) ***REMOVED***
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  ***REMOVED*** else ***REMOVED***
    tagHandle = '!';
  ***REMOVED***

  _position = state.position;

  if (isVerbatim) ***REMOVED***
    do ***REMOVED*** ch = state.input.charCodeAt(++state.position); ***REMOVED***
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) ***REMOVED***
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    ***REMOVED*** else ***REMOVED***
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    while (ch !== 0 && !is_WS_OR_EOL(ch)) ***REMOVED***

      if (ch === 0x21/* ! */) ***REMOVED***
        if (!isNamed) ***REMOVED***
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) ***REMOVED***
            throwError(state, 'named tag handle cannot contain such characters');
          ***REMOVED***

          isNamed = true;
          _position = state.position + 1;
        ***REMOVED*** else ***REMOVED***
          throwError(state, 'tag suffix cannot contain exclamation marks');
        ***REMOVED***
      ***REMOVED***

      ch = state.input.charCodeAt(++state.position);
    ***REMOVED***

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) ***REMOVED***
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    ***REMOVED***
  ***REMOVED***

  if (tagName && !PATTERN_TAG_URI.test(tagName)) ***REMOVED***
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  ***REMOVED***

  if (isVerbatim) ***REMOVED***
    state.tag = tagName;

  ***REMOVED*** else if (_hasOwnProperty.call(state.tagMap, tagHandle)) ***REMOVED***
    state.tag = state.tagMap[tagHandle] + tagName;

  ***REMOVED*** else if (tagHandle === '!') ***REMOVED***
    state.tag = '!' + tagName;

  ***REMOVED*** else if (tagHandle === '!!') ***REMOVED***
    state.tag = 'tag:yaml.org,2002:' + tagName;

  ***REMOVED*** else ***REMOVED***
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  ***REMOVED***

  return true;
***REMOVED***

function readAnchorProperty(state) ***REMOVED***
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) ***REMOVED***
    throwError(state, 'duplication of an anchor property');
  ***REMOVED***

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) ***REMOVED***
    ch = state.input.charCodeAt(++state.position);
  ***REMOVED***

  if (state.position === _position) ***REMOVED***
    throwError(state, 'name of an anchor node must contain at least one character');
  ***REMOVED***

  state.anchor = state.input.slice(_position, state.position);
  return true;
***REMOVED***

function readAlias(state) ***REMOVED***
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) ***REMOVED***
    ch = state.input.charCodeAt(++state.position);
  ***REMOVED***

  if (state.position === _position) ***REMOVED***
    throwError(state, 'name of an alias node must contain at least one character');
  ***REMOVED***

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) ***REMOVED***
    throwError(state, 'unidentified alias "' + alias + '"');
  ***REMOVED***

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
***REMOVED***

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) ***REMOVED***
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) ***REMOVED***
    state.listener('open', state);
  ***REMOVED***

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) ***REMOVED***
    if (skipSeparationSpace(state, true, -1)) ***REMOVED***
      atNewLine = true;

      if (state.lineIndent > parentIndent) ***REMOVED***
        indentStatus = 1;
      ***REMOVED*** else if (state.lineIndent === parentIndent) ***REMOVED***
        indentStatus = 0;
      ***REMOVED*** else if (state.lineIndent < parentIndent) ***REMOVED***
        indentStatus = -1;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  if (indentStatus === 1) ***REMOVED***
    while (readTagProperty(state) || readAnchorProperty(state)) ***REMOVED***
      if (skipSeparationSpace(state, true, -1)) ***REMOVED***
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) ***REMOVED***
          indentStatus = 1;
        ***REMOVED*** else if (state.lineIndent === parentIndent) ***REMOVED***
          indentStatus = 0;
        ***REMOVED*** else if (state.lineIndent < parentIndent) ***REMOVED***
          indentStatus = -1;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        allowBlockCollections = false;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  if (allowBlockCollections) ***REMOVED***
    allowBlockCollections = atNewLine || allowCompact;
  ***REMOVED***

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) ***REMOVED***
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) ***REMOVED***
      flowIndent = parentIndent;
    ***REMOVED*** else ***REMOVED***
      flowIndent = parentIndent + 1;
    ***REMOVED***

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) ***REMOVED***
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) ***REMOVED***
        hasContent = true;
      ***REMOVED*** else ***REMOVED***
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) ***REMOVED***
          hasContent = true;

        ***REMOVED*** else if (readAlias(state)) ***REMOVED***
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) ***REMOVED***
            throwError(state, 'alias node should not have any properties');
          ***REMOVED***

        ***REMOVED*** else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) ***REMOVED***
          hasContent = true;

          if (state.tag === null) ***REMOVED***
            state.tag = '?';
          ***REMOVED***
        ***REMOVED***

        if (state.anchor !== null) ***REMOVED***
          state.anchorMap[state.anchor] = state.result;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if (indentStatus === 0) ***REMOVED***
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    ***REMOVED***
  ***REMOVED***

  if (state.tag !== null && state.tag !== '!') ***REMOVED***
    if (state.tag === '?') ***REMOVED***
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) ***REMOVED***
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) ***REMOVED*** // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) ***REMOVED***
            state.anchorMap[state.anchor] = state.result;
          ***REMOVED***
          break;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) ***REMOVED***
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) ***REMOVED***
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      ***REMOVED***

      if (!type.resolve(state.result)) ***REMOVED*** // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      ***REMOVED*** else ***REMOVED***
        state.result = type.construct(state.result);
        if (state.anchor !== null) ***REMOVED***
          state.anchorMap[state.anchor] = state.result;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      throwError(state, 'unknown tag !<' + state.tag + '>');
    ***REMOVED***
  ***REMOVED***

  if (state.listener !== null) ***REMOVED***
    state.listener('close', state);
  ***REMOVED***
  return state.tag !== null ||  state.anchor !== null || hasContent;
***REMOVED***

function readDocument(state) ***REMOVED***
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = ***REMOVED******REMOVED***;
  state.anchorMap = ***REMOVED******REMOVED***;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) ***REMOVED***
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) ***REMOVED***
      break;
    ***REMOVED***

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) ***REMOVED***
      ch = state.input.charCodeAt(++state.position);
    ***REMOVED***

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) ***REMOVED***
      throwError(state, 'directive name must not be less than one character in length');
    ***REMOVED***

    while (ch !== 0) ***REMOVED***
      while (is_WHITE_SPACE(ch)) ***REMOVED***
        ch = state.input.charCodeAt(++state.position);
      ***REMOVED***

      if (ch === 0x23/* # */) ***REMOVED***
        do ***REMOVED*** ch = state.input.charCodeAt(++state.position); ***REMOVED***
        while (ch !== 0 && !is_EOL(ch));
        break;
      ***REMOVED***

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) ***REMOVED***
        ch = state.input.charCodeAt(++state.position);
      ***REMOVED***

      directiveArgs.push(state.input.slice(_position, state.position));
    ***REMOVED***

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) ***REMOVED***
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    ***REMOVED*** else ***REMOVED***
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    ***REMOVED***
  ***REMOVED***

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) ***REMOVED***
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  ***REMOVED*** else if (hasDirectives) ***REMOVED***
    throwError(state, 'directives end mark is expected');
  ***REMOVED***

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) ***REMOVED***
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  ***REMOVED***

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) ***REMOVED***

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) ***REMOVED***
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    ***REMOVED***
    return;
  ***REMOVED***

  if (state.position < (state.length - 1)) ***REMOVED***
    throwError(state, 'end of the stream or a document separator is expected');
  ***REMOVED*** else ***REMOVED***
    return;
  ***REMOVED***
***REMOVED***


function loadDocuments(input, options) ***REMOVED***
  input = String(input);
  options = options || ***REMOVED******REMOVED***;

  if (input.length !== 0) ***REMOVED***

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) ***REMOVED***
      input += '\n';
    ***REMOVED***

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) ***REMOVED***
      input = input.slice(1);
    ***REMOVED***
  ***REMOVED***

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) ***REMOVED***
    state.lineIndent += 1;
    state.position += 1;
  ***REMOVED***

  while (state.position < (state.length - 1)) ***REMOVED***
    readDocument(state);
  ***REMOVED***

  return state.documents;
***REMOVED***


function loadAll$1(input, iterator, options) ***REMOVED***
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') ***REMOVED***
    return documents;
  ***REMOVED***

  for (index = 0, length = documents.length; index < length; index += 1) ***REMOVED***
    iterator(documents[index]);
  ***REMOVED***
***REMOVED***


function load$1(input, options) ***REMOVED***
  var documents = loadDocuments(input, options);

  if (documents.length === 0) ***REMOVED***
    /*eslint-disable no-undefined*/
    return undefined;
  ***REMOVED*** else if (documents.length === 1) ***REMOVED***
    return documents[0];
  ***REMOVED***
  throw new exception('expected a single document in the stream, but found more');
***REMOVED***


function safeLoadAll$1(input, output, options) ***REMOVED***
  if (typeof output === 'function') ***REMOVED***
    loadAll$1(input, output, common.extend(***REMOVED*** schema: default_safe ***REMOVED***, options));
  ***REMOVED*** else ***REMOVED***
    return loadAll$1(input, common.extend(***REMOVED*** schema: default_safe ***REMOVED***, options));
  ***REMOVED***
***REMOVED***


function safeLoad$1(input, options) ***REMOVED***
  return load$1(input, common.extend(***REMOVED*** schema: default_safe ***REMOVED***, options));
***REMOVED***


var loadAll_1     = loadAll$1;
var load_1        = load$1;
var safeLoadAll_1 = safeLoadAll$1;
var safeLoad_1    = safeLoad$1;

var loader = ***REMOVED***
	loadAll: loadAll_1,
	load: load_1,
	safeLoadAll: safeLoadAll_1,
	safeLoad: safeLoad_1
***REMOVED***;

/*eslint-disable no-use-before-define*/






var _toString$2       = Object.prototype.toString;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* ***REMOVED*** */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* ***REMOVED*** */

var ESCAPE_SEQUENCES = ***REMOVED******REMOVED***;

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) ***REMOVED***
  var result, keys, index, length, tag, style, type;

  if (map === null) return ***REMOVED******REMOVED***;

  result = ***REMOVED******REMOVED***;
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) ***REMOVED***
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') ***REMOVED***
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    ***REMOVED***
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty$3.call(type.styleAliases, style)) ***REMOVED***
      style = type.styleAliases[style];
    ***REMOVED***

    result[tag] = style;
  ***REMOVED***

  return result;
***REMOVED***

function encodeHex(character) ***REMOVED***
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) ***REMOVED***
    handle = 'x';
    length = 2;
  ***REMOVED*** else if (character <= 0xFFFF) ***REMOVED***
    handle = 'u';
    length = 4;
  ***REMOVED*** else if (character <= 0xFFFFFFFF) ***REMOVED***
    handle = 'U';
    length = 8;
  ***REMOVED*** else ***REMOVED***
    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
  ***REMOVED***

  return '\\' + handle + common.repeat('0', length - string.length) + string;
***REMOVED***

function State$1(options) ***REMOVED***
  this.schema       = options['schema'] || default_full;
  this.indent       = Math.max(1, (options['indent'] || 2));
  this.skipInvalid  = options['skipInvalid'] || false;
  this.flowLevel    = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap     = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys     = options['sortKeys'] || false;
  this.lineWidth    = options['lineWidth'] || 80;
  this.noRefs       = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
***REMOVED***

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) ***REMOVED***
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) ***REMOVED***
    next = string.indexOf('\n', position);
    if (next === -1) ***REMOVED***
      line = string.slice(position);
      position = length;
    ***REMOVED*** else ***REMOVED***
      line = string.slice(position, next + 1);
      position = next + 1;
    ***REMOVED***

    if (line.length && line !== '\n') result += ind;

    result += line;
  ***REMOVED***

  return result;
***REMOVED***

function generateNextLine(state, level) ***REMOVED***
  return '\n' + common.repeat(' ', state.indent * level);
***REMOVED***

function testImplicitResolving(state, str) ***REMOVED***
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) ***REMOVED***
    type = state.implicitTypes[index];

    if (type.resolve(str)) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) ***REMOVED***
  return c === CHAR_SPACE || c === CHAR_TAB;
***REMOVED***

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) ***REMOVED***
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
***REMOVED***

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) ***REMOVED***
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
***REMOVED***

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) ***REMOVED***
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “***REMOVED***” | “***REMOVED***”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
***REMOVED***

var STYLE_PLAIN   = 1;
var STYLE_SINGLE  = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED  = 4;
var STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) ***REMOVED***
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) ***REMOVED***
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) ***REMOVED***
      char = string.charCodeAt(i);
      if (!isPrintable(char)) ***REMOVED***
        return STYLE_DOUBLE;
      ***REMOVED***
      plain = plain && isPlainSafe(char);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) ***REMOVED***
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) ***REMOVED***
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) ***REMOVED***
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        ***REMOVED***
      ***REMOVED*** else if (!isPrintable(char)) ***REMOVED***
        return STYLE_DOUBLE;
      ***REMOVED***
      plain = plain && isPlainSafe(char);
    ***REMOVED***
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  ***REMOVED***
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) ***REMOVED***
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  ***REMOVED***
  // Edge case: block indentation indicator can only have one digit.
  if (string[0] === ' ' && indentPerLevel > 9) ***REMOVED***
    return STYLE_DOUBLE;
  ***REMOVED***
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
***REMOVED***

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) ***REMOVED***
  state.dump = (function () ***REMOVED***
    if (string.length === 0) ***REMOVED***
      return "''";
    ***REMOVED***
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) ***REMOVED***
      return "'" + string + "'";
    ***REMOVED***

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) ***REMOVED***
      return testImplicitResolving(state, string);
    ***REMOVED***

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) ***REMOVED***
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new exception('impossible error: invalid scalar style');
    ***REMOVED***
  ***REMOVED***());
***REMOVED***

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) ***REMOVED***
  var indentIndicator = (string[0] === ' ') ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
***REMOVED***

// (See the note for writeScalar.)
function dropEndingNewline(string) ***REMOVED***
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
***REMOVED***

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) ***REMOVED***
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () ***REMOVED***
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  ***REMOVED***());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) ***REMOVED***
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  ***REMOVED***

  return result;
***REMOVED***

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) ***REMOVED***
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) ***REMOVED***
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) ***REMOVED***
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    ***REMOVED***
    curr = next;
  ***REMOVED***

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) ***REMOVED***
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  ***REMOVED*** else ***REMOVED***
    result += line.slice(start);
  ***REMOVED***

  return result.slice(1); // drop extra \n joiner
***REMOVED***

// Escapes a double-quoted string.
function escapeString(string) ***REMOVED***
  var result = '';
  var char;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) ***REMOVED***
    char = string.charCodeAt(i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  ***REMOVED***

  return result;
***REMOVED***

function writeFlowSequence(state, level, object) ***REMOVED***
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) ***REMOVED***
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) ***REMOVED***
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    ***REMOVED***
  ***REMOVED***

  state.tag = _tag;
  state.dump = '[' + _result + ']';
***REMOVED***

function writeBlockSequence(state, level, object, compact) ***REMOVED***
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) ***REMOVED***
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) ***REMOVED***
      if (!compact || index !== 0) ***REMOVED***
        _result += generateNextLine(state, level);
      ***REMOVED***

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) ***REMOVED***
        _result += '-';
      ***REMOVED*** else ***REMOVED***
        _result += '- ';
      ***REMOVED***

      _result += state.dump;
    ***REMOVED***
  ***REMOVED***

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
***REMOVED***

function writeFlowMapping(state, level, object) ***REMOVED***
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) ***REMOVED***
    pairBuffer = '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) ***REMOVED***
      continue; // Skip this pair because of invalid key;
    ***REMOVED***

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) ***REMOVED***
      continue; // Skip this pair because of invalid value.
    ***REMOVED***

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  ***REMOVED***

  state.tag = _tag;
  state.dump = '***REMOVED***' + _result + '***REMOVED***';
***REMOVED***

function writeBlockMapping(state, level, object, compact) ***REMOVED***
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) ***REMOVED***
    // Default sorting
    objectKeyList.sort();
  ***REMOVED*** else if (typeof state.sortKeys === 'function') ***REMOVED***
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  ***REMOVED*** else if (state.sortKeys) ***REMOVED***
    // Something is wrong
    throw new exception('sortKeys must be a boolean or a function');
  ***REMOVED***

  for (index = 0, length = objectKeyList.length; index < length; index += 1) ***REMOVED***
    pairBuffer = '';

    if (!compact || index !== 0) ***REMOVED***
      pairBuffer += generateNextLine(state, level);
    ***REMOVED***

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) ***REMOVED***
      continue; // Skip this pair because of invalid key.
    ***REMOVED***

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) ***REMOVED***
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) ***REMOVED***
        pairBuffer += '?';
      ***REMOVED*** else ***REMOVED***
        pairBuffer += '? ';
      ***REMOVED***
    ***REMOVED***

    pairBuffer += state.dump;

    if (explicitPair) ***REMOVED***
      pairBuffer += generateNextLine(state, level);
    ***REMOVED***

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) ***REMOVED***
      continue; // Skip this pair because of invalid value.
    ***REMOVED***

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) ***REMOVED***
      pairBuffer += ':';
    ***REMOVED*** else ***REMOVED***
      pairBuffer += ': ';
    ***REMOVED***

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  ***REMOVED***

  state.tag = _tag;
  state.dump = _result || '***REMOVED******REMOVED***'; // Empty mapping if no valid pairs.
***REMOVED***

function detectType(state, object, explicit) ***REMOVED***
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) ***REMOVED***
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) ***REMOVED***

      state.tag = explicit ? type.tag : '?';

      if (type.represent) ***REMOVED***
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString$2.call(type.represent) === '[object Function]') ***REMOVED***
          _result = type.represent(object, style);
        ***REMOVED*** else if (_hasOwnProperty$3.call(type.represent, style)) ***REMOVED***
          _result = type.represent[style](object, style);
        ***REMOVED*** else ***REMOVED***
          throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        ***REMOVED***

        state.dump = _result;
      ***REMOVED***

      return true;
    ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) ***REMOVED***
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) ***REMOVED***
    detectType(state, object, true);
  ***REMOVED***

  var type = _toString$2.call(state.dump);

  if (block) ***REMOVED***
    block = (state.flowLevel < 0 || state.flowLevel > level);
  ***REMOVED***

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) ***REMOVED***
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  ***REMOVED***

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) ***REMOVED***
    compact = false;
  ***REMOVED***

  if (duplicate && state.usedDuplicates[duplicateIndex]) ***REMOVED***
    state.dump = '*ref_' + duplicateIndex;
  ***REMOVED*** else ***REMOVED***
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) ***REMOVED***
      state.usedDuplicates[duplicateIndex] = true;
    ***REMOVED***
    if (type === '[object Object]') ***REMOVED***
      if (block && (Object.keys(state.dump).length !== 0)) ***REMOVED***
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) ***REMOVED***
          state.dump = '&ref_' + duplicateIndex + state.dump;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        writeFlowMapping(state, level, state.dump);
        if (duplicate) ***REMOVED***
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if (type === '[object Array]') ***REMOVED***
      if (block && (state.dump.length !== 0)) ***REMOVED***
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) ***REMOVED***
          state.dump = '&ref_' + duplicateIndex + state.dump;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        writeFlowSequence(state, level, state.dump);
        if (duplicate) ***REMOVED***
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if (type === '[object String]') ***REMOVED***
      if (state.tag !== '?') ***REMOVED***
        writeScalar(state, state.dump, level, iskey);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (state.skipInvalid) return false;
      throw new exception('unacceptable kind of an object to dump ' + type);
    ***REMOVED***

    if (state.tag !== null && state.tag !== '?') ***REMOVED***
      state.dump = '!<' + state.tag + '> ' + state.dump;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***

function getDuplicateReferences(object, state) ***REMOVED***
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) ***REMOVED***
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  ***REMOVED***
  state.usedDuplicates = new Array(length);
***REMOVED***

function inspectNode(object, objects, duplicatesIndexes) ***REMOVED***
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') ***REMOVED***
    index = objects.indexOf(object);
    if (index !== -1) ***REMOVED***
      if (duplicatesIndexes.indexOf(index) === -1) ***REMOVED***
        duplicatesIndexes.push(index);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      objects.push(object);

      if (Array.isArray(object)) ***REMOVED***
        for (index = 0, length = object.length; index < length; index += 1) ***REMOVED***
          inspectNode(object[index], objects, duplicatesIndexes);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) ***REMOVED***
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function dump$1(input, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  var state = new State$1(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
***REMOVED***

function safeDump$1(input, options) ***REMOVED***
  return dump$1(input, common.extend(***REMOVED*** schema: default_safe ***REMOVED***, options));
***REMOVED***

var dump_1     = dump$1;
var safeDump_1 = safeDump$1;

var dumper = ***REMOVED***
	dump: dump_1,
	safeDump: safeDump_1
***REMOVED***;

function deprecated(name) ***REMOVED***
  return function () ***REMOVED***
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  ***REMOVED***;
***REMOVED***


var Type                = type;
var Schema              = schema;
var FAILSAFE_SCHEMA     = failsafe;
var JSON_SCHEMA         = json;
var CORE_SCHEMA         = core;
var DEFAULT_SAFE_SCHEMA = default_safe;
var DEFAULT_FULL_SCHEMA = default_full;
var load                = loader.load;
var loadAll             = loader.loadAll;
var safeLoad            = loader.safeLoad;
var safeLoadAll         = loader.safeLoadAll;
var dump                = dumper.dump;
var safeDump            = dumper.safeDump;
var YAMLException       = exception;

// Deprecated schema names from JS-YAML 2.0.x
var MINIMAL_SCHEMA = failsafe;
var SAFE_SCHEMA    = default_safe;
var DEFAULT_SCHEMA = default_full;

// Deprecated functions from JS-YAML 1.x.x
var scan           = deprecated('scan');
var parse          = deprecated('parse');
var compose        = deprecated('compose');
var addConstructor = deprecated('addConstructor');

var jsYaml$2 = ***REMOVED***
	Type: Type,
	Schema: Schema,
	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
	JSON_SCHEMA: JSON_SCHEMA,
	CORE_SCHEMA: CORE_SCHEMA,
	DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,
	DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,
	load: load,
	loadAll: loadAll,
	safeLoad: safeLoad,
	safeLoadAll: safeLoadAll,
	dump: dump,
	safeDump: safeDump,
	YAMLException: YAMLException,
	MINIMAL_SCHEMA: MINIMAL_SCHEMA,
	SAFE_SCHEMA: SAFE_SCHEMA,
	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
	scan: scan,
	parse: parse,
	compose: compose,
	addConstructor: addConstructor
***REMOVED***;

var jsYaml = jsYaml$2;

var requireFromString = createCommonjsModule(function (module) ***REMOVED***
'use strict';




module.exports = function requireFromString(code, filename, opts) ***REMOVED***
	if (typeof filename === 'object') ***REMOVED***
		opts = filename;
		filename = undefined;
	***REMOVED***

	opts = opts || ***REMOVED******REMOVED***;
	filename = filename || '';

	opts.appendPaths = opts.appendPaths || [];
	opts.prependPaths = opts.prependPaths || [];

	if (typeof code !== 'string') ***REMOVED***
		throw new Error('code must be a string, not ' + typeof code);
	***REMOVED***

	var paths = module$1._nodeModulePaths(path.dirname(filename));

	var parent = (module.parent || module);
	var m = new module$1(filename, parent);
	m.filename = filename;
	m.paths = [].concat(opts.prependPaths).concat(paths).concat(opts.appendPaths);
	m._compile(code, filename);

	var exports = m.exports;
	parent.children && parent.children.splice(parent.children.indexOf(m), 1);

	return exports;
***REMOVED***;
***REMOVED***);

//      
const chainFuncsAsync = (result, func) => result.then(func);
const chainFuncsSync = (result, func) => func(result);

/**
 * Runs the given functions sequentially. If the `init` param is a promise,
 * functions are chained using `p.then()`. Otherwise, functions are chained by passing
 * the result of each function to the next.
 */
var funcRunner = function funcRunner(
  init                ,
  funcs                 
)                 ***REMOVED***
  const isAsync = init instanceof Promise;

  return funcs.reduce(
    isAsync === true ? chainFuncsAsync : chainFuncsSync,
    init
  );
***REMOVED***;

var loadRc = function loadRc(
  filepath        ,
  options   
                   
                           
                           
   
)                                                     ***REMOVED***
  if (!options.sync) ***REMOVED***
    return readFile_1(filepath)
      .then(parseExtensionlessRcFile)
      .then(checkExtensionlessRcResult);
  ***REMOVED*** else ***REMOVED***
    return checkExtensionlessRcResult(
      parseExtensionlessRcFile(readFile_1.sync(filepath))
    );
  ***REMOVED***

  function checkExtensionlessRcResult(result) ***REMOVED***
    if (result) return result;
    if (options.rcExtensions) return loadRcWithExtensions();
    return null;
  ***REMOVED***

  function parseExtensionlessRcFile(content         )                      ***REMOVED***
    if (!content) return null;
    const pasedConfig = options.rcStrictJson
      ? parseJson_1(content, filepath)
      : jsYaml.safeLoad(content, ***REMOVED*** filename: filepath ***REMOVED***);
    return ***REMOVED***
      config: pasedConfig,
      filepath,
    ***REMOVED***;
  ***REMOVED***

  function loadRcWithExtensions() ***REMOVED***
    let foundConfig = null;
    return funcRunner(readRcFile('json'), [
      (jsonContent         ) => ***REMOVED***
        // Since this is the first try, config cannot have been found, so don't
        // check `if (foundConfig)`.
        if (jsonContent) ***REMOVED***
          const successFilepath = `$***REMOVED***filepath***REMOVED***.json`;
          foundConfig = ***REMOVED***
            config: parseJson_1(jsonContent, successFilepath),
            filepath: successFilepath,
          ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
          return readRcFile('yaml');
        ***REMOVED***
      ***REMOVED***,
      (yamlContent         ) => ***REMOVED***
        if (foundConfig) ***REMOVED***
          return;
        ***REMOVED*** else if (yamlContent) ***REMOVED***
          const successFilepath = `$***REMOVED***filepath***REMOVED***.yaml`;
          foundConfig = ***REMOVED***
            config: jsYaml.safeLoad(yamlContent, ***REMOVED*** filename: successFilepath ***REMOVED***),
            filepath: successFilepath,
          ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
          return readRcFile('yml');
        ***REMOVED***
      ***REMOVED***,
      (ymlContent         ) => ***REMOVED***
        if (foundConfig) ***REMOVED***
          return;
        ***REMOVED*** else if (ymlContent) ***REMOVED***
          const successFilepath = `$***REMOVED***filepath***REMOVED***.yml`;
          foundConfig = ***REMOVED***
            config: jsYaml.safeLoad(ymlContent, ***REMOVED*** filename: successFilepath ***REMOVED***),
            filepath: successFilepath,
          ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
          return readRcFile('js');
        ***REMOVED***
      ***REMOVED***,
      (jsContent         ) => ***REMOVED***
        if (foundConfig) ***REMOVED***
          return;
        ***REMOVED*** else if (jsContent) ***REMOVED***
          const successFilepath = `$***REMOVED***filepath***REMOVED***.js`;
          foundConfig = ***REMOVED***
            config: requireFromString(jsContent, successFilepath),
            filepath: successFilepath,
          ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
          return;
        ***REMOVED***
      ***REMOVED***,
      () => foundConfig,
    ]);
  ***REMOVED***

  function readRcFile(extension        )                             ***REMOVED***
    const filepathWithExtension = `$***REMOVED***filepath***REMOVED***.$***REMOVED***extension***REMOVED***`;
    return !options.sync
      ? readFile_1(filepathWithExtension)
      : readFile_1.sync(filepathWithExtension);
  ***REMOVED***
***REMOVED***;

var loadJs = function loadJs(
  filepath        ,
  options                    
)                                                     ***REMOVED***
  function parseJsFile(content         )                      ***REMOVED***
    if (!content) return null;

    return ***REMOVED***
      config: requireFromString(content, filepath),
      filepath,
    ***REMOVED***;
  ***REMOVED***

  return !options.sync
    ? readFile_1(filepath).then(parseJsFile)
    : parseJsFile(readFile_1.sync(filepath));
***REMOVED***;

var loadDefinedFile = function loadDefinedFile(
  filepath        ,
  options   
                   
                                    
   
)                                                     ***REMOVED***
  function parseContent(content         )                      ***REMOVED***
    if (!content) ***REMOVED***
      throw new Error(`Config file is empty! Filepath - "$***REMOVED***filepath***REMOVED***".`);
    ***REMOVED***

    let parsedConfig;

    switch (options.format || inferFormat(filepath)) ***REMOVED***
      case 'json':
        parsedConfig = parseJson_1(content, filepath);
        break;
      case 'yaml':
        parsedConfig = jsYaml.safeLoad(content, ***REMOVED***
          filename: filepath,
        ***REMOVED***);
        break;
      case 'js':
        parsedConfig = requireFromString(content, filepath);
        break;
      default:
        parsedConfig = tryAllParsing(content, filepath);
    ***REMOVED***

    if (!parsedConfig) ***REMOVED***
      throw new Error(`Failed to parse "$***REMOVED***filepath***REMOVED***" as JSON, JS, or YAML.`);
    ***REMOVED***

    return ***REMOVED***
      config: parsedConfig,
      filepath,
    ***REMOVED***;
  ***REMOVED***

  return !options.sync
    ? readFile_1(filepath, ***REMOVED*** throwNotFound: true ***REMOVED***).then(parseContent)
    : parseContent(readFile_1.sync(filepath, ***REMOVED*** throwNotFound: true ***REMOVED***));
***REMOVED***;

function inferFormat(filepath        )          ***REMOVED***
  switch (path.extname(filepath)) ***REMOVED***
    case '.js':
      return 'js';
    case '.json':
      return 'json';
    // istanbul ignore next
    case '.yml':
    case '.yaml':
      return 'yaml';
    default:
      return undefined;
  ***REMOVED***
***REMOVED***

function tryAllParsing(content        , filepath        )          ***REMOVED***
  return tryYaml(content, filepath, () => ***REMOVED***
    return tryRequire(content, filepath, () => ***REMOVED***
      return null;
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

function tryYaml(content        , filepath        , cb               ) ***REMOVED***
  try ***REMOVED***
    const result = jsYaml.safeLoad(content, ***REMOVED***
      filename: filepath,
    ***REMOVED***);
    if (typeof result === 'string') ***REMOVED***
      return cb();
    ***REMOVED***
    return result;
  ***REMOVED*** catch (e) ***REMOVED***
    return cb();
  ***REMOVED***
***REMOVED***

function tryRequire(content        , filepath        , cb               ) ***REMOVED***
  try ***REMOVED***
    return requireFromString(content, filepath);
  ***REMOVED*** catch (e) ***REMOVED***
    return cb();
  ***REMOVED***
***REMOVED***

/**
 * async
 */

function isDirectory(filepath, cb) ***REMOVED***
  if (typeof cb !== 'function') ***REMOVED***
    throw new Error('expected a callback function');
  ***REMOVED***

  if (typeof filepath !== 'string') ***REMOVED***
    cb(new Error('expected filepath to be a string'));
    return;
  ***REMOVED***

  fs.stat(filepath, function(err, stats) ***REMOVED***
    if (err) ***REMOVED***
      if (err.code === 'ENOENT') ***REMOVED***
        cb(null, false);
        return;
      ***REMOVED***
      cb(err);
      return;
    ***REMOVED***
    cb(null, stats.isDirectory());
  ***REMOVED***);
***REMOVED***

/**
 * sync
 */

isDirectory.sync = function isDirectorySync(filepath) ***REMOVED***
  if (typeof filepath !== 'string') ***REMOVED***
    throw new Error('expected filepath to be a string');
  ***REMOVED***

  try ***REMOVED***
    var stat = fs.statSync(filepath);
    return stat.isDirectory();
  ***REMOVED*** catch (err) ***REMOVED***
    if (err.code === 'ENOENT') ***REMOVED***
      return false;
    ***REMOVED*** else ***REMOVED***
      throw err;
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Expose `isDirectory`
 */

var isDirectory_1 = isDirectory;

var getDirectory = function getDirectory(
  filepath        ,
  sync          
)                           ***REMOVED***
  if (sync === true) ***REMOVED***
    return isDirectory_1.sync(filepath) ? filepath : path.dirname(filepath);
  ***REMOVED***

  return new Promise((resolve, reject) => ***REMOVED***
    return isDirectory_1(filepath, (err, filepathIsDirectory) => ***REMOVED***
      if (err) ***REMOVED***
        return reject(err);
      ***REMOVED***
      return resolve(filepathIsDirectory ? filepath : path.dirname(filepath));
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var createExplorer = function createExplorer(options   
                               
                      
                      
                                  
                         
                         
                   
                  
                 
                                   
                      
 ) ***REMOVED***
  // When `options.sync` is `false` (default),
  // these cache Promises that resolve with results, not the results themselves.
  const fileCache = options.cache ? new Map() : null;
  const directoryCache = options.cache ? new Map() : null;
  const transform = options.transform || identity;
  const packageProp = options.packageProp;

  function clearFileCache() ***REMOVED***
    if (fileCache) fileCache.clear();
  ***REMOVED***

  function clearDirectoryCache() ***REMOVED***
    if (directoryCache) directoryCache.clear();
  ***REMOVED***

  function clearCaches() ***REMOVED***
    clearFileCache();
    clearDirectoryCache();
  ***REMOVED***

  function throwError(error) ***REMOVED***
    if (options.sync) ***REMOVED***
      throw error;
    ***REMOVED*** else ***REMOVED***
      return Promise.reject(error);
    ***REMOVED***
  ***REMOVED***

  function load(
    searchPath        ,
    configPath         
  )                                                     ***REMOVED***
    if (!configPath && options.configPath) ***REMOVED***
      configPath = options.configPath;
    ***REMOVED***

    if (configPath) ***REMOVED***
      const absoluteConfigPath = path.resolve(process.cwd(), configPath);
      if (fileCache && fileCache.has(absoluteConfigPath)) ***REMOVED***
        return fileCache.get(absoluteConfigPath);
      ***REMOVED***

      let load;
      if (path.basename(absoluteConfigPath) === 'package.json') ***REMOVED***
        if (!packageProp) ***REMOVED***
          return throwError(
            new Error(
              'Please specify the packageProp option. The configPath argument cannot point to a package.json file if packageProp is false.'
            )
          );
        ***REMOVED***
        load = () =>
          loadPackageProp(path.dirname(absoluteConfigPath), ***REMOVED***
            packageProp,
            sync: options.sync,
          ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        load = () =>
          loadDefinedFile(absoluteConfigPath, ***REMOVED***
            sync: options.sync,
            format: options.format,
          ***REMOVED***);
      ***REMOVED***

      const loadResult = load();
      const result =
        loadResult instanceof Promise
          ? loadResult.then(transform)
          : transform(loadResult);
      if (fileCache) fileCache.set(absoluteConfigPath, result);
      return result;
    ***REMOVED***

    if (!searchPath) return !options.sync ? Promise.resolve(null) : null;

    const absoluteSearchPath = path.resolve(process.cwd(), searchPath);
    const searchPathDir = getDirectory(absoluteSearchPath, options.sync);

    return searchPathDir instanceof Promise
      ? searchPathDir.then(searchDirectory)
      : searchDirectory(searchPathDir);
  ***REMOVED***

  function searchDirectory(
    directory        
  )                                                     ***REMOVED***
    if (directoryCache && directoryCache.has(directory)) ***REMOVED***
      return directoryCache.get(directory);
    ***REMOVED***

    const result = funcRunner(!options.sync ? Promise.resolve() : undefined, [
      () => ***REMOVED***
        if (!packageProp) return;
        return loadPackageProp(directory, ***REMOVED***
          packageProp,
          sync: options.sync,
        ***REMOVED***);
      ***REMOVED***,
      result => ***REMOVED***
        if (result || !options.rc) return result;
        return loadRc(path.join(directory, options.rc), ***REMOVED***
          sync: options.sync,
          rcStrictJson: options.rcStrictJson,
          rcExtensions: options.rcExtensions,
        ***REMOVED***);
      ***REMOVED***,
      result => ***REMOVED***
        if (result || !options.js) return result;
        return loadJs(path.join(directory, options.js), ***REMOVED*** sync: options.sync ***REMOVED***);
      ***REMOVED***,
      result => ***REMOVED***
        if (result) return result;

        const nextDirectory = path.dirname(directory);

        if (nextDirectory === directory || directory === options.stopDir)
          return null;

        return searchDirectory(nextDirectory);
      ***REMOVED***,
      transform,
    ]);

    if (directoryCache) directoryCache.set(directory, result);
    return result;
  ***REMOVED***

  return ***REMOVED***
    load,
    clearFileCache,
    clearDirectoryCache,
    clearCaches,
  ***REMOVED***;
***REMOVED***;

function identity(x) ***REMOVED***
  return x;
***REMOVED***

const homedir = os.homedir();

var dist = function cosmiconfig(
  moduleName        ,
  options   
                                 
                        
                        
                                    
                           
                           
                     
                    
                   
                                     
                        
   
) ***REMOVED***
  options = Object.assign(
    ***REMOVED******REMOVED***,
    ***REMOVED***
      packageProp: moduleName,
      rc: `.$***REMOVED***moduleName***REMOVED***rc`,
      js: `$***REMOVED***moduleName***REMOVED***.config.js`,
      rcStrictJson: false,
      stopDir: homedir,
      cache: true,
      sync: false,
    ***REMOVED***,
    options
  );

  return createExplorer(options);
***REMOVED***;

var thirdParty = ***REMOVED***
  getStream: getStream_1,
  cosmiconfig: dist
***REMOVED***;

module.exports = thirdParty;
