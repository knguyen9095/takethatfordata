/*!
 * fragment-cache <https://github.com/jonschlinkert/fragment-cache>
 *
 * Copyright (c) 2016-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var MapCache = require('map-cache');

/**
 * Create a new `FragmentCache` with an optional object to use for `caches`.
 *
 * ```js
 * var fragment = new FragmentCache();
 * ```
 * @name FragmentCache
 * @param ***REMOVED***String***REMOVED*** `cacheName`
 * @return ***REMOVED***Object***REMOVED*** Returns the [map-cache][] instance.
 * @api public
 */

function FragmentCache(caches) ***REMOVED***
  this.caches = caches || ***REMOVED******REMOVED***;
***REMOVED***

/**
 * Prototype
 */

FragmentCache.prototype = ***REMOVED***

  /**
   * Get cache `name` from the `fragment.caches` object. Creates a new
   * `MapCache` if it doesn't already exist.
   *
   * ```js
   * var cache = fragment.cache('files');
   * console.log(fragment.caches.hasOwnProperty('files'));
   * //=> true
   * ```
   * @name .cache
   * @param ***REMOVED***String***REMOVED*** `cacheName`
   * @return ***REMOVED***Object***REMOVED*** Returns the [map-cache][] instance.
   * @api public
   */

  cache: function(cacheName) ***REMOVED***
    return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());
  ***REMOVED***,

  /**
   * Set a value for property `key` on cache `name`
   *
   * ```js
   * fragment.set('files', 'somefile.js', new File(***REMOVED***path: 'somefile.js'***REMOVED***));
   * ```
   * @name .set
   * @param ***REMOVED***String***REMOVED*** `name`
   * @param ***REMOVED***String***REMOVED*** `key` Property name to set
   * @param ***REMOVED***any***REMOVED*** `val` The value of `key`
   * @return ***REMOVED***Object***REMOVED*** The cache instance for chaining
   * @api public
   */

  set: function(cacheName, key, val) ***REMOVED***
    var cache = this.cache(cacheName);
    cache.set(key, val);
    return cache;
  ***REMOVED***,

  /**
   * Returns true if a non-undefined value is set for `key` on fragment cache `name`.
   *
   * ```js
   * var cache = fragment.cache('files');
   * cache.set('somefile.js');
   *
   * console.log(cache.has('somefile.js'));
   * //=> true
   *
   * console.log(cache.has('some-other-file.js'));
   * //=> false
   * ```
   * @name .has
   * @param ***REMOVED***String***REMOVED*** `name` Cache name
   * @param ***REMOVED***String***REMOVED*** `key` Optionally specify a property to check for on cache `name`
   * @return ***REMOVED***Boolean***REMOVED***
   * @api public
   */

  has: function(cacheName, key) ***REMOVED***
    return typeof this.get(cacheName, key) !== 'undefined';
  ***REMOVED***,

  /**
   * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,
   * so that cache `name` will be created it doesn't already exist. If `key` is not passed,
   * the entire cache (`name`) is returned.
   *
   * ```js
   * var Vinyl = require('vinyl');
   * var cache = fragment.cache('files');
   * cache.set('somefile.js', new Vinyl(***REMOVED***path: 'somefile.js'***REMOVED***));
   * console.log(cache.get('somefile.js'));
   * //=> <File "somefile.js">
   * ```
   * @name .get
   * @param ***REMOVED***String***REMOVED*** `name`
   * @return ***REMOVED***Object***REMOVED*** Returns cache `name`, or the value of `key` if specified
   * @api public
   */

  get: function(name, key) ***REMOVED***
    var cache = this.cache(name);
    if (typeof key === 'string') ***REMOVED***
      return cache.get(key);
    ***REMOVED***
    return cache;
  ***REMOVED***
***REMOVED***;

/**
 * Expose `FragmentCache`
 */

exports = module.exports = FragmentCache;
