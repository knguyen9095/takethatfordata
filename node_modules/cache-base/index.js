'use strict';

var isObject = require('isobject');
var Emitter = require('component-emitter');
var visit = require('collection-visit');
var toPath = require('to-object-path');
var union = require('union-value');
var del = require('unset-value');
var get = require('get-value');
var has = require('has-value');
var set = require('set-value');

/**
 * Create a `Cache` constructor that when instantiated will
 * store values on the given `prop`.
 *
 * ```js
 * var Cache = require('cache-base').namespace('data');
 * var cache = new Cache();
 *
 * cache.set('foo', 'bar');
 * //=> ***REMOVED***data: ***REMOVED***foo: 'bar'***REMOVED******REMOVED***
 * ```
 * @param ***REMOVED***String***REMOVED*** `prop` The property name to use for storing values.
 * @return ***REMOVED***Function***REMOVED*** Returns a custom `Cache` constructor
 * @api public
 */

function namespace(prop) ***REMOVED***

  /**
   * Create a new `Cache`. Internally the `Cache` constructor is created using
   * the `namespace` function, with `cache` defined as the storage object.
   *
   * ```js
   * var app = new Cache();
   * ```
   * @param ***REMOVED***Object***REMOVED*** `cache` Optionally pass an object to initialize with.
   * @constructor
   * @api public
   */

  function Cache(cache) ***REMOVED***
    if (prop) ***REMOVED***
      this[prop] = ***REMOVED******REMOVED***;
    ***REMOVED***
    if (cache) ***REMOVED***
      this.set(cache);
    ***REMOVED***
  ***REMOVED***

  /**
   * Inherit Emitter
   */

  Emitter(Cache.prototype);

  /**
   * Assign `value` to `key`. Also emits `set` with
   * the key and value.
   *
   * ```js
   * app.on('set', function(key, val) ***REMOVED***
   *   // do something when `set` is emitted
   * ***REMOVED***);
   *
   * app.set(key, value);
   *
   * // also takes an object or array
   * app.set(***REMOVED***name: 'Halle'***REMOVED***);
   * app.set([***REMOVED***foo: 'bar'***REMOVED***, ***REMOVED***baz: 'quux'***REMOVED***]);
   * console.log(app);
   * //=> ***REMOVED***name: 'Halle', foo: 'bar', baz: 'quux'***REMOVED***
   * ```
   *
   * @name .set
   * @emits `set` with `key` and `value` as arguments.
   * @param ***REMOVED***String***REMOVED*** `key`
   * @param ***REMOVED***any***REMOVED*** `value`
   * @return ***REMOVED***Object***REMOVED*** Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.set = function(key, val) ***REMOVED***
    if (Array.isArray(key) && arguments.length === 2) ***REMOVED***
      key = toPath(key);
    ***REMOVED***
    if (isObject(key) || Array.isArray(key)) ***REMOVED***
      this.visit('set', key);
    ***REMOVED*** else ***REMOVED***
      set(prop ? this[prop] : this, key, val);
      this.emit('set', key, val);
    ***REMOVED***
    return this;
  ***REMOVED***;

  /**
   * Union `array` to `key`. Also emits `set` with
   * the key and value.
   *
   * ```js
   * app.union('a.b', ['foo']);
   * app.union('a.b', ['bar']);
   * console.log(app.get('a'));
   * //=> ***REMOVED***b: ['foo', 'bar']***REMOVED***
   * ```
   * @name .union
   * @param ***REMOVED***String***REMOVED*** `key`
   * @param ***REMOVED***any***REMOVED*** `value`
   * @return ***REMOVED***Object***REMOVED*** Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.union = function(key, val) ***REMOVED***
    if (Array.isArray(key) && arguments.length === 2) ***REMOVED***
      key = toPath(key);
    ***REMOVED***
    var ctx = prop ? this[prop] : this;
    union(ctx, key, arrayify(val));
    this.emit('union', val);
    return this;
  ***REMOVED***;

  /**
   * Return the value of `key`. Dot notation may be used
   * to get [nested property values][get-value].
   *
   * ```js
   * app.set('a.b.c', 'd');
   * app.get('a.b');
   * //=> ***REMOVED***c: 'd'***REMOVED***
   *
   * app.get(['a', 'b']);
   * //=> ***REMOVED***c: 'd'***REMOVED***
   * ```
   *
   * @name .get
   * @emits `get` with `key` and `value` as arguments.
   * @param ***REMOVED***String***REMOVED*** `key` The name of the property to get. Dot-notation may be used.
   * @return ***REMOVED***any***REMOVED*** Returns the value of `key`
   * @api public
   */

  Cache.prototype.get = function(key) ***REMOVED***
    key = toPath(arguments);

    var ctx = prop ? this[prop] : this;
    var val = get(ctx, key);

    this.emit('get', key, val);
    return val;
  ***REMOVED***;

  /**
   * Return true if app has a stored value for `key`,
   * false only if value is `undefined`.
   *
   * ```js
   * app.set('foo', 'bar');
   * app.has('foo');
   * //=> true
   * ```
   *
   * @name .has
   * @emits `has` with `key` and true or false as arguments.
   * @param ***REMOVED***String***REMOVED*** `key`
   * @return ***REMOVED***Boolean***REMOVED***
   * @api public
   */

  Cache.prototype.has = function(key) ***REMOVED***
    key = toPath(arguments);

    var ctx = prop ? this[prop] : this;
    var val = get(ctx, key);

    var has = typeof val !== 'undefined';
    this.emit('has', key, has);
    return has;
  ***REMOVED***;

  /**
   * Delete one or more properties from the instance.
   *
   * ```js
   * app.del(); // delete all
   * // or
   * app.del('foo');
   * // or
   * app.del(['foo', 'bar']);
   * ```
   * @name .del
   * @emits `del` with the `key` as the only argument.
   * @param ***REMOVED***String|Array***REMOVED*** `key` Property name or array of property names.
   * @return ***REMOVED***Object***REMOVED*** Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.del = function(key) ***REMOVED***
    if (Array.isArray(key)) ***REMOVED***
      this.visit('del', key);
    ***REMOVED*** else ***REMOVED***
      del(prop ? this[prop] : this, key);
      this.emit('del', key);
    ***REMOVED***
    return this;
  ***REMOVED***;

  /**
   * Reset the entire cache to an empty object.
   *
   * ```js
   * app.clear();
   * ```
   * @api public
   */

  Cache.prototype.clear = function() ***REMOVED***
    if (prop) ***REMOVED***
      this[prop] = ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***;

  /**
   * Visit `method` over the properties in the given object, or map
   * visit over the object-elements in an array.
   *
   * @name .visit
   * @param ***REMOVED***String***REMOVED*** `method` The name of the `base` method to call.
   * @param ***REMOVED***Object|Array***REMOVED*** `val` The object or array to iterate over.
   * @return ***REMOVED***Object***REMOVED*** Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.visit = function(method, val) ***REMOVED***
    visit(this, method, val);
    return this;
  ***REMOVED***;

  return Cache;
***REMOVED***

/**
 * Cast val to an array
 */

function arrayify(val) ***REMOVED***
  return val ? (Array.isArray(val) ? val : [val]) : [];
***REMOVED***

/**
 * Expose `Cache`
 */

module.exports = namespace();

/**
 * Expose `Cache.namespace`
 */

module.exports.namespace = namespace;
