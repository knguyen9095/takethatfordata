!function (name, context, definition) ***REMOVED***
  if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') ***REMOVED***
    module.exports = definition();
  ***REMOVED*** else if (typeof define === 'function' && typeof define.amd  === 'object') ***REMOVED***
    define(function () ***REMOVED***
      return definition();
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    context[name] = definition();
  ***REMOVED***
***REMOVED***('chai', this, function () ***REMOVED***

  function require(p) ***REMOVED***
    var path = require.resolve(p)
      , mod = require.modules[path];
    if (!mod) throw new Error('failed to require "' + p + '"');
    if (!mod.exports) ***REMOVED***
      mod.exports = ***REMOVED******REMOVED***;
      mod.call(mod.exports, mod, mod.exports, require.relative(path));
    ***REMOVED***
    return mod.exports;
  ***REMOVED***

  require.modules = ***REMOVED******REMOVED***;

  require.resolve = function (path) ***REMOVED***
    var orig = path
      , reg = path + '.js'
      , index = path + '/index.js';
    return require.modules[reg] && reg
      || require.modules[index] && index
      || orig;
  ***REMOVED***;

  require.register = function (path, fn) ***REMOVED***
    require.modules[path] = fn;
  ***REMOVED***;

  require.relative = function (parent) ***REMOVED***
    return function(p)***REMOVED***
      if ('.' != p.charAt(0)) return require(p);

      var path = parent.split('/')
        , segs = p.split('/');
      path.pop();

      for (var i = 0; i < segs.length; i++) ***REMOVED***
        var seg = segs[i];
        if ('..' == seg) path.pop();
        else if ('.' != seg) path.push(seg);
      ***REMOVED***

      return require(path.join('/'));
    ***REMOVED***;
  ***REMOVED***;

  require.alias = function (from, to) ***REMOVED***
    var fn = require.modules[from];
    require.modules[to] = fn;
  ***REMOVED***;


  require.register("chai.js", function(module, exports, require)***REMOVED***
    /*!
     * chai
     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    var used = []
      , exports = module.exports = ***REMOVED******REMOVED***;

    /*!
     * Chai version
     */

    exports.version = '1.5.0';

    /*!
     * Primary `Assertion` prototype
     */

    exports.Assertion = require('./chai/assertion');

    /*!
     * Assertion Error
     */

    exports.AssertionError = require('./chai/error');

    /*!
     * Utils for plugins (not exported)
     */

    var util = require('./chai/utils');

    /**
     * # .use(function)
     *
     * Provides a way to extend the internals of Chai
     *
     * @param ***REMOVED***Function***REMOVED***
     * @returns ***REMOVED***this***REMOVED*** for chaining
     * @api public
     */

    exports.use = function (fn) ***REMOVED***
      if (!~used.indexOf(fn)) ***REMOVED***
        fn(this, util);
        used.push(fn);
      ***REMOVED***

      return this;
    ***REMOVED***;

    /*!
     * Core Assertions
     */

    var core = require('./chai/core/assertions');
    exports.use(core);

    /*!
     * Expect interface
     */

    var expect = require('./chai/interface/expect');
    exports.use(expect);

    /*!
     * Should interface
     */

    var should = require('./chai/interface/should');
    exports.use(should);

    /*!
     * Assert interface
     */

    var assert = require('./chai/interface/assert');
    exports.use(assert);

  ***REMOVED***); // module: chai.js

  require.register("chai/assertion.js", function(module, exports, require)***REMOVED***
    /*!
     * chai
     * http://chaijs.com
     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependencies.
     */

    var AssertionError = require('./error')
      , util = require('./utils')
      , flag = util.flag;

    /*!
     * Module export.
     */

    module.exports = Assertion;


    /*!
     * Assertion Constructor
     *
     * Creates object for chaining.
     *
     * @api private
     */

    function Assertion (obj, msg, stack) ***REMOVED***
      flag(this, 'ssfi', stack || arguments.callee);
      flag(this, 'object', obj);
      flag(this, 'message', msg);
    ***REMOVED***

    /*!
      * ### Assertion.includeStack
      *
      * User configurable property, influences whether stack trace
      * is included in Assertion error message. Default of false
      * suppresses stack trace in the error message
      *
      *     Assertion.includeStack = true;  // enable stack on error
      *
      * @api public
      */

    Assertion.includeStack = false;

    /*!
     * ### Assertion.showDiff
     *
     * User configurable property, influences whether or not
     * the `showDiff` flag should be included in the thrown
     * AssertionErrors. `false` will always be `false`; `true`
     * will be true when the assertion has requested a diff
     * be shown.
     *
     * @api public
     */

    Assertion.showDiff = true;

    Assertion.addProperty = function (name, fn) ***REMOVED***
      util.addProperty(this.prototype, name, fn);
    ***REMOVED***;

    Assertion.addMethod = function (name, fn) ***REMOVED***
      util.addMethod(this.prototype, name, fn);
    ***REMOVED***;

    Assertion.addChainableMethod = function (name, fn, chainingBehavior) ***REMOVED***
      util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
    ***REMOVED***;

    Assertion.overwriteProperty = function (name, fn) ***REMOVED***
      util.overwriteProperty(this.prototype, name, fn);
    ***REMOVED***;

    Assertion.overwriteMethod = function (name, fn) ***REMOVED***
      util.overwriteMethod(this.prototype, name, fn);
    ***REMOVED***;

    /*!
     * ### .assert(expression, message, negateMessage, expected, actual)
     *
     * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
     *
     * @name assert
     * @param ***REMOVED***Philosophical***REMOVED*** expression to be tested
     * @param ***REMOVED***String***REMOVED*** message to display if fails
     * @param ***REMOVED***String***REMOVED*** negatedMessage to display if negated expression fails
     * @param ***REMOVED***Mixed***REMOVED*** expected value (remember to check for negation)
     * @param ***REMOVED***Mixed***REMOVED*** actual (optional) will default to `this.obj`
     * @api private
     */

    Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) ***REMOVED***
      var ok = util.test(this, arguments);
      if (true !== showDiff) showDiff = false;
      if (true !== Assertion.showDiff) showDiff = false;

      if (!ok) ***REMOVED***
        var msg = util.getMessage(this, arguments)
          , actual = util.getActual(this, arguments);
        throw new AssertionError(***REMOVED***
            message: msg
          , actual: actual
          , expected: expected
          , stackStartFunction: (Assertion.includeStack) ? this.assert : flag(this, 'ssfi')
          , showDiff: showDiff
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;

    /*!
     * ### ._obj
     *
     * Quick reference to stored `actual` value for plugin developers.
     *
     * @api private
     */

    Object.defineProperty(Assertion.prototype, '_obj',
      ***REMOVED*** get: function () ***REMOVED***
          return flag(this, 'object');
        ***REMOVED***
      , set: function (val) ***REMOVED***
          flag(this, 'object', val);
        ***REMOVED***
    ***REMOVED***);

  ***REMOVED***); // module: chai/assertion.js

  require.register("chai/core/assertions.js", function(module, exports, require)***REMOVED***
    /*!
     * chai
     * http://chaijs.com
     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    module.exports = function (chai, _) ***REMOVED***
      var Assertion = chai.Assertion
        , toString = Object.prototype.toString
        , flag = _.flag;

      /**
       * ### Language Chains
       *
       * The following are provide as chainable getters to
       * improve the readability of your assertions. They
       * do not provide an testing capability unless they
       * have been overwritten by a plugin.
       *
       * **Chains**
       *
       * - to
       * - be
       * - been
       * - is
       * - that
       * - and
       * - have
       * - with
       * - at
       * - of
       *
       * @name language chains
       * @api public
       */

      [ 'to', 'be', 'been'
      , 'is', 'and', 'have'
      , 'with', 'that', 'at'
      , 'of' ].forEach(function (chain) ***REMOVED***
        Assertion.addProperty(chain, function () ***REMOVED***
          return this;
        ***REMOVED***);
      ***REMOVED***);

      /**
       * ### .not
       *
       * Negates any of assertions following in the chain.
       *
       *     expect(foo).to.not.equal('bar');
       *     expect(goodFn).to.not.throw(Error);
       *     expect(***REMOVED*** foo: 'baz' ***REMOVED***).to.have.property('foo')
       *       .and.not.equal('bar');
       *
       * @name not
       * @api public
       */

      Assertion.addProperty('not', function () ***REMOVED***
        flag(this, 'negate', true);
      ***REMOVED***);

      /**
       * ### .deep
       *
       * Sets the `deep` flag, later used by the `equal` and
       * `property` assertions.
       *
       *     expect(foo).to.deep.equal(***REMOVED*** bar: 'baz' ***REMOVED***);
       *     expect(***REMOVED*** foo: ***REMOVED*** bar: ***REMOVED*** baz: 'quux' ***REMOVED*** ***REMOVED*** ***REMOVED***)
       *       .to.have.deep.property('foo.bar.baz', 'quux');
       *
       * @name deep
       * @api public
       */

      Assertion.addProperty('deep', function () ***REMOVED***
        flag(this, 'deep', true);
      ***REMOVED***);

      /**
       * ### .a(type)
       *
       * The `a` and `an` assertions are aliases that can be
       * used either as language chains or to assert a value's
       * type.
       *
       *     // typeof
       *     expect('test').to.be.a('string');
       *     expect(***REMOVED*** foo: 'bar' ***REMOVED***).to.be.an('object');
       *     expect(null).to.be.a('null');
       *     expect(undefined).to.be.an('undefined');
       *
       *     // language chain
       *     expect(foo).to.be.an.instanceof(Foo);
       *
       * @name a
       * @alias an
       * @param ***REMOVED***String***REMOVED*** type
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function an (type, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        type = type.toLowerCase();
        var obj = flag(this, 'object')
          , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

        this.assert(
            type === _.type(obj)
          , 'expected #***REMOVED***this***REMOVED*** to be ' + article + type
          , 'expected #***REMOVED***this***REMOVED*** not to be ' + article + type
        );
      ***REMOVED***

      Assertion.addChainableMethod('an', an);
      Assertion.addChainableMethod('a', an);

      /**
       * ### .include(value)
       *
       * The `include` and `contain` assertions can be used as either property
       * based language chains or as methods to assert the inclusion of an object
       * in an array or a substring in a string. When used as language chains,
       * they toggle the `contain` flag for the `keys` assertion.
       *
       *     expect([1,2,3]).to.include(2);
       *     expect('foobar').to.contain('foo');
       *     expect(***REMOVED*** foo: 'bar', hello: 'universe' ***REMOVED***).to.include.keys('foo');
       *
       * @name include
       * @alias contain
       * @param ***REMOVED***Object|String|Number***REMOVED*** obj
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function includeChainingBehavior () ***REMOVED***
        flag(this, 'contains', true);
      ***REMOVED***

      function include (val, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
        this.assert(
            ~obj.indexOf(val)
          , 'expected #***REMOVED***this***REMOVED*** to include ' + _.inspect(val)
          , 'expected #***REMOVED***this***REMOVED*** to not include ' + _.inspect(val));
      ***REMOVED***

      Assertion.addChainableMethod('include', include, includeChainingBehavior);
      Assertion.addChainableMethod('contain', include, includeChainingBehavior);

      /**
       * ### .ok
       *
       * Asserts that the target is truthy.
       *
       *     expect('everthing').to.be.ok;
       *     expect(1).to.be.ok;
       *     expect(false).to.not.be.ok;
       *     expect(undefined).to.not.be.ok;
       *     expect(null).to.not.be.ok;
       *
       * @name ok
       * @api public
       */

      Assertion.addProperty('ok', function () ***REMOVED***
        this.assert(
            flag(this, 'object')
          , 'expected #***REMOVED***this***REMOVED*** to be truthy'
          , 'expected #***REMOVED***this***REMOVED*** to be falsy');
      ***REMOVED***);

      /**
       * ### .true
       *
       * Asserts that the target is `true`.
       *
       *     expect(true).to.be.true;
       *     expect(1).to.not.be.true;
       *
       * @name true
       * @api public
       */

      Assertion.addProperty('true', function () ***REMOVED***
        this.assert(
            true === flag(this, 'object')
          , 'expected #***REMOVED***this***REMOVED*** to be true'
          , 'expected #***REMOVED***this***REMOVED*** to be false'
          , this.negate ? false : true
        );
      ***REMOVED***);

      /**
       * ### .false
       *
       * Asserts that the target is `false`.
       *
       *     expect(false).to.be.false;
       *     expect(0).to.not.be.false;
       *
       * @name false
       * @api public
       */

      Assertion.addProperty('false', function () ***REMOVED***
        this.assert(
            false === flag(this, 'object')
          , 'expected #***REMOVED***this***REMOVED*** to be false'
          , 'expected #***REMOVED***this***REMOVED*** to be true'
          , this.negate ? true : false
        );
      ***REMOVED***);

      /**
       * ### .null
       *
       * Asserts that the target is `null`.
       *
       *     expect(null).to.be.null;
       *     expect(undefined).not.to.be.null;
       *
       * @name null
       * @api public
       */

      Assertion.addProperty('null', function () ***REMOVED***
        this.assert(
            null === flag(this, 'object')
          , 'expected #***REMOVED***this***REMOVED*** to be null'
          , 'expected #***REMOVED***this***REMOVED*** not to be null'
        );
      ***REMOVED***);

      /**
       * ### .undefined
       *
       * Asserts that the target is `undefined`.
       *
       *      expect(undefined).to.be.undefined;
       *      expect(null).to.not.be.undefined;
       *
       * @name undefined
       * @api public
       */

      Assertion.addProperty('undefined', function () ***REMOVED***
        this.assert(
            undefined === flag(this, 'object')
          , 'expected #***REMOVED***this***REMOVED*** to be undefined'
          , 'expected #***REMOVED***this***REMOVED*** not to be undefined'
        );
      ***REMOVED***);

      /**
       * ### .exist
       *
       * Asserts that the target is neither `null` nor `undefined`.
       *
       *     var foo = 'hi'
       *       , bar = null
       *       , baz;
       *
       *     expect(foo).to.exist;
       *     expect(bar).to.not.exist;
       *     expect(baz).to.not.exist;
       *
       * @name exist
       * @api public
       */

      Assertion.addProperty('exist', function () ***REMOVED***
        this.assert(
            null != flag(this, 'object')
          , 'expected #***REMOVED***this***REMOVED*** to exist'
          , 'expected #***REMOVED***this***REMOVED*** to not exist'
        );
      ***REMOVED***);


      /**
       * ### .empty
       *
       * Asserts that the target's length is `0`. For arrays, it checks
       * the `length` property. For objects, it gets the count of
       * enumerable keys.
       *
       *     expect([]).to.be.empty;
       *     expect('').to.be.empty;
       *     expect(***REMOVED******REMOVED***).to.be.empty;
       *
       * @name empty
       * @api public
       */

      Assertion.addProperty('empty', function () ***REMOVED***
        var obj = flag(this, 'object')
          , expected = obj;

        if (Array.isArray(obj) || 'string' === typeof object) ***REMOVED***
          expected = obj.length;
        ***REMOVED*** else if (typeof obj === 'object') ***REMOVED***
          expected = Object.keys(obj).length;
        ***REMOVED***

        this.assert(
            !expected
          , 'expected #***REMOVED***this***REMOVED*** to be empty'
          , 'expected #***REMOVED***this***REMOVED*** not to be empty'
        );
      ***REMOVED***);

      /**
       * ### .arguments
       *
       * Asserts that the target is an arguments object.
       *
       *     function test () ***REMOVED***
       *       expect(arguments).to.be.arguments;
       *     ***REMOVED***
       *
       * @name arguments
       * @alias Arguments
       * @api public
       */

      function checkArguments () ***REMOVED***
        var obj = flag(this, 'object')
          , type = Object.prototype.toString.call(obj);
        this.assert(
            '[object Arguments]' === type
          , 'expected #***REMOVED***this***REMOVED*** to be arguments but got ' + type
          , 'expected #***REMOVED***this***REMOVED*** to not be arguments'
        );
      ***REMOVED***

      Assertion.addProperty('arguments', checkArguments);
      Assertion.addProperty('Arguments', checkArguments);

      /**
       * ### .equal(value)
       *
       * Asserts that the target is strictly equal (`===`) to `value`.
       * Alternately, if the `deep` flag is set, asserts that
       * the target is deeply equal to `value`.
       *
       *     expect('hello').to.equal('hello');
       *     expect(42).to.equal(42);
       *     expect(1).to.not.equal(true);
       *     expect(***REMOVED*** foo: 'bar' ***REMOVED***).to.not.equal(***REMOVED*** foo: 'bar' ***REMOVED***);
       *     expect(***REMOVED*** foo: 'bar' ***REMOVED***).to.deep.equal(***REMOVED*** foo: 'bar' ***REMOVED***);
       *
       * @name equal
       * @alias equals
       * @alias eq
       * @alias deep.equal
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function assertEqual (val, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        if (flag(this, 'deep')) ***REMOVED***
          return this.eql(val);
        ***REMOVED*** else ***REMOVED***
          this.assert(
              val === obj
            , 'expected #***REMOVED***this***REMOVED*** to equal #***REMOVED***exp***REMOVED***'
            , 'expected #***REMOVED***this***REMOVED*** to not equal #***REMOVED***exp***REMOVED***'
            , val
            , this._obj
            , true
          );
        ***REMOVED***
      ***REMOVED***

      Assertion.addMethod('equal', assertEqual);
      Assertion.addMethod('equals', assertEqual);
      Assertion.addMethod('eq', assertEqual);

      /**
       * ### .eql(value)
       *
       * Asserts that the target is deeply equal to `value`.
       *
       *     expect(***REMOVED*** foo: 'bar' ***REMOVED***).to.eql(***REMOVED*** foo: 'bar' ***REMOVED***);
       *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
       *
       * @name eql
       * @alias eqls
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function assertEql(obj, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        this.assert(
            _.eql(obj, flag(this, 'object'))
          , 'expected #***REMOVED***this***REMOVED*** to deeply equal #***REMOVED***exp***REMOVED***'
          , 'expected #***REMOVED***this***REMOVED*** to not deeply equal #***REMOVED***exp***REMOVED***'
          , obj
          , this._obj
          , true
        );
      ***REMOVED***

      Assertion.addMethod('eql', assertEql);
      Assertion.addMethod('eqls', assertEql);

      /**
       * ### .above(value)
       *
       * Asserts that the target is greater than `value`.
       *
       *     expect(10).to.be.above(5);
       *
       * Can also be used in conjunction with `length` to
       * assert a minimum length. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect('foo').to.have.length.above(2);
       *     expect([ 1, 2, 3 ]).to.have.length.above(2);
       *
       * @name above
       * @alias gt
       * @alias greaterThan
       * @param ***REMOVED***Number***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function assertAbove (n, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        if (flag(this, 'doLength')) ***REMOVED***
          new Assertion(obj, msg).to.have.property('length');
          var len = obj.length;
          this.assert(
              len > n
            , 'expected #***REMOVED***this***REMOVED*** to have a length above #***REMOVED***exp***REMOVED*** but got #***REMOVED***act***REMOVED***'
            , 'expected #***REMOVED***this***REMOVED*** to not have a length above #***REMOVED***exp***REMOVED***'
            , n
            , len
          );
        ***REMOVED*** else ***REMOVED***
          this.assert(
              obj > n
            , 'expected #***REMOVED***this***REMOVED*** to be above ' + n
            , 'expected #***REMOVED***this***REMOVED*** to be at most ' + n
          );
        ***REMOVED***
      ***REMOVED***

      Assertion.addMethod('above', assertAbove);
      Assertion.addMethod('gt', assertAbove);
      Assertion.addMethod('greaterThan', assertAbove);

      /**
       * ### .least(value)
       *
       * Asserts that the target is greater than or equal to `value`.
       *
       *     expect(10).to.be.at.least(10);
       *
       * Can also be used in conjunction with `length` to
       * assert a minimum length. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect('foo').to.have.length.of.at.least(2);
       *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
       *
       * @name least
       * @alias gte
       * @param ***REMOVED***Number***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function assertLeast (n, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        if (flag(this, 'doLength')) ***REMOVED***
          new Assertion(obj, msg).to.have.property('length');
          var len = obj.length;
          this.assert(
              len >= n
            , 'expected #***REMOVED***this***REMOVED*** to have a length at least #***REMOVED***exp***REMOVED*** but got #***REMOVED***act***REMOVED***'
            , 'expected #***REMOVED***this***REMOVED*** to have a length below #***REMOVED***exp***REMOVED***'
            , n
            , len
          );
        ***REMOVED*** else ***REMOVED***
          this.assert(
              obj >= n
            , 'expected #***REMOVED***this***REMOVED*** to be at least ' + n
            , 'expected #***REMOVED***this***REMOVED*** to be below ' + n
          );
        ***REMOVED***
      ***REMOVED***

      Assertion.addMethod('least', assertLeast);
      Assertion.addMethod('gte', assertLeast);

      /**
       * ### .below(value)
       *
       * Asserts that the target is less than `value`.
       *
       *     expect(5).to.be.below(10);
       *
       * Can also be used in conjunction with `length` to
       * assert a maximum length. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect('foo').to.have.length.below(4);
       *     expect([ 1, 2, 3 ]).to.have.length.below(4);
       *
       * @name below
       * @alias lt
       * @alias lessThan
       * @param ***REMOVED***Number***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function assertBelow (n, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        if (flag(this, 'doLength')) ***REMOVED***
          new Assertion(obj, msg).to.have.property('length');
          var len = obj.length;
          this.assert(
              len < n
            , 'expected #***REMOVED***this***REMOVED*** to have a length below #***REMOVED***exp***REMOVED*** but got #***REMOVED***act***REMOVED***'
            , 'expected #***REMOVED***this***REMOVED*** to not have a length below #***REMOVED***exp***REMOVED***'
            , n
            , len
          );
        ***REMOVED*** else ***REMOVED***
          this.assert(
              obj < n
            , 'expected #***REMOVED***this***REMOVED*** to be below ' + n
            , 'expected #***REMOVED***this***REMOVED*** to be at least ' + n
          );
        ***REMOVED***
      ***REMOVED***

      Assertion.addMethod('below', assertBelow);
      Assertion.addMethod('lt', assertBelow);
      Assertion.addMethod('lessThan', assertBelow);

      /**
       * ### .most(value)
       *
       * Asserts that the target is less than or equal to `value`.
       *
       *     expect(5).to.be.at.most(5);
       *
       * Can also be used in conjunction with `length` to
       * assert a maximum length. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect('foo').to.have.length.of.at.most(4);
       *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
       *
       * @name most
       * @alias lte
       * @param ***REMOVED***Number***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function assertMost (n, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        if (flag(this, 'doLength')) ***REMOVED***
          new Assertion(obj, msg).to.have.property('length');
          var len = obj.length;
          this.assert(
              len <= n
            , 'expected #***REMOVED***this***REMOVED*** to have a length at most #***REMOVED***exp***REMOVED*** but got #***REMOVED***act***REMOVED***'
            , 'expected #***REMOVED***this***REMOVED*** to have a length above #***REMOVED***exp***REMOVED***'
            , n
            , len
          );
        ***REMOVED*** else ***REMOVED***
          this.assert(
              obj <= n
            , 'expected #***REMOVED***this***REMOVED*** to be at most ' + n
            , 'expected #***REMOVED***this***REMOVED*** to be above ' + n
          );
        ***REMOVED***
      ***REMOVED***

      Assertion.addMethod('most', assertMost);
      Assertion.addMethod('lte', assertMost);

      /**
       * ### .within(start, finish)
       *
       * Asserts that the target is within a range.
       *
       *     expect(7).to.be.within(5,10);
       *
       * Can also be used in conjunction with `length` to
       * assert a length range. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect('foo').to.have.length.within(2,4);
       *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
       *
       * @name within
       * @param ***REMOVED***Number***REMOVED*** start lowerbound inclusive
       * @param ***REMOVED***Number***REMOVED*** finish upperbound inclusive
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      Assertion.addMethod('within', function (start, finish, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , range = start + '..' + finish;
        if (flag(this, 'doLength')) ***REMOVED***
          new Assertion(obj, msg).to.have.property('length');
          var len = obj.length;
          this.assert(
              len >= start && len <= finish
            , 'expected #***REMOVED***this***REMOVED*** to have a length within ' + range
            , 'expected #***REMOVED***this***REMOVED*** to not have a length within ' + range
          );
        ***REMOVED*** else ***REMOVED***
          this.assert(
              obj >= start && obj <= finish
            , 'expected #***REMOVED***this***REMOVED*** to be within ' + range
            , 'expected #***REMOVED***this***REMOVED*** to not be within ' + range
          );
        ***REMOVED***
      ***REMOVED***);

      /**
       * ### .instanceof(constructor)
       *
       * Asserts that the target is an instance of `constructor`.
       *
       *     var Tea = function (name) ***REMOVED*** this.name = name; ***REMOVED***
       *       , Chai = new Tea('chai');
       *
       *     expect(Chai).to.be.an.instanceof(Tea);
       *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
       *
       * @name instanceof
       * @param ***REMOVED***Constructor***REMOVED*** constructor
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @alias instanceOf
       * @api public
       */

      function assertInstanceOf (constructor, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var name = _.getName(constructor);
        this.assert(
            flag(this, 'object') instanceof constructor
          , 'expected #***REMOVED***this***REMOVED*** to be an instance of ' + name
          , 'expected #***REMOVED***this***REMOVED*** to not be an instance of ' + name
        );
      ***REMOVED***;

      Assertion.addMethod('instanceof', assertInstanceOf);
      Assertion.addMethod('instanceOf', assertInstanceOf);

      /**
       * ### .property(name, [value])
       *
       * Asserts that the target has a property `name`, optionally asserting that
       * the value of that property is strictly equal to  `value`.
       * If the `deep` flag is set, you can use dot- and bracket-notation for deep
       * references into objects and arrays.
       *
       *     // simple referencing
       *     var obj = ***REMOVED*** foo: 'bar' ***REMOVED***;
       *     expect(obj).to.have.property('foo');
       *     expect(obj).to.have.property('foo', 'bar');
       *
       *     // deep referencing
       *     var deepObj = ***REMOVED***
       *         green: ***REMOVED*** tea: 'matcha' ***REMOVED***
       *       , teas: [ 'chai', 'matcha', ***REMOVED*** tea: 'konacha' ***REMOVED*** ]
       *     ***REMOVED***;

       *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
       *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
       *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
       *
       * You can also use an array as the starting point of a `deep.property`
       * assertion, or traverse nested arrays.
       *
       *     var arr = [
       *         [ 'chai', 'matcha', 'konacha' ]
       *       , [ ***REMOVED*** tea: 'chai' ***REMOVED***
       *         , ***REMOVED*** tea: 'matcha' ***REMOVED***
       *         , ***REMOVED*** tea: 'konacha' ***REMOVED*** ]
       *     ];
       *
       *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
       *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
       *
       * Furthermore, `property` changes the subject of the assertion
       * to be the value of that property from the original object. This
       * permits for further chainable assertions on that property.
       *
       *     expect(obj).to.have.property('foo')
       *       .that.is.a('string');
       *     expect(deepObj).to.have.property('green')
       *       .that.is.an('object')
       *       .that.deep.equals(***REMOVED*** tea: 'matcha' ***REMOVED***);
       *     expect(deepObj).to.have.property('teas')
       *       .that.is.an('array')
       *       .with.deep.property('[2]')
       *         .that.deep.equals(***REMOVED*** tea: 'konacha' ***REMOVED***);
       *
       * @name property
       * @alias deep.property
       * @param ***REMOVED***String***REMOVED*** name
       * @param ***REMOVED***Mixed***REMOVED*** value (optional)
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @returns value of property for chaining
       * @api public
       */

      Assertion.addMethod('property', function (name, val, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);

        var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
          , negate = flag(this, 'negate')
          , obj = flag(this, 'object')
          , value = flag(this, 'deep')
            ? _.getPathValue(name, obj)
            : obj[name];

        if (negate && undefined !== val) ***REMOVED***
          if (undefined === value) ***REMOVED***
            msg = (msg != null) ? msg + ': ' : '';
            throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          this.assert(
              undefined !== value
            , 'expected #***REMOVED***this***REMOVED*** to have a ' + descriptor + _.inspect(name)
            , 'expected #***REMOVED***this***REMOVED*** to not have ' + descriptor + _.inspect(name));
        ***REMOVED***

        if (undefined !== val) ***REMOVED***
          this.assert(
              val === value
            , 'expected #***REMOVED***this***REMOVED*** to have a ' + descriptor + _.inspect(name) + ' of #***REMOVED***exp***REMOVED***, but got #***REMOVED***act***REMOVED***'
            , 'expected #***REMOVED***this***REMOVED*** to not have a ' + descriptor + _.inspect(name) + ' of #***REMOVED***act***REMOVED***'
            , val
            , value
          );
        ***REMOVED***

        flag(this, 'object', value);
      ***REMOVED***);


      /**
       * ### .ownProperty(name)
       *
       * Asserts that the target has an own property `name`.
       *
       *     expect('test').to.have.ownProperty('length');
       *
       * @name ownProperty
       * @alias haveOwnProperty
       * @param ***REMOVED***String***REMOVED*** name
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function assertOwnProperty (name, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        this.assert(
            obj.hasOwnProperty(name)
          , 'expected #***REMOVED***this***REMOVED*** to have own property ' + _.inspect(name)
          , 'expected #***REMOVED***this***REMOVED*** to not have own property ' + _.inspect(name)
        );
      ***REMOVED***

      Assertion.addMethod('ownProperty', assertOwnProperty);
      Assertion.addMethod('haveOwnProperty', assertOwnProperty);

      /**
       * ### .length(value)
       *
       * Asserts that the target's `length` property has
       * the expected value.
       *
       *     expect([ 1, 2, 3]).to.have.length(3);
       *     expect('foobar').to.have.length(6);
       *
       * Can also be used as a chain precursor to a value
       * comparison for the length property.
       *
       *     expect('foo').to.have.length.above(2);
       *     expect([ 1, 2, 3 ]).to.have.length.above(2);
       *     expect('foo').to.have.length.below(4);
       *     expect([ 1, 2, 3 ]).to.have.length.below(4);
       *     expect('foo').to.have.length.within(2,4);
       *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
       *
       * @name length
       * @alias lengthOf
       * @param ***REMOVED***Number***REMOVED*** length
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      function assertLengthChain () ***REMOVED***
        flag(this, 'doLength', true);
      ***REMOVED***

      function assertLength (n, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        new Assertion(obj, msg).to.have.property('length');
        var len = obj.length;

        this.assert(
            len == n
          , 'expected #***REMOVED***this***REMOVED*** to have a length of #***REMOVED***exp***REMOVED*** but got #***REMOVED***act***REMOVED***'
          , 'expected #***REMOVED***this***REMOVED*** to not have a length of #***REMOVED***act***REMOVED***'
          , n
          , len
        );
      ***REMOVED***

      Assertion.addChainableMethod('length', assertLength, assertLengthChain);
      Assertion.addMethod('lengthOf', assertLength, assertLengthChain);

      /**
       * ### .match(regexp)
       *
       * Asserts that the target matches a regular expression.
       *
       *     expect('foobar').to.match(/^foo/);
       *
       * @name match
       * @param ***REMOVED***RegExp***REMOVED*** RegularExpression
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      Assertion.addMethod('match', function (re, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        this.assert(
            re.exec(obj)
          , 'expected #***REMOVED***this***REMOVED*** to match ' + re
          , 'expected #***REMOVED***this***REMOVED*** not to match ' + re
        );
      ***REMOVED***);

      /**
       * ### .string(string)
       *
       * Asserts that the string target contains another string.
       *
       *     expect('foobar').to.have.string('bar');
       *
       * @name string
       * @param ***REMOVED***String***REMOVED*** string
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      Assertion.addMethod('string', function (str, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        new Assertion(obj, msg).is.a('string');

        this.assert(
            ~obj.indexOf(str)
          , 'expected #***REMOVED***this***REMOVED*** to contain ' + _.inspect(str)
          , 'expected #***REMOVED***this***REMOVED*** to not contain ' + _.inspect(str)
        );
      ***REMOVED***);


      /**
       * ### .keys(key1, [key2], [...])
       *
       * Asserts that the target has exactly the given keys, or
       * asserts the inclusion of some keys when using the
       * `include` or `contain` modifiers.
       *
       *     expect(***REMOVED*** foo: 1, bar: 2 ***REMOVED***).to.have.keys(['foo', 'bar']);
       *     expect(***REMOVED*** foo: 1, bar: 2, baz: 3 ***REMOVED***).to.contain.keys('foo', 'bar');
       *
       * @name keys
       * @alias key
       * @param ***REMOVED***String...|Array***REMOVED*** keys
       * @api public
       */

      function assertKeys (keys) ***REMOVED***
        var obj = flag(this, 'object')
          , str
          , ok = true;

        keys = keys instanceof Array
          ? keys
          : Array.prototype.slice.call(arguments);

        if (!keys.length) throw new Error('keys required');

        var actual = Object.keys(obj)
          , len = keys.length;

        // Inclusion
        ok = keys.every(function(key)***REMOVED***
          return ~actual.indexOf(key);
        ***REMOVED***);

        // Strict
        if (!flag(this, 'negate') && !flag(this, 'contains')) ***REMOVED***
          ok = ok && keys.length == actual.length;
        ***REMOVED***

        // Key string
        if (len > 1) ***REMOVED***
          keys = keys.map(function(key)***REMOVED***
            return _.inspect(key);
          ***REMOVED***);
          var last = keys.pop();
          str = keys.join(', ') + ', and ' + last;
        ***REMOVED*** else ***REMOVED***
          str = _.inspect(keys[0]);
        ***REMOVED***

        // Form
        str = (len > 1 ? 'keys ' : 'key ') + str;

        // Have / include
        str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

        // Assertion
        this.assert(
            ok
          , 'expected #***REMOVED***this***REMOVED*** to ' + str
          , 'expected #***REMOVED***this***REMOVED*** to not ' + str
        );
      ***REMOVED***

      Assertion.addMethod('keys', assertKeys);
      Assertion.addMethod('key', assertKeys);

      /**
       * ### .throw(constructor)
       *
       * Asserts that the function target will throw a specific error, or specific type of error
       * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
       * for the error's message.
       *
       *     var err = new ReferenceError('This is a bad function.');
       *     var fn = function () ***REMOVED*** throw err; ***REMOVED***
       *     expect(fn).to.throw(ReferenceError);
       *     expect(fn).to.throw(Error);
       *     expect(fn).to.throw(/bad function/);
       *     expect(fn).to.not.throw('good function');
       *     expect(fn).to.throw(ReferenceError, /bad function/);
       *     expect(fn).to.throw(err);
       *     expect(fn).to.not.throw(new RangeError('Out of range.'));
       *
       * Please note that when a throw expectation is negated, it will check each
       * parameter independently, starting with error constructor type. The appropriate way
       * to check for the existence of a type of error but for a message that does not match
       * is to use `and`.
       *
       *     expect(fn).to.throw(ReferenceError)
       *        .and.not.throw(/good function/);
       *
       * @name throw
       * @alias throws
       * @alias Throw
       * @param ***REMOVED***ErrorConstructor***REMOVED*** constructor
       * @param ***REMOVED***String|RegExp***REMOVED*** expected error message
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
       * @api public
       */

      function assertThrows (constructor, errMsg, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        new Assertion(obj, msg).is.a('function');

        var thrown = false
          , desiredError = null
          , name = null
          , thrownError = null;

        if (arguments.length === 0) ***REMOVED***
          errMsg = null;
          constructor = null;
        ***REMOVED*** else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) ***REMOVED***
          errMsg = constructor;
          constructor = null;
        ***REMOVED*** else if (constructor && constructor instanceof Error) ***REMOVED***
          desiredError = constructor;
          constructor = null;
          errMsg = null;
        ***REMOVED*** else if (typeof constructor === 'function') ***REMOVED***
          name = (new constructor()).name;
        ***REMOVED*** else ***REMOVED***
          constructor = null;
        ***REMOVED***

        try ***REMOVED***
          obj();
        ***REMOVED*** catch (err) ***REMOVED***
          // first, check desired error
          if (desiredError) ***REMOVED***
            this.assert(
                err === desiredError
              , 'expected #***REMOVED***this***REMOVED*** to throw #***REMOVED***exp***REMOVED*** but #***REMOVED***act***REMOVED*** was thrown'
              , 'expected #***REMOVED***this***REMOVED*** to not throw #***REMOVED***exp***REMOVED***'
              , desiredError
              , err
            );

            return this;
          ***REMOVED***
          // next, check constructor
          if (constructor) ***REMOVED***
            this.assert(
                err instanceof constructor
              , 'expected #***REMOVED***this***REMOVED*** to throw #***REMOVED***exp***REMOVED*** but #***REMOVED***act***REMOVED*** was thrown'
              , 'expected #***REMOVED***this***REMOVED*** to not throw #***REMOVED***exp***REMOVED*** but #***REMOVED***act***REMOVED*** was thrown'
              , name
              , err
            );

            if (!errMsg) return this;
          ***REMOVED***
          // next, check message
          var message = 'object' === _.type(err) && "message" in err
            ? err.message
            : '' + err;

          if ((message != null) && errMsg && errMsg instanceof RegExp) ***REMOVED***
            this.assert(
                errMsg.exec(message)
              , 'expected #***REMOVED***this***REMOVED*** to throw error matching #***REMOVED***exp***REMOVED*** but got #***REMOVED***act***REMOVED***'
              , 'expected #***REMOVED***this***REMOVED*** to throw error not matching #***REMOVED***exp***REMOVED***'
              , errMsg
              , message
            );

            return this;
          ***REMOVED*** else if ((message != null) && errMsg && 'string' === typeof errMsg) ***REMOVED***
            this.assert(
                ~message.indexOf(errMsg)
              , 'expected #***REMOVED***this***REMOVED*** to throw error including #***REMOVED***exp***REMOVED*** but got #***REMOVED***act***REMOVED***'
              , 'expected #***REMOVED***this***REMOVED*** to throw error not including #***REMOVED***act***REMOVED***'
              , errMsg
              , message
            );

            return this;
          ***REMOVED*** else ***REMOVED***
            thrown = true;
            thrownError = err;
          ***REMOVED***
        ***REMOVED***

        var actuallyGot = ''
          , expectedThrown = name !== null
            ? name
            : desiredError
              ? '#***REMOVED***exp***REMOVED***' //_.inspect(desiredError)
              : 'an error';

        if (thrown) ***REMOVED***
          actuallyGot = ' but #***REMOVED***act***REMOVED*** was thrown'
        ***REMOVED***

        this.assert(
            thrown === true
          , 'expected #***REMOVED***this***REMOVED*** to throw ' + expectedThrown + actuallyGot
          , 'expected #***REMOVED***this***REMOVED*** to not throw ' + expectedThrown + actuallyGot
          , desiredError
          , thrownError
        );
      ***REMOVED***;

      Assertion.addMethod('throw', assertThrows);
      Assertion.addMethod('throws', assertThrows);
      Assertion.addMethod('Throw', assertThrows);

      /**
       * ### .respondTo(method)
       *
       * Asserts that the object or class target will respond to a method.
       *
       *     Klass.prototype.bar = function()***REMOVED******REMOVED***;
       *     expect(Klass).to.respondTo('bar');
       *     expect(obj).to.respondTo('bar');
       *
       * To check if a constructor will respond to a static function,
       * set the `itself` flag.
       *
       *    Klass.baz = function()***REMOVED******REMOVED***;
       *    expect(Klass).itself.to.respondTo('baz');
       *
       * @name respondTo
       * @param ***REMOVED***String***REMOVED*** method
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      Assertion.addMethod('respondTo', function (method, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , itself = flag(this, 'itself')
          , context = ('function' === _.type(obj) && !itself)
            ? obj.prototype[method]
            : obj[method];

        this.assert(
            'function' === typeof context
          , 'expected #***REMOVED***this***REMOVED*** to respond to ' + _.inspect(method)
          , 'expected #***REMOVED***this***REMOVED*** to not respond to ' + _.inspect(method)
        );
      ***REMOVED***);

      /**
       * ### .itself
       *
       * Sets the `itself` flag, later used by the `respondTo` assertion.
       *
       *    function Foo() ***REMOVED******REMOVED***
       *    Foo.bar = function() ***REMOVED******REMOVED***
       *    Foo.prototype.baz = function() ***REMOVED******REMOVED***
       *
       *    expect(Foo).itself.to.respondTo('bar');
       *    expect(Foo).itself.not.to.respondTo('baz');
       *
       * @name itself
       * @api public
       */

      Assertion.addProperty('itself', function () ***REMOVED***
        flag(this, 'itself', true);
      ***REMOVED***);

      /**
       * ### .satisfy(method)
       *
       * Asserts that the target passes a given truth test.
       *
       *     expect(1).to.satisfy(function(num) ***REMOVED*** return num > 0; ***REMOVED***);
       *
       * @name satisfy
       * @param ***REMOVED***Function***REMOVED*** matcher
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      Assertion.addMethod('satisfy', function (matcher, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        this.assert(
            matcher(obj)
          , 'expected #***REMOVED***this***REMOVED*** to satisfy ' + _.objDisplay(matcher)
          , 'expected #***REMOVED***this***REMOVED*** to not satisfy' + _.objDisplay(matcher)
          , this.negate ? false : true
          , matcher(obj)
        );
      ***REMOVED***);

      /**
       * ### .closeTo(expected, delta)
       *
       * Asserts that the target is equal `expected`, to within a +/- `delta` range.
       *
       *     expect(1.5).to.be.closeTo(1, 0.5);
       *
       * @name closeTo
       * @param ***REMOVED***Number***REMOVED*** expected
       * @param ***REMOVED***Number***REMOVED*** delta
       * @param ***REMOVED***String***REMOVED*** message _optional_
       * @api public
       */

      Assertion.addMethod('closeTo', function (expected, delta, msg) ***REMOVED***
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        this.assert(
            Math.abs(obj - expected) <= delta
          , 'expected #***REMOVED***this***REMOVED*** to be close to ' + expected + ' +/- ' + delta
          , 'expected #***REMOVED***this***REMOVED*** not to be close to ' + expected + ' +/- ' + delta
        );
      ***REMOVED***);

    ***REMOVED***;

  ***REMOVED***); // module: chai/core/assertions.js

  require.register("chai/error.js", function(module, exports, require)***REMOVED***
    /*!
     * chai
     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Main export
     */

    module.exports = AssertionError;

    /**
     * # AssertionError (constructor)
     *
     * Create a new assertion error based on the Javascript
     * `Error` prototype.
     *
     * **Options**
     * - message
     * - actual
     * - expected
     * - operator
     * - startStackFunction
     *
     * @param ***REMOVED***Object***REMOVED*** options
     * @api public
     */

    function AssertionError (options) ***REMOVED***
      options = options || ***REMOVED******REMOVED***;
      this.message = options.message;
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;
      this.showDiff = options.showDiff;

      if (options.stackStartFunction && Error.captureStackTrace) ***REMOVED***
        var stackStartFunction = options.stackStartFunction;
        Error.captureStackTrace(this, stackStartFunction);
      ***REMOVED***
    ***REMOVED***

    /*!
     * Inherit from Error
     */

    AssertionError.prototype = Object.create(Error.prototype);
    AssertionError.prototype.name = 'AssertionError';
    AssertionError.prototype.constructor = AssertionError;

    /**
     * # toString()
     *
     * Override default to string method
     */

    AssertionError.prototype.toString = function() ***REMOVED***
      return this.message;
    ***REMOVED***;

  ***REMOVED***); // module: chai/error.js

  require.register("chai/interface/assert.js", function(module, exports, require)***REMOVED***
    /*!
     * chai
     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */


    module.exports = function (chai, util) ***REMOVED***

      /*!
       * Chai dependencies.
       */

      var Assertion = chai.Assertion
        , flag = util.flag;

      /*!
       * Module export.
       */

      /**
       * ### assert(expression, message)
       *
       * Write your own test expressions.
       *
       *     assert('foo' !== 'bar', 'foo is not bar');
       *     assert(Array.isArray([]), 'empty arrays are arrays');
       *
       * @param ***REMOVED***Mixed***REMOVED*** expression to test for truthiness
       * @param ***REMOVED***String***REMOVED*** message to display on error
       * @name assert
       * @api public
       */

      var assert = chai.assert = function (express, errmsg) ***REMOVED***
        var test = new Assertion(null);
        test.assert(
            express
          , errmsg
          , '[ negation message unavailable ]'
        );
      ***REMOVED***;

      /**
       * ### .fail(actual, expected, [message], [operator])
       *
       * Throw a failure. Node.js `assert` module-compatible.
       *
       * @name fail
       * @param ***REMOVED***Mixed***REMOVED*** actual
       * @param ***REMOVED***Mixed***REMOVED*** expected
       * @param ***REMOVED***String***REMOVED*** message
       * @param ***REMOVED***String***REMOVED*** operator
       * @api public
       */

      assert.fail = function (actual, expected, message, operator) ***REMOVED***
        throw new chai.AssertionError(***REMOVED***
            actual: actual
          , expected: expected
          , message: message
          , operator: operator
          , stackStartFunction: assert.fail
        ***REMOVED***);
      ***REMOVED***;

      /**
       * ### .ok(object, [message])
       *
       * Asserts that `object` is truthy.
       *
       *     assert.ok('everything', 'everything is ok');
       *     assert.ok(false, 'this will fail');
       *
       * @name ok
       * @param ***REMOVED***Mixed***REMOVED*** object to test
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.ok = function (val, msg) ***REMOVED***
        new Assertion(val, msg).is.ok;
      ***REMOVED***;

      /**
       * ### .equal(actual, expected, [message])
       *
       * Asserts non-strict equality (`==`) of `actual` and `expected`.
       *
       *     assert.equal(3, '3', '== coerces values to strings');
       *
       * @name equal
       * @param ***REMOVED***Mixed***REMOVED*** actual
       * @param ***REMOVED***Mixed***REMOVED*** expected
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.equal = function (act, exp, msg) ***REMOVED***
        var test = new Assertion(act, msg);

        test.assert(
            exp == flag(test, 'object')
          , 'expected #***REMOVED***this***REMOVED*** to equal #***REMOVED***exp***REMOVED***'
          , 'expected #***REMOVED***this***REMOVED*** to not equal #***REMOVED***act***REMOVED***'
          , exp
          , act
        );
      ***REMOVED***;

      /**
       * ### .notEqual(actual, expected, [message])
       *
       * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
       *
       *     assert.notEqual(3, 4, 'these numbers are not equal');
       *
       * @name notEqual
       * @param ***REMOVED***Mixed***REMOVED*** actual
       * @param ***REMOVED***Mixed***REMOVED*** expected
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.notEqual = function (act, exp, msg) ***REMOVED***
        var test = new Assertion(act, msg);

        test.assert(
            exp != flag(test, 'object')
          , 'expected #***REMOVED***this***REMOVED*** to not equal #***REMOVED***exp***REMOVED***'
          , 'expected #***REMOVED***this***REMOVED*** to equal #***REMOVED***act***REMOVED***'
          , exp
          , act
        );
      ***REMOVED***;

      /**
       * ### .strictEqual(actual, expected, [message])
       *
       * Asserts strict equality (`===`) of `actual` and `expected`.
       *
       *     assert.strictEqual(true, true, 'these booleans are strictly equal');
       *
       * @name strictEqual
       * @param ***REMOVED***Mixed***REMOVED*** actual
       * @param ***REMOVED***Mixed***REMOVED*** expected
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.strictEqual = function (act, exp, msg) ***REMOVED***
        new Assertion(act, msg).to.equal(exp);
      ***REMOVED***;

      /**
       * ### .notStrictEqual(actual, expected, [message])
       *
       * Asserts strict inequality (`!==`) of `actual` and `expected`.
       *
       *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
       *
       * @name notStrictEqual
       * @param ***REMOVED***Mixed***REMOVED*** actual
       * @param ***REMOVED***Mixed***REMOVED*** expected
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.notStrictEqual = function (act, exp, msg) ***REMOVED***
        new Assertion(act, msg).to.not.equal(exp);
      ***REMOVED***;

      /**
       * ### .deepEqual(actual, expected, [message])
       *
       * Asserts that `actual` is deeply equal to `expected`.
       *
       *     assert.deepEqual(***REMOVED*** tea: 'green' ***REMOVED***, ***REMOVED*** tea: 'green' ***REMOVED***);
       *
       * @name deepEqual
       * @param ***REMOVED***Mixed***REMOVED*** actual
       * @param ***REMOVED***Mixed***REMOVED*** expected
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.deepEqual = function (act, exp, msg) ***REMOVED***
        new Assertion(act, msg).to.eql(exp);
      ***REMOVED***;

      /**
       * ### .notDeepEqual(actual, expected, [message])
       *
       * Assert that `actual` is not deeply equal to `expected`.
       *
       *     assert.notDeepEqual(***REMOVED*** tea: 'green' ***REMOVED***, ***REMOVED*** tea: 'jasmine' ***REMOVED***);
       *
       * @name notDeepEqual
       * @param ***REMOVED***Mixed***REMOVED*** actual
       * @param ***REMOVED***Mixed***REMOVED*** expected
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.notDeepEqual = function (act, exp, msg) ***REMOVED***
        new Assertion(act, msg).to.not.eql(exp);
      ***REMOVED***;

      /**
       * ### .isTrue(value, [message])
       *
       * Asserts that `value` is true.
       *
       *     var teaServed = true;
       *     assert.isTrue(teaServed, 'the tea has been served');
       *
       * @name isTrue
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isTrue = function (val, msg) ***REMOVED***
        new Assertion(val, msg).is['true'];
      ***REMOVED***;

      /**
       * ### .isFalse(value, [message])
       *
       * Asserts that `value` is false.
       *
       *     var teaServed = false;
       *     assert.isFalse(teaServed, 'no tea yet? hmm...');
       *
       * @name isFalse
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isFalse = function (val, msg) ***REMOVED***
        new Assertion(val, msg).is['false'];
      ***REMOVED***;

      /**
       * ### .isNull(value, [message])
       *
       * Asserts that `value` is null.
       *
       *     assert.isNull(err, 'there was no error');
       *
       * @name isNull
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isNull = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.equal(null);
      ***REMOVED***;

      /**
       * ### .isNotNull(value, [message])
       *
       * Asserts that `value` is not null.
       *
       *     var tea = 'tasty chai';
       *     assert.isNotNull(tea, 'great, time for tea!');
       *
       * @name isNotNull
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isNotNull = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.not.equal(null);
      ***REMOVED***;

      /**
       * ### .isUndefined(value, [message])
       *
       * Asserts that `value` is `undefined`.
       *
       *     var tea;
       *     assert.isUndefined(tea, 'no tea defined');
       *
       * @name isUndefined
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isUndefined = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.equal(undefined);
      ***REMOVED***;

      /**
       * ### .isDefined(value, [message])
       *
       * Asserts that `value` is not `undefined`.
       *
       *     var tea = 'cup of chai';
       *     assert.isDefined(tea, 'tea has been defined');
       *
       * @name isUndefined
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isDefined = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.not.equal(undefined);
      ***REMOVED***;

      /**
       * ### .isFunction(value, [message])
       *
       * Asserts that `value` is a function.
       *
       *     function serveTea() ***REMOVED*** return 'cup of tea'; ***REMOVED***;
       *     assert.isFunction(serveTea, 'great, we can have tea now');
       *
       * @name isFunction
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isFunction = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.be.a('function');
      ***REMOVED***;

      /**
       * ### .isNotFunction(value, [message])
       *
       * Asserts that `value` is _not_ a function.
       *
       *     var serveTea = [ 'heat', 'pour', 'sip' ];
       *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
       *
       * @name isNotFunction
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isNotFunction = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.not.be.a('function');
      ***REMOVED***;

      /**
       * ### .isObject(value, [message])
       *
       * Asserts that `value` is an object (as revealed by
       * `Object.prototype.toString`).
       *
       *     var selection = ***REMOVED*** name: 'Chai', serve: 'with spices' ***REMOVED***;
       *     assert.isObject(selection, 'tea selection is an object');
       *
       * @name isObject
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isObject = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.be.a('object');
      ***REMOVED***;

      /**
       * ### .isNotObject(value, [message])
       *
       * Asserts that `value` is _not_ an object.
       *
       *     var selection = 'chai'
       *     assert.isObject(selection, 'tea selection is not an object');
       *     assert.isObject(null, 'null is not an object');
       *
       * @name isNotObject
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isNotObject = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.not.be.a('object');
      ***REMOVED***;

      /**
       * ### .isArray(value, [message])
       *
       * Asserts that `value` is an array.
       *
       *     var menu = [ 'green', 'chai', 'oolong' ];
       *     assert.isArray(menu, 'what kind of tea do we want?');
       *
       * @name isArray
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isArray = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.be.an('array');
      ***REMOVED***;

      /**
       * ### .isNotArray(value, [message])
       *
       * Asserts that `value` is _not_ an array.
       *
       *     var menu = 'green|chai|oolong';
       *     assert.isNotArray(menu, 'what kind of tea do we want?');
       *
       * @name isNotArray
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isNotArray = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.not.be.an('array');
      ***REMOVED***;

      /**
       * ### .isString(value, [message])
       *
       * Asserts that `value` is a string.
       *
       *     var teaOrder = 'chai';
       *     assert.isString(teaOrder, 'order placed');
       *
       * @name isString
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isString = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.be.a('string');
      ***REMOVED***;

      /**
       * ### .isNotString(value, [message])
       *
       * Asserts that `value` is _not_ a string.
       *
       *     var teaOrder = 4;
       *     assert.isNotString(teaOrder, 'order placed');
       *
       * @name isNotString
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isNotString = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.not.be.a('string');
      ***REMOVED***;

      /**
       * ### .isNumber(value, [message])
       *
       * Asserts that `value` is a number.
       *
       *     var cups = 2;
       *     assert.isNumber(cups, 'how many cups');
       *
       * @name isNumber
       * @param ***REMOVED***Number***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isNumber = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.be.a('number');
      ***REMOVED***;

      /**
       * ### .isNotNumber(value, [message])
       *
       * Asserts that `value` is _not_ a number.
       *
       *     var cups = '2 cups please';
       *     assert.isNotNumber(cups, 'how many cups');
       *
       * @name isNotNumber
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isNotNumber = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.not.be.a('number');
      ***REMOVED***;

      /**
       * ### .isBoolean(value, [message])
       *
       * Asserts that `value` is a boolean.
       *
       *     var teaReady = true
       *       , teaServed = false;
       *
       *     assert.isBoolean(teaReady, 'is the tea ready');
       *     assert.isBoolean(teaServed, 'has tea been served');
       *
       * @name isBoolean
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isBoolean = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.be.a('boolean');
      ***REMOVED***;

      /**
       * ### .isNotBoolean(value, [message])
       *
       * Asserts that `value` is _not_ a boolean.
       *
       *     var teaReady = 'yep'
       *       , teaServed = 'nope';
       *
       *     assert.isNotBoolean(teaReady, 'is the tea ready');
       *     assert.isNotBoolean(teaServed, 'has tea been served');
       *
       * @name isNotBoolean
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.isNotBoolean = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.not.be.a('boolean');
      ***REMOVED***;

      /**
       * ### .typeOf(value, name, [message])
       *
       * Asserts that `value`'s type is `name`, as determined by
       * `Object.prototype.toString`.
       *
       *     assert.typeOf(***REMOVED*** tea: 'chai' ***REMOVED***, 'object', 'we have an object');
       *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
       *     assert.typeOf('tea', 'string', 'we have a string');
       *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
       *     assert.typeOf(null, 'null', 'we have a null');
       *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
       *
       * @name typeOf
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** name
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.typeOf = function (val, type, msg) ***REMOVED***
        new Assertion(val, msg).to.be.a(type);
      ***REMOVED***;

      /**
       * ### .notTypeOf(value, name, [message])
       *
       * Asserts that `value`'s type is _not_ `name`, as determined by
       * `Object.prototype.toString`.
       *
       *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
       *
       * @name notTypeOf
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** typeof name
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.notTypeOf = function (val, type, msg) ***REMOVED***
        new Assertion(val, msg).to.not.be.a(type);
      ***REMOVED***;

      /**
       * ### .instanceOf(object, constructor, [message])
       *
       * Asserts that `value` is an instance of `constructor`.
       *
       *     var Tea = function (name) ***REMOVED*** this.name = name; ***REMOVED***
       *       , chai = new Tea('chai');
       *
       *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
       *
       * @name instanceOf
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***Constructor***REMOVED*** constructor
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.instanceOf = function (val, type, msg) ***REMOVED***
        new Assertion(val, msg).to.be.instanceOf(type);
      ***REMOVED***;

      /**
       * ### .notInstanceOf(object, constructor, [message])
       *
       * Asserts `value` is not an instance of `constructor`.
       *
       *     var Tea = function (name) ***REMOVED*** this.name = name; ***REMOVED***
       *       , chai = new String('chai');
       *
       *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
       *
       * @name notInstanceOf
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***Constructor***REMOVED*** constructor
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.notInstanceOf = function (val, type, msg) ***REMOVED***
        new Assertion(val, msg).to.not.be.instanceOf(type);
      ***REMOVED***;

      /**
       * ### .include(haystack, needle, [message])
       *
       * Asserts that `haystack` includes `needle`. Works
       * for strings and arrays.
       *
       *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
       *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
       *
       * @name include
       * @param ***REMOVED***Array|String***REMOVED*** haystack
       * @param ***REMOVED***Mixed***REMOVED*** needle
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.include = function (exp, inc, msg) ***REMOVED***
        var obj = new Assertion(exp, msg);

        if (Array.isArray(exp)) ***REMOVED***
          obj.to.include(inc);
        ***REMOVED*** else if ('string' === typeof exp) ***REMOVED***
          obj.to.contain.string(inc);
        ***REMOVED***
      ***REMOVED***;

      /**
       * ### .match(value, regexp, [message])
       *
       * Asserts that `value` matches the regular expression `regexp`.
       *
       *     assert.match('foobar', /^foo/, 'regexp matches');
       *
       * @name match
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***RegExp***REMOVED*** regexp
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.match = function (exp, re, msg) ***REMOVED***
        new Assertion(exp, msg).to.match(re);
      ***REMOVED***;

      /**
       * ### .notMatch(value, regexp, [message])
       *
       * Asserts that `value` does not match the regular expression `regexp`.
       *
       *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
       *
       * @name notMatch
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***RegExp***REMOVED*** regexp
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.notMatch = function (exp, re, msg) ***REMOVED***
        new Assertion(exp, msg).to.not.match(re);
      ***REMOVED***;

      /**
       * ### .property(object, property, [message])
       *
       * Asserts that `object` has a property named by `property`.
       *
       *     assert.property(***REMOVED*** tea: ***REMOVED*** green: 'matcha' ***REMOVED******REMOVED***, 'tea');
       *
       * @name property
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***String***REMOVED*** property
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.property = function (obj, prop, msg) ***REMOVED***
        new Assertion(obj, msg).to.have.property(prop);
      ***REMOVED***;

      /**
       * ### .notProperty(object, property, [message])
       *
       * Asserts that `object` does _not_ have a property named by `property`.
       *
       *     assert.notProperty(***REMOVED*** tea: ***REMOVED*** green: 'matcha' ***REMOVED******REMOVED***, 'coffee');
       *
       * @name notProperty
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***String***REMOVED*** property
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.notProperty = function (obj, prop, msg) ***REMOVED***
        new Assertion(obj, msg).to.not.have.property(prop);
      ***REMOVED***;

      /**
       * ### .deepProperty(object, property, [message])
       *
       * Asserts that `object` has a property named by `property`, which can be a
       * string using dot- and bracket-notation for deep reference.
       *
       *     assert.deepProperty(***REMOVED*** tea: ***REMOVED*** green: 'matcha' ***REMOVED******REMOVED***, 'tea.green');
       *
       * @name deepProperty
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***String***REMOVED*** property
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.deepProperty = function (obj, prop, msg) ***REMOVED***
        new Assertion(obj, msg).to.have.deep.property(prop);
      ***REMOVED***;

      /**
       * ### .notDeepProperty(object, property, [message])
       *
       * Asserts that `object` does _not_ have a property named by `property`, which
       * can be a string using dot- and bracket-notation for deep reference.
       *
       *     assert.notDeepProperty(***REMOVED*** tea: ***REMOVED*** green: 'matcha' ***REMOVED******REMOVED***, 'tea.oolong');
       *
       * @name notDeepProperty
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***String***REMOVED*** property
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.notDeepProperty = function (obj, prop, msg) ***REMOVED***
        new Assertion(obj, msg).to.not.have.deep.property(prop);
      ***REMOVED***;

      /**
       * ### .propertyVal(object, property, value, [message])
       *
       * Asserts that `object` has a property named by `property` with value given
       * by `value`.
       *
       *     assert.propertyVal(***REMOVED*** tea: 'is good' ***REMOVED***, 'tea', 'is good');
       *
       * @name propertyVal
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***String***REMOVED*** property
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.propertyVal = function (obj, prop, val, msg) ***REMOVED***
        new Assertion(obj, msg).to.have.property(prop, val);
      ***REMOVED***;

      /**
       * ### .propertyNotVal(object, property, value, [message])
       *
       * Asserts that `object` has a property named by `property`, but with a value
       * different from that given by `value`.
       *
       *     assert.propertyNotVal(***REMOVED*** tea: 'is good' ***REMOVED***, 'tea', 'is bad');
       *
       * @name propertyNotVal
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***String***REMOVED*** property
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.propertyNotVal = function (obj, prop, val, msg) ***REMOVED***
        new Assertion(obj, msg).to.not.have.property(prop, val);
      ***REMOVED***;

      /**
       * ### .deepPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` has a property named by `property` with value given
       * by `value`. `property` can use dot- and bracket-notation for deep
       * reference.
       *
       *     assert.deepPropertyVal(***REMOVED*** tea: ***REMOVED*** green: 'matcha' ***REMOVED******REMOVED***, 'tea.green', 'matcha');
       *
       * @name deepPropertyVal
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***String***REMOVED*** property
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.deepPropertyVal = function (obj, prop, val, msg) ***REMOVED***
        new Assertion(obj, msg).to.have.deep.property(prop, val);
      ***REMOVED***;

      /**
       * ### .deepPropertyNotVal(object, property, value, [message])
       *
       * Asserts that `object` has a property named by `property`, but with a value
       * different from that given by `value`. `property` can use dot- and
       * bracket-notation for deep reference.
       *
       *     assert.deepPropertyNotVal(***REMOVED*** tea: ***REMOVED*** green: 'matcha' ***REMOVED******REMOVED***, 'tea.green', 'konacha');
       *
       * @name deepPropertyNotVal
       * @param ***REMOVED***Object***REMOVED*** object
       * @param ***REMOVED***String***REMOVED*** property
       * @param ***REMOVED***Mixed***REMOVED*** value
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.deepPropertyNotVal = function (obj, prop, val, msg) ***REMOVED***
        new Assertion(obj, msg).to.not.have.deep.property(prop, val);
      ***REMOVED***;

      /**
       * ### .lengthOf(object, length, [message])
       *
       * Asserts that `object` has a `length` property with the expected value.
       *
       *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
       *     assert.lengthOf('foobar', 5, 'string has length of 6');
       *
       * @name lengthOf
       * @param ***REMOVED***Mixed***REMOVED*** object
       * @param ***REMOVED***Number***REMOVED*** length
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.lengthOf = function (exp, len, msg) ***REMOVED***
        new Assertion(exp, msg).to.have.length(len);
      ***REMOVED***;

      /**
       * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
       *
       * Asserts that `function` will throw an error that is an instance of
       * `constructor`, or alternately that it will throw an error with message
       * matching `regexp`.
       *
       *     assert.throw(fn, 'function throws a reference error');
       *     assert.throw(fn, /function throws a reference error/);
       *     assert.throw(fn, ReferenceError);
       *     assert.throw(fn, ReferenceError, 'function throws a reference error');
       *     assert.throw(fn, ReferenceError, /function throws a reference error/);
       *
       * @name throws
       * @alias throw
       * @alias Throw
       * @param ***REMOVED***Function***REMOVED*** function
       * @param ***REMOVED***ErrorConstructor***REMOVED*** constructor
       * @param ***REMOVED***RegExp***REMOVED*** regexp
       * @param ***REMOVED***String***REMOVED*** message
       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
       * @api public
       */

      assert.Throw = function (fn, errt, errs, msg) ***REMOVED***
        if ('string' === typeof errt || errt instanceof RegExp) ***REMOVED***
          errs = errt;
          errt = null;
        ***REMOVED***

        new Assertion(fn, msg).to.Throw(errt, errs);
      ***REMOVED***;

      /**
       * ### .doesNotThrow(function, [constructor/regexp], [message])
       *
       * Asserts that `function` will _not_ throw an error that is an instance of
       * `constructor`, or alternately that it will not throw an error with message
       * matching `regexp`.
       *
       *     assert.doesNotThrow(fn, Error, 'function does not throw');
       *
       * @name doesNotThrow
       * @param ***REMOVED***Function***REMOVED*** function
       * @param ***REMOVED***ErrorConstructor***REMOVED*** constructor
       * @param ***REMOVED***RegExp***REMOVED*** regexp
       * @param ***REMOVED***String***REMOVED*** message
       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
       * @api public
       */

      assert.doesNotThrow = function (fn, type, msg) ***REMOVED***
        if ('string' === typeof type) ***REMOVED***
          msg = type;
          type = null;
        ***REMOVED***

        new Assertion(fn, msg).to.not.Throw(type);
      ***REMOVED***;

      /**
       * ### .operator(val1, operator, val2, [message])
       *
       * Compares two values using `operator`.
       *
       *     assert.operator(1, '<', 2, 'everything is ok');
       *     assert.operator(1, '>', 2, 'this will fail');
       *
       * @name operator
       * @param ***REMOVED***Mixed***REMOVED*** val1
       * @param ***REMOVED***String***REMOVED*** operator
       * @param ***REMOVED***Mixed***REMOVED*** val2
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.operator = function (val, operator, val2, msg) ***REMOVED***
        if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) ***REMOVED***
          throw new Error('Invalid operator "' + operator + '"');
        ***REMOVED***
        var test = new Assertion(eval(val + operator + val2), msg);
        test.assert(
            true === flag(test, 'object')
          , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
          , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
      ***REMOVED***;

      /**
       * ### .closeTo(actual, expected, delta, [message])
       *
       * Asserts that the target is equal `expected`, to within a +/- `delta` range.
       *
       *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
       *
       * @name closeTo
       * @param ***REMOVED***Number***REMOVED*** actual
       * @param ***REMOVED***Number***REMOVED*** expected
       * @param ***REMOVED***Number***REMOVED*** delta
       * @param ***REMOVED***String***REMOVED*** message
       * @api public
       */

      assert.closeTo = function (act, exp, delta, msg) ***REMOVED***
        new Assertion(act, msg).to.be.closeTo(exp, delta);
      ***REMOVED***;

      /*!
       * Undocumented / untested
       */

      assert.ifError = function (val, msg) ***REMOVED***
        new Assertion(val, msg).to.not.be.ok;
      ***REMOVED***;

      /*!
       * Aliases.
       */

      (function alias(name, as)***REMOVED***
        assert[as] = assert[name];
        return alias;
      ***REMOVED***)
      ('Throw', 'throw')
      ('Throw', 'throws');
    ***REMOVED***;

  ***REMOVED***); // module: chai/interface/assert.js

  require.register("chai/interface/expect.js", function(module, exports, require)***REMOVED***
    /*!
     * chai
     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    module.exports = function (chai, util) ***REMOVED***
      chai.expect = function (val, message) ***REMOVED***
        return new chai.Assertion(val, message);
      ***REMOVED***;
    ***REMOVED***;


  ***REMOVED***); // module: chai/interface/expect.js

  require.register("chai/interface/should.js", function(module, exports, require)***REMOVED***
    /*!
     * chai
     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    module.exports = function (chai, util) ***REMOVED***
      var Assertion = chai.Assertion;

      function loadShould () ***REMOVED***
        // modify Object.prototype to have `should`
        Object.defineProperty(Object.prototype, 'should',
          ***REMOVED***
            set: function (value) ***REMOVED***
              // See https://github.com/chaijs/chai/issues/86: this makes
              // `whatever.should = someValue` actually set `someValue`, which is
              // especially useful for `global.should = require('chai').should()`.
              //
              // Note that we have to use [[DefineProperty]] instead of [[Put]]
              // since otherwise we would trigger this very setter!
              Object.defineProperty(this, 'should', ***REMOVED***
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              ***REMOVED***);
            ***REMOVED***
          , get: function()***REMOVED***
              if (this instanceof String || this instanceof Number) ***REMOVED***
                return new Assertion(this.constructor(this));
              ***REMOVED*** else if (this instanceof Boolean) ***REMOVED***
                return new Assertion(this == true);
              ***REMOVED***
              return new Assertion(this);
            ***REMOVED***
          , configurable: true
        ***REMOVED***);

        var should = ***REMOVED******REMOVED***;

        should.equal = function (val1, val2, msg) ***REMOVED***
          new Assertion(val1, msg).to.equal(val2);
        ***REMOVED***;

        should.Throw = function (fn, errt, errs, msg) ***REMOVED***
          new Assertion(fn, msg).to.Throw(errt, errs);
        ***REMOVED***;

        should.exist = function (val, msg) ***REMOVED***
          new Assertion(val, msg).to.exist;
        ***REMOVED***

        // negation
        should.not = ***REMOVED******REMOVED***

        should.not.equal = function (val1, val2, msg) ***REMOVED***
          new Assertion(val1, msg).to.not.equal(val2);
        ***REMOVED***;

        should.not.Throw = function (fn, errt, errs, msg) ***REMOVED***
          new Assertion(fn, msg).to.not.Throw(errt, errs);
        ***REMOVED***;

        should.not.exist = function (val, msg) ***REMOVED***
          new Assertion(val, msg).to.not.exist;
        ***REMOVED***

        should['throw'] = should['Throw'];
        should.not['throw'] = should.not['Throw'];

        return should;
      ***REMOVED***;

      chai.should = loadShould;
      chai.Should = loadShould;
    ***REMOVED***;

  ***REMOVED***); // module: chai/interface/should.js

  require.register("chai/utils/addChainableMethod.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - addChainingMethod utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependencies
     */

    var transferFlags = require('./transferFlags');

    /*!
     * Module variables
     */

    // Check whether `__proto__` is supported
    var hasProtoSupport = '__proto__' in Object;

    // Without `__proto__` support, this module will need to add properties to a function.
    // However, some Function.prototype methods cannot be overwritten,
    // and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
    var excludeNames = /^(?:length|name|arguments|caller)$/;

    /**
     * ### addChainableMethod (ctx, name, method, chainingBehavior)
     *
     * Adds a method to an object, such that the method can also be chained.
     *
     *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) ***REMOVED***
     *       var obj = utils.flag(this, 'object');
     *       new chai.Assertion(obj).to.be.equal(str);
     *     ***REMOVED***);
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
     *
     * The result can then be used as both a method assertion, executing both `method` and
     * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
     *
     *     expect(fooStr).to.be.foo('bar');
     *     expect(fooStr).to.be.foo.equal('foo');
     *
     * @param ***REMOVED***Object***REMOVED*** ctx object to which the method is added
     * @param ***REMOVED***String***REMOVED*** name of method to add
     * @param ***REMOVED***Function***REMOVED*** method function to be used for `name`, when called
     * @param ***REMOVED***Function***REMOVED*** chainingBehavior function to be called every time the property is accessed
     * @name addChainableMethod
     * @api public
     */

    module.exports = function (ctx, name, method, chainingBehavior) ***REMOVED***
      if (typeof chainingBehavior !== 'function')
        chainingBehavior = function () ***REMOVED*** ***REMOVED***;

      Object.defineProperty(ctx, name,
        ***REMOVED*** get: function () ***REMOVED***
            chainingBehavior.call(this);

            var assert = function () ***REMOVED***
              var result = method.apply(this, arguments);
              return result === undefined ? this : result;
            ***REMOVED***;

            // Use `__proto__` if available
            if (hasProtoSupport) ***REMOVED***
              assert.__proto__ = this;
            ***REMOVED***
            // Otherwise, redefine all properties (slow!)
            else ***REMOVED***
              var asserterNames = Object.getOwnPropertyNames(ctx);
              asserterNames.forEach(function (asserterName) ***REMOVED***
                if (!excludeNames.test(asserterName)) ***REMOVED***
                  var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
                  Object.defineProperty(assert, asserterName, pd);
                ***REMOVED***
              ***REMOVED***);
            ***REMOVED***

            transferFlags(this, assert);
            return assert;
          ***REMOVED***
        , configurable: true
      ***REMOVED***);
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/addChainableMethod.js

  require.register("chai/utils/addMethod.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - addMethod utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .addMethod (ctx, name, method)
     *
     * Adds a method to the prototype of an object.
     *
     *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) ***REMOVED***
     *       var obj = utils.flag(this, 'object');
     *       new chai.Assertion(obj).to.be.equal(str);
     *     ***REMOVED***);
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.addMethod('foo', fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(fooStr).to.be.foo('bar');
     *
     * @param ***REMOVED***Object***REMOVED*** ctx object to which the method is added
     * @param ***REMOVED***String***REMOVED*** name of method to add
     * @param ***REMOVED***Function***REMOVED*** method function to be used for name
     * @name addMethod
     * @api public
     */

    module.exports = function (ctx, name, method) ***REMOVED***
      ctx[name] = function () ***REMOVED***
        var result = method.apply(this, arguments);
        return result === undefined ? this : result;
      ***REMOVED***;
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/addMethod.js

  require.register("chai/utils/addProperty.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - addProperty utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### addProperty (ctx, name, getter)
     *
     * Adds a property to the prototype of an object.
     *
     *     utils.addProperty(chai.Assertion.prototype, 'foo', function () ***REMOVED***
     *       var obj = utils.flag(this, 'object');
     *       new chai.Assertion(obj).to.be.instanceof(Foo);
     *     ***REMOVED***);
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.addProperty('foo', fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.be.foo;
     *
     * @param ***REMOVED***Object***REMOVED*** ctx object to which the property is added
     * @param ***REMOVED***String***REMOVED*** name of property to add
     * @param ***REMOVED***Function***REMOVED*** getter function to be used for name
     * @name addProperty
     * @api public
     */

    module.exports = function (ctx, name, getter) ***REMOVED***
      Object.defineProperty(ctx, name,
        ***REMOVED*** get: function () ***REMOVED***
            var result = getter.call(this);
            return result === undefined ? this : result;
          ***REMOVED***
        , configurable: true
      ***REMOVED***);
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/addProperty.js

  require.register("chai/utils/eql.js", function(module, exports, require)***REMOVED***
    // This is (almost) directly from Node.js assert
    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/assert.js

    module.exports = _deepEqual;

    var getEnumerableProperties = require('./getEnumerableProperties');

    // for the browser
    var Buffer;
    try ***REMOVED***
      Buffer = require('buffer').Buffer;
    ***REMOVED*** catch (ex) ***REMOVED***
      Buffer = ***REMOVED***
        isBuffer: function () ***REMOVED*** return false; ***REMOVED***
      ***REMOVED***;
    ***REMOVED***

    function _deepEqual(actual, expected, memos) ***REMOVED***

      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) ***REMOVED***
        return true;

      ***REMOVED*** else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) ***REMOVED***
        if (actual.length != expected.length) return false;

        for (var i = 0; i < actual.length; i++) ***REMOVED***
          if (actual[i] !== expected[i]) return false;
        ***REMOVED***

        return true;

      // 7.2. If the expected value is a Date object, the actual value is
      // equivalent if it is also a Date object that refers to the same time.
      ***REMOVED*** else if (actual instanceof Date && expected instanceof Date) ***REMOVED***
        return actual.getTime() === expected.getTime();

      // 7.3. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      ***REMOVED*** else if (typeof actual != 'object' && typeof expected != 'object') ***REMOVED***
        return actual === expected;

      // 7.4. For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      ***REMOVED*** else ***REMOVED***
        return objEquiv(actual, expected, memos);
      ***REMOVED***
    ***REMOVED***

    function isUndefinedOrNull(value) ***REMOVED***
      return value === null || value === undefined;
    ***REMOVED***

    function isArguments(object) ***REMOVED***
      return Object.prototype.toString.call(object) == '[object Arguments]';
    ***REMOVED***

    function objEquiv(a, b, memos) ***REMOVED***
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
        return false;

      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;

      // check if we have already compared a and b
      var i;
      if (memos) ***REMOVED***
        for(i = 0; i < memos.length; i++) ***REMOVED***
          if ((memos[i][0] === a && memos[i][1] === b) ||
              (memos[i][0] === b && memos[i][1] === a))
            return true;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        memos = [];
      ***REMOVED***

      //~~~I've managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (isArguments(a)) ***REMOVED***
        if (!isArguments(b)) ***REMOVED***
          return false;
        ***REMOVED***
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b, memos);
      ***REMOVED***
      try ***REMOVED***
        var ka = getEnumerableProperties(a),
            kb = getEnumerableProperties(b),
            key;
      ***REMOVED*** catch (e) ***REMOVED***//happens when one is a string literal and the other isn't
        return false;
      ***REMOVED***

      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;

      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) ***REMOVED***
        if (ka[i] != kb[i])
          return false;
      ***REMOVED***

      // remember objects we have compared to guard against circular references
      memos.push([ a, b ]);

      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) ***REMOVED***
        key = ka[i];
        if (!_deepEqual(a[key], b[key], memos)) return false;
      ***REMOVED***

      return true;
    ***REMOVED***

  ***REMOVED***); // module: chai/utils/eql.js

  require.register("chai/utils/flag.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - flag utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### flag(object ,key, [value])
     *
     * Get or set a flag value on an object. If a
     * value is provided it will be set, else it will
     * return the currently set value or `undefined` if
     * the value is not set.
     *
     *     utils.flag(this, 'foo', 'bar'); // setter
     *     utils.flag(this, 'foo'); // getter, returns `bar`
     *
     * @param ***REMOVED***Object***REMOVED*** object (constructed Assertion
     * @param ***REMOVED***String***REMOVED*** key
     * @param ***REMOVED***Mixed***REMOVED*** value (optional)
     * @name flag
     * @api private
     */

    module.exports = function (obj, key, value) ***REMOVED***
      var flags = obj.__flags || (obj.__flags = Object.create(null));
      if (arguments.length === 3) ***REMOVED***
        flags[key] = value;
      ***REMOVED*** else ***REMOVED***
        return flags[key];
      ***REMOVED***
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/flag.js

  require.register("chai/utils/getActual.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - getActual utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * # getActual(object, [actual])
     *
     * Returns the `actual` value for an Assertion
     *
     * @param ***REMOVED***Object***REMOVED*** object (constructed Assertion)
     * @param ***REMOVED***Arguments***REMOVED*** chai.Assertion.prototype.assert arguments
     */

    module.exports = function (obj, args) ***REMOVED***
      var actual = args[4];
      return 'undefined' !== typeof actual ? actual : obj._obj;
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/getActual.js

  require.register("chai/utils/getEnumerableProperties.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - getEnumerableProperties utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .getEnumerableProperties(object)
     *
     * This allows the retrieval of enumerable property names of an object,
     * inherited or not.
     *
     * @param ***REMOVED***Object***REMOVED*** object
     * @returns ***REMOVED***Array***REMOVED***
     * @name getEnumerableProperties
     * @api public
     */

    module.exports = function getEnumerableProperties(object) ***REMOVED***
      var result = [];
      for (var name in object) ***REMOVED***
        result.push(name);
      ***REMOVED***
      return result;
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/getEnumerableProperties.js

  require.register("chai/utils/getMessage.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - message composition utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */

    var flag = require('./flag')
      , getActual = require('./getActual')
      , inspect = require('./inspect')
      , objDisplay = require('./objDisplay');

    /**
     * ### .getMessage(object, message, negateMessage)
     *
     * Construct the error message based on flags
     * and template tags. Template tags will return
     * a stringified inspection of the object referenced.
     *
     * Messsage template tags:
     * - `#***REMOVED***this***REMOVED***` current asserted object
     * - `#***REMOVED***act***REMOVED***` actual value
     * - `#***REMOVED***exp***REMOVED***` expected value
     *
     * @param ***REMOVED***Object***REMOVED*** object (constructed Assertion)
     * @param ***REMOVED***Arguments***REMOVED*** chai.Assertion.prototype.assert arguments
     * @name getMessage
     * @api public
     */

    module.exports = function (obj, args) ***REMOVED***
      var negate = flag(obj, 'negate')
        , val = flag(obj, 'object')
        , expected = args[3]
        , actual = getActual(obj, args)
        , msg = negate ? args[2] : args[1]
        , flagMsg = flag(obj, 'message');

      msg = msg || '';
      msg = msg
        .replace(/#***REMOVED***this***REMOVED***/g, objDisplay(val))
        .replace(/#***REMOVED***act***REMOVED***/g, objDisplay(actual))
        .replace(/#***REMOVED***exp***REMOVED***/g, objDisplay(expected));

      return flagMsg ? flagMsg + ': ' + msg : msg;
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/getMessage.js

  require.register("chai/utils/getName.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - getName utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * # getName(func)
     *
     * Gets the name of a function, in a cross-browser way.
     *
     * @param ***REMOVED***Function***REMOVED*** a function (usually a constructor)
     */

    module.exports = function (func) ***REMOVED***
      if (func.name) return func.name;

      var match = /^\s?function ([^(]*)\(/.exec(func);
      return match && match[1] ? match[1] : "";
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/getName.js

  require.register("chai/utils/getPathValue.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - getPathValue utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * @see https://github.com/logicalparadox/filtr
     * MIT Licensed
     */

    /**
     * ### .getPathValue(path, object)
     *
     * This allows the retrieval of values in an
     * object given a string path.
     *
     *     var obj = ***REMOVED***
     *         prop1: ***REMOVED***
     *             arr: ['a', 'b', 'c']
     *           , str: 'Hello'
     *         ***REMOVED***
     *       , prop2: ***REMOVED***
     *             arr: [ ***REMOVED*** nested: 'Universe' ***REMOVED*** ]
     *           , str: 'Hello again!'
     *         ***REMOVED***
     *     ***REMOVED***
     *
     * The following would be the results.
     *
     *     getPathValue('prop1.str', obj); // Hello
     *     getPathValue('prop1.att[2]', obj); // b
     *     getPathValue('prop2.arr[0].nested', obj); // Universe
     *
     * @param ***REMOVED***String***REMOVED*** path
     * @param ***REMOVED***Object***REMOVED*** object
     * @returns ***REMOVED***Object***REMOVED*** value or `undefined`
     * @name getPathValue
     * @api public
     */

    var getPathValue = module.exports = function (path, obj) ***REMOVED***
      var parsed = parsePath(path);
      return _getPathValue(parsed, obj);
    ***REMOVED***;

    /*!
     * ## parsePath(path)
     *
     * Helper function used to parse string object
     * paths. Use in conjunction with `_getPathValue`.
     *
     *      var parsed = parsePath('myobject.property.subprop');
     *
     * ### Paths:
     *
     * * Can be as near infinitely deep and nested
     * * Arrays are also valid using the formal `myobject.document[3].property`.
     *
     * @param ***REMOVED***String***REMOVED*** path
     * @returns ***REMOVED***Object***REMOVED*** parsed
     * @api private
     */

    function parsePath (path) ***REMOVED***
      var str = path.replace(/\[/g, '.[')
        , parts = str.match(/(\\\.|[^.]+?)+/g);
      return parts.map(function (value) ***REMOVED***
        var re = /\[(\d+)\]$/
          , mArr = re.exec(value)
        if (mArr) return ***REMOVED*** i: parseFloat(mArr[1]) ***REMOVED***;
        else return ***REMOVED*** p: value ***REMOVED***;
      ***REMOVED***);
    ***REMOVED***;

    /*!
     * ## _getPathValue(parsed, obj)
     *
     * Helper companion function for `.parsePath` that returns
     * the value located at the parsed address.
     *
     *      var value = getPathValue(parsed, obj);
     *
     * @param ***REMOVED***Object***REMOVED*** parsed definition from `parsePath`.
     * @param ***REMOVED***Object***REMOVED*** object to search against
     * @returns ***REMOVED***Object|Undefined***REMOVED*** value
     * @api private
     */

    function _getPathValue (parsed, obj) ***REMOVED***
      var tmp = obj
        , res;
      for (var i = 0, l = parsed.length; i < l; i++) ***REMOVED***
        var part = parsed[i];
        if (tmp) ***REMOVED***
          if ('undefined' !== typeof part.p)
            tmp = tmp[part.p];
          else if ('undefined' !== typeof part.i)
            tmp = tmp[part.i];
          if (i == (l - 1)) res = tmp;
        ***REMOVED*** else ***REMOVED***
          res = undefined;
        ***REMOVED***
      ***REMOVED***
      return res;
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/getPathValue.js

  require.register("chai/utils/getProperties.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - getProperties utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .getProperties(object)
     *
     * This allows the retrieval of property names of an object, enumerable or not,
     * inherited or not.
     *
     * @param ***REMOVED***Object***REMOVED*** object
     * @returns ***REMOVED***Array***REMOVED***
     * @name getProperties
     * @api public
     */

    module.exports = function getProperties(object) ***REMOVED***
      var result = Object.getOwnPropertyNames(subject);

      function addProperty(property) ***REMOVED***
        if (result.indexOf(property) === -1) ***REMOVED***
          result.push(property);
        ***REMOVED***
      ***REMOVED***

      var proto = Object.getPrototypeOf(subject);
      while (proto !== null) ***REMOVED***
        Object.getOwnPropertyNames(proto).forEach(addProperty);
        proto = Object.getPrototypeOf(proto);
      ***REMOVED***

      return result;
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/getProperties.js

  require.register("chai/utils/index.js", function(module, exports, require)***REMOVED***
    /*!
     * chai
     * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Main exports
     */

    var exports = module.exports = ***REMOVED******REMOVED***;

    /*!
     * test utility
     */

    exports.test = require('./test');

    /*!
     * type utility
     */

    exports.type = require('./type');

    /*!
     * message utility
     */

    exports.getMessage = require('./getMessage');

    /*!
     * actual utility
     */

    exports.getActual = require('./getActual');

    /*!
     * Inspect util
     */

    exports.inspect = require('./inspect');

    /*!
     * Object Display util
     */

    exports.objDisplay = require('./objDisplay');

    /*!
     * Flag utility
     */

    exports.flag = require('./flag');

    /*!
     * Flag transferring utility
     */

    exports.transferFlags = require('./transferFlags');

    /*!
     * Deep equal utility
     */

    exports.eql = require('./eql');

    /*!
     * Deep path value
     */

    exports.getPathValue = require('./getPathValue');

    /*!
     * Function name
     */

    exports.getName = require('./getName');

    /*!
     * add Property
     */

    exports.addProperty = require('./addProperty');

    /*!
     * add Method
     */

    exports.addMethod = require('./addMethod');

    /*!
     * overwrite Property
     */

    exports.overwriteProperty = require('./overwriteProperty');

    /*!
     * overwrite Method
     */

    exports.overwriteMethod = require('./overwriteMethod');

    /*!
     * Add a chainable method
     */

    exports.addChainableMethod = require('./addChainableMethod');


  ***REMOVED***); // module: chai/utils/index.js

  require.register("chai/utils/inspect.js", function(module, exports, require)***REMOVED***
    // This is (almost) directly from Node.js utils
    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

    var getName = require('./getName');
    var getProperties = require('./getProperties');
    var getEnumerableProperties = require('./getEnumerableProperties');

    module.exports = inspect;

    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param ***REMOVED***Object***REMOVED*** obj The object to print out.
     * @param ***REMOVED***Boolean***REMOVED*** showHidden Flag that shows hidden (not enumerable)
     *    properties of objects.
     * @param ***REMOVED***Number***REMOVED*** depth Depth in which to descend in object. Default is 2.
     * @param ***REMOVED***Boolean***REMOVED*** colors Flag to turn on ANSI escape codes to color the
     *    output. Default is false (no coloring).
     */
    function inspect(obj, showHidden, depth, colors) ***REMOVED***
      var ctx = ***REMOVED***
        showHidden: showHidden,
        seen: [],
        stylize: function (str) ***REMOVED*** return str; ***REMOVED***
      ***REMOVED***;
      return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
    ***REMOVED***

    // https://gist.github.com/1044128/
    var getOuterHTML = function(element) ***REMOVED***
      if ('outerHTML' in element) return element.outerHTML;
      var ns = "http://www.w3.org/1999/xhtml";
      var container = document.createElementNS(ns, '_');
      var elemProto = (window.HTMLElement || window.Element).prototype;
      var xmlSerializer = new XMLSerializer();
      var html;
      if (document.xmlVersion) ***REMOVED***
        return xmlSerializer.serializeToString(element);
      ***REMOVED*** else ***REMOVED***
        container.appendChild(element.cloneNode(false));
        html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
        container.innerHTML = '';
        return html;
      ***REMOVED***
    ***REMOVED***;

    // Returns true if object is a DOM element.
    var isDOMElement = function (object) ***REMOVED***
      if (typeof HTMLElement === 'object') ***REMOVED***
        return object instanceof HTMLElement;
      ***REMOVED*** else ***REMOVED***
        return object &&
          typeof object === 'object' &&
          object.nodeType === 1 &&
          typeof object.nodeName === 'string';
      ***REMOVED***
    ***REMOVED***;

    function formatValue(ctx, value, recurseTimes) ***REMOVED***
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (value && typeof value.inspect === 'function' &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== exports.inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) ***REMOVED***
        return value.inspect(recurseTimes);
      ***REMOVED***

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) ***REMOVED***
        return primitive;
      ***REMOVED***

      // If it's DOM elem, get outer HTML.
      if (isDOMElement(value)) ***REMOVED***
        return getOuterHTML(value);
      ***REMOVED***

      // Look up the keys of the object.
      var visibleKeys = getEnumerableProperties(value);
      var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

      // Some type of object without properties can be shortcutted.
      // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
      // a `stack` plus `description` property; ignore those for consistency.
      if (keys.length === 0 || (isError(value) && (
          (keys.length === 1 && keys[0] === 'stack') ||
          (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
         ))) ***REMOVED***
        if (typeof value === 'function') ***REMOVED***
          var name = getName(value);
          var nameSuffix = name ? ': ' + name : '';
          return ctx.stylize('[Function' + nameSuffix + ']', 'special');
        ***REMOVED***
        if (isRegExp(value)) ***REMOVED***
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        ***REMOVED***
        if (isDate(value)) ***REMOVED***
          return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
        ***REMOVED***
        if (isError(value)) ***REMOVED***
          return formatError(value);
        ***REMOVED***
      ***REMOVED***

      var base = '', array = false, braces = ['***REMOVED***', '***REMOVED***'];

      // Make Array say that they are Array
      if (isArray(value)) ***REMOVED***
        array = true;
        braces = ['[', ']'];
      ***REMOVED***

      // Make functions say that they are functions
      if (typeof value === 'function') ***REMOVED***
        var name = getName(value);
        var nameSuffix = name ? ': ' + name : '';
        base = ' [Function' + nameSuffix + ']';
      ***REMOVED***

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) ***REMOVED***
        base = ' ' + RegExp.prototype.toString.call(value);
      ***REMOVED***

      // Make dates with properties first say the date
      if (isDate(value)) ***REMOVED***
        base = ' ' + Date.prototype.toUTCString.call(value);
      ***REMOVED***

      // Make error with message first say the error
      if (isError(value)) ***REMOVED***
        return formatError(value);
      ***REMOVED***

      if (keys.length === 0 && (!array || value.length == 0)) ***REMOVED***
        return braces[0] + base + braces[1];
      ***REMOVED***

      if (recurseTimes < 0) ***REMOVED***
        if (isRegExp(value)) ***REMOVED***
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        ***REMOVED*** else ***REMOVED***
          return ctx.stylize('[Object]', 'special');
        ***REMOVED***
      ***REMOVED***

      ctx.seen.push(value);

      var output;
      if (array) ***REMOVED***
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      ***REMOVED*** else ***REMOVED***
        output = keys.map(function(key) ***REMOVED***
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        ***REMOVED***);
      ***REMOVED***

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    ***REMOVED***


    function formatPrimitive(ctx, value) ***REMOVED***
      switch (typeof value) ***REMOVED***
        case 'undefined':
          return ctx.stylize('undefined', 'undefined');

        case 'string':
          var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                   .replace(/'/g, "\\'")
                                                   .replace(/\\"/g, '"') + '\'';
          return ctx.stylize(simple, 'string');

        case 'number':
          return ctx.stylize('' + value, 'number');

        case 'boolean':
          return ctx.stylize('' + value, 'boolean');
      ***REMOVED***
      // For some reason typeof null is "object", so special case here.
      if (value === null) ***REMOVED***
        return ctx.stylize('null', 'null');
      ***REMOVED***
    ***REMOVED***


    function formatError(value) ***REMOVED***
      return '[' + Error.prototype.toString.call(value) + ']';
    ***REMOVED***


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) ***REMOVED***
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) ***REMOVED***
        if (Object.prototype.hasOwnProperty.call(value, String(i))) ***REMOVED***
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        ***REMOVED*** else ***REMOVED***
          output.push('');
        ***REMOVED***
      ***REMOVED***
      keys.forEach(function(key) ***REMOVED***
        if (!key.match(/^\d+$/)) ***REMOVED***
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        ***REMOVED***
      ***REMOVED***);
      return output;
    ***REMOVED***


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) ***REMOVED***
      var name, str;
      if (value.__lookupGetter__) ***REMOVED***
        if (value.__lookupGetter__(key)) ***REMOVED***
          if (value.__lookupSetter__(key)) ***REMOVED***
            str = ctx.stylize('[Getter/Setter]', 'special');
          ***REMOVED*** else ***REMOVED***
            str = ctx.stylize('[Getter]', 'special');
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          if (value.__lookupSetter__(key)) ***REMOVED***
            str = ctx.stylize('[Setter]', 'special');
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      if (visibleKeys.indexOf(key) < 0) ***REMOVED***
        name = '[' + key + ']';
      ***REMOVED***
      if (!str) ***REMOVED***
        if (ctx.seen.indexOf(value[key]) < 0) ***REMOVED***
          if (recurseTimes === null) ***REMOVED***
            str = formatValue(ctx, value[key], null);
          ***REMOVED*** else ***REMOVED***
            str = formatValue(ctx, value[key], recurseTimes - 1);
          ***REMOVED***
          if (str.indexOf('\n') > -1) ***REMOVED***
            if (array) ***REMOVED***
              str = str.split('\n').map(function(line) ***REMOVED***
                return '  ' + line;
              ***REMOVED***).join('\n').substr(2);
            ***REMOVED*** else ***REMOVED***
              str = '\n' + str.split('\n').map(function(line) ***REMOVED***
                return '   ' + line;
              ***REMOVED***).join('\n');
            ***REMOVED***
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          str = ctx.stylize('[Circular]', 'special');
        ***REMOVED***
      ***REMOVED***
      if (typeof name === 'undefined') ***REMOVED***
        if (array && key.match(/^\d+$/)) ***REMOVED***
          return str;
        ***REMOVED***
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) ***REMOVED***
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        ***REMOVED*** else ***REMOVED***
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        ***REMOVED***
      ***REMOVED***

      return name + ': ' + str;
    ***REMOVED***


    function reduceToSingleString(output, base, braces) ***REMOVED***
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) ***REMOVED***
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.length + 1;
      ***REMOVED***, 0);

      if (length > 60) ***REMOVED***
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      ***REMOVED***

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    ***REMOVED***

    function isArray(ar) ***REMOVED***
      return Array.isArray(ar) ||
             (typeof ar === 'object' && objectToString(ar) === '[object Array]');
    ***REMOVED***

    function isRegExp(re) ***REMOVED***
      return typeof re === 'object' && objectToString(re) === '[object RegExp]';
    ***REMOVED***

    function isDate(d) ***REMOVED***
      return typeof d === 'object' && objectToString(d) === '[object Date]';
    ***REMOVED***

    function isError(e) ***REMOVED***
      return typeof e === 'object' && objectToString(e) === '[object Error]';
    ***REMOVED***

    function objectToString(o) ***REMOVED***
      return Object.prototype.toString.call(o);
    ***REMOVED***

  ***REMOVED***); // module: chai/utils/inspect.js

  require.register("chai/utils/objDisplay.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - flag utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */

    var inspect = require('./inspect');

    /**
     * ### .objDisplay (object)
     *
     * Determines if an object or an array matches
     * criteria to be inspected in-line for error
     * messages or should be truncated.
     *
     * @param ***REMOVED***Mixed***REMOVED*** javascript object to inspect
     * @name objDisplay
     * @api public
     */

    module.exports = function (obj) ***REMOVED***
      var str = inspect(obj)
        , type = Object.prototype.toString.call(obj);

      if (str.length >= 40) ***REMOVED***
        if (type === '[object Function]') ***REMOVED***
          return !obj.name || obj.name === ''
            ? '[Function]'
            : '[Function: ' + obj.name + ']';
        ***REMOVED*** else if (type === '[object Array]') ***REMOVED***
          return '[ Array(' + obj.length + ') ]';
        ***REMOVED*** else if (type === '[object Object]') ***REMOVED***
          var keys = Object.keys(obj)
            , kstr = keys.length > 2
              ? keys.splice(0, 2).join(', ') + ', ...'
              : keys.join(', ');
          return '***REMOVED*** Object (' + kstr + ') ***REMOVED***';
        ***REMOVED*** else ***REMOVED***
          return str;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        return str;
      ***REMOVED***
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/objDisplay.js

  require.register("chai/utils/overwriteMethod.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - overwriteMethod utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### overwriteMethod (ctx, name, fn)
     *
     * Overwites an already existing method and provides
     * access to previous function. Must return function
     * to be used for name.
     *
     *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) ***REMOVED***
     *       return function (str) ***REMOVED***
     *         var obj = utils.flag(this, 'object');
     *         if (obj instanceof Foo) ***REMOVED***
     *           new chai.Assertion(obj.value).to.equal(str);
     *         ***REMOVED*** else ***REMOVED***
     *           _super.apply(this, arguments);
     *         ***REMOVED***
     *       ***REMOVED***
     *     ***REMOVED***);
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.overwriteMethod('foo', fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.equal('bar');
     *
     * @param ***REMOVED***Object***REMOVED*** ctx object whose method is to be overwritten
     * @param ***REMOVED***String***REMOVED*** name of method to overwrite
     * @param ***REMOVED***Function***REMOVED*** method function that returns a function to be used for name
     * @name overwriteMethod
     * @api public
     */

    module.exports = function (ctx, name, method) ***REMOVED***
      var _method = ctx[name]
        , _super = function () ***REMOVED*** return this; ***REMOVED***;

      if (_method && 'function' === typeof _method)
        _super = _method;

      ctx[name] = function () ***REMOVED***
        var result = method(_super).apply(this, arguments);
        return result === undefined ? this : result;
      ***REMOVED***
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/overwriteMethod.js

  require.register("chai/utils/overwriteProperty.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - overwriteProperty utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### overwriteProperty (ctx, name, fn)
     *
     * Overwites an already existing property getter and provides
     * access to previous value. Must return function to use as getter.
     *
     *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) ***REMOVED***
     *       return function () ***REMOVED***
     *         var obj = utils.flag(this, 'object');
     *         if (obj instanceof Foo) ***REMOVED***
     *           new chai.Assertion(obj.name).to.equal('bar');
     *         ***REMOVED*** else ***REMOVED***
     *           _super.call(this);
     *         ***REMOVED***
     *       ***REMOVED***
     *     ***REMOVED***);
     *
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.overwriteProperty('foo', fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.be.ok;
     *
     * @param ***REMOVED***Object***REMOVED*** ctx object whose property is to be overwritten
     * @param ***REMOVED***String***REMOVED*** name of property to overwrite
     * @param ***REMOVED***Function***REMOVED*** getter function that returns a getter function to be used for name
     * @name overwriteProperty
     * @api public
     */

    module.exports = function (ctx, name, getter) ***REMOVED***
      var _get = Object.getOwnPropertyDescriptor(ctx, name)
        , _super = function () ***REMOVED******REMOVED***;

      if (_get && 'function' === typeof _get.get)
        _super = _get.get

      Object.defineProperty(ctx, name,
        ***REMOVED*** get: function () ***REMOVED***
            var result = getter(_super).call(this);
            return result === undefined ? this : result;
          ***REMOVED***
        , configurable: true
      ***REMOVED***);
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/overwriteProperty.js

  require.register("chai/utils/test.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - test utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */

    var flag = require('./flag');

    /**
     * # test(object, expression)
     *
     * Test and object for expression.
     *
     * @param ***REMOVED***Object***REMOVED*** object (constructed Assertion)
     * @param ***REMOVED***Arguments***REMOVED*** chai.Assertion.prototype.assert arguments
     */

    module.exports = function (obj, args) ***REMOVED***
      var negate = flag(obj, 'negate')
        , expr = args[0];
      return negate ? !expr : expr;
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/test.js

  require.register("chai/utils/transferFlags.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - transferFlags utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### transferFlags(assertion, object, includeAll = true)
     *
     * Transfer all the flags for `assertion` to `object`. If
     * `includeAll` is set to `false`, then the base Chai
     * assertion flags (namely `object`, `ssfi`, and `message`)
     * will not be transferred.
     *
     *
     *     var newAssertion = new Assertion();
     *     utils.transferFlags(assertion, newAssertion);
     *
     *     var anotherAsseriton = new Assertion(myObj);
     *     utils.transferFlags(assertion, anotherAssertion, false);
     *
     * @param ***REMOVED***Assertion***REMOVED*** assertion the assertion to transfer the flags from
     * @param ***REMOVED***Object***REMOVED*** object the object to transfer the flags too; usually a new assertion
     * @param ***REMOVED***Boolean***REMOVED*** includeAll
     * @name getAllFlags
     * @api private
     */

    module.exports = function (assertion, object, includeAll) ***REMOVED***
      var flags = assertion.__flags || (assertion.__flags = Object.create(null));

      if (!object.__flags) ***REMOVED***
        object.__flags = Object.create(null);
      ***REMOVED***

      includeAll = arguments.length === 3 ? includeAll : true;

      for (var flag in flags) ***REMOVED***
        if (includeAll ||
            (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) ***REMOVED***
          object.__flags[flag] = flags[flag];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/transferFlags.js

  require.register("chai/utils/type.js", function(module, exports, require)***REMOVED***
    /*!
     * Chai - type utility
     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Detectable javascript natives
     */

    var natives = ***REMOVED***
        '[object Arguments]': 'arguments'
      , '[object Array]': 'array'
      , '[object Date]': 'date'
      , '[object Function]': 'function'
      , '[object Number]': 'number'
      , '[object RegExp]': 'regexp'
      , '[object String]': 'string'
    ***REMOVED***;

    /**
     * ### type(object)
     *
     * Better implementation of `typeof` detection that can
     * be used cross-browser. Handles the inconsistencies of
     * Array, `null`, and `undefined` detection.
     *
     *     utils.type(***REMOVED******REMOVED***) // 'object'
     *     utils.type(null) // `null'
     *     utils.type(undefined) // `undefined`
     *     utils.type([]) // `array`
     *
     * @param ***REMOVED***Mixed***REMOVED*** object to detect type of
     * @name type
     * @api private
     */

    module.exports = function (obj) ***REMOVED***
      var str = Object.prototype.toString.call(obj);
      if (natives[str]) return natives[str];
      if (obj === null) return 'null';
      if (obj === undefined) return 'undefined';
      if (obj === Object(obj)) return 'object';
      return typeof obj;
    ***REMOVED***;

  ***REMOVED***); // module: chai/utils/type.js

  require.alias("./chai.js", "chai");

  return require('chai');
***REMOVED***);