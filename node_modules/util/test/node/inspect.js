// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.




var assert = require('assert');
var util = require('../../');

// test the internal isDate implementation
var Date2 = require('vm').runInNewContext('Date');
var d = new Date2();
var orig = util.inspect(d);
Date2.prototype.foo = 'bar';
var after = util.inspect(d);
assert.equal(orig, after);

// test for sparse array
var a = ['foo', 'bar', 'baz'];
assert.equal(util.inspect(a), '[ \'foo\', \'bar\', \'baz\' ]');
delete a[1];
assert.equal(util.inspect(a), '[ \'foo\', , \'baz\' ]');
assert.equal(util.inspect(a, true), '[ \'foo\', , \'baz\', [length]: 3 ]');
assert.equal(util.inspect(new Array(5)), '[ , , , ,  ]');

// test for property descriptors
var getter = Object.create(null, ***REMOVED***
  a: ***REMOVED***
    get: function() ***REMOVED*** return 'aaa'; ***REMOVED***
  ***REMOVED***
***REMOVED***);
var setter = Object.create(null, ***REMOVED***
  b: ***REMOVED***
    set: function() ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED***);
var getterAndSetter = Object.create(null, ***REMOVED***
  c: ***REMOVED***
    get: function() ***REMOVED*** return 'ccc'; ***REMOVED***,
    set: function() ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED***);
assert.equal(util.inspect(getter, true), '***REMOVED*** [a]: [Getter] ***REMOVED***');
assert.equal(util.inspect(setter, true), '***REMOVED*** [b]: [Setter] ***REMOVED***');
assert.equal(util.inspect(getterAndSetter, true), '***REMOVED*** [c]: [Getter/Setter] ***REMOVED***');

// exceptions should print the error message, not '***REMOVED******REMOVED***'
assert.equal(util.inspect(new Error()), '[Error]');
assert.equal(util.inspect(new Error('FAIL')), '[Error: FAIL]');
assert.equal(util.inspect(new TypeError('FAIL')), '[TypeError: FAIL]');
assert.equal(util.inspect(new SyntaxError('FAIL')), '[SyntaxError: FAIL]');
try ***REMOVED***
  undef();
***REMOVED*** catch (e) ***REMOVED***
  assert.equal(util.inspect(e), '[ReferenceError: undef is not defined]');
***REMOVED***
var ex = util.inspect(new Error('FAIL'), true);
assert.ok(ex.indexOf('[Error: FAIL]') != -1);
assert.ok(ex.indexOf('[stack]') != -1);
assert.ok(ex.indexOf('[message]') != -1);

// GH-1941
// should not throw:
assert.equal(util.inspect(Object.create(Date.prototype)), '***REMOVED******REMOVED***');

// GH-1944
assert.doesNotThrow(function() ***REMOVED***
  var d = new Date();
  d.toUTCString = null;
  util.inspect(d);
***REMOVED***);

assert.doesNotThrow(function() ***REMOVED***
  var r = /regexp/;
  r.toString = null;
  util.inspect(r);
***REMOVED***);

// bug with user-supplied inspect function returns non-string
assert.doesNotThrow(function() ***REMOVED***
  util.inspect([***REMOVED***
    inspect: function() ***REMOVED*** return 123; ***REMOVED***
  ***REMOVED***]);
***REMOVED***);

// GH-2225
var x = ***REMOVED*** inspect: util.inspect ***REMOVED***;
assert.ok(util.inspect(x).indexOf('inspect') != -1);

// util.inspect.styles and util.inspect.colors
function test_color_style(style, input, implicit) ***REMOVED***
  var color_name = util.inspect.styles[style];
  var color = ['', ''];
  if(util.inspect.colors[color_name])
    color = util.inspect.colors[color_name];

  var without_color = util.inspect(input, false, 0, false);
  var with_color = util.inspect(input, false, 0, true);
  var expect = '\u001b[' + color[0] + 'm' + without_color +
               '\u001b[' + color[1] + 'm';
  assert.equal(with_color, expect, 'util.inspect color for style '+style);
***REMOVED***

test_color_style('special', function()***REMOVED******REMOVED***);
test_color_style('number', 123.456);
test_color_style('boolean', true);
test_color_style('undefined', undefined);
test_color_style('null', null);
test_color_style('string', 'test string');
test_color_style('date', new Date);
test_color_style('regexp', /regexp/);

// an object with "hasOwnProperty" overwritten should not throw
assert.doesNotThrow(function() ***REMOVED***
  util.inspect(***REMOVED***
    hasOwnProperty: null
  ***REMOVED***);
***REMOVED***);

// new API, accepts an "options" object
var subject = ***REMOVED*** foo: 'bar', hello: 31, a: ***REMOVED*** b: ***REMOVED*** c: ***REMOVED*** d: 0 ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***;
Object.defineProperty(subject, 'hidden', ***REMOVED*** enumerable: false, value: null ***REMOVED***);

assert(util.inspect(subject, ***REMOVED*** showHidden: false ***REMOVED***).indexOf('hidden') === -1);
assert(util.inspect(subject, ***REMOVED*** showHidden: true ***REMOVED***).indexOf('hidden') !== -1);
assert(util.inspect(subject, ***REMOVED*** colors: false ***REMOVED***).indexOf('\u001b[32m') === -1);
assert(util.inspect(subject, ***REMOVED*** colors: true ***REMOVED***).indexOf('\u001b[32m') !== -1);
assert(util.inspect(subject, ***REMOVED*** depth: 2 ***REMOVED***).indexOf('c: [Object]') !== -1);
assert(util.inspect(subject, ***REMOVED*** depth: 0 ***REMOVED***).indexOf('a: [Object]') !== -1);
assert(util.inspect(subject, ***REMOVED*** depth: null ***REMOVED***).indexOf('***REMOVED*** d: 0 ***REMOVED***') !== -1);

// "customInspect" option can enable/disable calling inspect() on objects
subject = ***REMOVED*** inspect: function() ***REMOVED*** return 123; ***REMOVED*** ***REMOVED***;

assert(util.inspect(subject, ***REMOVED*** customInspect: true ***REMOVED***).indexOf('123') !== -1);
assert(util.inspect(subject, ***REMOVED*** customInspect: true ***REMOVED***).indexOf('inspect') === -1);
assert(util.inspect(subject, ***REMOVED*** customInspect: false ***REMOVED***).indexOf('123') === -1);
assert(util.inspect(subject, ***REMOVED*** customInspect: false ***REMOVED***).indexOf('inspect') !== -1);

// custom inspect() functions should be able to return other Objects
subject.inspect = function() ***REMOVED*** return ***REMOVED*** foo: 'bar' ***REMOVED***; ***REMOVED***;

assert.equal(util.inspect(subject), '***REMOVED*** foo: \'bar\' ***REMOVED***');

subject.inspect = function(depth, opts) ***REMOVED***
  assert.strictEqual(opts.customInspectOptions, true);
***REMOVED***;

util.inspect(subject, ***REMOVED*** customInspectOptions: true ***REMOVED***);

// util.inspect with "colors" option should produce as many lines as without it
function test_lines(input) ***REMOVED***
  var count_lines = function(str) ***REMOVED***
    return (str.match(/\n/g) || []).length;
  ***REMOVED***

  var without_color = util.inspect(input);
  var with_color = util.inspect(input, ***REMOVED***colors: true***REMOVED***);
  assert.equal(count_lines(without_color), count_lines(with_color));
***REMOVED***

test_lines([1, 2, 3, 4, 5, 6, 7]);
test_lines(function() ***REMOVED***
  var big_array = [];
  for (var i = 0; i < 100; i++) ***REMOVED***
    big_array.push(i);
  ***REMOVED***
  return big_array;
***REMOVED***());
test_lines(***REMOVED***foo: 'bar', baz: 35, b: ***REMOVED***a: 35***REMOVED******REMOVED***);
test_lines(***REMOVED***
  foo: 'bar',
  baz: 35,
  b: ***REMOVED***a: 35***REMOVED***,
  very_long_key: 'very_long_value',
  even_longer_key: ['with even longer value in array']
***REMOVED***);
