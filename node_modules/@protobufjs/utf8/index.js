"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param ***REMOVED***string***REMOVED*** string String
 * @returns ***REMOVED***number***REMOVED*** Byte length
 */
utf8.length = function utf8_length(string) ***REMOVED***
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) ***REMOVED***
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) ***REMOVED***
            ++i;
            len += 4;
        ***REMOVED*** else
            len += 3;
    ***REMOVED***
    return len;
***REMOVED***;

/**
 * Reads UTF8 bytes as a string.
 * @param ***REMOVED***Uint8Array***REMOVED*** buffer Source buffer
 * @param ***REMOVED***number***REMOVED*** start Source start
 * @param ***REMOVED***number***REMOVED*** end Source end
 * @returns ***REMOVED***string***REMOVED*** String read
 */
utf8.read = function utf8_read(buffer, start, end) ***REMOVED***
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) ***REMOVED***
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) ***REMOVED***
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        ***REMOVED*** else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) ***REMOVED***
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        ***REMOVED***
    ***REMOVED***
    if (parts) ***REMOVED***
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    ***REMOVED***
    return String.fromCharCode.apply(String, chunk.slice(0, i));
***REMOVED***;

/**
 * Writes a string as UTF8 bytes.
 * @param ***REMOVED***string***REMOVED*** string Source string
 * @param ***REMOVED***Uint8Array***REMOVED*** buffer Destination buffer
 * @param ***REMOVED***number***REMOVED*** offset Destination offset
 * @returns ***REMOVED***number***REMOVED*** Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) ***REMOVED***
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) ***REMOVED***
        c1 = string.charCodeAt(i);
        if (c1 < 128) ***REMOVED***
            buffer[offset++] = c1;
        ***REMOVED*** else if (c1 < 2048) ***REMOVED***
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        ***REMOVED*** else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) ***REMOVED***
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        ***REMOVED*** else ***REMOVED***
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        ***REMOVED***
    ***REMOVED***
    return offset - start;
***REMOVED***;
