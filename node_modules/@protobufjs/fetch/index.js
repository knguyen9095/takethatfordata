"use strict";
module.exports = fetch;

var asPromise = require("@protobufjs/aspromise"),
    inquire   = require("@protobufjs/inquire");

var fs = inquire("fs");

/**
 * Node-style callback as used by ***REMOVED***@link util.fetch***REMOVED***.
 * @typedef FetchCallback
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***?Error***REMOVED*** error Error, if any, otherwise `null`
 * @param ***REMOVED***string***REMOVED*** [contents] File contents, if there hasn't been an error
 * @returns ***REMOVED***undefined***REMOVED***
 */

/**
 * Options as used by ***REMOVED***@link util.fetch***REMOVED***.
 * @typedef FetchOptions
 * @type ***REMOVED***Object***REMOVED***
 * @property ***REMOVED***boolean***REMOVED*** [binary=false] Whether expecting a binary response
 * @property ***REMOVED***boolean***REMOVED*** [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param ***REMOVED***string***REMOVED*** filename File path or url
 * @param ***REMOVED***FetchOptions***REMOVED*** options Fetch options
 * @param ***REMOVED***FetchCallback***REMOVED*** callback Callback function
 * @returns ***REMOVED***undefined***REMOVED***
 */
function fetch(filename, options, callback) ***REMOVED***
    if (typeof options === "function") ***REMOVED***
        callback = options;
        options = ***REMOVED******REMOVED***;
    ***REMOVED*** else if (!options)
        options = ***REMOVED******REMOVED***;

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) ***REMOVED***
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        ***REMOVED***);

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
***REMOVED***

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param ***REMOVED***string***REMOVED*** path File path or url
 * @param ***REMOVED***FetchCallback***REMOVED*** callback Callback function
 * @returns ***REMOVED***undefined***REMOVED***
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param ***REMOVED***string***REMOVED*** path File path or url
 * @param ***REMOVED***FetchOptions***REMOVED*** [options] Fetch options
 * @returns ***REMOVED***Promise<string|Uint8Array>***REMOVED*** Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) ***REMOVED***
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() ***REMOVED***

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) ***REMOVED***
            var buffer = xhr.response;
            if (!buffer) ***REMOVED***
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            ***REMOVED***
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        ***REMOVED***
        return callback(null, xhr.responseText);
    ***REMOVED***;

    if (options.binary) ***REMOVED***
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    ***REMOVED***

    xhr.open("GET", filename);
    xhr.send();
***REMOVED***;
