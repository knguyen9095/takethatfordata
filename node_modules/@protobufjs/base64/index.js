"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param ***REMOVED***string***REMOVED*** string Base64 encoded string
 * @returns ***REMOVED***number***REMOVED*** Byte length
 */
base64.length = function length(string) ***REMOVED***
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
***REMOVED***;

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param ***REMOVED***Uint8Array***REMOVED*** buffer Source buffer
 * @param ***REMOVED***number***REMOVED*** start Source start
 * @param ***REMOVED***number***REMOVED*** end Source end
 * @returns ***REMOVED***string***REMOVED*** Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) ***REMOVED***
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) ***REMOVED***
        var b = buffer[start++];
        switch (j) ***REMOVED***
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        ***REMOVED***
        if (i > 8191) ***REMOVED***
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        ***REMOVED***
    ***REMOVED***
    if (j) ***REMOVED***
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    ***REMOVED***
    if (parts) ***REMOVED***
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    ***REMOVED***
    return String.fromCharCode.apply(String, chunk.slice(0, i));
***REMOVED***;

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param ***REMOVED***string***REMOVED*** string Source string
 * @param ***REMOVED***Uint8Array***REMOVED*** buffer Destination buffer
 * @param ***REMOVED***number***REMOVED*** offset Destination offset
 * @returns ***REMOVED***number***REMOVED*** Number of bytes written
 * @throws ***REMOVED***Error***REMOVED*** If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) ***REMOVED***
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) ***REMOVED***
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) ***REMOVED***
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        ***REMOVED***
    ***REMOVED***
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
***REMOVED***;

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param ***REMOVED***string***REMOVED*** string String to test
 * @returns ***REMOVED***boolean***REMOVED*** `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) ***REMOVED***
    return /^(?:[A-Za-z0-9+/]***REMOVED***4***REMOVED***)*(?:[A-Za-z0-9+/]***REMOVED***2***REMOVED***==|[A-Za-z0-9+/]***REMOVED***3***REMOVED***=)?$/.test(string);
***REMOVED***;
