var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) ***REMOVED***
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
***REMOVED***

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) ***REMOVED***
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) ***REMOVED***
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  ***REMOVED***

  return Buffer.concat(out)
***REMOVED***

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () ***REMOVED***
  var chunk = this._cache.flush()
  if (this._autopadding) ***REMOVED***
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  ***REMOVED***

  if (!chunk.equals(PADDING)) ***REMOVED***
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  ***REMOVED***
***REMOVED***

Cipher.prototype.setAutoPadding = function (setTo) ***REMOVED***
  this._autopadding = !!setTo
  return this
***REMOVED***

function Splitter () ***REMOVED***
  this.cache = Buffer.allocUnsafe(0)
***REMOVED***

Splitter.prototype.add = function (data) ***REMOVED***
  this.cache = Buffer.concat([this.cache, data])
***REMOVED***

Splitter.prototype.get = function () ***REMOVED***
  if (this.cache.length > 15) ***REMOVED***
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  ***REMOVED***
  return null
***REMOVED***

Splitter.prototype.flush = function () ***REMOVED***
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) ***REMOVED***
    padBuff.writeUInt8(len, i)
  ***REMOVED***

  return Buffer.concat([this.cache, padBuff])
***REMOVED***

function createCipheriv (suite, password, iv) ***REMOVED***
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') ***REMOVED***
    return new StreamCipher(config.module, password, iv)
  ***REMOVED*** else if (config.type === 'auth') ***REMOVED***
    return new AuthCipher(config.module, password, iv)
  ***REMOVED***

  return new Cipher(config.module, password, iv)
***REMOVED***

function createCipher (suite, password) ***REMOVED***
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
***REMOVED***

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher
