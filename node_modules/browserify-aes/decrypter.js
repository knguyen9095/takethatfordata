var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) ***REMOVED***
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
***REMOVED***

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) ***REMOVED***
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) ***REMOVED***
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  ***REMOVED***
  return Buffer.concat(out)
***REMOVED***

Decipher.prototype._final = function () ***REMOVED***
  var chunk = this._cache.flush()
  if (this._autopadding) ***REMOVED***
    return unpad(this._mode.decrypt(this, chunk))
  ***REMOVED*** else if (chunk) ***REMOVED***
    throw new Error('data not multiple of block length')
  ***REMOVED***
***REMOVED***

Decipher.prototype.setAutoPadding = function (setTo) ***REMOVED***
  this._autopadding = !!setTo
  return this
***REMOVED***

function Splitter () ***REMOVED***
  this.cache = Buffer.allocUnsafe(0)
***REMOVED***

Splitter.prototype.add = function (data) ***REMOVED***
  this.cache = Buffer.concat([this.cache, data])
***REMOVED***

Splitter.prototype.get = function (autoPadding) ***REMOVED***
  var out
  if (autoPadding) ***REMOVED***
    if (this.cache.length > 16) ***REMOVED***
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    if (this.cache.length >= 16) ***REMOVED***
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    ***REMOVED***
  ***REMOVED***

  return null
***REMOVED***

Splitter.prototype.flush = function () ***REMOVED***
  if (this.cache.length) return this.cache
***REMOVED***

function unpad (last) ***REMOVED***
  var padded = last[15]
  var i = -1
  while (++i < padded) ***REMOVED***
    if (last[(i + (16 - padded))] !== padded) ***REMOVED***
      throw new Error('unable to decrypt data')
    ***REMOVED***
  ***REMOVED***
  if (padded === 16) return

  return last.slice(0, 16 - padded)
***REMOVED***

function createDecipheriv (suite, password, iv) ***REMOVED***
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') ***REMOVED***
    return new StreamCipher(config.module, password, iv, true)
  ***REMOVED*** else if (config.type === 'auth') ***REMOVED***
    return new AuthCipher(config.module, password, iv, true)
  ***REMOVED***

  return new Decipher(config.module, password, iv)
***REMOVED***

function createDecipher (suite, password) ***REMOVED***
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
***REMOVED***

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv
