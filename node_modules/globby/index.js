'use strict';
const arrayUnion = require('array-union');
const glob = require('glob');
const pify = require('pify');
const dirGlob = require('dir-glob');
const gitignore = require('./gitignore');

const globP = pify(glob);
const DEFAULT_FILTER = () => false;

const isNegative = pattern => pattern[0] === '!';

const assertPatternsInput = patterns => ***REMOVED***
	if (!patterns.every(x => typeof x === 'string')) ***REMOVED***
		throw new TypeError('Patterns must be a string or an array of strings');
	***REMOVED***
***REMOVED***;

const generateGlobTasks = (patterns, taskOpts) => ***REMOVED***
	patterns = [].concat(patterns);
	assertPatternsInput(patterns);

	const globTasks = [];

	taskOpts = Object.assign(***REMOVED***
		cache: Object.create(null),
		statCache: Object.create(null),
		realpathCache: Object.create(null),
		symlinks: Object.create(null),
		ignore: [],
		expandDirectories: true,
		nodir: true
	***REMOVED***, taskOpts);

	patterns.forEach((pattern, i) => ***REMOVED***
		if (isNegative(pattern)) ***REMOVED***
			return;
		***REMOVED***

		const ignore = patterns
			.slice(i)
			.filter(isNegative)
			.map(pattern => pattern.slice(1));

		const opts = Object.assign(***REMOVED******REMOVED***, taskOpts, ***REMOVED***
			ignore: taskOpts.ignore.concat(ignore)
		***REMOVED***);

		globTasks.push(***REMOVED***pattern, opts***REMOVED***);
	***REMOVED***);

	return globTasks;
***REMOVED***;

const globDirs = (task, fn) => ***REMOVED***
	if (Array.isArray(task.opts.expandDirectories)) ***REMOVED***
		return fn(task.pattern, ***REMOVED***files: task.opts.expandDirectories***REMOVED***);
	***REMOVED***

	if (typeof task.opts.expandDirectories === 'object') ***REMOVED***
		return fn(task.pattern, task.opts.expandDirectories);
	***REMOVED***

	return fn(task.pattern);
***REMOVED***;

const getPattern = (task, fn) => task.opts.expandDirectories ? globDirs(task, fn) : [task.pattern];

module.exports = (patterns, opts) => ***REMOVED***
	let globTasks;

	try ***REMOVED***
		globTasks = generateGlobTasks(patterns, opts);
	***REMOVED*** catch (err) ***REMOVED***
		return Promise.reject(err);
	***REMOVED***

	const getTasks = Promise.all(globTasks.map(task => Promise.resolve(getPattern(task, dirGlob))
		.then(globs => Promise.all(globs.map(glob => (***REMOVED***
			pattern: glob,
			opts: task.opts
		***REMOVED***))))
	))
		.then(tasks => arrayUnion.apply(null, tasks));

	const getFilter = () => ***REMOVED***
		return Promise.resolve(
			opts && opts.gitignore ?
				gitignore(***REMOVED***cwd: opts.cwd, ignore: opts.ignore***REMOVED***) :
				DEFAULT_FILTER
		);
	***REMOVED***;

	return getFilter()
		.then(filter => ***REMOVED***
			return getTasks
				.then(tasks => Promise.all(tasks.map(task => globP(task.pattern, task.opts))))
				.then(paths => arrayUnion.apply(null, paths))
				.then(paths => paths.filter(p => !filter(p)));
		***REMOVED***);
***REMOVED***;

module.exports.sync = (patterns, opts) => ***REMOVED***
	const globTasks = generateGlobTasks(patterns, opts);

	const getFilter = () => ***REMOVED***
		return opts && opts.gitignore ?
			gitignore.sync(***REMOVED***cwd: opts.cwd, ignore: opts.ignore***REMOVED***) :
			DEFAULT_FILTER;
	***REMOVED***;

	const tasks = globTasks.reduce((tasks, task) => ***REMOVED***
		const newTask = getPattern(task, dirGlob.sync).map(glob => (***REMOVED***
			pattern: glob,
			opts: task.opts
		***REMOVED***));
		return tasks.concat(newTask);
	***REMOVED***, []);

	const filter = getFilter();

	return tasks.reduce(
		(matches, task) => arrayUnion(matches, glob.sync(task.pattern, task.opts)),
		[]
	).filter(p => !filter(p));
***REMOVED***;

module.exports.generateGlobTasks = generateGlobTasks;

module.exports.hasMagic = (patterns, opts) => []
	.concat(patterns)
	.some(pattern => glob.hasMagic(pattern, opts));

module.exports.gitignore = gitignore;
