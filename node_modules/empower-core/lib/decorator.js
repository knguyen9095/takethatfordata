'use strict';

var forEach = require('core-js/library/fn/array/for-each');
var filter = require('core-js/library/fn/array/filter');
var map = require('core-js/library/fn/array/map');
var signature = require('call-signature');
var decorate = require('./decorate');
var keys = require('core-js/library/fn/object/keys');


function Decorator (receiver, config) ***REMOVED***
    this.receiver = receiver;
    this.config = config;
    this.onError = config.onError;
    this.onSuccess = config.onSuccess;
    this.signatures = map(config.patterns, parse);
    this.wrapOnlySignatures = map(config.wrapOnlyPatterns, parse);
***REMOVED***

Decorator.prototype.enhancement = function () ***REMOVED***
    var that = this;
    var container = this.container();
    var wrappedMethods = [];

    function attach(matcherSpec, enhanced) ***REMOVED***
        var matcher = matcherSpec.parsed;
        var methodName = detectMethodName(matcher.callee);
        if (typeof that.receiver[methodName] !== 'function' || wrappedMethods.indexOf(methodName) !== -1) ***REMOVED***
            return;
        ***REMOVED***
        var callSpec = ***REMOVED***
            thisObj: that.receiver,
            func: that.receiver[methodName],
            numArgsToCapture: numberOfArgumentsToCapture(matcherSpec),
            matcherSpec: matcherSpec,
            enhanced: enhanced
        ***REMOVED***;
        container[methodName] = callSpec.enhancedFunc = decorate(callSpec, that);
        wrappedMethods.push(methodName);
    ***REMOVED***

    forEach(filter(this.signatures, methodCall), function (matcher) ***REMOVED***
        attach(matcher, true);
    ***REMOVED***);

    forEach(filter(this.wrapOnlySignatures, methodCall), function (matcher) ***REMOVED***
        attach(matcher, false);
    ***REMOVED***);

    return container;
***REMOVED***;

Decorator.prototype.container = function () ***REMOVED***
    var basement = ***REMOVED******REMOVED***;
    if (typeof this.receiver === 'function') ***REMOVED***
        var candidates = filter(this.signatures, functionCall);
        var enhanced = true;
        if (candidates.length === 0) ***REMOVED***
            enhanced = false;
            candidates = filter(this.wrapOnlySignatures, functionCall);
        ***REMOVED***
        if (candidates.length === 1) ***REMOVED***
            var callSpec = ***REMOVED***
                thisObj: null,
                func: this.receiver,
                numArgsToCapture: numberOfArgumentsToCapture(candidates[0]),
                matcherSpec: candidates[0],
                enhanced: enhanced
            ***REMOVED***;
            basement = callSpec.enhancedFunc = decorate(callSpec, this);
        ***REMOVED***
    ***REMOVED***
    return basement;
***REMOVED***;

Decorator.prototype.concreteAssert = function (callSpec, invocation, context) ***REMOVED***
    var func = callSpec.func;
    var thisObj = this.config.bindReceiver ? callSpec.thisObj : invocation.thisObj;
    var enhanced = callSpec.enhanced;
    var args = invocation.values;
    var message = invocation.message;
    var matcherSpec = callSpec.matcherSpec;

    if (context && typeof this.config.modifyMessageBeforeAssert === 'function') ***REMOVED***
        message = this.config.modifyMessageBeforeAssert(***REMOVED***originalMessage: message, powerAssertContext: context***REMOVED***);
    ***REMOVED***
    args = args.concat(message);

    var data = ***REMOVED***
        thisObj: invocation.thisObj,
        assertionFunction: callSpec.enhancedFunc,
        originalMessage: message,
        defaultMessage: matcherSpec.defaultMessage,
        matcherSpec: matcherSpec,
        enhanced: enhanced,
        args: args
    ***REMOVED***;

    if (context) ***REMOVED***
        data.powerAssertContext = context;
    ***REMOVED***

    return this._callFunc(func, thisObj, args, data);
***REMOVED***;

// see: https://github.com/twada/empower-core/pull/8#issuecomment-173480982
Decorator.prototype._callFunc = function (func, thisObj, args, data) ***REMOVED***
    var ret;
    try ***REMOVED***
        ret = func.apply(thisObj, args);
    ***REMOVED*** catch (e) ***REMOVED***
        data.assertionThrew = true;
        data.error = e;
        return this.onError.call(thisObj, data);
    ***REMOVED***
    data.assertionThrew = false;
    data.returnValue = ret;
    return this.onSuccess.call(thisObj, data);
***REMOVED***;

function numberOfArgumentsToCapture (matcherSpec) ***REMOVED***
    var matcher = matcherSpec.parsed;
    var len = matcher.args.length;
    var lastArg;
    if (0 < len) ***REMOVED***
        lastArg = matcher.args[len - 1];
        if (lastArg.name === 'message' && lastArg.optional) ***REMOVED***
            len -= 1;
        ***REMOVED***
    ***REMOVED***
    return len;
***REMOVED***


function detectMethodName (callee) ***REMOVED***
    if (callee.type === 'MemberExpression') ***REMOVED***
        return callee.member;
    ***REMOVED***
    return null;
***REMOVED***


function functionCall (matcherSpec) ***REMOVED***
    return matcherSpec.parsed.callee.type === 'Identifier';
***REMOVED***


function methodCall (matcherSpec) ***REMOVED***
    return matcherSpec.parsed.callee.type === 'MemberExpression';
***REMOVED***

function parse(matcherSpec) ***REMOVED***
    if (typeof matcherSpec === 'string') ***REMOVED***
        matcherSpec = ***REMOVED***pattern: matcherSpec***REMOVED***;
    ***REMOVED***
    var ret = ***REMOVED******REMOVED***;
    forEach(keys(matcherSpec), function (key) ***REMOVED***
        ret[key] = matcherSpec[key];
    ***REMOVED***);
    ret.parsed = signature.parse(matcherSpec.pattern);
    return ret;
***REMOVED***


module.exports = Decorator;
