'use strict';
const bufferStream = require('./buffer-stream');

function getStream(inputStream, opts) ***REMOVED***
	if (!inputStream) ***REMOVED***
		return Promise.reject(new Error('Expected a stream'));
	***REMOVED***

	opts = Object.assign(***REMOVED***maxBuffer: Infinity***REMOVED***, opts);

	const maxBuffer = opts.maxBuffer;
	let stream;
	let clean;

	const p = new Promise((resolve, reject) => ***REMOVED***
		const error = err => ***REMOVED***
			if (err) ***REMOVED*** // null check
				err.bufferedData = stream.getBufferedValue();
			***REMOVED***

			reject(err);
		***REMOVED***;

		stream = bufferStream(opts);
		inputStream.once('error', error);
		inputStream.pipe(stream);

		stream.on('data', () => ***REMOVED***
			if (stream.getBufferedLength() > maxBuffer) ***REMOVED***
				reject(new Error('maxBuffer exceeded'));
			***REMOVED***
		***REMOVED***);
		stream.once('error', error);
		stream.on('end', resolve);

		clean = () => ***REMOVED***
			// some streams doesn't implement the `stream.Readable` interface correctly
			if (inputStream.unpipe) ***REMOVED***
				inputStream.unpipe(stream);
			***REMOVED***
		***REMOVED***;
	***REMOVED***);

	p.then(clean, clean);

	return p.then(() => stream.getBufferedValue());
***REMOVED***

module.exports = getStream;
module.exports.buffer = (stream, opts) => getStream(stream, Object.assign(***REMOVED******REMOVED***, opts, ***REMOVED***encoding: 'buffer'***REMOVED***));
module.exports.array = (stream, opts) => getStream(stream, Object.assign(***REMOVED******REMOVED***, opts, ***REMOVED***array: true***REMOVED***));
