// fancy-pants parsing of argv, originally forked
// from minimist: https://www.npmjs.com/package/minimist
var camelCase = require('camelcase')
var path = require('path')

function increment (orig) ***REMOVED***
  return orig !== undefined ? orig + 1 : 0
***REMOVED***

module.exports = function (args, opts, y18n) ***REMOVED***
  if (!opts) opts = ***REMOVED******REMOVED***

  var __ = y18n.__
  var error = null
  var flags = ***REMOVED*** arrays: ***REMOVED******REMOVED***, bools: ***REMOVED******REMOVED***, strings: ***REMOVED******REMOVED***, counts: ***REMOVED******REMOVED***, normalize: ***REMOVED******REMOVED***, configs: ***REMOVED******REMOVED***, defaulted: ***REMOVED******REMOVED*** ***REMOVED***

  ;[].concat(opts['array']).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.arrays[key] = true
  ***REMOVED***)

  ;[].concat(opts['boolean']).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.bools[key] = true
  ***REMOVED***)

  ;[].concat(opts.string).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.strings[key] = true
  ***REMOVED***)

  ;[].concat(opts.count).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.counts[key] = true
  ***REMOVED***)

  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) ***REMOVED***
    flags.normalize[key] = true
  ***REMOVED***)

  Object.keys(opts.config).forEach(function (k) ***REMOVED***
    flags.configs[k] = opts.config[k]
  ***REMOVED***)

  var aliases = ***REMOVED******REMOVED***
  var newAliases = ***REMOVED******REMOVED***

  extendAliases(opts.key)
  extendAliases(opts.alias)
  extendAliases(opts.default)

  var defaults = opts['default'] || ***REMOVED******REMOVED***
  Object.keys(defaults).forEach(function (key) ***REMOVED***
    if (/-/.test(key) && !opts.alias[key]) ***REMOVED***
      aliases[key] = aliases[key] || []
    ***REMOVED***
    (aliases[key] || []).forEach(function (alias) ***REMOVED***
      defaults[alias] = defaults[key]
    ***REMOVED***)
  ***REMOVED***)

  var argv = ***REMOVED*** _: [] ***REMOVED***

  Object.keys(flags.bools).forEach(function (key) ***REMOVED***
    setArg(key, !(key in defaults) ? false : defaults[key])
    setDefaulted(key)
  ***REMOVED***)

  var notFlags = []
  if (args.indexOf('--') !== -1) ***REMOVED***
    notFlags = args.slice(args.indexOf('--') + 1)
    args = args.slice(0, args.indexOf('--'))
  ***REMOVED***

  for (var i = 0; i < args.length; i++) ***REMOVED***
    var arg = args[i]
    var broken
    var key
    var letters
    var m
    var next
    var value

    // -- seperated by =
    if (arg.match(/^--.+=/)) ***REMOVED***
      // Using [\s\S] instead of . because js doesn't support the
      // 'dotall' regex modifier. See:
      // http://stackoverflow.com/a/1068308/13216
      m = arg.match(/^--([^=]+)=([\s\S]*)$/)

      // nargs format = '--f=monkey washing cat'
      if (checkAllAliases(m[1], opts.narg)) ***REMOVED***
        args.splice(i + 1, m[1], m[2])
        i = eatNargs(i, m[1], args)
      // arrays format = '--f=a b c'
      ***REMOVED*** else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) ***REMOVED***
        args.splice(i + 1, m[1], m[2])
        i = eatArray(i, m[1], args)
      ***REMOVED*** else ***REMOVED***
        setArg(m[1], m[2])
      ***REMOVED***
    ***REMOVED*** else if (arg.match(/^--no-.+/)) ***REMOVED***
      key = arg.match(/^--no-(.+)/)[1]
      setArg(key, false)

    // -- seperated by space.
    ***REMOVED*** else if (arg.match(/^--.+/)) ***REMOVED***
      key = arg.match(/^--(.+)/)[1]

      // nargs format = '--foo a b c'
      if (checkAllAliases(key, opts.narg)) ***REMOVED***
        i = eatNargs(i, key, args)
      // array format = '--foo a b c'
      ***REMOVED*** else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) ***REMOVED***
        i = eatArray(i, key, args)
      ***REMOVED*** else ***REMOVED***
        next = args[i + 1]

        if (next !== undefined && !next.match(/^-/) &&
          !checkAllAliases(key, flags.bools) &&
          !checkAllAliases(key, flags.counts)) ***REMOVED***
          setArg(key, next)
          i++
        ***REMOVED*** else if (/^(true|false)$/.test(next)) ***REMOVED***
          setArg(key, next)
          i++
        ***REMOVED*** else ***REMOVED***
          setArg(key, defaultForType(guessType(key, flags)))
        ***REMOVED***
      ***REMOVED***

    // dot-notation flag seperated by '='.
    ***REMOVED*** else if (arg.match(/^-.\..+=/)) ***REMOVED***
      m = arg.match(/^-([^=]+)=([\s\S]*)$/)
      setArg(m[1], m[2])

    // dot-notation flag seperated by space.
    ***REMOVED*** else if (arg.match(/^-.\..+/)) ***REMOVED***
      next = args[i + 1]
      key = arg.match(/^-(.\..+)/)[1]

      if (next !== undefined && !next.match(/^-/) &&
        !checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts)) ***REMOVED***
        setArg(key, next)
        i++
      ***REMOVED*** else ***REMOVED***
        setArg(key, defaultForType(guessType(key, flags)))
      ***REMOVED***
    ***REMOVED*** else if (arg.match(/^-[^-]+/)) ***REMOVED***
      letters = arg.slice(1, -1).split('')
      broken = false

      for (var j = 0; j < letters.length; j++) ***REMOVED***
        next = arg.slice(j + 2)

        if (letters[j + 1] && letters[j + 1] === '=') ***REMOVED***
          value = arg.slice(j + 3)
          key = letters[j]

          // nargs format = '-f=monkey washing cat'
          if (checkAllAliases(letters[j], opts.narg)) ***REMOVED***
            args.splice(i + 1, 0, value)
            i = eatNargs(i, key, args)
          // array format = '-f=a b c'
          ***REMOVED*** else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) ***REMOVED***
            args.splice(i + 1, 0, value)
            i = eatArray(i, key, args)
          ***REMOVED*** else ***REMOVED***
            setArg(key, value)
          ***REMOVED***

          broken = true
          break
        ***REMOVED***

        if (next === '-') ***REMOVED***
          setArg(letters[j], next)
          continue
        ***REMOVED***

        if (/[A-Za-z]/.test(letters[j]) &&
          /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ***REMOVED***
          setArg(letters[j], next)
          broken = true
          break
        ***REMOVED***

        if (letters[j + 1] && letters[j + 1].match(/\W/)) ***REMOVED***
          setArg(letters[j], arg.slice(j + 2))
          broken = true
          break
        ***REMOVED*** else ***REMOVED***
          setArg(letters[j], defaultForType(guessType(letters[j], flags)))
        ***REMOVED***
      ***REMOVED***

      key = arg.slice(-1)[0]

      if (!broken && key !== '-') ***REMOVED***
        // nargs format = '-f a b c'
        if (checkAllAliases(key, opts.narg)) ***REMOVED***
          i = eatNargs(i, key, args)
        // array format = '-f a b c'
        ***REMOVED*** else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) ***REMOVED***
          i = eatArray(i, key, args)
        ***REMOVED*** else ***REMOVED***
          if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) ***REMOVED***
            setArg(key, args[i + 1])
            i++
          ***REMOVED*** else if (args[i + 1] && /true|false/.test(args[i + 1])) ***REMOVED***
            setArg(key, args[i + 1])
            i++
          ***REMOVED*** else ***REMOVED***
            setArg(key, defaultForType(guessType(key, flags)))
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      argv._.push(
        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
      )
    ***REMOVED***
  ***REMOVED***

  // order of precedence:
  // 1. command line arg
  // 2. value from config file
  // 3. value from env var
  // 4. configured default value
  applyEnvVars(opts, argv, true) // special case: check env vars that point to config file
  setConfig(argv)
  applyEnvVars(opts, argv, false)
  applyDefaultsAndAliases(argv, aliases, defaults)

  Object.keys(flags.counts).forEach(function (key) ***REMOVED***
    setArg(key, defaults[key])
  ***REMOVED***)

  notFlags.forEach(function (key) ***REMOVED***
    argv._.push(key)
  ***REMOVED***)

  // how many arguments should we consume, based
  // on the nargs option?
  function eatNargs (i, key, args) ***REMOVED***
    var toEat = checkAllAliases(key, opts.narg)

    if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key))

    for (var ii = i + 1; ii < (toEat + i + 1); ii++) ***REMOVED***
      setArg(key, args[ii])
    ***REMOVED***

    return (i + toEat)
  ***REMOVED***

  // if an option is an array, eat all non-hyphenated arguments
  // following it... YUM!
  // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
  function eatArray (i, key, args) ***REMOVED***
    for (var ii = i + 1; ii < args.length; ii++) ***REMOVED***
      if (/^-/.test(args[ii])) break
      i = ii
      setArg(key, args[ii])
    ***REMOVED***

    return i
  ***REMOVED***

  function setArg (key, val) ***REMOVED***
    unsetDefaulted(key)

    // handle parsing boolean arguments --foo=true --bar false.
    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) ***REMOVED***
      if (typeof val === 'string') val = val === 'true'
    ***REMOVED***

    if (/-/.test(key) && !(aliases[key] && aliases[key].length)) ***REMOVED***
      var c = camelCase(key)
      aliases[key] = [c]
      newAliases[c] = true
    ***REMOVED***

    var value = !checkAllAliases(key, flags.strings) && isNumber(val) ? Number(val) : val

    if (checkAllAliases(key, flags.counts)) ***REMOVED***
      value = increment
    ***REMOVED***

    var splitKey = key.split('.')
    setKey(argv, splitKey, value)

    // alias references an inner-value within
    // a dot-notation object. see #279.
    if (~key.indexOf('.') && aliases[key]) ***REMOVED***
      aliases[key].forEach(function (x) ***REMOVED***
        x = x.split('.')
        setKey(argv, x, value)
      ***REMOVED***)
    ***REMOVED***

    ;(aliases[splitKey[0]] || []).forEach(function (x) ***REMOVED***
      x = x.split('.')

      // handle populating dot notation for both
      // the key and its aliases.
      if (splitKey.length > 1) ***REMOVED***
        var a = [].concat(splitKey)
        a.shift() // nuke the old key.
        x = x.concat(a)
      ***REMOVED***

      setKey(argv, x, value)
    ***REMOVED***)

    var keys = [key].concat(aliases[key] || [])
    for (var i = 0, l = keys.length; i < l; i++) ***REMOVED***
      if (flags.normalize[keys[i]]) ***REMOVED***
        keys.forEach(function (key) ***REMOVED***
          argv.__defineSetter__(key, function (v) ***REMOVED***
            val = path.normalize(v)
          ***REMOVED***)

          argv.__defineGetter__(key, function () ***REMOVED***
            return typeof val === 'string' ? path.normalize(val) : val
          ***REMOVED***)
        ***REMOVED***)
        break
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // set args from config.json file, this should be
  // applied last so that defaults can be applied.
  function setConfig (argv) ***REMOVED***
    var configLookup = ***REMOVED******REMOVED***

    // expand defaults/aliases, in-case any happen to reference
    // the config.json file.
    applyDefaultsAndAliases(configLookup, aliases, defaults)

    Object.keys(flags.configs).forEach(function (configKey) ***REMOVED***
      var configPath = argv[configKey] || configLookup[configKey]
      if (configPath) ***REMOVED***
        try ***REMOVED***
          var config = null
          var resolvedConfigPath = path.resolve(process.cwd(), configPath)

          if (typeof flags.configs[configKey] === 'function') ***REMOVED***
            try ***REMOVED***
              config = flags.configs[configKey](resolvedConfigPath)
            ***REMOVED*** catch (e) ***REMOVED***
              config = e
            ***REMOVED***
            if (config instanceof Error) ***REMOVED***
              error = config
              return
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            config = require(resolvedConfigPath)
          ***REMOVED***

          Object.keys(config).forEach(function (key) ***REMOVED***
            // setting arguments via CLI takes precedence over
            // values within the config file.
            if (argv[key] === undefined || (flags.defaulted[key])) ***REMOVED***
              delete argv[key]
              setArg(key, config[key])
            ***REMOVED***
          ***REMOVED***)
        ***REMOVED*** catch (ex) ***REMOVED***
          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  function applyEnvVars (opts, argv, configOnly) ***REMOVED***
    if (typeof opts.envPrefix === 'undefined') return

    var prefix = typeof opts.envPrefix === 'string' ? opts.envPrefix : ''
    Object.keys(process.env).forEach(function (envVar) ***REMOVED***
      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) ***REMOVED***
        var key = camelCase(envVar.substring(prefix.length))
        if (((configOnly && flags.configs[key]) || !configOnly) && (!(key in argv) || flags.defaulted[key])) ***REMOVED***
          setArg(key, process.env[envVar])
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  function applyDefaultsAndAliases (obj, aliases, defaults) ***REMOVED***
    Object.keys(defaults).forEach(function (key) ***REMOVED***
      if (!hasKey(obj, key.split('.'))) ***REMOVED***
        setKey(obj, key.split('.'), defaults[key])

        ;(aliases[key] || []).forEach(function (x) ***REMOVED***
          if (hasKey(obj, x.split('.'))) return
          setKey(obj, x.split('.'), defaults[key])
        ***REMOVED***)
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  function hasKey (obj, keys) ***REMOVED***
    var o = obj
    keys.slice(0, -1).forEach(function (key) ***REMOVED***
      o = (o[key] || ***REMOVED******REMOVED***)
    ***REMOVED***)

    var key = keys[keys.length - 1]

    if (typeof o !== 'object') return false
    else return key in o
  ***REMOVED***

  function setKey (obj, keys, value) ***REMOVED***
    var o = obj
    keys.slice(0, -1).forEach(function (key) ***REMOVED***
      if (o[key] === undefined) o[key] = ***REMOVED******REMOVED***
      o = o[key]
    ***REMOVED***)

    var key = keys[keys.length - 1]
    if (value === increment) ***REMOVED***
      o[key] = increment(o[key])
    ***REMOVED*** else if (o[key] === undefined && checkAllAliases(key, flags.arrays)) ***REMOVED***
      o[key] = Array.isArray(value) ? value : [value]
    ***REMOVED*** else if (o[key] === undefined || typeof o[key] === 'boolean') ***REMOVED***
      o[key] = value
    ***REMOVED*** else if (Array.isArray(o[key])) ***REMOVED***
      o[key].push(value)
    ***REMOVED*** else ***REMOVED***
      o[key] = [ o[key], value ]
    ***REMOVED***
  ***REMOVED***

  // extend the aliases list with inferred aliases.
  function extendAliases (obj) ***REMOVED***
    Object.keys(obj || ***REMOVED******REMOVED***).forEach(function (key) ***REMOVED***
      // short-circuit if we've already added a key
      // to the aliases array, for example it might
      // exist in both 'opts.default' and 'opts.key'.
      if (aliases[key]) return

      aliases[key] = [].concat(opts.alias[key] || [])
      // For "--option-name", also set argv.optionName
      aliases[key].concat(key).forEach(function (x) ***REMOVED***
        if (/-/.test(x)) ***REMOVED***
          var c = camelCase(x)
          aliases[key].push(c)
          newAliases[c] = true
        ***REMOVED***
      ***REMOVED***)
      aliases[key].forEach(function (x) ***REMOVED***
        aliases[x] = [key].concat(aliases[key].filter(function (y) ***REMOVED***
          return x !== y
        ***REMOVED***))
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***

  // check if a flag is set for any of a key's aliases.
  function checkAllAliases (key, flag) ***REMOVED***
    var isSet = false
    var toCheck = [].concat(aliases[key] || [], key)

    toCheck.forEach(function (key) ***REMOVED***
      if (flag[key]) isSet = flag[key]
    ***REMOVED***)

    return isSet
  ***REMOVED***

  function setDefaulted (key) ***REMOVED***
    [].concat(aliases[key] || [], key).forEach(function (k) ***REMOVED***
      flags.defaulted[k] = true
    ***REMOVED***)
  ***REMOVED***

  function unsetDefaulted (key) ***REMOVED***
    [].concat(aliases[key] || [], key).forEach(function (k) ***REMOVED***
      delete flags.defaulted[k]
    ***REMOVED***)
  ***REMOVED***

  // return a default value, given the type of a flag.,
  // e.g., key of type 'string' will default to '', rather than 'true'.
  function defaultForType (type) ***REMOVED***
    var def = ***REMOVED***
      boolean: true,
      string: '',
      array: []
    ***REMOVED***

    return def[type]
  ***REMOVED***

  // given a flag, enforce a default type.
  function guessType (key, flags) ***REMOVED***
    var type = 'boolean'

    if (flags.strings && flags.strings[key]) type = 'string'
    else if (flags.arrays && flags.arrays[key]) type = 'array'

    return type
  ***REMOVED***

  function isNumber (x) ***REMOVED***
    if (typeof x === 'number') return true
    if (/^0x[0-9a-f]+$/i.test(x)) return true
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
  ***REMOVED***

  return ***REMOVED***
    argv: argv,
    aliases: aliases,
    error: error,
    newAliases: newAliases
  ***REMOVED***
***REMOVED***
