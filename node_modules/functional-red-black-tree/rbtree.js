"use strict"

module.exports = createRBTree

var RED   = 0
var BLACK = 1

function RBNode(color, key, value, left, right, count) ***REMOVED***
  this._color = color
  this.key = key
  this.value = value
  this.left = left
  this.right = right
  this._count = count
***REMOVED***

function cloneNode(node) ***REMOVED***
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)
***REMOVED***

function repaint(color, node) ***REMOVED***
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)
***REMOVED***

function recount(node) ***REMOVED***
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)
***REMOVED***

function RedBlackTree(compare, root) ***REMOVED***
  this._compare = compare
  this.root = root
***REMOVED***

var proto = RedBlackTree.prototype

Object.defineProperty(proto, "keys", ***REMOVED***
  get: function() ***REMOVED***
    var result = []
    this.forEach(function(k,v) ***REMOVED***
      result.push(k)
    ***REMOVED***)
    return result
  ***REMOVED***
***REMOVED***)

Object.defineProperty(proto, "values", ***REMOVED***
  get: function() ***REMOVED***
    var result = []
    this.forEach(function(k,v) ***REMOVED***
      result.push(v)
    ***REMOVED***)
    return result
  ***REMOVED***
***REMOVED***)

//Returns the number of nodes in the tree
Object.defineProperty(proto, "length", ***REMOVED***
  get: function() ***REMOVED***
    if(this.root) ***REMOVED***
      return this.root._count
    ***REMOVED***
    return 0
  ***REMOVED***
***REMOVED***)

//Insert a new item into the tree
proto.insert = function(key, value) ***REMOVED***
  var cmp = this._compare
  //Find point to insert new node at
  var n = this.root
  var n_stack = []
  var d_stack = []
  while(n) ***REMOVED***
    var d = cmp(key, n.key)
    n_stack.push(n)
    d_stack.push(d)
    if(d <= 0) ***REMOVED***
      n = n.left
    ***REMOVED*** else ***REMOVED***
      n = n.right
    ***REMOVED***
  ***REMOVED***
  //Rebuild path to leaf node
  n_stack.push(new RBNode(RED, key, value, null, null, 1))
  for(var s=n_stack.length-2; s>=0; --s) ***REMOVED***
    var n = n_stack[s]
    if(d_stack[s] <= 0) ***REMOVED***
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)
    ***REMOVED*** else ***REMOVED***
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)
    ***REMOVED***
  ***REMOVED***
  //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)
  for(var s=n_stack.length-1; s>1; --s) ***REMOVED***
    var p = n_stack[s-1]
    var n = n_stack[s]
    if(p._color === BLACK || n._color === BLACK) ***REMOVED***
      break
    ***REMOVED***
    var pp = n_stack[s-2]
    if(pp.left === p) ***REMOVED***
      if(p.left === n) ***REMOVED***
        var y = pp.right
        if(y && y._color === RED) ***REMOVED***
          //console.log("LLr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        ***REMOVED*** else ***REMOVED***
          //console.log("LLb")
          pp._color = RED
          pp.left = p.right
          p._color = BLACK
          p.right = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) ***REMOVED***
            var ppp = n_stack[s-3]
            if(ppp.left === pp) ***REMOVED***
              ppp.left = p
            ***REMOVED*** else ***REMOVED***
              ppp.right = p
            ***REMOVED***
          ***REMOVED***
          break
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        var y = pp.right
        if(y && y._color === RED) ***REMOVED***
          //console.log("LRr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        ***REMOVED*** else ***REMOVED***
          //console.log("LRb")
          p.right = n.left
          pp._color = RED
          pp.left = n.right
          n._color = BLACK
          n.left = p
          n.right = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) ***REMOVED***
            var ppp = n_stack[s-3]
            if(ppp.left === pp) ***REMOVED***
              ppp.left = n
            ***REMOVED*** else ***REMOVED***
              ppp.right = n
            ***REMOVED***
          ***REMOVED***
          break
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if(p.right === n) ***REMOVED***
        var y = pp.left
        if(y && y._color === RED) ***REMOVED***
          //console.log("RRr", y.key)
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        ***REMOVED*** else ***REMOVED***
          //console.log("RRb")
          pp._color = RED
          pp.right = p.left
          p._color = BLACK
          p.left = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) ***REMOVED***
            var ppp = n_stack[s-3]
            if(ppp.right === pp) ***REMOVED***
              ppp.right = p
            ***REMOVED*** else ***REMOVED***
              ppp.left = p
            ***REMOVED***
          ***REMOVED***
          break
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        var y = pp.left
        if(y && y._color === RED) ***REMOVED***
          //console.log("RLr")
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        ***REMOVED*** else ***REMOVED***
          //console.log("RLb")
          p.left = n.right
          pp._color = RED
          pp.right = n.left
          n._color = BLACK
          n.right = p
          n.left = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) ***REMOVED***
            var ppp = n_stack[s-3]
            if(ppp.right === pp) ***REMOVED***
              ppp.right = n
            ***REMOVED*** else ***REMOVED***
              ppp.left = n
            ***REMOVED***
          ***REMOVED***
          break
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  //Return new tree
  n_stack[0]._color = BLACK
  return new RedBlackTree(cmp, n_stack[0])
***REMOVED***


//Visit all nodes inorder
function doVisitFull(visit, node) ***REMOVED***
  if(node.left) ***REMOVED***
    var v = doVisitFull(visit, node.left)
    if(v) ***REMOVED*** return v ***REMOVED***
  ***REMOVED***
  var v = visit(node.key, node.value)
  if(v) ***REMOVED*** return v ***REMOVED***
  if(node.right) ***REMOVED***
    return doVisitFull(visit, node.right)
  ***REMOVED***
***REMOVED***

//Visit half nodes in order
function doVisitHalf(lo, compare, visit, node) ***REMOVED***
  var l = compare(lo, node.key)
  if(l <= 0) ***REMOVED***
    if(node.left) ***REMOVED***
      var v = doVisitHalf(lo, compare, visit, node.left)
      if(v) ***REMOVED*** return v ***REMOVED***
    ***REMOVED***
    var v = visit(node.key, node.value)
    if(v) ***REMOVED*** return v ***REMOVED***
  ***REMOVED***
  if(node.right) ***REMOVED***
    return doVisitHalf(lo, compare, visit, node.right)
  ***REMOVED***
***REMOVED***

//Visit all nodes within a range
function doVisit(lo, hi, compare, visit, node) ***REMOVED***
  var l = compare(lo, node.key)
  var h = compare(hi, node.key)
  var v
  if(l <= 0) ***REMOVED***
    if(node.left) ***REMOVED***
      v = doVisit(lo, hi, compare, visit, node.left)
      if(v) ***REMOVED*** return v ***REMOVED***
    ***REMOVED***
    if(h > 0) ***REMOVED***
      v = visit(node.key, node.value)
      if(v) ***REMOVED*** return v ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if(h > 0 && node.right) ***REMOVED***
    return doVisit(lo, hi, compare, visit, node.right)
  ***REMOVED***
***REMOVED***


proto.forEach = function rbTreeForEach(visit, lo, hi) ***REMOVED***
  if(!this.root) ***REMOVED***
    return
  ***REMOVED***
  switch(arguments.length) ***REMOVED***
    case 1:
      return doVisitFull(visit, this.root)
    break

    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root)
    break

    case 3:
      if(this._compare(lo, hi) >= 0) ***REMOVED***
        return
      ***REMOVED***
      return doVisit(lo, hi, this._compare, visit, this.root)
    break
  ***REMOVED***
***REMOVED***

//First item in list
Object.defineProperty(proto, "begin", ***REMOVED***
  get: function() ***REMOVED***
    var stack = []
    var n = this.root
    while(n) ***REMOVED***
      stack.push(n)
      n = n.left
    ***REMOVED***
    return new RedBlackTreeIterator(this, stack)
  ***REMOVED***
***REMOVED***)

//Last item in list
Object.defineProperty(proto, "end", ***REMOVED***
  get: function() ***REMOVED***
    var stack = []
    var n = this.root
    while(n) ***REMOVED***
      stack.push(n)
      n = n.right
    ***REMOVED***
    return new RedBlackTreeIterator(this, stack)
  ***REMOVED***
***REMOVED***)

//Find the ith item in the tree
proto.at = function(idx) ***REMOVED***
  if(idx < 0) ***REMOVED***
    return new RedBlackTreeIterator(this, [])
  ***REMOVED***
  var n = this.root
  var stack = []
  while(true) ***REMOVED***
    stack.push(n)
    if(n.left) ***REMOVED***
      if(idx < n.left._count) ***REMOVED***
        n = n.left
        continue
      ***REMOVED***
      idx -= n.left._count
    ***REMOVED***
    if(!idx) ***REMOVED***
      return new RedBlackTreeIterator(this, stack)
    ***REMOVED***
    idx -= 1
    if(n.right) ***REMOVED***
      if(idx >= n.right._count) ***REMOVED***
        break
      ***REMOVED***
      n = n.right
    ***REMOVED*** else ***REMOVED***
      break
    ***REMOVED***
  ***REMOVED***
  return new RedBlackTreeIterator(this, [])
***REMOVED***

proto.ge = function(key) ***REMOVED***
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) ***REMOVED***
    var d = cmp(key, n.key)
    stack.push(n)
    if(d <= 0) ***REMOVED***
      last_ptr = stack.length
    ***REMOVED***
    if(d <= 0) ***REMOVED***
      n = n.left
    ***REMOVED*** else ***REMOVED***
      n = n.right
    ***REMOVED***
  ***REMOVED***
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
***REMOVED***

proto.gt = function(key) ***REMOVED***
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) ***REMOVED***
    var d = cmp(key, n.key)
    stack.push(n)
    if(d < 0) ***REMOVED***
      last_ptr = stack.length
    ***REMOVED***
    if(d < 0) ***REMOVED***
      n = n.left
    ***REMOVED*** else ***REMOVED***
      n = n.right
    ***REMOVED***
  ***REMOVED***
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
***REMOVED***

proto.lt = function(key) ***REMOVED***
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) ***REMOVED***
    var d = cmp(key, n.key)
    stack.push(n)
    if(d > 0) ***REMOVED***
      last_ptr = stack.length
    ***REMOVED***
    if(d <= 0) ***REMOVED***
      n = n.left
    ***REMOVED*** else ***REMOVED***
      n = n.right
    ***REMOVED***
  ***REMOVED***
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
***REMOVED***

proto.le = function(key) ***REMOVED***
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) ***REMOVED***
    var d = cmp(key, n.key)
    stack.push(n)
    if(d >= 0) ***REMOVED***
      last_ptr = stack.length
    ***REMOVED***
    if(d < 0) ***REMOVED***
      n = n.left
    ***REMOVED*** else ***REMOVED***
      n = n.right
    ***REMOVED***
  ***REMOVED***
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
***REMOVED***

//Finds the item with key if it exists
proto.find = function(key) ***REMOVED***
  var cmp = this._compare
  var n = this.root
  var stack = []
  while(n) ***REMOVED***
    var d = cmp(key, n.key)
    stack.push(n)
    if(d === 0) ***REMOVED***
      return new RedBlackTreeIterator(this, stack)
    ***REMOVED***
    if(d <= 0) ***REMOVED***
      n = n.left
    ***REMOVED*** else ***REMOVED***
      n = n.right
    ***REMOVED***
  ***REMOVED***
  return new RedBlackTreeIterator(this, [])
***REMOVED***

//Removes item with key from tree
proto.remove = function(key) ***REMOVED***
  var iter = this.find(key)
  if(iter) ***REMOVED***
    return iter.remove()
  ***REMOVED***
  return this
***REMOVED***

//Returns the item at `key`
proto.get = function(key) ***REMOVED***
  var cmp = this._compare
  var n = this.root
  while(n) ***REMOVED***
    var d = cmp(key, n.key)
    if(d === 0) ***REMOVED***
      return n.value
    ***REMOVED***
    if(d <= 0) ***REMOVED***
      n = n.left
    ***REMOVED*** else ***REMOVED***
      n = n.right
    ***REMOVED***
  ***REMOVED***
  return
***REMOVED***

//Iterator for red black tree
function RedBlackTreeIterator(tree, stack) ***REMOVED***
  this.tree = tree
  this._stack = stack
***REMOVED***

var iproto = RedBlackTreeIterator.prototype

//Test if iterator is valid
Object.defineProperty(iproto, "valid", ***REMOVED***
  get: function() ***REMOVED***
    return this._stack.length > 0
  ***REMOVED***
***REMOVED***)

//Node of the iterator
Object.defineProperty(iproto, "node", ***REMOVED***
  get: function() ***REMOVED***
    if(this._stack.length > 0) ***REMOVED***
      return this._stack[this._stack.length-1]
    ***REMOVED***
    return null
  ***REMOVED***,
  enumerable: true
***REMOVED***)

//Makes a copy of an iterator
iproto.clone = function() ***REMOVED***
  return new RedBlackTreeIterator(this.tree, this._stack.slice())
***REMOVED***

//Swaps two nodes
function swapNode(n, v) ***REMOVED***
  n.key = v.key
  n.value = v.value
  n.left = v.left
  n.right = v.right
  n._color = v._color
  n._count = v._count
***REMOVED***

//Fix up a double black node in a tree
function fixDoubleBlack(stack) ***REMOVED***
  var n, p, s, z
  for(var i=stack.length-1; i>=0; --i) ***REMOVED***
    n = stack[i]
    if(i === 0) ***REMOVED***
      n._color = BLACK
      return
    ***REMOVED***
    //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
    p = stack[i-1]
    if(p.left === n) ***REMOVED***
      //console.log("left child")
      s = p.right
      if(s.right && s.right._color === RED) ***REMOVED***
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.right = s.left
        s.left = p
        s.right = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) ***REMOVED***
          var pp = stack[i-2]
          if(pp.left === p) ***REMOVED***
            pp.left = s
          ***REMOVED*** else ***REMOVED***
            pp.right = s
          ***REMOVED***
        ***REMOVED***
        stack[i-1] = s
        return
      ***REMOVED*** else if(s.left && s.left._color === RED) ***REMOVED***
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.right = z.left
        s.left = z.right
        z.left = p
        z.right = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) ***REMOVED***
          var pp = stack[i-2]
          if(pp.left === p) ***REMOVED***
            pp.left = z
          ***REMOVED*** else ***REMOVED***
            pp.right = z
          ***REMOVED***
        ***REMOVED***
        stack[i-1] = z
        return
      ***REMOVED***
      if(s._color === BLACK) ***REMOVED***
        if(p._color === RED) ***REMOVED***
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK
          p.right = repaint(RED, s)
          return
        ***REMOVED*** else ***REMOVED***
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s)
          continue  
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.right = s.left
        s.left = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) ***REMOVED***
          var pp = stack[i-2]
          if(pp.left === p) ***REMOVED***
            pp.left = s
          ***REMOVED*** else ***REMOVED***
            pp.right = s
          ***REMOVED***
        ***REMOVED***
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) ***REMOVED***
          stack[i+1] = n
        ***REMOVED*** else ***REMOVED***
          stack.push(n)
        ***REMOVED***
        i = i+2
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      //console.log("right child")
      s = p.left
      if(s.left && s.left._color === RED) ***REMOVED***
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.left = s.right
        s.right = p
        s.left = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) ***REMOVED***
          var pp = stack[i-2]
          if(pp.right === p) ***REMOVED***
            pp.right = s
          ***REMOVED*** else ***REMOVED***
            pp.left = s
          ***REMOVED***
        ***REMOVED***
        stack[i-1] = s
        return
      ***REMOVED*** else if(s.right && s.right._color === RED) ***REMOVED***
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.left = z.right
        s.right = z.left
        z.right = p
        z.left = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) ***REMOVED***
          var pp = stack[i-2]
          if(pp.right === p) ***REMOVED***
            pp.right = z
          ***REMOVED*** else ***REMOVED***
            pp.left = z
          ***REMOVED***
        ***REMOVED***
        stack[i-1] = z
        return
      ***REMOVED***
      if(s._color === BLACK) ***REMOVED***
        if(p._color === RED) ***REMOVED***
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK
          p.left = repaint(RED, s)
          return
        ***REMOVED*** else ***REMOVED***
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s)
          continue  
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.left = s.right
        s.right = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) ***REMOVED***
          var pp = stack[i-2]
          if(pp.right === p) ***REMOVED***
            pp.right = s
          ***REMOVED*** else ***REMOVED***
            pp.left = s
          ***REMOVED***
        ***REMOVED***
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) ***REMOVED***
          stack[i+1] = n
        ***REMOVED*** else ***REMOVED***
          stack.push(n)
        ***REMOVED***
        i = i+2
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

//Removes item at iterator from tree
iproto.remove = function() ***REMOVED***
  var stack = this._stack
  if(stack.length === 0) ***REMOVED***
    return this.tree
  ***REMOVED***
  //First copy path to node
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) ***REMOVED***
    var n = stack[i]
    if(n.left === stack[i+1]) ***REMOVED***
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    ***REMOVED*** else ***REMOVED***
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    ***REMOVED***
  ***REMOVED***

  //Get node
  n = cstack[cstack.length-1]
  //console.log("start remove: ", n.value)

  //If not leaf, then swap with previous node
  if(n.left && n.right) ***REMOVED***
    //console.log("moving to leaf")

    //First walk to previous leaf
    var split = cstack.length
    n = n.left
    while(n.right) ***REMOVED***
      cstack.push(n)
      n = n.right
    ***REMOVED***
    //Copy path to leaf
    var v = cstack[split-1]
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))
    cstack[split-1].key = n.key
    cstack[split-1].value = n.value

    //Fix up stack
    for(var i=cstack.length-2; i>=split; --i) ***REMOVED***
      n = cstack[i]
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    ***REMOVED***
    cstack[split-1].left = cstack[split]
  ***REMOVED***
  //console.log("stack=", cstack.map(function(v) ***REMOVED*** return v.value ***REMOVED***))

  //Remove leaf node
  n = cstack[cstack.length-1]
  if(n._color === RED) ***REMOVED***
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length-2]
    if(p.left === n) ***REMOVED***
      p.left = null
    ***REMOVED*** else if(p.right === n) ***REMOVED***
      p.right = null
    ***REMOVED***
    cstack.pop()
    for(var i=0; i<cstack.length; ++i) ***REMOVED***
      cstack[i]._count--
    ***REMOVED***
    return new RedBlackTree(this.tree._compare, cstack[0])
  ***REMOVED*** else ***REMOVED***
    if(n.left || n.right) ***REMOVED***
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if(n.left) ***REMOVED***
        swapNode(n, n.left)
      ***REMOVED*** else if(n.right) ***REMOVED***
        swapNode(n, n.right)
      ***REMOVED***
      //Child must be red, so repaint it black to balance color
      n._color = BLACK
      for(var i=0; i<cstack.length-1; ++i) ***REMOVED***
        cstack[i]._count--
      ***REMOVED***
      return new RedBlackTree(this.tree._compare, cstack[0])
    ***REMOVED*** else if(cstack.length === 1) ***REMOVED***
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null)
    ***REMOVED*** else ***REMOVED***
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for(var i=0; i<cstack.length; ++i) ***REMOVED***
        cstack[i]._count--
      ***REMOVED***
      var parent = cstack[cstack.length-2]
      fixDoubleBlack(cstack)
      //Fix up links
      if(parent.left === n) ***REMOVED***
        parent.left = null
      ***REMOVED*** else ***REMOVED***
        parent.right = null
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return new RedBlackTree(this.tree._compare, cstack[0])
***REMOVED***

//Returns key
Object.defineProperty(iproto, "key", ***REMOVED***
  get: function() ***REMOVED***
    if(this._stack.length > 0) ***REMOVED***
      return this._stack[this._stack.length-1].key
    ***REMOVED***
    return
  ***REMOVED***,
  enumerable: true
***REMOVED***)

//Returns value
Object.defineProperty(iproto, "value", ***REMOVED***
  get: function() ***REMOVED***
    if(this._stack.length > 0) ***REMOVED***
      return this._stack[this._stack.length-1].value
    ***REMOVED***
    return
  ***REMOVED***,
  enumerable: true
***REMOVED***)


//Returns the position of this iterator in the sorted list
Object.defineProperty(iproto, "index", ***REMOVED***
  get: function() ***REMOVED***
    var idx = 0
    var stack = this._stack
    if(stack.length === 0) ***REMOVED***
      var r = this.tree.root
      if(r) ***REMOVED***
        return r._count
      ***REMOVED***
      return 0
    ***REMOVED*** else if(stack[stack.length-1].left) ***REMOVED***
      idx = stack[stack.length-1].left._count
    ***REMOVED***
    for(var s=stack.length-2; s>=0; --s) ***REMOVED***
      if(stack[s+1] === stack[s].right) ***REMOVED***
        ++idx
        if(stack[s].left) ***REMOVED***
          idx += stack[s].left._count
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    return idx
  ***REMOVED***,
  enumerable: true
***REMOVED***)

//Advances iterator to next element in list
iproto.next = function() ***REMOVED***
  var stack = this._stack
  if(stack.length === 0) ***REMOVED***
    return
  ***REMOVED***
  var n = stack[stack.length-1]
  if(n.right) ***REMOVED***
    n = n.right
    while(n) ***REMOVED***
      stack.push(n)
      n = n.left
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].right === n) ***REMOVED***
      n = stack[stack.length-1]
      stack.pop()
    ***REMOVED***
  ***REMOVED***
***REMOVED***

//Checks if iterator is at end of tree
Object.defineProperty(iproto, "hasNext", ***REMOVED***
  get: function() ***REMOVED***
    var stack = this._stack
    if(stack.length === 0) ***REMOVED***
      return false
    ***REMOVED***
    if(stack[stack.length-1].right) ***REMOVED***
      return true
    ***REMOVED***
    for(var s=stack.length-1; s>0; --s) ***REMOVED***
      if(stack[s-1].left === stack[s]) ***REMOVED***
        return true
      ***REMOVED***
    ***REMOVED***
    return false
  ***REMOVED***
***REMOVED***)

//Update value
iproto.update = function(value) ***REMOVED***
  var stack = this._stack
  if(stack.length === 0) ***REMOVED***
    throw new Error("Can't update empty node!")
  ***REMOVED***
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) ***REMOVED***
    n = stack[i]
    if(n.left === stack[i+1]) ***REMOVED***
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    ***REMOVED*** else ***REMOVED***
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    ***REMOVED***
  ***REMOVED***
  return new RedBlackTree(this.tree._compare, cstack[0])
***REMOVED***

//Moves iterator backward one element
iproto.prev = function() ***REMOVED***
  var stack = this._stack
  if(stack.length === 0) ***REMOVED***
    return
  ***REMOVED***
  var n = stack[stack.length-1]
  if(n.left) ***REMOVED***
    n = n.left
    while(n) ***REMOVED***
      stack.push(n)
      n = n.right
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].left === n) ***REMOVED***
      n = stack[stack.length-1]
      stack.pop()
    ***REMOVED***
  ***REMOVED***
***REMOVED***

//Checks if iterator is at start of tree
Object.defineProperty(iproto, "hasPrev", ***REMOVED***
  get: function() ***REMOVED***
    var stack = this._stack
    if(stack.length === 0) ***REMOVED***
      return false
    ***REMOVED***
    if(stack[stack.length-1].left) ***REMOVED***
      return true
    ***REMOVED***
    for(var s=stack.length-1; s>0; --s) ***REMOVED***
      if(stack[s-1].right === stack[s]) ***REMOVED***
        return true
      ***REMOVED***
    ***REMOVED***
    return false
  ***REMOVED***
***REMOVED***)

//Default comparison function
function defaultCompare(a, b) ***REMOVED***
  if(a < b) ***REMOVED***
    return -1
  ***REMOVED***
  if(a > b) ***REMOVED***
    return 1
  ***REMOVED***
  return 0
***REMOVED***

//Build a tree
function createRBTree(compare) ***REMOVED***
  return new RedBlackTree(compare || defaultCompare, null)
***REMOVED***