'use strict';

var isObject = require('isobject');
var define = require('define-property');
var utils = require('snapdragon-util');
var ownNames;

/**
 * Create a new AST `Node` with the given `val` and `type`.
 *
 * ```js
 * var node = new Node('*', 'Star');
 * var node = new Node(***REMOVED***type: 'star', val: '*'***REMOVED***);
 * ```
 * @name Node
 * @param ***REMOVED***String|Object***REMOVED*** `val` Pass a matched substring, or an object to merge onto the node.
 * @param ***REMOVED***String***REMOVED*** `type` The node type to use when `val` is a string.
 * @return ***REMOVED***Object***REMOVED*** node instance
 * @api public
 */

function Node(val, type, parent) ***REMOVED***
  if (typeof type !== 'string') ***REMOVED***
    parent = type;
    type = null;
  ***REMOVED***

  define(this, 'parent', parent);
  define(this, 'isNode', true);
  define(this, 'expect', null);

  if (typeof type !== 'string' && isObject(val)) ***REMOVED***
    lazyKeys();
    var keys = Object.keys(val);
    for (var i = 0; i < keys.length; i++) ***REMOVED***
      var key = keys[i];
      if (ownNames.indexOf(key) === -1) ***REMOVED***
        this[key] = val[key];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    this.type = type;
    this.val = val;
  ***REMOVED***
***REMOVED***

/**
 * Returns true if the given value is a node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * console.log(Node.isNode(node)); //=> true
 * console.log(Node.isNode(***REMOVED******REMOVED***)); //=> false
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node`
 * @returns ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Node.isNode = function(node) ***REMOVED***
  return utils.isNode(node);
***REMOVED***;

/**
 * Define a non-enumberable property on the node instance.
 * Useful for adding properties that shouldn't be extended
 * or visible during debugging.
 *
 * ```js
 * var node = new Node();
 * node.define('foo', 'something non-enumerable');
 * ```
 * @param ***REMOVED***String***REMOVED*** `name`
 * @param ***REMOVED***any***REMOVED*** `val`
 * @return ***REMOVED***Object***REMOVED*** returns the node instance
 * @api public
 */

Node.prototype.define = function(name, val) ***REMOVED***
  define(this, name, val);
  return this;
***REMOVED***;

/**
 * Returns true if `node.val` is an empty string, or `node.nodes` does
 * not contain any non-empty text nodes.
 *
 * ```js
 * var node = new Node(***REMOVED***type: 'text'***REMOVED***);
 * node.isEmpty(); //=> true
 * node.val = 'foo';
 * node.isEmpty(); //=> false
 * ```
 * @param ***REMOVED***Function***REMOVED*** `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Node.prototype.isEmpty = function(fn) ***REMOVED***
  return utils.isEmpty(this, fn);
***REMOVED***;

/**
 * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and
 * set `foo` as `bar.parent`.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * foo.push(bar);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node`
 * @return ***REMOVED***Number***REMOVED*** Returns the length of `node.nodes`
 * @api public
 */

Node.prototype.push = function(node) ***REMOVED***
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  define(node, 'parent', this);

  this.nodes = this.nodes || [];
  return this.nodes.push(node);
***REMOVED***;

/**
 * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and
 * set `foo` as `bar.parent`.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * foo.unshift(bar);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node`
 * @return ***REMOVED***Number***REMOVED*** Returns the length of `node.nodes`
 * @api public
 */

Node.prototype.unshift = function(node) ***REMOVED***
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  define(node, 'parent', this);

  this.nodes = this.nodes || [];
  return this.nodes.unshift(node);
***REMOVED***;

/**
 * Pop a node from `node.nodes`.
 *
 * ```js
 * var node = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * node.push(new Node(***REMOVED***type: 'a'***REMOVED***));
 * node.push(new Node(***REMOVED***type: 'b'***REMOVED***));
 * node.push(new Node(***REMOVED***type: 'c'***REMOVED***));
 * node.push(new Node(***REMOVED***type: 'd'***REMOVED***));
 * console.log(node.nodes.length);
 * //=> 4
 * node.pop();
 * console.log(node.nodes.length);
 * //=> 3
 * ```
 * @return ***REMOVED***Number***REMOVED*** Returns the popped `node`
 * @api public
 */

Node.prototype.pop = function() ***REMOVED***
  return this.nodes && this.nodes.pop();
***REMOVED***;

/**
 * Shift a node from `node.nodes`.
 *
 * ```js
 * var node = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * node.push(new Node(***REMOVED***type: 'a'***REMOVED***));
 * node.push(new Node(***REMOVED***type: 'b'***REMOVED***));
 * node.push(new Node(***REMOVED***type: 'c'***REMOVED***));
 * node.push(new Node(***REMOVED***type: 'd'***REMOVED***));
 * console.log(node.nodes.length);
 * //=> 4
 * node.shift();
 * console.log(node.nodes.length);
 * //=> 3
 * ```
 * @return ***REMOVED***Object***REMOVED*** Returns the shifted `node`
 * @api public
 */

Node.prototype.shift = function() ***REMOVED***
  return this.nodes && this.nodes.shift();
***REMOVED***;

/**
 * Remove `node` from `node.nodes`.
 *
 * ```js
 * node.remove(childNode);
 * ```
 * @param ***REMOVED***Object***REMOVED*** `node`
 * @return ***REMOVED***Object***REMOVED*** Returns the removed node.
 * @api public
 */

Node.prototype.remove = function(node) ***REMOVED***
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  this.nodes = this.nodes || [];
  var idx = node.index;
  if (idx !== -1) ***REMOVED***
    node.index = -1;
    return this.nodes.splice(idx, 1);
  ***REMOVED***
  return null;
***REMOVED***;

/**
 * Get the first child node from `node.nodes` that matches the given `type`.
 * If `type` is a number, the child node at that index is returned.
 *
 * ```js
 * var child = node.find(1); //<= index of the node to get
 * var child = node.find('foo'); //<= node.type of a child node
 * var child = node.find(/^(foo|bar)$/); //<= regex to match node.type
 * var child = node.find(['foo', 'bar']); //<= array of node.type(s)
 * ```
 * @param ***REMOVED***String***REMOVED*** `type`
 * @return ***REMOVED***Object***REMOVED*** Returns a child node or undefined.
 * @api public
 */

Node.prototype.find = function(type) ***REMOVED***
  return utils.findNode(this.nodes, type);
***REMOVED***;

/**
 * Return true if the node is the given `type`.
 *
 * ```js
 * var node = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * cosole.log(node.isType('foo'));          // false
 * cosole.log(node.isType(/^(foo|bar)$/));  // true
 * cosole.log(node.isType(['foo', 'bar'])); // true
 * ```
 * @param ***REMOVED***String***REMOVED*** `type`
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Node.prototype.isType = function(type) ***REMOVED***
  return utils.isType(this, type);
***REMOVED***;

/**
 * Return true if the `node.nodes` has the given `type`.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * foo.push(bar);
 *
 * cosole.log(foo.hasType('qux'));          // false
 * cosole.log(foo.hasType(/^(qux|bar)$/));  // true
 * cosole.log(foo.hasType(['qux', 'bar'])); // true
 * ```
 * @param ***REMOVED***String***REMOVED*** `type`
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Node.prototype.hasType = function(type) ***REMOVED***
  return utils.hasType(this, type);
***REMOVED***;

/**
 * Get the siblings array, or `null` if it doesn't exist.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * var baz = new Node(***REMOVED***type: 'baz'***REMOVED***);
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(bar.siblings.length) // 2
 * console.log(baz.siblings.length) // 2
 * ```
 * @return ***REMOVED***Array***REMOVED***
 * @api public
 */

Object.defineProperty(Node.prototype, 'siblings', ***REMOVED***
  set: function() ***REMOVED***
    throw new Error('node.siblings is a getter and cannot be defined');
  ***REMOVED***,
  get: function() ***REMOVED***
    return this.parent ? this.parent.nodes : null;
  ***REMOVED***
***REMOVED***);

/**
 * Get the node's current index from `node.parent.nodes`.
 * This should always be correct, even when the parent adds nodes.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * var baz = new Node(***REMOVED***type: 'baz'***REMOVED***);
 * var qux = new Node(***REMOVED***type: 'qux'***REMOVED***);
 * foo.push(bar);
 * foo.push(baz);
 * foo.unshift(qux);
 *
 * console.log(bar.index) // 1
 * console.log(baz.index) // 2
 * console.log(qux.index) // 0
 * ```
 * @return ***REMOVED***Number***REMOVED***
 * @api public
 */

Object.defineProperty(Node.prototype, 'index', ***REMOVED***
  set: function(index) ***REMOVED***
    define(this, 'idx', index);
  ***REMOVED***,
  get: function() ***REMOVED***
    if (!Array.isArray(this.siblings)) ***REMOVED***
      return -1;
    ***REMOVED***
    var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
    if (tok !== this) ***REMOVED***
      this.idx = this.siblings.indexOf(this);
    ***REMOVED***
    return this.idx;
  ***REMOVED***
***REMOVED***);

/**
 * Get the previous node from the siblings array or `null`.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * var baz = new Node(***REMOVED***type: 'baz'***REMOVED***);
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(baz.prev.type) // 'bar'
 * ```
 * @return ***REMOVED***Object***REMOVED***
 * @api public
 */

Object.defineProperty(Node.prototype, 'prev', ***REMOVED***
  set: function() ***REMOVED***
    throw new Error('node.prev is a getter and cannot be defined');
  ***REMOVED***,
  get: function() ***REMOVED***
    if (Array.isArray(this.siblings)) ***REMOVED***
      return this.siblings[this.index - 1] || this.parent.prev;
    ***REMOVED***
    return null;
  ***REMOVED***
***REMOVED***);

/**
 * Get the siblings array, or `null` if it doesn't exist.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * var baz = new Node(***REMOVED***type: 'baz'***REMOVED***);
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(bar.siblings.length) // 2
 * console.log(baz.siblings.length) // 2
 * ```
 * @return ***REMOVED***Object***REMOVED***
 * @api public
 */

Object.defineProperty(Node.prototype, 'next', ***REMOVED***
  set: function() ***REMOVED***
    throw new Error('node.next is a getter and cannot be defined');
  ***REMOVED***,
  get: function() ***REMOVED***
    if (Array.isArray(this.siblings)) ***REMOVED***
      return this.siblings[this.index + 1] || this.parent.next;
    ***REMOVED***
    return null;
  ***REMOVED***
***REMOVED***);

/**
 * Get the first node from `node.nodes`.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * var baz = new Node(***REMOVED***type: 'baz'***REMOVED***);
 * var qux = new Node(***REMOVED***type: 'qux'***REMOVED***);
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.first.type) // 'bar'
 * ```
 * @return ***REMOVED***Object***REMOVED*** The first node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'first', ***REMOVED***
  get: function() ***REMOVED***
    return this.nodes ? this.nodes[0] : null;
  ***REMOVED***
***REMOVED***);

/**
 * Get the last node from `node.nodes`.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * var baz = new Node(***REMOVED***type: 'baz'***REMOVED***);
 * var qux = new Node(***REMOVED***type: 'qux'***REMOVED***);
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.last.type) // 'qux'
 * ```
 * @return ***REMOVED***Object***REMOVED*** The last node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'last', ***REMOVED***
  get: function() ***REMOVED***
    return this.nodes ? utils.last(this.nodes) : null;
  ***REMOVED***
***REMOVED***);

/**
 * Get the last node from `node.nodes`.
 *
 * ```js
 * var foo = new Node(***REMOVED***type: 'foo'***REMOVED***);
 * var bar = new Node(***REMOVED***type: 'bar'***REMOVED***);
 * var baz = new Node(***REMOVED***type: 'baz'***REMOVED***);
 * var qux = new Node(***REMOVED***type: 'qux'***REMOVED***);
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.last.type) // 'qux'
 * ```
 * @return ***REMOVED***Object***REMOVED*** The last node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'scope', ***REMOVED***
  get: function() ***REMOVED***
    if (this.isScope !== true) ***REMOVED***
      return this.parent ? this.parent.scope : this;
    ***REMOVED***
    return this;
  ***REMOVED***
***REMOVED***);

/**
 * Get own property names from Node prototype, but only the
 * first time `Node` is instantiated
 */

function lazyKeys() ***REMOVED***
  if (!ownNames) ***REMOVED***
    ownNames = Object.getOwnPropertyNames(Node.prototype);
  ***REMOVED***
***REMOVED***

/**
 * Simplified assertion. Throws an error is `val` is falsey.
 */

function assert(val, message) ***REMOVED***
  if (!val) throw new Error(message);
***REMOVED***

/**
 * Expose `Node`
 */

exports = module.exports = Node;
