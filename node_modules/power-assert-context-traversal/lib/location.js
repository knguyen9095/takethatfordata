'use strict';

var syntax = require('estraverse').Syntax;

function locationOf(currentNode, tokens) ***REMOVED***
    switch(currentNode.type) ***REMOVED***
    case syntax.MemberExpression:
        return propertyLocationOf(currentNode, tokens);
    case syntax.CallExpression:
        if (currentNode.callee.type === syntax.MemberExpression) ***REMOVED***
            return propertyLocationOf(currentNode.callee, tokens);
        ***REMOVED***
        break;
    case syntax.BinaryExpression:
    case syntax.LogicalExpression:
    case syntax.AssignmentExpression:
        return infixOperatorLocationOf(currentNode, tokens);
    default:
        break;
    ***REMOVED***
    return currentNode.range;
***REMOVED***

function propertyLocationOf(memberExpression, tokens) ***REMOVED***
    var prop = memberExpression.property;
    var token;
    if (!memberExpression.computed) ***REMOVED***
        return prop.range;
    ***REMOVED***
    token = findLeftBracketTokenOf(memberExpression, tokens);
    return token ? token.range : prop.range;
***REMOVED***

// calculate location of infix operator for BinaryExpression, AssignmentExpression and LogicalExpression.
function infixOperatorLocationOf (expression, tokens) ***REMOVED***
    var token = findOperatorTokenOf(expression, tokens);
    return token ? token.range : expression.left.range;
***REMOVED***

function findLeftBracketTokenOf(expression, tokens) ***REMOVED***
    var fromColumn = expression.property.range[0];
    return searchToken(tokens, function (token, index) ***REMOVED***
        var prevToken;
        if (token.range[0] === fromColumn) ***REMOVED***
            prevToken = tokens[index - 1];
            // if (prevToken.type === 'Punctuator' && prevToken.value === '[') ***REMOVED***  // esprima
            if (prevToken.type.label === '[') ***REMOVED***  // acorn
                return prevToken;
            ***REMOVED***
        ***REMOVED***
        return undefined;
    ***REMOVED***);
***REMOVED***

function findOperatorTokenOf(expression, tokens) ***REMOVED***
    var fromColumn = expression.left.range[1];
    var toColumn = expression.right.range[0];
    return searchToken(tokens, function (token, index) ***REMOVED***
        if (fromColumn < token.range[0] &&
            token.range[1] < toColumn &&
            token.value === expression.operator) ***REMOVED***
            return token;
        ***REMOVED***
        return undefined;
    ***REMOVED***);
***REMOVED***

function searchToken(tokens, predicate) ***REMOVED***
    var i, token, found;
    for(i = 0; i < tokens.length; i += 1) ***REMOVED***
        token = tokens[i];
        found = predicate(token, i);
        if (found) ***REMOVED***
            return found;
        ***REMOVED***
    ***REMOVED***
    return undefined;
***REMOVED***

module.exports = locationOf;
