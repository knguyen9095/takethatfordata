var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = ***REMOVED***
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
***REMOVED***

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) ***REMOVED***
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = ***REMOVED******REMOVED***
	self.rawHeaders = []
	self.trailers = ***REMOVED******REMOVED***
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () ***REMOVED***
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () ***REMOVED***
			self.emit('close')
		***REMOVED***)
	***REMOVED***)

	if (mode === 'fetch') ***REMOVED***
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key)***REMOVED***
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		***REMOVED***)

		if (capability.writableStream) ***REMOVED***
			var writable = new WritableStream(***REMOVED***
				write: function (chunk) ***REMOVED***
					return new Promise(function (resolve, reject) ***REMOVED***
						if (self._destroyed) ***REMOVED***
							return
						***REMOVED*** else if(self.push(new Buffer(chunk))) ***REMOVED***
							resolve()
						***REMOVED*** else ***REMOVED***
							self._resumeFetch = resolve
						***REMOVED***
					***REMOVED***)
				***REMOVED***,
				close: function () ***REMOVED***
					if (!self._destroyed)
						self.push(null)
				***REMOVED***,
				abort: function (err) ***REMOVED***
					if (!self._destroyed)
						self.emit('error', err)
				***REMOVED***
			***REMOVED***)

			try ***REMOVED***
				response.body.pipeTo(writable)
				return
			***REMOVED*** catch (e) ***REMOVED******REMOVED*** // pipeTo method isn't defined. Can't find a better way to feature test this
		***REMOVED***
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () ***REMOVED***
			reader.read().then(function (result) ***REMOVED***
				if (self._destroyed)
					return
				if (result.done) ***REMOVED***
					self.push(null)
					return
				***REMOVED***
				self.push(new Buffer(result.value))
				read()
			***REMOVED***).catch(function(err) ***REMOVED***
				if (!self._destroyed)
					self.emit('error', err)
			***REMOVED***)
		***REMOVED***
		read()
	***REMOVED*** else ***REMOVED***
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) ***REMOVED***
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) ***REMOVED***
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') ***REMOVED***
					if (self.headers[key] === undefined) ***REMOVED***
						self.headers[key] = []
					***REMOVED***
					self.headers[key].push(matches[2])
				***REMOVED*** else if (self.headers[key] !== undefined) ***REMOVED***
					self.headers[key] += ', ' + matches[2]
				***REMOVED*** else ***REMOVED***
					self.headers[key] = matches[2]
				***REMOVED***
				self.rawHeaders.push(matches[1], matches[2])
			***REMOVED***
		***REMOVED***)

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) ***REMOVED***
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) ***REMOVED***
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) ***REMOVED***
					self._charset = charsetMatch[1].toLowerCase()
				***REMOVED***
			***REMOVED***
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		***REMOVED***
	***REMOVED***
***REMOVED***

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () ***REMOVED***
	var self = this

	var resolve = self._resumeFetch
	if (resolve) ***REMOVED***
		self._resumeFetch = null
		resolve()
	***REMOVED***
***REMOVED***

IncomingMessage.prototype._onXHRProgress = function () ***REMOVED***
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) ***REMOVED***
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try ***REMOVED***
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			***REMOVED*** catch (e) ***REMOVED******REMOVED***
			if (response !== null) ***REMOVED***
				self.push(new Buffer(response))
				break
			***REMOVED***
			// Falls through in IE8	
		case 'text':
			try ***REMOVED*** // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			***REMOVED*** catch (e) ***REMOVED***
				self._mode = 'text:vbarray'
				break
			***REMOVED***
			if (response.length > self._pos) ***REMOVED***
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') ***REMOVED***
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				***REMOVED*** else ***REMOVED***
					self.push(newData, self._charset)
				***REMOVED***
				self._pos = response.length
			***REMOVED***
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () ***REMOVED***
				if (reader.result.byteLength > self._pos) ***REMOVED***
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				***REMOVED***
			***REMOVED***
			reader.onload = function () ***REMOVED***
				self.push(null)
			***REMOVED***
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	***REMOVED***

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') ***REMOVED***
		self.push(null)
	***REMOVED***
***REMOVED***
