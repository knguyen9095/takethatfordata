var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) ***REMOVED***
	if (capability.fetch && useFetch) ***REMOVED***
		return 'fetch'
	***REMOVED*** else if (capability.mozchunkedarraybuffer) ***REMOVED***
		return 'moz-chunked-arraybuffer'
	***REMOVED*** else if (capability.msstream) ***REMOVED***
		return 'ms-stream'
	***REMOVED*** else if (capability.arraybuffer && preferBinary) ***REMOVED***
		return 'arraybuffer'
	***REMOVED*** else if (capability.vbArray && preferBinary) ***REMOVED***
		return 'text:vbarray'
	***REMOVED*** else ***REMOVED***
		return 'text'
	***REMOVED***
***REMOVED***

var ClientRequest = module.exports = function (opts) ***REMOVED***
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = ***REMOVED******REMOVED***
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) ***REMOVED***
		self.setHeader(name, opts.headers[name])
	***REMOVED***)

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) ***REMOVED***
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	***REMOVED*** else if (opts.mode === 'prefer-streaming') ***REMOVED***
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	***REMOVED*** else if (opts.mode === 'allow-wrong-content-type') ***REMOVED***
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	***REMOVED*** else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') ***REMOVED***
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	***REMOVED*** else ***REMOVED***
		throw new Error('Invalid value for opts.mode')
	***REMOVED***
	self._mode = decideMode(preferBinary, useFetch)

	self.on('finish', function () ***REMOVED***
		self._onFinish()
	***REMOVED***)
***REMOVED***

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) ***REMOVED***
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = ***REMOVED***
		name: name,
		value: value
	***REMOVED***
***REMOVED***

ClientRequest.prototype.getHeader = function (name) ***REMOVED***
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
***REMOVED***

ClientRequest.prototype.removeHeader = function (name) ***REMOVED***
	var self = this
	delete self._headers[name.toLowerCase()]
***REMOVED***

ClientRequest.prototype._onFinish = function () ***REMOVED***
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') ***REMOVED***
		if (capability.arraybuffer) ***REMOVED***
			body = toArrayBuffer(Buffer.concat(self._body))
		***REMOVED*** else if (capability.blobConstructor) ***REMOVED***
			body = new global.Blob(self._body.map(function (buffer) ***REMOVED***
				return toArrayBuffer(buffer)
			***REMOVED***), ***REMOVED***
				type: (headersObj['content-type'] || ***REMOVED******REMOVED***).value || ''
			***REMOVED***)
		***REMOVED*** else ***REMOVED***
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		***REMOVED***
	***REMOVED***

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) ***REMOVED***
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) ***REMOVED***
			value.forEach(function (v) ***REMOVED***
				headersList.push([name, v])
			***REMOVED***)
		***REMOVED*** else ***REMOVED***
			headersList.push([name, value])
		***REMOVED***
	***REMOVED***)

	if (self._mode === 'fetch') ***REMOVED***
		var signal = null
		if (capability.abortController) ***REMOVED***
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) ***REMOVED***
				global.setTimeout(function () ***REMOVED***
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				***REMOVED***, opts.requestTimeout)
			***REMOVED***
		***REMOVED***

		global.fetch(self._opts.url, ***REMOVED***
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		***REMOVED***).then(function (response) ***REMOVED***
			self._fetchResponse = response
			self._connect()
		***REMOVED***, function (reason) ***REMOVED***
			self.emit('error', reason)
		***REMOVED***)
	***REMOVED*** else ***REMOVED***
		var xhr = self._xhr = new global.XMLHttpRequest()
		try ***REMOVED***
			xhr.open(self._opts.method, self._opts.url, true)
		***REMOVED*** catch (err) ***REMOVED***
			process.nextTick(function () ***REMOVED***
				self.emit('error', err)
			***REMOVED***)
			return
		***REMOVED***

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) ***REMOVED***
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () ***REMOVED***
				self.emit('requestTimeout')
			***REMOVED***
		***REMOVED***

		headersList.forEach(function (header) ***REMOVED***
			xhr.setRequestHeader(header[0], header[1])
		***REMOVED***)

		self._response = null
		xhr.onreadystatechange = function () ***REMOVED***
			switch (xhr.readyState) ***REMOVED***
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			***REMOVED***
		***REMOVED***
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') ***REMOVED***
			xhr.onprogress = function () ***REMOVED***
				self._onXHRProgress()
			***REMOVED***
		***REMOVED***

		xhr.onerror = function () ***REMOVED***
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		***REMOVED***

		try ***REMOVED***
			xhr.send(body)
		***REMOVED*** catch (err) ***REMOVED***
			process.nextTick(function () ***REMOVED***
				self.emit('error', err)
			***REMOVED***)
			return
		***REMOVED***
	***REMOVED***
***REMOVED***

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) ***REMOVED***
	try ***REMOVED***
		var status = xhr.status
		return (status !== null && status !== 0)
	***REMOVED*** catch (e) ***REMOVED***
		return false
	***REMOVED***
***REMOVED***

ClientRequest.prototype._onXHRProgress = function () ***REMOVED***
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
***REMOVED***

ClientRequest.prototype._connect = function () ***REMOVED***
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
	self._response.on('error', function(err) ***REMOVED***
		self.emit('error', err)
	***REMOVED***)

	self.emit('response', self._response)
***REMOVED***

ClientRequest.prototype._write = function (chunk, encoding, cb) ***REMOVED***
	var self = this

	self._body.push(chunk)
	cb()
***REMOVED***

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () ***REMOVED***
	var self = this
	self._destroyed = true
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
***REMOVED***

ClientRequest.prototype.end = function (data, encoding, cb) ***REMOVED***
	var self = this
	if (typeof data === 'function') ***REMOVED***
		cb = data
		data = undefined
	***REMOVED***

	stream.Writable.prototype.end.call(self, data, encoding, cb)
***REMOVED***

ClientRequest.prototype.flushHeaders = function () ***REMOVED******REMOVED***
ClientRequest.prototype.setTimeout = function () ***REMOVED******REMOVED***
ClientRequest.prototype.setNoDelay = function () ***REMOVED******REMOVED***
ClientRequest.prototype.setSocketKeepAlive = function () ***REMOVED******REMOVED***

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'user-agent',
	'via'
]
