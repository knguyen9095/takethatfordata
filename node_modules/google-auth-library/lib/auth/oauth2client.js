"use strict";
/**
 * Copyright 2012 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var querystring = require("querystring");
var pemverifier_1 = require("./../pemverifier");
var transporters_1 = require("./../transporters");
var authclient_1 = require("./authclient");
var loginticket_1 = require("./loginticket");
var merge = require('lodash.merge');
var noop = Function.prototype;
var OAuth2Client = /** @class */ (function (_super) ***REMOVED***
    __extends(OAuth2Client, _super);
    /**
     * Handles OAuth2 flow for Google APIs.
     *
     * @param ***REMOVED***string=***REMOVED*** clientId The authentication client ID.
     * @param ***REMOVED***string=***REMOVED*** clientSecret The authentication client secret.
     * @param ***REMOVED***string=***REMOVED*** redirectUri The URI to redirect to after completing the auth request.
     * @param ***REMOVED***Object=***REMOVED*** opt_opts optional options for overriding the given parameters.
     * @constructor
     */
    function OAuth2Client(clientId, clientSecret, redirectUri, opt_opts) ***REMOVED***
        var _this = _super.call(this) || this;
        _this._certificateCache = null;
        _this._certificateExpiry = null;
        _this._clientId = clientId;
        _this._clientSecret = clientSecret;
        _this._redirectUri = redirectUri;
        _this._opts = opt_opts || ***REMOVED******REMOVED***;
        _this.credentials = ***REMOVED******REMOVED***;
        return _this;
    ***REMOVED***
    /**
     * Generates URL for consent page landing.
     * @param ***REMOVED***object=***REMOVED*** opt_opts Options.
     * @return ***REMOVED***string***REMOVED*** URL to consent page.
     */
    OAuth2Client.prototype.generateAuthUrl = function (opt_opts) ***REMOVED***
        var opts = opt_opts || ***REMOVED******REMOVED***;
        opts.response_type = opts.response_type || 'code';
        opts.client_id = opts.client_id || this._clientId;
        opts.redirect_uri = opts.redirect_uri || this._redirectUri;
        // Allow scopes to be passed either as array or a string
        if (opts.scope instanceof Array) ***REMOVED***
            opts.scope = opts.scope.join(' ');
        ***REMOVED***
        var rootUrl = this._opts.authBaseUrl || OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;
        return rootUrl + '?' + querystring.stringify(opts);
    ***REMOVED***;
    /**
     * Gets the access token for the given code.
     * @param ***REMOVED***string***REMOVED*** code The authorization code.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback fn.
     */
    OAuth2Client.prototype.getToken = function (code, callback) ***REMOVED***
        var uri = this._opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
        var values = ***REMOVED***
            code: code,
            client_id: this._clientId,
            client_secret: this._clientSecret,
            redirect_uri: this._redirectUri,
            grant_type: 'authorization_code'
        ***REMOVED***;
        this.transporter.request(***REMOVED*** method: 'POST', uri: uri, form: values, json: true ***REMOVED***, function (err, tokens, response) ***REMOVED***
            if (!err && tokens && tokens.expires_in) ***REMOVED***
                tokens.expiry_date =
                    ((new Date()).getTime() + (tokens.expires_in * 1000));
                delete tokens.expires_in;
            ***REMOVED***
            var done = callback || noop;
            done(err, tokens, response);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Refreshes the access token.
     * @param ***REMOVED***string***REMOVED*** refresh_token Existing refresh token.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback.
     * @private
     */
    OAuth2Client.prototype.refreshToken = function (refresh_token, callback) ***REMOVED***
        var uri = this._opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
        var values = ***REMOVED***
            refresh_token: refresh_token,
            client_id: this._clientId,
            client_secret: this._clientSecret,
            grant_type: 'refresh_token'
        ***REMOVED***;
        // request for new token
        return this.transporter.request(***REMOVED*** method: 'POST', uri: uri, form: values, json: true ***REMOVED***, function (err, tokens, response) ***REMOVED***
            if (!err && tokens && tokens.expires_in) ***REMOVED***
                tokens.expiry_date =
                    ((new Date()).getTime() + (tokens.expires_in * 1000));
                delete tokens.expires_in;
            ***REMOVED***
            var done = callback || noop;
            done(err, tokens, response);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Retrieves the access token using refresh token
     *
     * @deprecated use getRequestMetadata instead.
     * @param ***REMOVED***function***REMOVED*** callback callback
     */
    OAuth2Client.prototype.refreshAccessToken = function (callback) ***REMOVED***
        var _this = this;
        if (!this.credentials.refresh_token) ***REMOVED***
            callback(new Error('No refresh token is set.'), null);
            return;
        ***REMOVED***
        this.refreshToken(this.credentials.refresh_token, function (err, result, response) ***REMOVED***
            if (err) ***REMOVED***
                callback(err, null, response);
            ***REMOVED***
            else ***REMOVED***
                var tokens = result;
                tokens.refresh_token = _this.credentials.refresh_token;
                _this.credentials = tokens;
                callback(null, _this.credentials, response);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Get a non-expired access token, after refreshing if necessary
     *
     * @param ***REMOVED***function***REMOVED*** callback Callback to call with the access token
     */
    OAuth2Client.prototype.getAccessToken = function (callback) ***REMOVED***
        var expiryDate = this.credentials.expiry_date;
        // if no expiry time, assume it's not expired
        var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;
        if (!this.credentials.access_token && !this.credentials.refresh_token) ***REMOVED***
            return callback(new Error('No access or refresh token is set.'), null);
        ***REMOVED***
        var shouldRefresh = !this.credentials.access_token || isTokenExpired;
        if (shouldRefresh && this.credentials.refresh_token) ***REMOVED***
            if (!this.credentials.refresh_token) ***REMOVED***
                return callback(new Error('No refresh token is set.'), null);
            ***REMOVED***
            this.refreshAccessToken(function (err, tokens, response) ***REMOVED***
                if (err) ***REMOVED***
                    return callback(err, null, response);
                ***REMOVED***
                if (!tokens || (tokens && !tokens.access_token)) ***REMOVED***
                    return callback(new Error('Could not refresh access token.'), null, response);
                ***REMOVED***
                return callback(null, tokens.access_token, response);
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            return callback(null, this.credentials.access_token, null);
        ***REMOVED***
    ***REMOVED***;
    /**
     * getRequestMetadata obtains auth metadata to be used by requests.
     *
     * getRequestMetadata is the main authentication interface.  It takes an
     * optional uri which when present is the endpoint being accessed, and a
     * callback func(err, metadata_obj, response) where metadata_obj contains
     * authorization metadata fields and response is an optional response object.
     *
     * In OAuth2Client, metadata_obj has the form.
     *
     * ***REMOVED***Authorization: 'Bearer <access_token_value>'***REMOVED***
     *
     * @param ***REMOVED***string***REMOVED*** opt_uri the Uri being authorized
     * @param ***REMOVED***function***REMOVED*** metadataCb the func described above
     */
    OAuth2Client.prototype.getRequestMetadata = function (opt_uri, metadataCb) ***REMOVED***
        var _this = this;
        var thisCreds = this.credentials;
        if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) ***REMOVED***
            return metadataCb(new Error('No access, refresh token or API key is set.'), null);
        ***REMOVED***
        // if no expiry time, assume it's not expired
        var expiryDate = thisCreds.expiry_date;
        var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;
        if (thisCreds.access_token && !isTokenExpired) ***REMOVED***
            thisCreds.token_type = thisCreds.token_type || 'Bearer';
            var headers = ***REMOVED***
                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token
            ***REMOVED***;
            return metadataCb(null, headers, null);
        ***REMOVED***
        if (this.apiKey) ***REMOVED***
            return metadataCb(null, ***REMOVED******REMOVED***, null);
        ***REMOVED***
        return this.refreshToken(thisCreds.refresh_token, function (err, tokens, response) ***REMOVED***
            // If the error code is 403 or 404, go to the else so the error
            // message is replaced. Otherwise, return the error.
            if (err && err.code != 403 &&
                err.code != 404) ***REMOVED***
                return metadataCb(err, null, response);
            ***REMOVED***
            else ***REMOVED***
                if (!tokens || (tokens && !tokens.access_token)) ***REMOVED***
                    return metadataCb(new Error('Could not refresh access token.'), null, response);
                ***REMOVED***
                var credentials = _this.credentials;
                credentials.token_type = credentials.token_type || 'Bearer';
                tokens.refresh_token = credentials.refresh_token;
                _this.credentials = tokens;
                var headers = ***REMOVED***
                    Authorization: credentials.token_type + ' ' + tokens.access_token
                ***REMOVED***;
                return metadataCb(err, headers, response);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Revokes the access given to token.
     * @param ***REMOVED***string***REMOVED*** token The existing token to be revoked.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback fn.
     */
    OAuth2Client.prototype.revokeToken = function (token, callback) ***REMOVED***
        this.transporter.request(***REMOVED***
            uri: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +
                querystring.stringify(***REMOVED*** token: token ***REMOVED***),
            json: true
        ***REMOVED***, callback);
    ***REMOVED***;
    /**
     * Revokes access token and clears the credentials object
     * @param  ***REMOVED***Function=***REMOVED*** callback callback
     */
    OAuth2Client.prototype.revokeCredentials = function (callback) ***REMOVED***
        var token = this.credentials.access_token;
        this.credentials = ***REMOVED******REMOVED***;
        if (token) ***REMOVED***
            this.revokeToken(token, callback);
        ***REMOVED***
        else ***REMOVED***
            callback(new transporters_1.RequestError('No access token to revoke.'), null, null);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Provides a request implementation with OAuth 2.0 flow.
     * If credentials have a refresh_token, in cases of HTTP
     * 401 and 403 responses, it automatically asks for a new
     * access token and replays the unsuccessful request.
     * @param ***REMOVED***object***REMOVED*** opts Request options.
     * @param ***REMOVED***function***REMOVED*** callback callback.
     * @return ***REMOVED***Request***REMOVED*** Request object
     */
    OAuth2Client.prototype.request = function (opts, callback) ***REMOVED***
        /* jshint latedef:false */
        var _this = this;
        // Callbacks will close over this to ensure that we only retry once
        var retry = true;
        var unusedUri = null;
        // Declare authCb upfront to avoid the linter complaining about use before
        // declaration.
        var authCb;
        // Hook the callback routine to call the _postRequest method.
        var postRequestCb = function (err, body, resp) ***REMOVED***
            var statusCode = resp && resp.statusCode;
            // Automatically retry 401 and 403 responses
            // if err is set and is unrelated to response
            // then getting credentials failed, and retrying won't help
            if (retry && (statusCode === 401 || statusCode === 403) &&
                (!err || err.code === statusCode)) ***REMOVED***
                /* It only makes sense to retry once, because the retry is intended
                 * to handle expiration-related failures. If refreshing the token
                 * does not fix the failure, then refreshing again probably won't
                 * help */
                retry = false;
                // Force token refresh
                _this.refreshAccessToken(function () ***REMOVED***
                    _this.getRequestMetadata(unusedUri, authCb);
                ***REMOVED***);
            ***REMOVED***
            else ***REMOVED***
                _this.postRequest(err, body, resp, callback);
            ***REMOVED***
        ***REMOVED***;
        authCb = function (err, headers, response) ***REMOVED***
            if (err) ***REMOVED***
                postRequestCb(err, null, response);
            ***REMOVED***
            else ***REMOVED***
                if (headers) ***REMOVED***
                    opts.headers = opts.headers || ***REMOVED******REMOVED***;
                    opts.headers.Authorization = headers.Authorization;
                ***REMOVED***
                if (_this.apiKey) ***REMOVED***
                    if (opts.qs) ***REMOVED***
                        opts.qs = merge(***REMOVED******REMOVED***, opts.qs, ***REMOVED*** key: _this.apiKey ***REMOVED***);
                    ***REMOVED***
                    else ***REMOVED***
                        opts.qs = ***REMOVED*** key: _this.apiKey ***REMOVED***;
                    ***REMOVED***
                ***REMOVED***
                return _this._makeRequest(opts, postRequestCb);
            ***REMOVED***
        ***REMOVED***;
        return this.getRequestMetadata(unusedUri, authCb);
    ***REMOVED***;
    /**
     * Makes a request without paying attention to refreshing or anything
     * Assumes that all credentials are set correctly.
     * @param  ***REMOVED***object***REMOVED***   opts     Options for request
     * @param  ***REMOVED***Function***REMOVED*** callback callback function
     * @return ***REMOVED***Request***REMOVED***           The request object created
     */
    OAuth2Client.prototype._makeRequest = function (opts, callback) ***REMOVED***
        return this.transporter.request(opts, callback);
    ***REMOVED***;
    /**
     * Allows inheriting classes to inspect and alter the request result.
     * @param ***REMOVED***object***REMOVED*** err Error result.
     * @param ***REMOVED***object***REMOVED*** result The result.
     * @param ***REMOVED***object***REMOVED*** result The HTTP response.
     * @param ***REMOVED***Function***REMOVED*** callback The callback.
     * @private
     */
    OAuth2Client.prototype.postRequest = function (err, result, response, callback) ***REMOVED***
        callback(err, result, response);
    ***REMOVED***;
    /**
     * Verify id token is token by checking the certs and audience
     * @param ***REMOVED***string***REMOVED*** idToken ID Token.
     * @param ***REMOVED***(string|Array.<string>)***REMOVED*** audience The audience to verify against the ID Token
     * @param ***REMOVED***function=***REMOVED*** callback Callback supplying GoogleLogin if successful
     */
    OAuth2Client.prototype.verifyIdToken = function (idToken, audience, callback) ***REMOVED***
        var _this = this;
        if (!idToken || !callback) ***REMOVED***
            throw new Error('The verifyIdToken method requires both ' +
                'an ID Token and a callback method');
        ***REMOVED***
        this.getFederatedSignonCerts((function (err, certs) ***REMOVED***
            if (err) ***REMOVED***
                callback(err, null);
            ***REMOVED***
            var login;
            try ***REMOVED***
                login = _this.verifySignedJwtWithCerts(idToken, certs, audience, OAuth2Client.ISSUERS_);
            ***REMOVED***
            catch (err) ***REMOVED***
                callback(err);
                return;
            ***REMOVED***
            callback(null, login);
        ***REMOVED***).bind(this));
    ***REMOVED***;
    /**
     * Gets federated sign-on certificates to use for verifying identity tokens.
     * Returns certs as array structure, where keys are key ids, and values
     * are PEM encoded certificates.
     * @param ***REMOVED***function=***REMOVED*** callback Callback supplying the certificates
     */
    OAuth2Client.prototype.getFederatedSignonCerts = function (callback) ***REMOVED***
        var _this = this;
        var nowTime = (new Date()).getTime();
        if (this._certificateExpiry &&
            (nowTime < this._certificateExpiry.getTime())) ***REMOVED***
            callback(null, this._certificateCache);
            return;
        ***REMOVED***
        this.transporter.request(***REMOVED***
            method: 'GET',
            uri: OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_,
            json: true
        ***REMOVED***, function (err, body, response) ***REMOVED***
            if (err) ***REMOVED***
                callback(new transporters_1.RequestError('Failed to retrieve verification certificates: ' + err), null, response);
                return;
            ***REMOVED***
            var cacheControl = response.headers['cache-control'];
            var cacheAge = -1;
            if (cacheControl) ***REMOVED***
                var pattern = new RegExp('max-age=([0-9]*)');
                var regexResult = pattern.exec(cacheControl);
                if (regexResult.length === 2) ***REMOVED***
                    // Cache results with max-age (in seconds)
                    cacheAge = Number(regexResult[1]) * 1000; // milliseconds
                ***REMOVED***
            ***REMOVED***
            var now = new Date();
            _this._certificateExpiry =
                cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
            _this._certificateCache = body;
            callback(null, body, response);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Verify the id token is signed with the correct certificate
     * and is from the correct audience.
     * @param ***REMOVED***string***REMOVED*** jwt The jwt to verify (The ID Token in this case).
     * @param ***REMOVED***array***REMOVED*** certs The array of certs to test the jwt against.
     * @param ***REMOVED***(string|Array.<string>)***REMOVED*** requiredAudience The audience to test the jwt against.
     * @param ***REMOVED***array***REMOVED*** issuers The allowed issuers of the jwt (Optional).
     * @param ***REMOVED***string***REMOVED*** maxExpiry The max expiry the certificate can be (Optional).
     * @return ***REMOVED***LoginTicket***REMOVED*** Returns a LoginTicket on verification.
     */
    OAuth2Client.prototype.verifySignedJwtWithCerts = function (jwt, certs, requiredAudience, issuers, maxExpiry) ***REMOVED***
        if (!maxExpiry) ***REMOVED***
            maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;
        ***REMOVED***
        var segments = jwt.split('.');
        if (segments.length !== 3) ***REMOVED***
            throw new Error('Wrong number of segments in token: ' + jwt);
        ***REMOVED***
        var signed = segments[0] + '.' + segments[1];
        var signature = segments[2];
        var envelope;
        var payload;
        try ***REMOVED***
            envelope = JSON.parse(this.decodeBase64(segments[0]));
        ***REMOVED***
        catch (err) ***REMOVED***
            throw new Error('Can\'t parse token envelope: ' + segments[0]);
        ***REMOVED***
        if (!envelope) ***REMOVED***
            throw new Error('Can\'t parse token envelope: ' + segments[0]);
        ***REMOVED***
        try ***REMOVED***
            payload = JSON.parse(this.decodeBase64(segments[1]));
        ***REMOVED***
        catch (err) ***REMOVED***
            throw new Error('Can\'t parse token payload: ' + segments[0]);
        ***REMOVED***
        if (!payload) ***REMOVED***
            throw new Error('Can\'t parse token payload: ' + segments[1]);
        ***REMOVED***
        if (!certs.hasOwnProperty(envelope.kid)) ***REMOVED***
            // If this is not present, then there's no reason to attempt verification
            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));
        ***REMOVED***
        var pem = certs[envelope.kid];
        var pemVerifier = new pemverifier_1.PemVerifier();
        var verified = pemVerifier.verify(pem, signed, signature, 'base64');
        if (!verified) ***REMOVED***
            throw new Error('Invalid token signature: ' + jwt);
        ***REMOVED***
        if (!payload.iat) ***REMOVED***
            throw new Error('No issue time in token: ' + JSON.stringify(payload));
        ***REMOVED***
        if (!payload.exp) ***REMOVED***
            throw new Error('No expiration time in token: ' + JSON.stringify(payload));
        ***REMOVED***
        var iat = parseInt(payload.iat, 10);
        var exp = parseInt(payload.exp, 10);
        var now = new Date().getTime() / 1000;
        if (exp >= now + maxExpiry) ***REMOVED***
            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));
        ***REMOVED***
        var earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;
        var latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;
        if (now < earliest) ***REMOVED***
            throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' +
                JSON.stringify(payload));
        ***REMOVED***
        if (now > latest) ***REMOVED***
            throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' +
                JSON.stringify(payload));
        ***REMOVED***
        if (issuers && issuers.indexOf(payload.iss) < 0) ***REMOVED***
            throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' +
                payload.iss);
        ***REMOVED***
        // Check the audience matches if we have one
        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) ***REMOVED***
            var aud = payload.aud;
            var audVerified = false;
            // If the requiredAudience is an array, check if it contains token
            // audience
            if (requiredAudience.constructor === Array) ***REMOVED***
                audVerified = (requiredAudience.indexOf(aud) > -1);
            ***REMOVED***
            else ***REMOVED***
                audVerified = (aud === requiredAudience);
            ***REMOVED***
            if (!audVerified) ***REMOVED***
                throw new Error('Wrong recipient, payload audience != requiredAudience');
            ***REMOVED***
        ***REMOVED***
        return new loginticket_1.LoginTicket(envelope, payload);
    ***REMOVED***;
    /**
     * This is a utils method to decode a base64 string
     * @param ***REMOVED***string***REMOVED*** b64String The string to base64 decode
     * @return ***REMOVED***string***REMOVED*** The decoded string
     */
    OAuth2Client.prototype.decodeBase64 = function (b64String) ***REMOVED***
        var buffer = new Buffer(b64String, 'base64');
        return buffer.toString('utf8');
    ***REMOVED***;
    /**
     * The base URL for auth endpoints.
     */
    OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/auth';
    /**
     * The base endpoint for token retrieval.
     */
    OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://accounts.google.com/o/oauth2/token';
    /**
     * The base endpoint to revoke tokens.
     */
    OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://accounts.google.com/o/oauth2/revoke';
    /**
     * Google Sign on certificates.
     */
    OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';
    /**
     * Clock skew - five minutes in seconds
     */
    OAuth2Client.CLOCK_SKEW_SECS_ = 300;
    /**
     * Max Token Lifetime is one day in seconds
     */
    OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;
    /**
     * The allowed oauth token issuers.
     */
    OAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];
    return OAuth2Client;
***REMOVED***(authclient_1.AuthClient));
exports.OAuth2Client = OAuth2Client;
//# sourceMappingURL=oauth2client.js.map