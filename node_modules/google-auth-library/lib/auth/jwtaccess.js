"use strict";
/**
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var jws = require('jws');
var noop = Function.prototype;
var JWTAccess = /** @class */ (function () ***REMOVED***
    /**
     * JWTAccess service account credentials.
     *
     * Create a new access token by using the credential to create a new JWT token
     * that's recognized as the access token.
     *
     * @param ***REMOVED***string=***REMOVED*** email the service account email address.
     * @param ***REMOVED***string=***REMOVED*** key the private key that will be used to sign the token.
     * @constructor
     */
    function JWTAccess(email, key) ***REMOVED***
        this.email = email;
        this.key = key;
    ***REMOVED***
    /**
     * Indicates whether the credential requires scopes to be created by calling
     * createdScoped before use.
     *
     * @return ***REMOVED***boolean***REMOVED*** always false
     */
    JWTAccess.prototype.createScopedRequired = function () ***REMOVED***
        // JWT Header authentication does not use scopes.
        return false;
    ***REMOVED***;
    /**
     * Get a non-expired access token, after refreshing if necessary
     *
     * @param ***REMOVED***string***REMOVED*** authURI the URI being authorized
     * @param ***REMOVED***function***REMOVED*** metadataCb a callback invoked with the jwt
     *                   request metadata.
     */
    JWTAccess.prototype.getRequestMetadata = function (authURI, metadataCb) ***REMOVED***
        var iat = Math.floor(new Date().getTime() / 1000);
        var exp = iat + 3600; // 3600 seconds = 1 hour
        // The payload used for signed JWT headers has:
        // iss == sub == <client email>
        // aud == <the authorization uri>
        var payload = ***REMOVED*** iss: this.email, sub: this.email, aud: authURI, exp: exp, iat: iat ***REMOVED***;
        var assertion = ***REMOVED***
            header: ***REMOVED*** alg: 'RS256', typ: 'JWT' ***REMOVED***,
            payload: payload,
            secret: this.key
        ***REMOVED***;
        // Sign the jwt and invoke metadataCb with it.
        return this._signJWT(assertion, function (err, signedJWT) ***REMOVED***
            if (!err) ***REMOVED***
                return metadataCb(null, ***REMOVED*** Authorization: 'Bearer ' + signedJWT ***REMOVED***);
            ***REMOVED***
            else ***REMOVED***
                return metadataCb(err, null);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Create a JWTAccess credentials instance using the given input options.
     * @param ***REMOVED***object=***REMOVED*** json The input object.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback.
     */
    JWTAccess.prototype.fromJSON = function (json, callback) ***REMOVED***
        var done = callback || noop;
        if (!json) ***REMOVED***
            done(new Error('Must pass in a JSON object containing the service account auth settings.'));
            return;
        ***REMOVED***
        if (!json.client_email) ***REMOVED***
            done(new Error('The incoming JSON object does not contain a client_email field'));
            return;
        ***REMOVED***
        if (!json.private_key) ***REMOVED***
            done(new Error('The incoming JSON object does not contain a private_key field'));
            return;
        ***REMOVED***
        // Extract the relevant information from the json key file.
        this.email = json.client_email;
        this.key = json.private_key;
        this.projectId = json.project_id;
        done();
    ***REMOVED***;
    /**
     * Create a JWTAccess credentials instance using the given input stream.
     * @param ***REMOVED***object=***REMOVED*** stream The input stream.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback.
     */
    JWTAccess.prototype.fromStream = function (stream, callback) ***REMOVED***
        var _this = this;
        var done = callback || noop;
        if (!stream) ***REMOVED***
            setImmediate(function () ***REMOVED***
                done(new Error('Must pass in a stream containing the service account auth settings.'));
            ***REMOVED***);
            return;
        ***REMOVED***
        var s = '';
        stream.setEncoding('utf8');
        stream.on('data', function (chunk) ***REMOVED***
            s += chunk;
        ***REMOVED***);
        stream.on('end', function () ***REMOVED***
            try ***REMOVED***
                var data = JSON.parse(s);
                _this.fromJSON(data, callback);
            ***REMOVED***
            catch (err) ***REMOVED***
                done(err);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Sign the JWT object, returning any errors in the callback.
     *
     * signedJwtFn is a callback function(err, signedJWT); it is called with an
     * error if there is an exception during signing.
     *
     * @param  ***REMOVED***object***REMOVED***   assertion   The assertion to sign
     * @param  ***REMOVED***Function***REMOVED*** signedJwtFn  fn(err, signedJWT)
     */
    JWTAccess.prototype._signJWT = function (assertion, signedJwtFn) ***REMOVED***
        try ***REMOVED***
            return signedJwtFn(null, jws.sign(assertion));
        ***REMOVED***
        catch (err) ***REMOVED***
            return signedJwtFn(err);
        ***REMOVED***
    ***REMOVED***;
    return JWTAccess;
***REMOVED***());
exports.JWTAccess = JWTAccess;
//# sourceMappingURL=jwtaccess.js.map