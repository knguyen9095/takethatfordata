"use strict";
/**
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = Object.setPrototypeOf ||
        (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
        function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var gToken = require('gtoken');
var jwtaccess_1 = require("./jwtaccess");
var oauth2client_1 = require("./oauth2client");
var isString = require('lodash.isstring');
var noop = Function.prototype;
var JWT = /** @class */ (function (_super) ***REMOVED***
    __extends(JWT, _super);
    /**
     * JWT service account credentials.
     *
     * Retrieve access token using gtoken.
     *
     * @param ***REMOVED***string=***REMOVED*** email service account email address.
     * @param ***REMOVED***string=***REMOVED*** keyFile path to private key file.
     * @param ***REMOVED***string=***REMOVED*** key value of key
     * @param ***REMOVED***(string|array)=***REMOVED*** scopes list of requested scopes or a single scope.
     * @param ***REMOVED***string=***REMOVED*** subject impersonated account's email address.
     * @constructor
     */
    function JWT(email, keyFile, key, scopes, subject) ***REMOVED***
        var _this = _super.call(this) || this;
        _this.email = email;
        _this.keyFile = keyFile;
        _this.key = key;
        _this.scopes = scopes;
        _this.subject = subject;
        _this.gToken = gToken;
        _this.credentials = ***REMOVED*** refresh_token: 'jwt-placeholder', expiry_date: 1 ***REMOVED***;
        return _this;
    ***REMOVED***
    /**
     * Creates a copy of the credential with the specified scopes.
     * @param ***REMOVED***(string|array)=***REMOVED*** scopes List of requested scopes or a single scope.
     * @return ***REMOVED***object***REMOVED*** The cloned instance.
     */
    JWT.prototype.createScoped = function (scopes) ***REMOVED***
        return new JWT(this.email, this.keyFile, this.key, scopes, this.subject);
    ***REMOVED***;
    /**
     * Obtains the metadata to be sent with the request.
     *
     * @param ***REMOVED***string***REMOVED*** opt_uri the URI being authorized.
     * @param ***REMOVED***function***REMOVED*** metadataCb
     */
    JWT.prototype.getRequestMetadata = function (opt_uri, metadataCb) ***REMOVED***
        if (this.createScopedRequired() && opt_uri) ***REMOVED***
            // no scopes have been set, but a uri has been provided.  Use JWTAccess
            // credentials.
            var alt = new jwtaccess_1.JWTAccess(this.email, this.key);
            return alt.getRequestMetadata(opt_uri, metadataCb);
        ***REMOVED***
        else ***REMOVED***
            return _super.prototype.getRequestMetadata.call(this, opt_uri, metadataCb);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Indicates whether the credential requires scopes to be created by calling
     * createdScoped before use.
     * @return ***REMOVED***boolean***REMOVED*** false if createScoped does not need to be called.
     */
    JWT.prototype.createScopedRequired = function () ***REMOVED***
        // If scopes is null, always return true.
        if (this.scopes) ***REMOVED***
            // For arrays, check the array length.
            if (this.scopes instanceof Array) ***REMOVED***
                return this.scopes.length === 0;
            ***REMOVED***
            // For others, convert to a string and check the length.
            return String(this.scopes).length === 0;
        ***REMOVED***
        return true;
    ***REMOVED***;
    /**
     * Get the initial access token using gToken.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback.
     */
    JWT.prototype.authorize = function (callback) ***REMOVED***
        var _this = this;
        var done = callback || noop;
        this.refreshToken(null, function (err, result) ***REMOVED***
            if (!err) ***REMOVED***
                _this.credentials = result;
                _this.credentials.refresh_token = 'jwt-placeholder';
                _this.key = _this.gtoken.key;
                _this.email = _this.gtoken.iss;
            ***REMOVED***
            done(err, result);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Refreshes the access token.
     * @param ***REMOVED***object=***REMOVED*** ignored_
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback.
     * @private
     */
    JWT.prototype.refreshToken = function (ignored_, callback) ***REMOVED***
        var done = callback || noop;
        return this._createGToken(function (err, gToken) ***REMOVED***
            if (err) ***REMOVED***
                return done(err);
            ***REMOVED***
            else ***REMOVED***
                return gToken.getToken(function (err2, token) ***REMOVED***
                    return done(err2, ***REMOVED***
                        access_token: token,
                        token_type: 'Bearer',
                        expiry_date: gToken.expires_at
                    ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Create a JWT credentials instance using the given input options.
     * @param ***REMOVED***object=***REMOVED*** json The input object.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback.
     */
    JWT.prototype.fromJSON = function (json, callback) ***REMOVED***
        var done = callback || noop;
        if (!json) ***REMOVED***
            done(new Error('Must pass in a JSON object containing the service account auth settings.'));
            return;
        ***REMOVED***
        if (!json.client_email) ***REMOVED***
            done(new Error('The incoming JSON object does not contain a client_email field'));
            return;
        ***REMOVED***
        if (!json.private_key) ***REMOVED***
            done(new Error('The incoming JSON object does not contain a private_key field'));
            return;
        ***REMOVED***
        // Extract the relevant information from the json key file.
        this.email = json.client_email;
        this.key = json.private_key;
        this.projectId = json.project_id;
        done();
    ***REMOVED***;
    /**
     * Create a JWT credentials instance using the given input stream.
     * @param ***REMOVED***object=***REMOVED*** stream The input stream.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback.
     */
    JWT.prototype.fromStream = function (stream, callback) ***REMOVED***
        var _this = this;
        var done = callback || noop;
        if (!stream) ***REMOVED***
            setImmediate(function () ***REMOVED***
                done(new Error('Must pass in a stream containing the service account auth settings.'));
            ***REMOVED***);
            return;
        ***REMOVED***
        var s = '';
        stream.setEncoding('utf8');
        stream.on('data', function (chunk) ***REMOVED***
            s += chunk;
        ***REMOVED***);
        stream.on('end', function () ***REMOVED***
            try ***REMOVED***
                var data = JSON.parse(s);
                _this.fromJSON(data, callback);
            ***REMOVED***
            catch (err) ***REMOVED***
                done(err);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Creates a JWT credentials instance using an API Key for authentication.
     * @param ***REMOVED***string***REMOVED*** apiKey - the API Key in string form.
     * @param ***REMOVED***function=***REMOVED*** callback - Optional callback to be invoked after
     *  initialization.
     */
    JWT.prototype.fromAPIKey = function (apiKey, callback) ***REMOVED***
        var done = callback || noop;
        if (!isString(apiKey)) ***REMOVED***
            setImmediate(function () ***REMOVED***
                done(new Error('Must provide an API Key string.'));
            ***REMOVED***);
            return;
        ***REMOVED***
        this.apiKey = apiKey;
        done(null);
    ***REMOVED***;
    /**
     * Creates the gToken instance if it has not been created already.
     * @param ***REMOVED***function=***REMOVED*** callback Callback.
     * @private
     */
    JWT.prototype._createGToken = function (callback) ***REMOVED***
        if (this.gtoken) ***REMOVED***
            return callback(null, this.gtoken);
        ***REMOVED***
        else ***REMOVED***
            this.gtoken = this.gToken(***REMOVED***
                iss: this.email,
                sub: this.subject,
                scope: this.scopes,
                keyFile: this.keyFile,
                key: this.key
            ***REMOVED***);
            return callback(null, this.gtoken);
        ***REMOVED***
    ***REMOVED***;
    return JWT;
***REMOVED***(oauth2client_1.OAuth2Client));
exports.JWT = JWT;
//# sourceMappingURL=jwtclient.js.map