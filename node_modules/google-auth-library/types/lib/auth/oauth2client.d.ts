/// <reference types="request" />
import * as request from 'request';
import ***REMOVED*** BodyResponseCallback ***REMOVED*** from './../transporters';
import ***REMOVED*** AuthClient ***REMOVED*** from './authclient';
import ***REMOVED*** Credentials ***REMOVED*** from './credentials';
import ***REMOVED*** LoginTicket ***REMOVED*** from './loginticket';
export interface GenerateAuthUrlOpts ***REMOVED***
    response_type?: string;
    client_id?: string;
    redirect_uri?: string;
    scope?: string[] | string;
***REMOVED***
export declare class OAuth2Client extends AuthClient ***REMOVED***
    private _redirectUri;
    private _certificateCache;
    private _certificateExpiry;
    protected _opts: any;
    _clientId: string;
    _clientSecret: string;
    apiKey: string;
    /**
     * Handles OAuth2 flow for Google APIs.
     *
     * @param ***REMOVED***string=***REMOVED*** clientId The authentication client ID.
     * @param ***REMOVED***string=***REMOVED*** clientSecret The authentication client secret.
     * @param ***REMOVED***string=***REMOVED*** redirectUri The URI to redirect to after completing the auth request.
     * @param ***REMOVED***Object=***REMOVED*** opt_opts optional options for overriding the given parameters.
     * @constructor
     */
    constructor(clientId?: string, clientSecret?: string, redirectUri?: string, opt_opts?: any);
    /**
     * The base URL for auth endpoints.
     */
    private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_;
    /**
     * The base endpoint for token retrieval.
     */
    private static readonly GOOGLE_OAUTH2_TOKEN_URL_;
    /**
     * The base endpoint to revoke tokens.
     */
    private static readonly GOOGLE_OAUTH2_REVOKE_URL_;
    /**
     * Google Sign on certificates.
     */
    private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_;
    /**
     * Clock skew - five minutes in seconds
     */
    private static readonly CLOCK_SKEW_SECS_;
    /**
     * Max Token Lifetime is one day in seconds
     */
    private static readonly MAX_TOKEN_LIFETIME_SECS_;
    /**
     * The allowed oauth token issuers.
     */
    private static readonly ISSUERS_;
    /**
     * Generates URL for consent page landing.
     * @param ***REMOVED***object=***REMOVED*** opt_opts Options.
     * @return ***REMOVED***string***REMOVED*** URL to consent page.
     */
    generateAuthUrl(opt_opts?: GenerateAuthUrlOpts): string;
    /**
     * Gets the access token for the given code.
     * @param ***REMOVED***string***REMOVED*** code The authorization code.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback fn.
     */
    getToken(code: string, callback?: BodyResponseCallback): void;
    /**
     * Refreshes the access token.
     * @param ***REMOVED***string***REMOVED*** refresh_token Existing refresh token.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback.
     * @private
     */
    protected refreshToken(refresh_token: any, callback?: BodyResponseCallback): request.Request | void;
    /**
     * Retrieves the access token using refresh token
     *
     * @deprecated use getRequestMetadata instead.
     * @param ***REMOVED***function***REMOVED*** callback callback
     */
    refreshAccessToken(callback: (err: Error, credentials: Credentials, response?: request.RequestResponse) => void): void;
    /**
     * Get a non-expired access token, after refreshing if necessary
     *
     * @param ***REMOVED***function***REMOVED*** callback Callback to call with the access token
     */
    getAccessToken(callback: (err: Error, access_token: string, response?: request.RequestResponse) => void): void;
    /**
     * getRequestMetadata obtains auth metadata to be used by requests.
     *
     * getRequestMetadata is the main authentication interface.  It takes an
     * optional uri which when present is the endpoint being accessed, and a
     * callback func(err, metadata_obj, response) where metadata_obj contains
     * authorization metadata fields and response is an optional response object.
     *
     * In OAuth2Client, metadata_obj has the form.
     *
     * ***REMOVED***Authorization: 'Bearer <access_token_value>'***REMOVED***
     *
     * @param ***REMOVED***string***REMOVED*** opt_uri the Uri being authorized
     * @param ***REMOVED***function***REMOVED*** metadataCb the func described above
     */
    getRequestMetadata(opt_uri: string, metadataCb: (err: Error, headers: any, response?: request.RequestResponse) => void): void | request.Request;
    /**
     * Revokes the access given to token.
     * @param ***REMOVED***string***REMOVED*** token The existing token to be revoked.
     * @param ***REMOVED***function=***REMOVED*** callback Optional callback fn.
     */
    revokeToken(token: string, callback?: BodyResponseCallback): void;
    /**
     * Revokes access token and clears the credentials object
     * @param  ***REMOVED***Function=***REMOVED*** callback callback
     */
    revokeCredentials(callback: BodyResponseCallback): void;
    /**
     * Provides a request implementation with OAuth 2.0 flow.
     * If credentials have a refresh_token, in cases of HTTP
     * 401 and 403 responses, it automatically asks for a new
     * access token and replays the unsuccessful request.
     * @param ***REMOVED***object***REMOVED*** opts Request options.
     * @param ***REMOVED***function***REMOVED*** callback callback.
     * @return ***REMOVED***Request***REMOVED*** Request object
     */
    request(opts?: any, callback?: BodyResponseCallback): void | request.Request;
    /**
     * Makes a request without paying attention to refreshing or anything
     * Assumes that all credentials are set correctly.
     * @param  ***REMOVED***object***REMOVED***   opts     Options for request
     * @param  ***REMOVED***Function***REMOVED*** callback callback function
     * @return ***REMOVED***Request***REMOVED***           The request object created
     */
    _makeRequest(opts: any, callback: BodyResponseCallback): request.Request;
    /**
     * Allows inheriting classes to inspect and alter the request result.
     * @param ***REMOVED***object***REMOVED*** err Error result.
     * @param ***REMOVED***object***REMOVED*** result The result.
     * @param ***REMOVED***object***REMOVED*** result The HTTP response.
     * @param ***REMOVED***Function***REMOVED*** callback The callback.
     * @private
     */
    protected postRequest(err: Error, result: any, response: request.RequestResponse, callback: BodyResponseCallback): void;
    /**
     * Verify id token is token by checking the certs and audience
     * @param ***REMOVED***string***REMOVED*** idToken ID Token.
     * @param ***REMOVED***(string|Array.<string>)***REMOVED*** audience The audience to verify against the ID Token
     * @param ***REMOVED***function=***REMOVED*** callback Callback supplying GoogleLogin if successful
     */
    verifyIdToken(idToken: string, audience: string | string[], callback: (err: Error, login?: LoginTicket) => void): void;
    /**
     * Gets federated sign-on certificates to use for verifying identity tokens.
     * Returns certs as array structure, where keys are key ids, and values
     * are PEM encoded certificates.
     * @param ***REMOVED***function=***REMOVED*** callback Callback supplying the certificates
     */
    getFederatedSignonCerts(callback: BodyResponseCallback): void;
    /**
     * Verify the id token is signed with the correct certificate
     * and is from the correct audience.
     * @param ***REMOVED***string***REMOVED*** jwt The jwt to verify (The ID Token in this case).
     * @param ***REMOVED***array***REMOVED*** certs The array of certs to test the jwt against.
     * @param ***REMOVED***(string|Array.<string>)***REMOVED*** requiredAudience The audience to test the jwt against.
     * @param ***REMOVED***array***REMOVED*** issuers The allowed issuers of the jwt (Optional).
     * @param ***REMOVED***string***REMOVED*** maxExpiry The max expiry the certificate can be (Optional).
     * @return ***REMOVED***LoginTicket***REMOVED*** Returns a LoginTicket on verification.
     */
    verifySignedJwtWithCerts(jwt: string, certs: any, requiredAudience: string | string[], issuers?: string[], maxExpiry?: number): LoginTicket;
    /**
     * This is a utils method to decode a base64 string
     * @param ***REMOVED***string***REMOVED*** b64String The string to base64 decode
     * @return ***REMOVED***string***REMOVED*** The decoded string
     */
    decodeBase64(b64String: string): string;
***REMOVED***
