'use strict';

var typeName = require('type-name');
var forEach = require('core-js/library/fn/array/for-each');
var arrayFilter = require('core-js/library/fn/array/filter');
var reduceRight = require('core-js/library/fn/array/reduce-right');
var indexOf = require('core-js/library/fn/array/index-of');
var slice = Array.prototype.slice;
var END = ***REMOVED******REMOVED***;
var ITERATE = ***REMOVED******REMOVED***;

// arguments should end with end or iterate
function compose () ***REMOVED***
    var filters = slice.apply(arguments);
    return reduceRight(filters, function(right, left) ***REMOVED***
        return left(right);
    ***REMOVED***);
***REMOVED***

// skip children
function end () ***REMOVED***
    return function (acc, x) ***REMOVED***
        acc.context.keys = [];
        return END;
    ***REMOVED***;
***REMOVED***

// iterate children
function iterate () ***REMOVED***
    return function (acc, x) ***REMOVED***
        return ITERATE;
    ***REMOVED***;
***REMOVED***

function filter (predicate) ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            var toBeIterated;
            var isIteratingArray = (typeName(x) === 'Array');
            if (typeName(predicate) === 'function') ***REMOVED***
                toBeIterated = [];
                forEach(acc.context.keys, function (key) ***REMOVED***
                    var indexOrKey = isIteratingArray ? parseInt(key, 10) : key;
                    var kvp = ***REMOVED***
                        key: indexOrKey,
                        value: x[key]
                    ***REMOVED***;
                    var decision = predicate(kvp);
                    if (decision) ***REMOVED***
                        toBeIterated.push(key);
                    ***REMOVED***
                    if (typeName(decision) === 'number') ***REMOVED***
                        truncateByKey(decision, key, acc);
                    ***REMOVED***
                    if (typeName(decision) === 'function') ***REMOVED***
                        customizeStrategyForKey(decision, key, acc);
                    ***REMOVED***
                ***REMOVED***);
                acc.context.keys = toBeIterated;
            ***REMOVED***
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function customizeStrategyForKey (strategy, key, acc) ***REMOVED***
    acc.handlers[currentPath(key, acc)] = strategy;
***REMOVED***

function truncateByKey (size, key, acc) ***REMOVED***
    acc.handlers[currentPath(key, acc)] = size;
***REMOVED***

function currentPath (key, acc) ***REMOVED***
    var pathToCurrentNode = [''].concat(acc.context.path);
    if (typeName(key) !== 'undefined') ***REMOVED***
        pathToCurrentNode.push(key);
    ***REMOVED***
    return pathToCurrentNode.join('/');
***REMOVED***

function allowedKeys (orderedWhiteList) ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            var isIteratingArray = (typeName(x) === 'Array');
            if (!isIteratingArray && typeName(orderedWhiteList) === 'Array') ***REMOVED***
                acc.context.keys = arrayFilter(orderedWhiteList, function (propKey) ***REMOVED***
                    return indexOf(acc.context.keys, propKey) !== -1;
                ***REMOVED***);
            ***REMOVED***
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function safeKeys () ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            if (typeName(x) !== 'Array') ***REMOVED***
                acc.context.keys = arrayFilter(acc.context.keys, function (propKey) ***REMOVED***
                    // Error handling for unsafe property access.
                    // For example, on PhantomJS,
                    // accessing HTMLInputElement.selectionEnd causes TypeError
                    try ***REMOVED***
                        var val = x[propKey];
                        return true;
                    ***REMOVED*** catch (e) ***REMOVED***
                        // skip unsafe key
                        return false;
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function arrayIndicesToKeys () ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            if (typeName(x) === 'Array' && 0 < x.length) ***REMOVED***
                var indices = Array(x.length);
                for(var i = 0; i < x.length; i += 1) ***REMOVED***
                    indices[i] = String(i); // traverse uses strings as keys
                ***REMOVED***
                acc.context.keys = indices;
            ***REMOVED***
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function when (guard, then) ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            var kvp = ***REMOVED***
                key: acc.context.key,
                value: x
            ***REMOVED***;
            if (guard(kvp, acc)) ***REMOVED***
                return then(acc, x);
            ***REMOVED***
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function truncate (size) ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            var orig = acc.push;
            var ret;
            acc.push = function (str) ***REMOVED***
                var savings = str.length - size;
                var truncated;
                if (savings <= size) ***REMOVED***
                    orig.call(acc, str);
                ***REMOVED*** else ***REMOVED***
                    truncated = str.substring(0, size);
                    orig.call(acc, truncated + acc.options.snip);
                ***REMOVED***
            ***REMOVED***;
            ret = next(acc, x);
            acc.push = orig;
            return ret;
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function constructorName () ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            var name = acc.options.typeFun(x);
            if (name === '') ***REMOVED***
                name = acc.options.anonymous;
            ***REMOVED***
            acc.push(name);
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function always (str) ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            acc.push(str);
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function optionValue (key) ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            acc.push(acc.options[key]);
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function json (replacer) ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            acc.push(JSON.stringify(x, replacer));
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function toStr () ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            acc.push(x.toString());
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function decorateArray () ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            acc.context.before(function (node) ***REMOVED***
                acc.push('[');
            ***REMOVED***);
            acc.context.after(function (node) ***REMOVED***
                afterAllChildren(this, acc.push, acc.options);
                acc.push(']');
            ***REMOVED***);
            acc.context.pre(function (val, key) ***REMOVED***
                beforeEachChild(this, acc.push, acc.options);
            ***REMOVED***);
            acc.context.post(function (childContext) ***REMOVED***
                afterEachChild(childContext, acc.push);
            ***REMOVED***);
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function decorateObject () ***REMOVED***
    return function (next) ***REMOVED***
        return function (acc, x) ***REMOVED***
            acc.context.before(function (node) ***REMOVED***
                acc.push('***REMOVED***');
            ***REMOVED***);
            acc.context.after(function (node) ***REMOVED***
                afterAllChildren(this, acc.push, acc.options);
                acc.push('***REMOVED***');
            ***REMOVED***);
            acc.context.pre(function (val, key) ***REMOVED***
                beforeEachChild(this, acc.push, acc.options);
                acc.push(sanitizeKey(key) + (acc.options.indent ? ': ' : ':'));
            ***REMOVED***);
            acc.context.post(function (childContext) ***REMOVED***
                afterEachChild(childContext, acc.push);
            ***REMOVED***);
            return next(acc, x);
        ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function sanitizeKey (key) ***REMOVED***
    return /^[A-Za-z_]+$/.test(key) ? key : JSON.stringify(key);
***REMOVED***

function afterAllChildren (context, push, options) ***REMOVED***
    if (options.indent && 0 < context.keys.length) ***REMOVED***
        push(options.lineSeparator);
        for(var i = 0; i < context.level; i += 1) ***REMOVED*** // indent level - 1
            push(options.indent);
        ***REMOVED***
    ***REMOVED***
***REMOVED***

function beforeEachChild (context, push, options) ***REMOVED***
    if (options.indent) ***REMOVED***
        push(options.lineSeparator);
        for(var i = 0; i <= context.level; i += 1) ***REMOVED***
            push(options.indent);
        ***REMOVED***
    ***REMOVED***
***REMOVED***

function afterEachChild (childContext, push) ***REMOVED***
    if (!childContext.isLast) ***REMOVED***
        push(',');
    ***REMOVED***
***REMOVED***

function nan (kvp, acc) ***REMOVED***
    return kvp.value !== kvp.value;
***REMOVED***

function positiveInfinity (kvp, acc) ***REMOVED***
    return !isFinite(kvp.value) && kvp.value === Infinity;
***REMOVED***

function negativeInfinity (kvp, acc) ***REMOVED***
    return !isFinite(kvp.value) && kvp.value !== Infinity;
***REMOVED***

function circular (kvp, acc) ***REMOVED***
    return acc.context.circular;
***REMOVED***

function maxDepth (kvp, acc) ***REMOVED***
    return (acc.options.maxDepth && acc.options.maxDepth <= acc.context.level);
***REMOVED***

var prune = compose(
    always('#'),
    constructorName(),
    always('#'),
    end()
);
var omitNaN = when(nan, compose(
    always('NaN'),
    end()
));
var omitPositiveInfinity = when(positiveInfinity, compose(
    always('Infinity'),
    end()
));
var omitNegativeInfinity = when(negativeInfinity, compose(
    always('-Infinity'),
    end()
));
var omitCircular = when(circular, compose(
    optionValue('circular'),
    end()
));
var omitMaxDepth = when(maxDepth, prune);

module.exports = ***REMOVED***
    filters: ***REMOVED***
        always: always,
        optionValue: optionValue,
        constructorName: constructorName,
        json: json,
        toStr: toStr,
        prune: prune,
        truncate: truncate,
        decorateArray: decorateArray,
        decorateObject: decorateObject
    ***REMOVED***,
    flow: ***REMOVED***
        compose: compose,
        when: when,
        allowedKeys: allowedKeys,
        safeKeys: safeKeys,
        arrayIndicesToKeys: arrayIndicesToKeys,
        filter: filter,
        iterate: iterate,
        end: end
    ***REMOVED***,
    symbols: ***REMOVED***
        END: END,
        ITERATE: ITERATE
    ***REMOVED***,
    always: function (str) ***REMOVED***
        return compose(always(str), end());
    ***REMOVED***,
    json: function () ***REMOVED***
        return compose(json(), end());
    ***REMOVED***,
    toStr: function () ***REMOVED***
        return compose(toStr(), end());
    ***REMOVED***,
    prune: function () ***REMOVED***
        return prune;
    ***REMOVED***,
    number: function () ***REMOVED***
        return compose(
            omitNaN,
            omitPositiveInfinity,
            omitNegativeInfinity,
            json(),
            end()
        );
    ***REMOVED***,
    newLike: function () ***REMOVED***
        return compose(
            always('new '),
            constructorName(),
            always('('),
            json(),
            always(')'),
            end()
        );
    ***REMOVED***,
    array: function (predicate) ***REMOVED***
        return compose(
            omitCircular,
            omitMaxDepth,
            decorateArray(),
            arrayIndicesToKeys(),
            filter(predicate),
            iterate()
        );
    ***REMOVED***,
    object: function (predicate, orderedWhiteList) ***REMOVED***
        return compose(
            omitCircular,
            omitMaxDepth,
            constructorName(),
            decorateObject(),
            allowedKeys(orderedWhiteList),
            safeKeys(),
            filter(predicate),
            iterate()
        );
    ***REMOVED***
***REMOVED***;
