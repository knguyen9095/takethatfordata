var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) ***REMOVED***
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
***REMOVED***;
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) ***REMOVED***
  return this.tree._encode(data, reporter).join();
***REMOVED***;

// Tree methods

function DERNode(parent) ***REMOVED***
  base.Node.call(this, 'der', parent);
***REMOVED***
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) ***REMOVED***
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) ***REMOVED***
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  ***REMOVED***

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
***REMOVED***;

DERNode.prototype._encodeStr = function encodeStr(str, tag) ***REMOVED***
  if (tag === 'bitstr') ***REMOVED***
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  ***REMOVED*** else if (tag === 'bmpstr') ***REMOVED***
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) ***REMOVED***
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    ***REMOVED***
    return this._createEncoderBuffer(buf);
  ***REMOVED*** else if (tag === 'numstr') ***REMOVED***
    if (!this._isNumstr(str)) ***REMOVED***
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    ***REMOVED***
    return this._createEncoderBuffer(str);
  ***REMOVED*** else if (tag === 'printstr') ***REMOVED***
    if (!this._isPrintstr(str)) ***REMOVED***
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    ***REMOVED***
    return this._createEncoderBuffer(str);
  ***REMOVED*** else if (/str$/.test(tag)) ***REMOVED***
    return this._createEncoderBuffer(str);
  ***REMOVED*** else if (tag === 'objDesc') ***REMOVED***
    return this._createEncoderBuffer(str);
  ***REMOVED*** else ***REMOVED***
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  ***REMOVED***
***REMOVED***;

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) ***REMOVED***
  if (typeof id === 'string') ***REMOVED***
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  ***REMOVED*** else if (Array.isArray(id)) ***REMOVED***
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  ***REMOVED***

  if (!Array.isArray(id)) ***REMOVED***
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  ***REMOVED***

  if (!relative) ***REMOVED***
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  ***REMOVED***

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) ***REMOVED***
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  ***REMOVED***

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) ***REMOVED***
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  ***REMOVED***

  return this._createEncoderBuffer(objid);
***REMOVED***;

function two(num) ***REMOVED***
  if (num < 10)
    return '0' + num;
  else
    return num;
***REMOVED***

DERNode.prototype._encodeTime = function encodeTime(time, tag) ***REMOVED***
  var str;
  var date = new Date(time);

  if (tag === 'gentime') ***REMOVED***
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  ***REMOVED*** else if (tag === 'utctime') ***REMOVED***
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  ***REMOVED*** else ***REMOVED***
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  ***REMOVED***

  return this._encodeStr(str, 'octstr');
***REMOVED***;

DERNode.prototype._encodeNull = function encodeNull() ***REMOVED***
  return this._createEncoderBuffer('');
***REMOVED***;

DERNode.prototype._encodeInt = function encodeInt(num, values) ***REMOVED***
  if (typeof num === 'string') ***REMOVED***
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) ***REMOVED***
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    ***REMOVED***
    num = values[num];
  ***REMOVED***

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) ***REMOVED***
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) ***REMOVED***
      numArray.unshift(0);
    ***REMOVED***
    num = new Buffer(numArray);
  ***REMOVED***

  if (Buffer.isBuffer(num)) ***REMOVED***
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  ***REMOVED***

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) ***REMOVED***
    out[i] = num & 0xff;
    num >>= 8;
  ***REMOVED***
  if(out[0] & 0x80) ***REMOVED***
    out.unshift(0);
  ***REMOVED***

  return this._createEncoderBuffer(new Buffer(out));
***REMOVED***;

DERNode.prototype._encodeBool = function encodeBool(value) ***REMOVED***
  return this._createEncoderBuffer(value ? 0xff : 0);
***REMOVED***;

DERNode.prototype._use = function use(entity, obj) ***REMOVED***
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
***REMOVED***;

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) ***REMOVED***
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
***REMOVED***;

// Utility methods

function encodeTag(tag, primitive, cls, reporter) ***REMOVED***
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
***REMOVED***
