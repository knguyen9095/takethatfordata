module.exports.watch = watch;
module.exports.resetWatchers = resetWatchers;

var debug = require('debug')('nodemon:watch');
var debugRoot = require('debug')('nodemon');
var chokidar = require('chokidar');
var undefsafe = require('undefsafe');
var config = require('../config');
var path = require('path');
var utils = require('../utils');
var bus = utils.bus;
var match = require('./match');
var watchers = [];
var debouncedBus;

bus.on('reset', resetWatchers);

function resetWatchers() ***REMOVED***
  debugRoot('resetting watchers');
  watchers.forEach(function (watcher) ***REMOVED***
    watcher.close();
  ***REMOVED***);
  watchers = [];
***REMOVED***

function watch() ***REMOVED***
  if (watchers.length) ***REMOVED***
    debug('early exit on watch, still watching (%s)', watchers.length);
    return;
  ***REMOVED***

  var dirs = [].slice.call(config.dirs);

  debugRoot('start watch on: %s', dirs.join(', '));
  const rootIgnored = config.options.ignore;
  debugRoot('ignored', rootIgnored);

  var promises = [];
  var watchedFiles = [];

  dirs.forEach(function (dir) ***REMOVED***
    var promise = new Promise(function (resolve) ***REMOVED***
      var dotFilePattern = /[/\\]\./;
      var ignored = Array.from(rootIgnored);

      // don't ignore dotfiles if explicitly watched.
      if (!dir.match(dotFilePattern)) ***REMOVED***
        ignored.push(dotFilePattern);
      ***REMOVED***

      var watchOptions = ***REMOVED***
        ignorePermissionErrors: true,
        cwd: process.cwd(), // use cwd for relative path ignore
        ignored: ignored,
        persistent: true,
        usePolling: config.options.legacyWatch || false,
        interval: config.options.pollingInterval,
      ***REMOVED***;

      if (utils.isWindows) ***REMOVED***
        watchOptions.disableGlobbing = true;
      ***REMOVED***

      if (process.env.TEST) ***REMOVED***
        watchOptions.useFsEvents = false;
      ***REMOVED***

      var watcher = chokidar.watch(
        dir,
        Object.assign(***REMOVED******REMOVED***, watchOptions, config.watchOptions || ***REMOVED******REMOVED***)
      );

      watcher.ready = false;

      var total = 0;

      watcher.on('change', filterAndRestart);
      watcher.on('add', function (file) ***REMOVED***
        if (watcher.ready) ***REMOVED***
          return filterAndRestart(file);
        ***REMOVED***

        watchedFiles.push(file);
        watchedFiles = Array.from(new Set(watchedFiles)); // ensure no dupes
        total = watchedFiles.length;
        debug('watching dir: %s', file);
      ***REMOVED***);
      watcher.on('ready', function () ***REMOVED***
        watcher.ready = true;
        resolve(total);
        debugRoot('watch is complete');
      ***REMOVED***);

      watcher.on('error', function (error) ***REMOVED***
        if (error.code === 'EINVAL') ***REMOVED***
          utils.log.error(
            'Internal watch failed. Likely cause: too many ' +
            'files being watched (perhaps from the root of a drive?\n' +
            'See https://github.com/paulmillr/chokidar/issues/229 for details'
          );
        ***REMOVED*** else ***REMOVED***
          utils.log.error('Internal watch failed: ' + error.message);
          process.exit(1);
        ***REMOVED***
      ***REMOVED***);

      watchers.push(watcher);
    ***REMOVED***);
    promises.push(promise);
  ***REMOVED***);

  return Promise.all(promises).then(function (res) ***REMOVED***
    utils.log.detail(`watching $***REMOVED***watchedFiles.length***REMOVED*** file$***REMOVED***
      watchedFiles.length === 1 ? '' : 's'***REMOVED***`);
    return watchedFiles;
  ***REMOVED***);
***REMOVED***

function filterAndRestart(files) ***REMOVED***
  if (!Array.isArray(files)) ***REMOVED***
    files = [files];
  ***REMOVED***
  if (files.length) ***REMOVED***
    if (utils.isWindows) ***REMOVED***
      // ensure the drive letter is in uppercase (c:\foo -> C:\foo)
      files = files.map(function (f) ***REMOVED***
        return f[0].toUpperCase() + f.slice(1);
      ***REMOVED***);
    ***REMOVED***

    var cwd = process.cwd();
    utils.log.detail(
      'files triggering change check: ' +
      files
        .map(function (file) ***REMOVED***
          return path.relative(cwd, file);
        ***REMOVED***)
        .join(', ')
    );

    debug('filterAndRestart on', files);

    var matched = match(
      files,
      config.options.monitor,
      undefsafe(config, 'options.execOptions.ext')
    );

    debug('matched?', JSON.stringify(matched));

    // if there's no matches, then test to see if the changed file is the
    // running script, if so, let's allow a restart
    if (config.options.execOptions.script) ***REMOVED***
      const script = path.resolve(config.options.execOptions.script);
      if (matched.result.length === 0 && script) ***REMOVED***
        const length = script.length;
        files.find(file => ***REMOVED***
          if (file.substr(-length, length) === script) ***REMOVED***
            matched = ***REMOVED***
              result: [file],
              total: 1,
            ***REMOVED***;
            return true;
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    utils.log.detail(
      'changes after filters (before/after): ' +
      [files.length, matched.result.length].join('/')
    );

    // reset the last check so we're only looking at recently modified files
    config.lastStarted = Date.now();

    if (matched.result.length) ***REMOVED***
      if (config.options.delay > 0) ***REMOVED***
        utils.log.detail('delaying restart for ' + config.options.delay + 'ms');
        if (debouncedBus === undefined) ***REMOVED***
          debouncedBus = debounce(restartBus, config.options.delay);
        ***REMOVED***
        debouncedBus(matched);
      ***REMOVED*** else ***REMOVED***
        return restartBus(matched);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function restartBus(matched) ***REMOVED***
  utils.log.status('restarting due to changes...');
  matched.result.map(function (file) ***REMOVED***
    utils.log.detail(path.relative(process.cwd(), file));
  ***REMOVED***);

  if (config.options.verbose) ***REMOVED***
    utils.log._log('');
  ***REMOVED***

  bus.emit('restart', matched.result);
***REMOVED***

function debounce(fn, delay) ***REMOVED***
  var timer = null;
  return function () ***REMOVED***
    var context = this;
    var args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function () ***REMOVED***
      fn.apply(context, args);
    ***REMOVED***, delay);
  ***REMOVED***;
***REMOVED***
