const minimatch = require('minimatch');
const path = require('path');
const fs = require('fs');
const debug = require('debug')('nodemon:match');
const utils = require('../utils');

module.exports = match;
module.exports.rulesToMonitor = rulesToMonitor;

function rulesToMonitor(watch, ignore, config) ***REMOVED***
  var monitor = [];

  if (!Array.isArray(ignore)) ***REMOVED***
    if (ignore) ***REMOVED***
      ignore = [ignore];
    ***REMOVED*** else ***REMOVED***
      ignore = [];
    ***REMOVED***
  ***REMOVED***

  if (!Array.isArray(watch)) ***REMOVED***
    if (watch) ***REMOVED***
      watch = [watch];
    ***REMOVED*** else ***REMOVED***
      watch = [];
    ***REMOVED***
  ***REMOVED***

  if (watch && watch.length) ***REMOVED***
    monitor = utils.clone(watch);
  ***REMOVED***

  if (ignore) ***REMOVED***
    [].push.apply(monitor, (ignore || []).map(function (rule) ***REMOVED***
      return '!' + rule;
    ***REMOVED***));
  ***REMOVED***

  var cwd = process.cwd();

  // next check if the monitored paths are actual directories
  // or just patterns - and expand the rule to include *.*
  monitor = monitor.map(function (rule) ***REMOVED***
    var not = rule.slice(0, 1) === '!';

    if (not) ***REMOVED***
      rule = rule.slice(1);
    ***REMOVED***

    if (rule === '.' || rule === '.*') ***REMOVED***
      rule = '*.*';
    ***REMOVED***

    var dir = path.resolve(cwd, rule);

    try ***REMOVED***
      var stat = fs.statSync(dir);
      if (stat.isDirectory()) ***REMOVED***
        rule = dir;
        if (rule.slice(-1) !== '/') ***REMOVED***
          rule += '/';
        ***REMOVED***
        rule += '**/*';

        // `!not` ... sorry.
        if (!not) ***REMOVED***
          config.dirs.push(dir);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        // ensures we end up in the check that tries to get a base directory
        // and then adds it to the watch list
        throw new Error();
      ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***
      var base = tryBaseDir(dir);
      if (!not && base) ***REMOVED***
        if (config.dirs.indexOf(base) === -1) ***REMOVED***
          config.dirs.push(base);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (rule.slice(-1) === '/') ***REMOVED***
      // just slap on a * anyway
      rule += '*';
    ***REMOVED***

    // if the url ends with * but not **/* and not *.*
    // then convert to **/* - somehow it was missed :-\
    if (rule.slice(-4) !== '**/*' &&
      rule.slice(-1) === '*' &&
      rule.indexOf('*.') === -1) ***REMOVED***

      if (rule.slice(-2) !== '**') ***REMOVED***
        rule += '*/*';
      ***REMOVED***
    ***REMOVED***


    return (not ? '!' : '') + rule;
  ***REMOVED***);

  return monitor;
***REMOVED***

function tryBaseDir(dir) ***REMOVED***
  var stat;
  if (/[?*\***REMOVED***\[]+/.test(dir)) ***REMOVED*** // if this is pattern, then try to find the base
    try ***REMOVED***
      var base = path.dirname(dir.replace(/([?*\***REMOVED***\[]+.*$)/, 'foo'));
      stat = fs.statSync(base);
      if (stat.isDirectory()) ***REMOVED***
        return base;
      ***REMOVED***
    ***REMOVED*** catch (error) ***REMOVED***
      // console.log(error);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    try ***REMOVED***
      stat = fs.statSync(dir);
      // if this path is actually a single file that exists, then just monitor
      // that, *specifically*.
      if (stat.isFile() || stat.isDirectory()) ***REMOVED***
        return dir;
      ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED*** ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***

function match(files, monitor, ext) ***REMOVED***
  // sort the rules by highest specificity (based on number of slashes)
  // ignore rules (!) get sorted highest as they take precedent
  const cwd = process.cwd();
  var rules = monitor.sort(function (a, b) ***REMOVED***
    var r = b.split(path.sep).length - a.split(path.sep).length;
    var aIsIgnore = a.slice(0, 1) === '!';
    var bIsIgnore = b.slice(0, 1) === '!';

    if (aIsIgnore || bIsIgnore) ***REMOVED***
      if (aIsIgnore) ***REMOVED***
        return -1;
      ***REMOVED***

      return 1;
    ***REMOVED***

    if (r === 0) ***REMOVED***
      return b.length - a.length;
    ***REMOVED***
    return r;
  ***REMOVED***).map(function (s) ***REMOVED***
    var prefix = s.slice(0, 1);

    if (prefix === '!') ***REMOVED***
      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);
    ***REMOVED***

    if (s.slice(0, 2) === '..') ***REMOVED***
      return path.resolve(cwd, s);
    ***REMOVED***

    if (s.indexOf(cwd) === 0) ***REMOVED***
      return s;
    ***REMOVED***

    return '**' + (prefix !== path.sep ? path.sep : '') + s;
  ***REMOVED***);

  debug('rules', rules);

  var good = [];
  var whitelist = []; // files that we won't check against the extension
  var ignored = 0;
  var watched = 0;
  var usedRules = [];
  var minimatchOpts = ***REMOVED***
    dot: true,
  ***REMOVED***;

  // enable case-insensitivity on Windows
  if (utils.isWindows) ***REMOVED***
    minimatchOpts.nocase = true;
  ***REMOVED***

  files.forEach(function (file) ***REMOVED***
    file = path.resolve(cwd, file);

    var matched = false;
    for (var i = 0; i < rules.length; i++) ***REMOVED***
      if (rules[i].slice(0, 1) === '!') ***REMOVED***
        if (!minimatch(file, rules[i], minimatchOpts)) ***REMOVED***
          ignored++;
          matched = true;
          break;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        debug('match', file, minimatch(file, rules[i], minimatchOpts));
        if (minimatch(file, rules[i], minimatchOpts)) ***REMOVED***
          watched++;

          // don't repeat the output if a rule is matched
          if (usedRules.indexOf(rules[i]) === -1) ***REMOVED***
            usedRules.push(rules[i]);
            utils.log.detail('matched rule: ' + rules[i]);
          ***REMOVED***

          // if the rule doesn't match the WATCH EVERYTHING
          // but *does* match a rule that ends with *.*, then
          // white list it - in that we don't run it through
          // the extension check too.
          if (rules[i] !== '**' + path.sep + '*.*' &&
            rules[i].slice(-3) === '*.*') ***REMOVED***
            whitelist.push(file);
          ***REMOVED*** else if (path.basename(file) === path.basename(rules[i])) ***REMOVED***
            // if the file matches the actual rule, then it's put on whitelist
            whitelist.push(file);
          ***REMOVED*** else ***REMOVED***
            good.push(file);
          ***REMOVED***
          matched = true;
          break;
        ***REMOVED*** else ***REMOVED***
          // utils.log.detail('no match: ' + rules[i], file);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    if (!matched) ***REMOVED***
      ignored++;
    ***REMOVED***
  ***REMOVED***);

  debug('good', good)

  // finally check the good files against the extensions that we're monitoring
  if (ext) ***REMOVED***
    if (ext.indexOf(',') === -1) ***REMOVED***
      ext = '**/*.' + ext;
    ***REMOVED*** else ***REMOVED***
      ext = '**/*.***REMOVED***' + ext + '***REMOVED***';
    ***REMOVED***

    good = good.filter(function (file) ***REMOVED***
      // only compare the filename to the extension test
      return minimatch(path.basename(file), ext, minimatchOpts);
    ***REMOVED***);
  ***REMOVED*** // else assume *.*

  var result = good.concat(whitelist);

  if (utils.isWindows) ***REMOVED***
    // fix for windows testing - I *think* this is okay to do
    result = result.map(function (file) ***REMOVED***
      return file.slice(0, 1).toLowerCase() + file.slice(1);
    ***REMOVED***);
  ***REMOVED***

  return ***REMOVED***
    result: result,
    ignored: ignored,
    watched: watched,
    total: files.length,
  ***REMOVED***;
***REMOVED***
