var debug = require('debug')('nodemon');
var fs = require('fs');
var path = require('path');
var exists = fs.exists || path.exists;
var utils = require('../utils');
var rules = require('../rules');
var parse = require('../rules/parse');
var exec = require('./exec');
var defaults = require('./defaults');

module.exports = load;
module.exports.mutateExecOptions = mutateExecOptions;

var existsSync = fs.existsSync || path.existsSync;

function findAppScript() ***REMOVED***
  // nodemon has been run alone, so try to read the package file
  // or try to read the index.js file
  if (existsSync('./index.js')) ***REMOVED***
    return 'index.js';
  ***REMOVED***
***REMOVED***

/**
 * Load the nodemon config, first reading the global root/nodemon.json, then
 * the local nodemon.json to the exec and then overwriting using any user
 * specified settings (i.e. from the cli)
 *
 * @param  ***REMOVED***Object***REMOVED*** settings user defined settings
 * @param  ***REMOVED***Function***REMOVED*** ready    callback that receives complete config
 */
function load(settings, options, config, callback) ***REMOVED***
  config.loaded = [];
  // first load the root nodemon.json
  loadFile(options, config, utils.home, function (options) ***REMOVED***
    // then load the user's local configuration file
    if (settings.configFile) ***REMOVED***
      options.configFile = path.resolve(settings.configFile);
    ***REMOVED***
    loadFile(options, config, process.cwd(), function (options) ***REMOVED***
      // Then merge over with the user settings (parsed from the cli).
      // Note that merge protects and favours existing values over new values,
      // and thus command line arguments get priority
      options = utils.merge(settings, options);

      // legacy support
      if (!Array.isArray(options.ignore)) ***REMOVED***
        options.ignore = [options.ignore];
      ***REMOVED***

      if (!options.ignoreRoot) ***REMOVED***
        options.ignoreRoot = defaults.ignoreRoot;
      ***REMOVED***

      // blend the user ignore and the default ignore together
      if (options.ignoreRoot && options.ignore) ***REMOVED***
        if (!Array.isArray(options.ignoreRoot)) ***REMOVED***
          options.ignoreRoot = [options.ignoreRoot];
        ***REMOVED***
        options.ignore = options.ignoreRoot.concat(options.ignore);
      ***REMOVED*** else ***REMOVED***
        options.ignore = defaults.ignore.concat(options.ignore);
      ***REMOVED***


      // add in any missing defaults
      options = utils.merge(options, defaults);

      if (!options.script && !options.exec) ***REMOVED***
        var found = findAppScript();
        if (found) ***REMOVED***
          options.script = found;
        ***REMOVED***
      ***REMOVED***

      mutateExecOptions(options);

      if (options.quiet) ***REMOVED***
        utils.quiet();
      ***REMOVED***

      if (options.verbose) ***REMOVED***
        utils.debug = true;
      ***REMOVED***

      // simplify the ready callback to be called after the rules are normalised
      // from strings to regexp through the rules lib. Note that this gets
      // created *after* options is overwritten twice in the lines above.
      var ready = function (options) ***REMOVED***
        normaliseRules(options, callback);
      ***REMOVED***;

      // if we didn't pick up a nodemon.json file & there's no cli ignores
      // then try loading an old style .nodemonignore file
      if (config.loaded.length === 0) ***REMOVED***
        var legacy = loadLegacyIgnore.bind(null, options, config, ready);

        // first try .nodemonignore, if that doesn't exist, try nodemon-ignore
        return legacy('.nodemonignore', function () ***REMOVED***
          legacy('nodemon-ignore', function (options) ***REMOVED***
            ready(options);
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***

      ready(options);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Loads the old style nodemonignore files which are simply a list of patterns
 * in a file to ignore
 *
 * @param  ***REMOVED***Object***REMOVED*** options    nodemon user options
 * @param  ***REMOVED***Function***REMOVED*** success
 * @param  ***REMOVED***String***REMOVED*** filename   ignore file (.nodemonignore or nodemon-ignore)
 * @param  ***REMOVED***Function***REMOVED*** fail     (optional) failure callback
 */
function loadLegacyIgnore(options, config, success, filename, fail) ***REMOVED***
  var ignoreFile = path.join(process.cwd(), filename);

  exists(ignoreFile, function (exists) ***REMOVED***
    if (exists) ***REMOVED***
      config.loaded.push(ignoreFile);
      return parse(ignoreFile, function (error, rules) ***REMOVED***
        options.ignore = rules.raw;
        success(options);
      ***REMOVED***);
    ***REMOVED***

    if (fail) ***REMOVED***
      fail(options);
    ***REMOVED*** else ***REMOVED***
      success(options);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

function normaliseRules(options, ready) ***REMOVED***
  // convert ignore and watch options to rules/regexp
  rules.watch.add(options.watch);
  rules.ignore.add(options.ignore);

  // normalise the watch and ignore arrays
  options.watch = options.watch === false ? false : rules.rules.watch;
  options.ignore = rules.rules.ignore;

  ready(options);
***REMOVED***

/**
 * Looks for a config in the current working directory, and a config in the
 * user's home directory, merging the two together, giving priority to local
 * config. This can then be overwritten later by command line arguments
 *
 * @param  ***REMOVED***Function***REMOVED*** ready callback to pass loaded settings to
 */
function loadFile(options, config, dir, ready) ***REMOVED***
  if (!ready) ***REMOVED***
    ready = function () ***REMOVED*** ***REMOVED***;
  ***REMOVED***

  var callback = function (settings) ***REMOVED***
    // prefer the local nodemon.json and fill in missing items using
    // the global options
    ready(utils.merge(settings, options));
  ***REMOVED***;

  if (!dir) ***REMOVED***
    return callback(***REMOVED******REMOVED***);
  ***REMOVED***

  var filename = options.configFile || path.join(dir, 'nodemon.json');

  if (config.loaded.indexOf(filename) !== -1) ***REMOVED***
    // don't bother re-parsing the same config file
    return callback(***REMOVED******REMOVED***);
  ***REMOVED***

  fs.readFile(filename, 'utf8', function (err, data) ***REMOVED***
    if (err) ***REMOVED***
      if (err.code === 'ENOENT') ***REMOVED***
        if (!options.configFile && dir !== utils.home) ***REMOVED***
          // if no specified local config file and local nodemon.json
          // doesn't exist, try the package.json
          return loadPackageJSON(config, callback);
        ***REMOVED***
      ***REMOVED***
      return callback(***REMOVED******REMOVED***);
    ***REMOVED***

    var settings = ***REMOVED******REMOVED***;

    try ***REMOVED***
      settings = JSON.parse(data.toString('utf8').replace(/^\uFEFF/, ''));
      if (!filename.endsWith('package.json') || settings.nodemonConfig) ***REMOVED***
        config.loaded.push(filename);
      ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***
      console.error(e);
      utils.log.fail('Failed to parse config ' + filename);
      process.exit(1);
    ***REMOVED***

    // options values will overwrite settings
    callback(settings);
  ***REMOVED***);
***REMOVED***

function loadPackageJSON(config, ready) ***REMOVED***
  if (!ready) ***REMOVED***
    ready = () => ***REMOVED******REMOVED***;
  ***REMOVED***

  const dir = process.cwd();
  const filename = path.join(dir, 'package.json');
  const packageLoadOptions = ***REMOVED*** configFile: filename ***REMOVED***;
  return loadFile(packageLoadOptions, config, dir, settings => ***REMOVED***
    ready(settings.nodemonConfig || ***REMOVED******REMOVED***);
  ***REMOVED***);
***REMOVED***

function mutateExecOptions(options) ***REMOVED***
  // work out the execOptions based on the final config we have
  options.execOptions = exec(***REMOVED***
    script: options.script,
    exec: options.exec,
    args: options.args,
    scriptPosition: options.scriptPosition,
    nodeArgs: options.nodeArgs,
    execArgs: options.execArgs,
    ext: options.ext,
    env: options.env,
  ***REMOVED***, options.execMap);

  // clean up values that we don't need at the top level
  delete options.scriptPosition;
  delete options.script;
  delete options.args;
  delete options.ext;

  return options;
***REMOVED***
