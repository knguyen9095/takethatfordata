/*! firebase-admin v5.8.2 */
"use strict";
/*!
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var validator = require("../utils/validator");
var deep_copy_1 = require("../utils/deep-copy");
var error_1 = require("../utils/error");
var error_2 = require("../utils/error");
var api_request_1 = require("../utils/api-request");
/** Firebase Auth backend host. */
var FIREBASE_AUTH_HOST = 'www.googleapis.com';
/** Firebase Auth backend port number. */
var FIREBASE_AUTH_PORT = 443;
/** Firebase Auth backend path. */
var FIREBASE_AUTH_PATH = '/identitytoolkit/v3/relyingparty/';
/** Firebase Auth request header. */
var FIREBASE_AUTH_HEADER = ***REMOVED***
    'Content-Type': 'application/json',
    'X-Client-Version': 'Node/Admin/5.8.2',
***REMOVED***;
/** Firebase Auth request timeout duration in milliseconds. */
var FIREBASE_AUTH_TIMEOUT = 10000;
/** List of reserved claims which cannot be provided when creating a custom token. */
exports.RESERVED_CLAIMS = [
    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat',
    'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase',
];
/** Maximum allowed number of characters in the custom claims payload. */
var MAX_CLAIMS_PAYLOAD_SIZE = 1000;
/** Maximum allowed number of users to batch download at one time. */
var MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;
/**
 * Validates a create/edit request object. All unsupported parameters
 * are removed from the original request. If an invalid field is passed
 * an error is thrown.
 *
 * @param ***REMOVED***any***REMOVED*** request The create/edit request object.
 */
function validateCreateEditRequest(request) ***REMOVED***
    // Hash set of whitelisted parameters.
    var validKeys = ***REMOVED***
        displayName: true,
        localId: true,
        email: true,
        password: true,
        rawPassword: true,
        emailVerified: true,
        photoUrl: true,
        disabled: true,
        disableUser: true,
        deleteAttribute: true,
        deleteProvider: true,
        sanityCheck: true,
        phoneNumber: true,
        customAttributes: true,
        validSince: true,
    ***REMOVED***;
    // Remove invalid keys from original request.
    for (var key in request) ***REMOVED***
        if (!(key in validKeys)) ***REMOVED***
            delete request[key];
        ***REMOVED***
    ***REMOVED***
    // For any invalid parameter, use the external key name in the error description.
    // displayName should be a string.
    if (typeof request.displayName !== 'undefined' &&
        typeof request.displayName !== 'string') ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_DISPLAY_NAME);
    ***REMOVED***
    if (typeof request.localId !== 'undefined' && !validator.isUid(request.localId)) ***REMOVED***
        // This is called localId on the backend but the developer specifies this as
        // uid externally. So the error message should use the client facing name.
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_UID);
    ***REMOVED***
    // email should be a string and a valid email.
    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_EMAIL);
    ***REMOVED***
    // phoneNumber should be a string and a valid phone number.
    if (typeof request.phoneNumber !== 'undefined' &&
        !validator.isPhoneNumber(request.phoneNumber)) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_PHONE_NUMBER);
    ***REMOVED***
    // password should be a string and a minimum of 6 chars.
    if (typeof request.password !== 'undefined' &&
        !validator.isPassword(request.password)) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_PASSWORD);
    ***REMOVED***
    // rawPassword should be a string and a minimum of 6 chars.
    if (typeof request.rawPassword !== 'undefined' &&
        !validator.isPassword(request.rawPassword)) ***REMOVED***
        // This is called rawPassword on the backend but the developer specifies this as
        // password externally. So the error message should use the client facing name.
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_PASSWORD);
    ***REMOVED***
    // emailVerified should be a boolean.
    if (typeof request.emailVerified !== 'undefined' &&
        typeof request.emailVerified !== 'boolean') ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);
    ***REMOVED***
    // photoUrl should be a URL.
    if (typeof request.photoUrl !== 'undefined' &&
        !validator.isURL(request.photoUrl)) ***REMOVED***
        // This is called photoUrl on the backend but the developer specifies this as
        // photoURL externally. So the error message should use the client facing name.
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_PHOTO_URL);
    ***REMOVED***
    // disabled should be a boolean.
    if (typeof request.disabled !== 'undefined' &&
        typeof request.disabled !== 'boolean') ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_DISABLED_FIELD);
    ***REMOVED***
    // validSince should be a number.
    if (typeof request.validSince !== 'undefined' &&
        !validator.isNumber(request.validSince)) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);
    ***REMOVED***
    // disableUser should be a boolean.
    if (typeof request.disableUser !== 'undefined' &&
        typeof request.disableUser !== 'boolean') ***REMOVED***
        // This is called disableUser on the backend but the developer specifies this as
        // disabled externally. So the error message should use the client facing name.
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_DISABLED_FIELD);
    ***REMOVED***
    // customAttributes should be stringified JSON with no blacklisted claims.
    // The payload should not exceed 1KB.
    if (typeof request.customAttributes !== 'undefined') ***REMOVED***
        var developerClaims_1;
        try ***REMOVED***
            developerClaims_1 = JSON.parse(request.customAttributes);
        ***REMOVED***
        catch (error) ***REMOVED***
            // JSON parsing error. This should never happen as we stringify the claims internally.
            // However, we still need to check since setAccountInfo via edit requests could pass
            // this field.
            throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_CLAIMS, error.message);
        ***REMOVED***
        var invalidClaims_1 = [];
        // Check for any invalid claims.
        exports.RESERVED_CLAIMS.forEach(function (blacklistedClaim) ***REMOVED***
            if (developerClaims_1.hasOwnProperty(blacklistedClaim)) ***REMOVED***
                invalidClaims_1.push(blacklistedClaim);
            ***REMOVED***
        ***REMOVED***);
        // Throw an error if an invalid claim is detected.
        if (invalidClaims_1.length > 0) ***REMOVED***
            throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims_1.length > 1 ?
                "Developer claims \"" + invalidClaims_1.join('", "') + "\" are reserved and cannot be specified." :
                "Developer claim \"" + invalidClaims_1[0] + "\" is reserved and cannot be specified.");
        ***REMOVED***
        // Check claims payload does not exceed maxmimum size.
        if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) ***REMOVED***
            throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.CLAIMS_TOO_LARGE, "Developer claims payload should not exceed " + MAX_CLAIMS_PAYLOAD_SIZE + " characters.");
        ***REMOVED***
    ***REMOVED***
***REMOVED***
;
/** Instantiates the downloadAccount endpoint settings. */
exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('downloadAccount', 'POST')
    .setRequestValidator(function (request) ***REMOVED***
    // Validate next page token.
    if (typeof request.nextPageToken !== 'undefined' &&
        !validator.isNonEmptyString(request.nextPageToken)) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_PAGE_TOKEN);
    ***REMOVED***
    // Validate max results.
    if (!validator.isNumber(request.maxResults) ||
        request.maxResults <= 0 ||
        request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_ARGUMENT, "Required \"maxResults\" must be a positive non-zero number that does not exceed " +
            ("the allowed " + MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE + "."));
    ***REMOVED***
***REMOVED***);
/** Instantiates the getAccountInfo endpoint settings. */
exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('getAccountInfo', 'POST')
    .setRequestValidator(function (request) ***REMOVED***
    if (!request.localId && !request.email && !request.phoneNumber) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');
    ***REMOVED***
***REMOVED***)
    .setResponseValidator(function (response) ***REMOVED***
    if (!response.users) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.USER_NOT_FOUND);
    ***REMOVED***
***REMOVED***);
/** Instantiates the deleteAccount endpoint settings. */
exports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('deleteAccount', 'POST')
    .setRequestValidator(function (request) ***REMOVED***
    if (!request.localId) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');
    ***REMOVED***
***REMOVED***);
/** Instantiates the setAccountInfo endpoint settings for updating existing accounts. */
exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('setAccountInfo', 'POST')
    .setRequestValidator(function (request) ***REMOVED***
    // localId is a required parameter.
    if (typeof request.localId === 'undefined') ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');
    ***REMOVED***
    validateCreateEditRequest(request);
***REMOVED***)
    .setResponseValidator(function (response) ***REMOVED***
    // If the localId is not returned, then the request failed.
    if (!response.localId) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.USER_NOT_FOUND);
    ***REMOVED***
***REMOVED***);
/**
 * Instantiates the signupNewUser endpoint settings for creating a new user with or without
 * uid being specified. The backend will create a new one if not provided and return it.
 */
exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('signupNewUser', 'POST')
    .setRequestValidator(function (request) ***REMOVED***
    // signupNewUser does not support customAttributes.
    if (typeof request.customAttributes !== 'undefined') ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_ARGUMENT, "\"customAttributes\" cannot be set when creating a new user.");
    ***REMOVED***
    // signupNewUser does not support validSince.
    if (typeof request.validSince !== 'undefined') ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_ARGUMENT, "\"validSince\" cannot be set when creating a new user.");
    ***REMOVED***
    validateCreateEditRequest(request);
***REMOVED***)
    .setResponseValidator(function (response) ***REMOVED***
    // If the localId is not returned, then the request failed.
    if (!response.localId) ***REMOVED***
        throw new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');
    ***REMOVED***
***REMOVED***);
/**
 * Class that provides mechanism to send requests to the Firebase Auth backend endpoints.
 */
var FirebaseAuthRequestHandler = /** @class */ (function () ***REMOVED***
    /**
     * @param ***REMOVED***FirebaseApp***REMOVED*** app The app used to fetch access tokens to sign API requests.
     * @constructor
     */
    function FirebaseAuthRequestHandler(app) ***REMOVED***
        this.host = FIREBASE_AUTH_HOST;
        this.port = FIREBASE_AUTH_PORT;
        this.path = FIREBASE_AUTH_PATH;
        this.headers = FIREBASE_AUTH_HEADER;
        this.timeout = FIREBASE_AUTH_TIMEOUT;
        this.signedApiRequestHandler = new api_request_1.SignedApiRequestHandler(app);
    ***REMOVED***
    /**
     * @param ***REMOVED***Object***REMOVED*** response The response to check for errors.
     * @return ***REMOVED***string|null***REMOVED*** The error code if present; null otherwise.
     */
    FirebaseAuthRequestHandler.getErrorCode = function (response) ***REMOVED***
        return (validator.isNonNullObject(response) && response.error && response.error.message) || null;
    ***REMOVED***;
    /**
     * Looks up a user by uid.
     *
     * @param ***REMOVED***string***REMOVED*** uid The uid of the user to lookup.
     * @return ***REMOVED***Promise<Object>***REMOVED*** A promise that resolves with the user information.
     */
    FirebaseAuthRequestHandler.prototype.getAccountInfoByUid = function (uid) ***REMOVED***
        if (!validator.isUid(uid)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_UID));
        ***REMOVED***
        var request = ***REMOVED***
            localId: [uid],
        ***REMOVED***;
        return this.invokeRequestHandler(exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
    ***REMOVED***;
    /**
     * Looks up a user by email.
     *
     * @param ***REMOVED***string***REMOVED*** email The email of the user to lookup.
     * @return ***REMOVED***Promise<Object>***REMOVED*** A promise that resolves with the user information.
     */
    FirebaseAuthRequestHandler.prototype.getAccountInfoByEmail = function (email) ***REMOVED***
        if (!validator.isEmail(email)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_EMAIL));
        ***REMOVED***
        var request = ***REMOVED***
            email: [email],
        ***REMOVED***;
        return this.invokeRequestHandler(exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
    ***REMOVED***;
    /**
     * Looks up a user by phone number.
     *
     * @param ***REMOVED***string***REMOVED*** phoneNumber The phone number of the user to lookup.
     * @return ***REMOVED***Promise<Object>***REMOVED*** A promise that resolves with the user information.
     */
    FirebaseAuthRequestHandler.prototype.getAccountInfoByPhoneNumber = function (phoneNumber) ***REMOVED***
        if (!validator.isPhoneNumber(phoneNumber)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_PHONE_NUMBER));
        ***REMOVED***
        var request = ***REMOVED***
            phoneNumber: [phoneNumber],
        ***REMOVED***;
        return this.invokeRequestHandler(exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
    ***REMOVED***;
    /**
     * Exports the users (single batch only) with a size of maxResults and starting from
     * the offset as specified by pageToken.
     *
     * @param ***REMOVED***number=***REMOVED*** maxResults The page size, 1000 if undefined. This is also the maximum
     *     allowed limit.
     * @param ***REMOVED***string=***REMOVED*** pageToken The next page token. If not specified, returns users starting
     *     without any offset. Users are returned in the order they were created from oldest to
     *     newest, relative to the page token offset.
     * @return ***REMOVED***Promise<Object>***REMOVED*** A promise that resolves with the current batch of downloaded
     *     users and the next page token if available. For the last page, an empty list of users
     *     and no page token are returned.
     */
    FirebaseAuthRequestHandler.prototype.downloadAccount = function (maxResults, pageToken) ***REMOVED***
        if (maxResults === void 0) ***REMOVED*** maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE; ***REMOVED***
        // Construct request.
        var request = ***REMOVED***
            maxResults: maxResults,
            nextPageToken: pageToken,
        ***REMOVED***;
        // Remove next page token if not provided.
        if (typeof request.nextPageToken === 'undefined') ***REMOVED***
            delete request.nextPageToken;
        ***REMOVED***
        return this.invokeRequestHandler(exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request)
            .then(function (response) ***REMOVED***
            // No more users available.
            if (!response.users) ***REMOVED***
                response.users = [];
            ***REMOVED***
            return response;
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Deletes an account identified by a uid.
     *
     * @param ***REMOVED***string***REMOVED*** uid The uid of the user to delete.
     * @return ***REMOVED***Promise<Object>***REMOVED*** A promise that resolves when the user is deleted.
     */
    FirebaseAuthRequestHandler.prototype.deleteAccount = function (uid) ***REMOVED***
        if (!validator.isUid(uid)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_UID));
        ***REMOVED***
        var request = ***REMOVED***
            localId: uid,
        ***REMOVED***;
        return this.invokeRequestHandler(exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);
    ***REMOVED***;
    /**
     * Sets additional developer claims on an existing user identified by provided UID.
     *
     * @param ***REMOVED***string***REMOVED*** uid The user to edit.
     * @param ***REMOVED***Object***REMOVED*** customUserClaims The developer claims to set.
     * @return ***REMOVED***Promise<string>***REMOVED*** A promise that resolves when the operation completes
     *     with the user id that was edited.
     */
    FirebaseAuthRequestHandler.prototype.setCustomUserClaims = function (uid, customUserClaims) ***REMOVED***
        // Validate user UID.
        if (!validator.isUid(uid)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_UID));
        ***REMOVED***
        else if (!validator.isObject(customUserClaims)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));
        ***REMOVED***
        // Delete operation. Replace null with an empty object.
        if (customUserClaims === null) ***REMOVED***
            customUserClaims = ***REMOVED******REMOVED***;
        ***REMOVED***
        // Construct custom user attribute editting request.
        var request = ***REMOVED***
            localId: uid,
            customAttributes: JSON.stringify(customUserClaims),
        ***REMOVED***;
        return this.invokeRequestHandler(exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)
            .then(function (response) ***REMOVED***
            return response.localId;
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Edits an existing user.
     *
     * @param ***REMOVED***string***REMOVED*** uid The user to edit.
     * @param ***REMOVED***Object***REMOVED*** properties The properties to set on the user.
     * @return ***REMOVED***Promise<string>***REMOVED*** A promise that resolves when the operation completes
     *     with the user id that was edited.
     */
    FirebaseAuthRequestHandler.prototype.updateExistingAccount = function (uid, properties) ***REMOVED***
        if (!validator.isUid(uid)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_UID));
        ***REMOVED***
        else if (!validator.isNonNullObject(properties)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));
        ***REMOVED***
        // Build the setAccountInfo request.
        var request = deep_copy_1.deepCopy(properties);
        request.localId = uid;
        // For deleting displayName or photoURL, these values must be passed as null.
        // They will be removed from the backend request and an additional parameter
        // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']
        // with an array of the parameter names to delete will be passed.
        // Parameters that are deletable and their deleteAttribute names.
        // Use client facing names, photoURL instead of photoUrl.
        var deletableParams = ***REMOVED***
            displayName: 'DISPLAY_NAME',
            photoURL: 'PHOTO_URL',
        ***REMOVED***;
        // Properties to delete if available.
        request.deleteAttribute = [];
        for (var key in deletableParams) ***REMOVED***
            if (request[key] === null) ***REMOVED***
                // Add property identifier to list of attributes to delete.
                request.deleteAttribute.push(deletableParams[key]);
                // Remove property from request.
                delete request[key];
            ***REMOVED***
        ***REMOVED***
        if (request.deleteAttribute.length === 0) ***REMOVED***
            delete request.deleteAttribute;
        ***REMOVED***
        // For deleting phoneNumber, this value must be passed as null.
        // It will be removed from the backend request and an additional parameter
        // deleteProvider: ['phone'] with an array of providerIds (phone in this case),
        // will be passed.
        // Currently this applies to phone provider only.
        if (request.phoneNumber === null) ***REMOVED***
            request.deleteProvider = ['phone'];
            delete request.phoneNumber;
        ***REMOVED***
        else ***REMOVED***
            // Doesn't apply to other providers in admin SDK.
            delete request.deleteProvider;
        ***REMOVED***
        // Rewrite photoURL to photoUrl.
        if (typeof request.photoURL !== 'undefined') ***REMOVED***
            request.photoUrl = request.photoURL;
            delete request.photoURL;
        ***REMOVED***
        // Rewrite disabled to disableUser.
        if (typeof request.disabled !== 'undefined') ***REMOVED***
            request.disableUser = request.disabled;
            delete request.disabled;
        ***REMOVED***
        return this.invokeRequestHandler(exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)
            .then(function (response) ***REMOVED***
            return response.localId;
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Revokes all refresh tokens for the specified user identified by the uid provided.
     * In addition to revoking all refresh tokens for a user, all ID tokens issued
     * before revocation will also be revoked on the Auth backend. Any request with an
     * ID token generated before revocation will be rejected with a token expired error.
     * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in
     * the same second as the revocation will still be valid. If there is a chance that a token
     * was minted in the last second, delay for 1 second before revoking.
     *
     * @param ***REMOVED***string***REMOVED*** uid The user whose tokens are to be revoked.
     * @return ***REMOVED***Promise<string>***REMOVED*** A promise that resolves when the operation completes
     *     successfully with the user id of the corresponding user.
     */
    FirebaseAuthRequestHandler.prototype.revokeRefreshTokens = function (uid) ***REMOVED***
        // Validate user UID.
        if (!validator.isUid(uid)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_UID));
        ***REMOVED***
        var request = ***REMOVED***
            localId: uid,
            // validSince is in UTC seconds.
            validSince: Math.ceil(new Date().getTime() / 1000),
        ***REMOVED***;
        return this.invokeRequestHandler(exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)
            .then(function (response) ***REMOVED***
            return response.localId;
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Create a new user with the properties supplied.
     *
     * @param ***REMOVED***Object***REMOVED*** properties The properties to set on the user.
     * @return ***REMOVED***Promise<string>***REMOVED*** A promise that resolves when the operation completes
     *     with the user id that was created.
     */
    FirebaseAuthRequestHandler.prototype.createNewAccount = function (properties) ***REMOVED***
        if (!validator.isNonNullObject(properties)) ***REMOVED***
            return Promise.reject(new error_2.FirebaseAuthError(error_2.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));
        ***REMOVED***
        // Build the signupNewUser request.
        var request = deep_copy_1.deepCopy(properties);
        // Rewrite photoURL to photoUrl.
        if (typeof request.photoURL !== 'undefined') ***REMOVED***
            request.photoUrl = request.photoURL;
            delete request.photoURL;
        ***REMOVED***
        // Rewrite uid to localId if it exists.
        if (typeof request.uid !== 'undefined') ***REMOVED***
            request.localId = request.uid;
            delete request.uid;
        ***REMOVED***
        return this.invokeRequestHandler(exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request)
            .then(function (response) ***REMOVED***
            // Return the user id.
            return response.localId;
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Invokes the request handler based on the API settings object passed.
     *
     * @param ***REMOVED***ApiSettings***REMOVED*** apiSettings The API endpoint settings to apply to request and response.
     * @param ***REMOVED***Object***REMOVED*** requestData The request data.
     * @return ***REMOVED***Promise<Object>***REMOVED*** A promise that resolves with the response.
     */
    FirebaseAuthRequestHandler.prototype.invokeRequestHandler = function (apiSettings, requestData) ***REMOVED***
        var _this = this;
        var path = this.path + apiSettings.getEndpoint();
        var httpMethod = apiSettings.getHttpMethod();
        return Promise.resolve()
            .then(function () ***REMOVED***
            // Validate request.
            var requestValidator = apiSettings.getRequestValidator();
            requestValidator(requestData);
            // Process request.
            return _this.signedApiRequestHandler.sendRequest(_this.host, _this.port, path, httpMethod, requestData, _this.headers, _this.timeout);
        ***REMOVED***)
            .then(function (response) ***REMOVED***
            // Check for backend errors in the response.
            var errorCode = FirebaseAuthRequestHandler.getErrorCode(response);
            if (errorCode) ***REMOVED***
                throw error_2.FirebaseAuthError.fromServerError(errorCode, /* message */ undefined, response);
            ***REMOVED***
            // Validate response.
            var responseValidator = apiSettings.getResponseValidator();
            responseValidator(response);
            // Return entire response.
            return response;
        ***REMOVED***)
            .catch(function (response) ***REMOVED***
            var error;
            if (typeof response === 'object' && 'statusCode' in response) ***REMOVED***
                // response came directly from a non-200 response.
                error = response.error;
            ***REMOVED***
            else ***REMOVED***
                // response came from a thrown error on a 200 response.
                error = response;
            ***REMOVED***
            if (error instanceof error_1.FirebaseError) ***REMOVED***
                throw error;
            ***REMOVED***
            var errorCode = FirebaseAuthRequestHandler.getErrorCode(error);
            throw error_2.FirebaseAuthError.fromServerError(errorCode, /* message */ undefined, error);
        ***REMOVED***);
    ***REMOVED***;
    return FirebaseAuthRequestHandler;
***REMOVED***());
exports.FirebaseAuthRequestHandler = FirebaseAuthRequestHandler;
