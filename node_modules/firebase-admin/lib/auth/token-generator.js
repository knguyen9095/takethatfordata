/*! firebase-admin v5.8.2 */
"use strict";
/*!
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var error_1 = require("../utils/error");
var validator = require("../utils/validator");
var jwt = require("jsonwebtoken");
// Use untyped import syntax for Node built-ins
var https = require("https");
var ALGORITHM = 'RS256';
var ONE_HOUR_IN_SECONDS = 60 * 60;
// List of blacklisted claims which cannot be provided when creating a custom token
var BLACKLISTED_CLAIMS = [
    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat', 'iss', 'jti',
    'nbf', 'nonce',
];
// URL containing the public keys for the Google certs (whose private keys are used to sign Firebase
// Auth ID tokens)
var CLIENT_CERT_URL = 'https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com';
// Audience to use for Firebase Auth Custom tokens
var FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';
/**
 * Class for generating and verifying different types of Firebase Auth tokens (JWTs).
 */
var FirebaseTokenGenerator = /** @class */ (function () ***REMOVED***
    function FirebaseTokenGenerator(certificate) ***REMOVED***
        if (!certificate) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'INTERNAL ASSERT: Must provide a certificate to use FirebaseTokenGenerator.');
        ***REMOVED***
        this.certificate_ = certificate;
    ***REMOVED***
    /**
     * Creates a new Firebase Auth Custom token.
     *
     * @param ***REMOVED***string***REMOVED*** uid The user ID to use for the generated Firebase Auth Custom token.
     * @param ***REMOVED***Object***REMOVED*** [developerClaims] Optional developer claims to include in the generated Firebase
     *                 Auth Custom token.
     * @return ***REMOVED***Promise<string>***REMOVED*** A Promise fulfilled with a Firebase Auth Custom token signed with a
     *                           service account key and containing the provided payload.
     */
    FirebaseTokenGenerator.prototype.createCustomToken = function (uid, developerClaims) ***REMOVED***
        var errorMessage;
        if (typeof uid !== 'string' || uid === '') ***REMOVED***
            errorMessage = 'First argument to createCustomToken() must be a non-empty string uid.';
        ***REMOVED***
        else if (uid.length > 128) ***REMOVED***
            errorMessage = 'First argument to createCustomToken() must a uid with less than or equal to 128 characters.';
        ***REMOVED***
        else if (!this.isDeveloperClaimsValid_(developerClaims)) ***REMOVED***
            errorMessage = 'Second argument to createCustomToken() must be an object containing the developer claims.';
        ***REMOVED***
        if (typeof errorMessage !== 'undefined') ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
        ***REMOVED***
        if (!validator.isNonEmptyString(this.certificate_.privateKey)) ***REMOVED***
            errorMessage = 'createCustomToken() requires a certificate with "private_key" set.';
        ***REMOVED***
        else if (!validator.isNonEmptyString(this.certificate_.clientEmail)) ***REMOVED***
            errorMessage = 'createCustomToken() requires a certificate with "client_email" set.';
        ***REMOVED***
        if (typeof errorMessage !== 'undefined') ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, errorMessage);
        ***REMOVED***
        var jwtPayload = ***REMOVED******REMOVED***;
        if (typeof developerClaims !== 'undefined') ***REMOVED***
            var claims = ***REMOVED******REMOVED***;
            for (var key in developerClaims) ***REMOVED***
                /* istanbul ignore else */
                if (developerClaims.hasOwnProperty(key)) ***REMOVED***
                    if (BLACKLISTED_CLAIMS.indexOf(key) !== -1) ***REMOVED***
                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Developer claim \"" + key + "\" is reserved and cannot be specified.");
                    ***REMOVED***
                    claims[key] = developerClaims[key];
                ***REMOVED***
            ***REMOVED***
            jwtPayload.claims = claims;
        ***REMOVED***
        jwtPayload.uid = uid;
        var customToken = jwt.sign(jwtPayload, this.certificate_.privateKey, ***REMOVED***
            audience: FIREBASE_AUDIENCE,
            expiresIn: ONE_HOUR_IN_SECONDS,
            issuer: this.certificate_.clientEmail,
            subject: this.certificate_.clientEmail,
            algorithm: ALGORITHM,
        ***REMOVED***);
        return Promise.resolve(customToken);
    ***REMOVED***;
    /**
     * Verifies the format and signature of a Firebase Auth ID token.
     *
     * @param ***REMOVED***string***REMOVED*** idToken The Firebase Auth ID token to verify.
     * @return ***REMOVED***Promise<Object>***REMOVED*** A promise fulfilled with the decoded claims of the Firebase Auth ID
     *                           token.
     */
    FirebaseTokenGenerator.prototype.verifyIdToken = function (idToken) ***REMOVED***
        if (typeof idToken !== 'string') ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument to verifyIdToken() must be a Firebase ID token string.');
        ***REMOVED***
        if (!validator.isNonEmptyString(this.certificate_.projectId)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'verifyIdToken() requires a certificate with "project_id" set.');
        ***REMOVED***
        var fullDecodedToken = jwt.decode(idToken, ***REMOVED***
            complete: true,
        ***REMOVED***);
        var header = fullDecodedToken && fullDecodedToken.header;
        var payload = fullDecodedToken && fullDecodedToken.payload;
        var projectIdMatchMessage = ' Make sure the ID token comes from the same Firebase project as the ' +
            'service account used to authenticate this SDK.';
        var verifyIdTokenDocsMessage = ' See https://firebase.google.com/docs/auth/admin/verify-id-tokens ' +
            'for details on how to retrieve an ID token.';
        var errorMessage;
        if (!fullDecodedToken) ***REMOVED***
            errorMessage = 'Decoding Firebase ID token failed. Make sure you passed the entire string JWT ' +
                'which represents an ID token.' + verifyIdTokenDocsMessage;
        ***REMOVED***
        else if (typeof header.kid === 'undefined') ***REMOVED***
            var isCustomToken = (payload.aud === FIREBASE_AUDIENCE);
            var isLegacyCustomToken = (header.alg === 'HS256' && payload.v === 0 && 'd' in payload && 'uid' in payload.d);
            if (isCustomToken) ***REMOVED***
                errorMessage = 'verifyIdToken() expects an ID token, but was given a custom token.';
            ***REMOVED***
            else if (isLegacyCustomToken) ***REMOVED***
                errorMessage = 'verifyIdToken() expects an ID token, but was given a legacy custom token.';
            ***REMOVED***
            else ***REMOVED***
                errorMessage = 'Firebase ID token has no "kid" claim.';
            ***REMOVED***
            errorMessage += verifyIdTokenDocsMessage;
        ***REMOVED***
        else if (header.alg !== ALGORITHM) ***REMOVED***
            errorMessage = 'Firebase ID token has incorrect algorithm. Expected "' + ALGORITHM + '" but got ' +
                '"' + header.alg + '".' + verifyIdTokenDocsMessage;
        ***REMOVED***
        else if (payload.aud !== this.certificate_.projectId) ***REMOVED***
            errorMessage = 'Firebase ID token has incorrect "aud" (audience) claim. Expected "' +
                this.certificate_.projectId + '" but got "' + payload.aud + '".' + projectIdMatchMessage +
                verifyIdTokenDocsMessage;
        ***REMOVED***
        else if (payload.iss !== 'https://securetoken.google.com/' + this.certificate_.projectId) ***REMOVED***
            errorMessage = 'Firebase ID token has incorrect "iss" (issuer) claim. Expected ' +
                '"https://securetoken.google.com/' + this.certificate_.projectId + '" but got "' +
                payload.iss + '".' + projectIdMatchMessage + verifyIdTokenDocsMessage;
        ***REMOVED***
        else if (typeof payload.sub !== 'string') ***REMOVED***
            errorMessage = 'Firebase ID token has no "sub" (subject) claim.' + verifyIdTokenDocsMessage;
        ***REMOVED***
        else if (payload.sub === '') ***REMOVED***
            errorMessage = 'Firebase ID token has an empty string "sub" (subject) claim.' + verifyIdTokenDocsMessage;
        ***REMOVED***
        else if (payload.sub.length > 128) ***REMOVED***
            errorMessage = 'Firebase ID token has "sub" (subject) claim longer than 128 characters.' +
                verifyIdTokenDocsMessage;
        ***REMOVED***
        if (typeof errorMessage !== 'undefined') ***REMOVED***
            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));
        ***REMOVED***
        return this.fetchPublicKeys_().then(function (publicKeys) ***REMOVED***
            if (!publicKeys.hasOwnProperty(header.kid)) ***REMOVED***
                return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Firebase ID token has "kid" claim which does not correspond to a known public key. ' +
                    'Most likely the ID token is expired, so get a fresh token from your client app and ' +
                    'try again.' + verifyIdTokenDocsMessage));
            ***REMOVED***
            return new Promise(function (resolve, reject) ***REMOVED***
                jwt.verify(idToken, publicKeys[header.kid], ***REMOVED***
                    algorithms: [ALGORITHM],
                ***REMOVED***, function (error, decodedToken) ***REMOVED***
                    if (error) ***REMOVED***
                        if (error.name === 'TokenExpiredError') ***REMOVED***
                            errorMessage = 'Firebase ID token has expired. Get a fresh token from your client app and try ' +
                                'again (auth/id-token-expired).' + verifyIdTokenDocsMessage;
                        ***REMOVED***
                        else if (error.name === 'JsonWebTokenError') ***REMOVED***
                            errorMessage = 'Firebase ID token has invalid signature.' + verifyIdTokenDocsMessage;
                        ***REMOVED***
                        return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));
                    ***REMOVED***
                    else ***REMOVED***
                        decodedToken.uid = decodedToken.sub;
                        resolve(decodedToken);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Returns whether or not the provided developer claims are valid.
     *
     * @param ***REMOVED***Object***REMOVED*** [developerClaims] Optional developer claims to validate.
     * @return ***REMOVED***boolean***REMOVED*** True if the provided claims are valid; otherwise, false.
     */
    FirebaseTokenGenerator.prototype.isDeveloperClaimsValid_ = function (developerClaims) ***REMOVED***
        if (typeof developerClaims === 'undefined') ***REMOVED***
            return true;
        ***REMOVED***
        if (typeof developerClaims === 'object' && developerClaims !== null && !(developerClaims instanceof Array)) ***REMOVED***
            return true;
        ***REMOVED***
        return false;
    ***REMOVED***;
    /**
     * Fetches the public keys for the Google certs.
     *
     * @return ***REMOVED***Promise<Object>***REMOVED*** A promise fulfilled with public keys for the Google certs.
     */
    FirebaseTokenGenerator.prototype.fetchPublicKeys_ = function () ***REMOVED***
        var _this = this;
        var publicKeysExist = (typeof this.publicKeys_ !== 'undefined');
        var publicKeysExpiredExists = (typeof this.publicKeysExpireAt_ !== 'undefined');
        var publicKeysStillValid = (publicKeysExpiredExists && Date.now() < this.publicKeysExpireAt_);
        if (publicKeysExist && publicKeysStillValid) ***REMOVED***
            return Promise.resolve(this.publicKeys_);
        ***REMOVED***
        return new Promise(function (resolve, reject) ***REMOVED***
            https.get(CLIENT_CERT_URL, function (res) ***REMOVED***
                var buffers = [];
                res.on('data', function (buffer) ***REMOVED*** return buffers.push(buffer); ***REMOVED***);
                res.on('end', function () ***REMOVED***
                    try ***REMOVED***
                        var response = JSON.parse(Buffer.concat(buffers).toString());
                        if (response.error) ***REMOVED***
                            var errorMessage = 'Error fetching public keys for Google certs: ' + response.error;
                            /* istanbul ignore else */
                            if (response.error_description) ***REMOVED***
                                errorMessage += ' (' + response.error_description + ')';
                            ***REMOVED***
                            reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, errorMessage));
                        ***REMOVED***
                        else ***REMOVED***
                            /* istanbul ignore else */
                            if (res.headers.hasOwnProperty('cache-control')) ***REMOVED***
                                var cacheControlHeader = res.headers['cache-control'];
                                var parts = cacheControlHeader.split(',');
                                parts.forEach(function (part) ***REMOVED***
                                    var subParts = part.trim().split('=');
                                    if (subParts[0] === 'max-age') ***REMOVED***
                                        var maxAge = +subParts[1];
                                        _this.publicKeysExpireAt_ = Date.now() + (maxAge * 1000);
                                    ***REMOVED***
                                ***REMOVED***);
                            ***REMOVED***
                            _this.publicKeys_ = response;
                            resolve(response);
                        ***REMOVED***
                    ***REMOVED***
                    catch (e) ***REMOVED***
                        /* istanbul ignore next */
                        reject(e);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***).on('error', reject);
        ***REMOVED***);
    ***REMOVED***;
    return FirebaseTokenGenerator;
***REMOVED***());
exports.FirebaseTokenGenerator = FirebaseTokenGenerator;
