/*! firebase-admin v5.8.2 */
"use strict";
/*!
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var jwt = require("jsonwebtoken");
var forge = require("node-forge");
// Use untyped import syntax for Node built-ins
var fs = require("fs");
var os = require("os");
var http = require("http");
var path = require("path");
var https = require("https");
var error_1 = require("../utils/error");
var GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';
var GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';
var GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token';
var GOOGLE_AUTH_TOKEN_PORT = 443;
// NOTE: the Google Metadata Service uses HTTP over a vlan
var GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';
var GOOGLE_METADATA_SERVICE_PATH = '/computeMetadata/v1beta1/instance/service-accounts/default/token';
var configDir = (function () ***REMOVED***
    // Windows has a dedicated low-rights location for apps at ~/Application Data
    var sys = os.platform();
    if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') ***REMOVED***
        return process.env.APPDATA;
    ***REMOVED***
    // On *nix the gcloud cli creates a . dir.
    return process.env.HOME && path.resolve(process.env.HOME, '.config');
***REMOVED***)();
var GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';
var GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);
var REFRESH_TOKEN_HOST = 'www.googleapis.com';
var REFRESH_TOKEN_PORT = 443;
var REFRESH_TOKEN_PATH = '/oauth2/v4/token';
var ONE_HOUR_IN_SECONDS = 60 * 60;
var JWT_ALGORITHM = 'RS256';
function copyAttr(to, from, key, alt) ***REMOVED***
    var tmp = from[key] || from[alt];
    if (typeof tmp !== 'undefined') ***REMOVED***
        to[key] = tmp;
    ***REMOVED***
***REMOVED***
var RefreshToken = /** @class */ (function () ***REMOVED***
    function RefreshToken(json) ***REMOVED***
        copyAttr(this, json, 'clientId', 'client_id');
        copyAttr(this, json, 'clientSecret', 'client_secret');
        copyAttr(this, json, 'refreshToken', 'refresh_token');
        copyAttr(this, json, 'type', 'type');
        var errorMessage;
        if (typeof this.clientId !== 'string' || !this.clientId) ***REMOVED***
            errorMessage = 'Refresh token must contain a "client_id" property.';
        ***REMOVED***
        else if (typeof this.clientSecret !== 'string' || !this.clientSecret) ***REMOVED***
            errorMessage = 'Refresh token must contain a "client_secret" property.';
        ***REMOVED***
        else if (typeof this.refreshToken !== 'string' || !this.refreshToken) ***REMOVED***
            errorMessage = 'Refresh token must contain a "refresh_token" property.';
        ***REMOVED***
        else if (typeof this.type !== 'string' || !this.type) ***REMOVED***
            errorMessage = 'Refresh token must contain a "type" property.';
        ***REMOVED***
        if (typeof errorMessage !== 'undefined') ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        ***REMOVED***
    ***REMOVED***
    /*
     * Tries to load a RefreshToken from a path. If the path is not present, returns null.
     * Throws if data at the path is invalid.
     */
    RefreshToken.fromPath = function (path) ***REMOVED***
        var jsonString;
        try ***REMOVED***
            jsonString = fs.readFileSync(path, 'utf8');
        ***REMOVED***
        catch (ignored) ***REMOVED***
            // Ignore errors if the file is not present, as this is sometimes an expected condition
            return null;
        ***REMOVED***
        try ***REMOVED***
            return new RefreshToken(JSON.parse(jsonString));
        ***REMOVED***
        catch (error) ***REMOVED***
            // Throw a nicely formed error message if the file contents cannot be parsed
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);
        ***REMOVED***
    ***REMOVED***;
    return RefreshToken;
***REMOVED***());
exports.RefreshToken = RefreshToken;
/**
 * A struct containing the properties necessary to use service-account JSON credentials.
 */
var Certificate = /** @class */ (function () ***REMOVED***
    function Certificate(json) ***REMOVED***
        if (typeof json !== 'object' || json === null) ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Certificate object must be an object.');
        ***REMOVED***
        copyAttr(this, json, 'projectId', 'project_id');
        copyAttr(this, json, 'privateKey', 'private_key');
        copyAttr(this, json, 'clientEmail', 'client_email');
        var errorMessage;
        if (typeof this.privateKey !== 'string' || !this.privateKey) ***REMOVED***
            errorMessage = 'Certificate object must contain a string "private_key" property.';
        ***REMOVED***
        else if (typeof this.clientEmail !== 'string' || !this.clientEmail) ***REMOVED***
            errorMessage = 'Certificate object must contain a string "client_email" property.';
        ***REMOVED***
        if (typeof errorMessage !== 'undefined') ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        ***REMOVED***
        try ***REMOVED***
            forge.pki.privateKeyFromPem(this.privateKey);
        ***REMOVED***
        catch (error) ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);
        ***REMOVED***
    ***REMOVED***
    Certificate.fromPath = function (path) ***REMOVED***
        // Node bug encountered in v6.x. fs.readFileSync hangs when path is a 0 or 1.
        if (typeof path !== 'string') ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse certificate key file: TypeError: path must be a string');
        ***REMOVED***
        try ***REMOVED***
            return new Certificate(JSON.parse(fs.readFileSync(path, 'utf8')));
        ***REMOVED***
        catch (error) ***REMOVED***
            // Throw a nicely formed error message if the file contents cannot be parsed
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse certificate key file: ' + error);
        ***REMOVED***
    ***REMOVED***;
    return Certificate;
***REMOVED***());
exports.Certificate = Certificate;
/**
 * A wrapper around the http and https request libraries to simplify & promisify JSON requests.
 * TODO(inlined): Create a type for "transit".
 */
function requestAccessToken(transit, options, data) ***REMOVED***
    return new Promise(function (resolve, reject) ***REMOVED***
        var req = transit.request(options, function (res) ***REMOVED***
            var buffers = [];
            res.on('data', function (buffer) ***REMOVED*** return buffers.push(buffer); ***REMOVED***);
            res.on('end', function () ***REMOVED***
                try ***REMOVED***
                    var json = JSON.parse(Buffer.concat(buffers).toString());
                    if (json.error) ***REMOVED***
                        var errorMessage = 'Error fetching access token: ' + json.error;
                        if (json.error_description) ***REMOVED***
                            errorMessage += ' (' + json.error_description + ')';
                        ***REMOVED***
                        reject(new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage));
                    ***REMOVED***
                    else if (!json.access_token || !json.expires_in) ***REMOVED***
                        reject(new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Unexpected response while fetching access token: " + JSON.stringify(json)));
                    ***REMOVED***
                    else ***REMOVED***
                        resolve(json);
                    ***REMOVED***
                ***REMOVED***
                catch (err) ***REMOVED***
                    reject(new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse access token response: " + err.toString()));
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***);
        req.on('error', reject);
        if (data) ***REMOVED***
            req.write(data);
        ***REMOVED***
        req.end();
    ***REMOVED***);
***REMOVED***
/**
 * Implementation of Credential that uses a service account certificate.
 */
var CertCredential = /** @class */ (function () ***REMOVED***
    function CertCredential(serviceAccountPathOrObject) ***REMOVED***
        if (typeof serviceAccountPathOrObject === 'string') ***REMOVED***
            this.certificate_ = Certificate.fromPath(serviceAccountPathOrObject);
        ***REMOVED***
        else ***REMOVED***
            this.certificate_ = new Certificate(serviceAccountPathOrObject);
        ***REMOVED***
    ***REMOVED***
    CertCredential.prototype.getAccessToken = function () ***REMOVED***
        var token = this.createAuthJwt_();
        var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' +
            'grant-type%3Ajwt-bearer&assertion=' +
            token;
        var options = ***REMOVED***
            method: 'POST',
            host: GOOGLE_AUTH_TOKEN_HOST,
            port: GOOGLE_AUTH_TOKEN_PORT,
            path: GOOGLE_AUTH_TOKEN_PATH,
            headers: ***REMOVED***
                'Content-Type': 'application/x-www-form-urlencoded',
                'Content-Length': postData.length,
            ***REMOVED***,
        ***REMOVED***;
        return requestAccessToken(https, options, postData);
    ***REMOVED***;
    CertCredential.prototype.getCertificate = function () ***REMOVED***
        return this.certificate_;
    ***REMOVED***;
    CertCredential.prototype.createAuthJwt_ = function () ***REMOVED***
        var claims = ***REMOVED***
            scope: [
                'https://www.googleapis.com/auth/cloud-platform',
                'https://www.googleapis.com/auth/firebase.database',
                'https://www.googleapis.com/auth/firebase.messaging',
                'https://www.googleapis.com/auth/identitytoolkit',
                'https://www.googleapis.com/auth/userinfo.email',
            ].join(' '),
        ***REMOVED***;
        // This method is actually synchronous so we can capture and return the buffer.
        return jwt.sign(claims, this.certificate_.privateKey, ***REMOVED***
            audience: GOOGLE_TOKEN_AUDIENCE,
            expiresIn: ONE_HOUR_IN_SECONDS,
            issuer: this.certificate_.clientEmail,
            algorithm: JWT_ALGORITHM,
        ***REMOVED***);
    ***REMOVED***;
    return CertCredential;
***REMOVED***());
exports.CertCredential = CertCredential;
/**
 * Implementation of Credential that gets access tokens from refresh tokens.
 */
var RefreshTokenCredential = /** @class */ (function () ***REMOVED***
    function RefreshTokenCredential(refreshTokenPathOrObject) ***REMOVED***
        if (typeof refreshTokenPathOrObject === 'string') ***REMOVED***
            this.refreshToken_ = RefreshToken.fromPath(refreshTokenPathOrObject);
        ***REMOVED***
        else ***REMOVED***
            this.refreshToken_ = new RefreshToken(refreshTokenPathOrObject);
        ***REMOVED***
    ***REMOVED***
    RefreshTokenCredential.prototype.getAccessToken = function () ***REMOVED***
        var postData = 'client_id=' + this.refreshToken_.clientId + '&' +
            'client_secret=' + this.refreshToken_.clientSecret + '&' +
            'refresh_token=' + this.refreshToken_.refreshToken + '&' +
            'grant_type=refresh_token';
        var options = ***REMOVED***
            method: 'POST',
            host: REFRESH_TOKEN_HOST,
            port: REFRESH_TOKEN_PORT,
            path: REFRESH_TOKEN_PATH,
            headers: ***REMOVED***
                'Content-Type': 'application/x-www-form-urlencoded',
                'Content-Length': postData.length,
            ***REMOVED***,
        ***REMOVED***;
        return requestAccessToken(https, options, postData);
    ***REMOVED***;
    ;
    RefreshTokenCredential.prototype.getCertificate = function () ***REMOVED***
        return null;
    ***REMOVED***;
    return RefreshTokenCredential;
***REMOVED***());
exports.RefreshTokenCredential = RefreshTokenCredential;
/**
 * Implementation of Credential that gets access tokens from the metadata service available
 * in the Google Cloud Platform. This authenticates the process as the default service account
 * of an App Engine instance or Google Compute Engine machine.
 */
var MetadataServiceCredential = /** @class */ (function () ***REMOVED***
    function MetadataServiceCredential() ***REMOVED***
    ***REMOVED***
    MetadataServiceCredential.prototype.getAccessToken = function () ***REMOVED***
        var options = ***REMOVED***
            method: 'GET',
            host: GOOGLE_METADATA_SERVICE_HOST,
            path: GOOGLE_METADATA_SERVICE_PATH,
            headers: ***REMOVED***
                'Content-Length': 0,
            ***REMOVED***,
        ***REMOVED***;
        return requestAccessToken(http, options);
    ***REMOVED***;
    MetadataServiceCredential.prototype.getCertificate = function () ***REMOVED***
        return null;
    ***REMOVED***;
    return MetadataServiceCredential;
***REMOVED***());
exports.MetadataServiceCredential = MetadataServiceCredential;
/**
 * ApplicationDefaultCredential implements the process for loading credentials as
 * described in https://developers.google.com/identity/protocols/application-default-credentials
 */
var ApplicationDefaultCredential = /** @class */ (function () ***REMOVED***
    function ApplicationDefaultCredential() ***REMOVED***
        if (process.env.GOOGLE_APPLICATION_CREDENTIALS) ***REMOVED***
            var serviceAccount = Certificate.fromPath(process.env.GOOGLE_APPLICATION_CREDENTIALS);
            this.credential_ = new CertCredential(serviceAccount);
            return;
        ***REMOVED***
        // It is OK to not have this file. If it is present, it must be valid.
        var refreshToken = RefreshToken.fromPath(GCLOUD_CREDENTIAL_PATH);
        if (refreshToken) ***REMOVED***
            this.credential_ = new RefreshTokenCredential(refreshToken);
            return;
        ***REMOVED***
        this.credential_ = new MetadataServiceCredential();
    ***REMOVED***
    ApplicationDefaultCredential.prototype.getAccessToken = function () ***REMOVED***
        return this.credential_.getAccessToken();
    ***REMOVED***;
    ApplicationDefaultCredential.prototype.getCertificate = function () ***REMOVED***
        return this.credential_.getCertificate();
    ***REMOVED***;
    // Used in testing to verify we are delegating to the correct implementation.
    ApplicationDefaultCredential.prototype.getCredential = function () ***REMOVED***
        return this.credential_;
    ***REMOVED***;
    return ApplicationDefaultCredential;
***REMOVED***());
exports.ApplicationDefaultCredential = ApplicationDefaultCredential;
