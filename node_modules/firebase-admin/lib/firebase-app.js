/*! firebase-admin v5.8.2 */
"use strict";
/*!
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var validator = require("./utils/validator");
var deep_copy_1 = require("./utils/deep-copy");
var error_1 = require("./utils/error");
var auth_1 = require("./auth/auth");
var messaging_1 = require("./messaging/messaging");
var storage_1 = require("./storage/storage");
var database_1 = require("./database/database");
var firestore_1 = require("./firestore/firestore");
var instance_id_1 = require("./instance-id/instance-id");
/**
 * Internals of a FirebaseApp instance.
 */
var FirebaseAppInternals = /** @class */ (function () ***REMOVED***
    function FirebaseAppInternals(credential_) ***REMOVED***
        this.credential_ = credential_;
        this.isDeleted_ = false;
        this.tokenListeners_ = [];
    ***REMOVED***
    /**
     * Gets an auth token for the associated app.
     *
     * @param ***REMOVED***boolean***REMOVED*** forceRefresh Whether or not to force a token refresh.
     * @return ***REMOVED***Promise<Object>***REMOVED*** A Promise that will be fulfilled with the current or new token.
     */
    FirebaseAppInternals.prototype.getToken = function (forceRefresh) ***REMOVED***
        var _this = this;
        var expired = this.cachedToken_ && this.cachedToken_.expirationTime < Date.now();
        if (this.cachedTokenPromise_ && !forceRefresh && !expired) ***REMOVED***
            return this.cachedTokenPromise_
                .catch(function (error) ***REMOVED***
                // Update the cached token promise to avoid caching errors. Set it to resolve with the
                // cached token if we have one (and return that promise since the token has still not
                // expired).
                if (_this.cachedToken_) ***REMOVED***
                    _this.cachedTokenPromise_ = Promise.resolve(_this.cachedToken_);
                    return _this.cachedTokenPromise_;
                ***REMOVED***
                // Otherwise, set the cached token promise to null so that it will force a refresh next
                // time getToken() is called.
                _this.cachedTokenPromise_ = null;
                // And re-throw the caught error.
                throw error;
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            // Clear the outstanding token refresh timeout. This is a noop if the timeout is undefined.
            clearTimeout(this.tokenRefreshTimeout_);
            // this.credential_ may be an external class; resolving it in a promise helps us
            // protect against exceptions and upgrades the result to a promise in all cases.
            this.cachedTokenPromise_ = Promise.resolve(this.credential_.getAccessToken())
                .then(function (result) ***REMOVED***
                // Since the developer can provide the credential implementation, we want to weakly verify
                // the return type until the type is properly exported.
                if (!validator.isNonNullObject(result) ||
                    typeof result.expires_in !== 'number' ||
                    typeof result.access_token !== 'string') ***REMOVED***
                    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Invalid access token generated: \"" + JSON.stringify(result) + "\". Valid access " +
                        'tokens must be an object with the "expires_in" (number) and "access_token" ' +
                        '(string) properties.');
                ***REMOVED***
                var token = ***REMOVED***
                    accessToken: result.access_token,
                    expirationTime: Date.now() + (result.expires_in * 1000),
                ***REMOVED***;
                var hasAccessTokenChanged = (_this.cachedToken_ && _this.cachedToken_.accessToken !== token.accessToken);
                var hasExpirationChanged = (_this.cachedToken_ && _this.cachedToken_.expirationTime !== token.expirationTime);
                if (!_this.cachedToken_ || hasAccessTokenChanged || hasExpirationChanged) ***REMOVED***
                    _this.cachedToken_ = token;
                    _this.tokenListeners_.forEach(function (listener) ***REMOVED***
                        listener(token.accessToken);
                    ***REMOVED***);
                ***REMOVED***
                // Establish a timeout to proactively refresh the token every minute starting at five
                // minutes before it expires. Once a token refresh succeeds, no further retries are
                // needed; if it fails, retry every minute until the token expires (resulting in a total
                // of four retries: at 4, 3, 2, and 1 minutes).
                var refreshTimeInSeconds = (result.expires_in - (5 * 60));
                var numRetries = 4;
                // In the rare cases the token is short-lived (that is, it expires in less than five
                // minutes from when it was fetched), establish the timeout to refresh it after the
                // current minute ends and update the number of retries that should be attempted before
                // the token expires.
                if (refreshTimeInSeconds <= 0) ***REMOVED***
                    refreshTimeInSeconds = result.expires_in % 60;
                    numRetries = Math.floor(result.expires_in / 60) - 1;
                ***REMOVED***
                // The token refresh timeout keeps the Node.js process alive, so only create it if this
                // instance has not already been deleted.
                if (numRetries && !_this.isDeleted_) ***REMOVED***
                    _this.setTokenRefreshTimeout(refreshTimeInSeconds * 1000, numRetries);
                ***REMOVED***
                return token;
            ***REMOVED***)
                .catch(function (error) ***REMOVED***
                var errorMessage = (typeof error === 'string') ? error : error.message;
                errorMessage = 'Credential implementation provided to initializeApp() via the ' +
                    '"credential" property failed to fetch a valid Google OAuth2 access token with the ' +
                    ("following error: \"" + errorMessage + "\".");
                if (errorMessage.indexOf('invalid_grant') !== -1) ***REMOVED***
                    errorMessage += ' There are two likely causes: (1) your server time is not properly ' +
                        'synced or (2) your certificate key file has been revoked. To solve (1), re-sync the ' +
                        'time on your server. To solve (2), make sure the key ID for your key file is still ' +
                        'present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If ' +
                        'not, generate a new key file at ' +
                        'https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.';
                ***REMOVED***
                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
            ***REMOVED***);
            return this.cachedTokenPromise_;
        ***REMOVED***
    ***REMOVED***;
    /**
     * Adds a listener that is called each time a token changes.
     *
     * @param ***REMOVED***function(string)***REMOVED*** listener The listener that will be called with each new token.
     */
    FirebaseAppInternals.prototype.addAuthTokenListener = function (listener) ***REMOVED***
        this.tokenListeners_.push(listener);
        if (this.cachedToken_) ***REMOVED***
            listener(this.cachedToken_.accessToken);
        ***REMOVED***
    ***REMOVED***;
    /**
     * Removes a token listener.
     *
     * @param ***REMOVED***function(string)***REMOVED*** listener The listener to remove.
     */
    FirebaseAppInternals.prototype.removeAuthTokenListener = function (listener) ***REMOVED***
        this.tokenListeners_ = this.tokenListeners_.filter(function (other) ***REMOVED*** return other !== listener; ***REMOVED***);
    ***REMOVED***;
    /**
     * Deletes the FirebaseAppInternals instance.
     */
    FirebaseAppInternals.prototype.delete = function () ***REMOVED***
        this.isDeleted_ = true;
        // Clear the token refresh timeout so it doesn't keep the Node.js process alive.
        clearTimeout(this.tokenRefreshTimeout_);
    ***REMOVED***;
    /**
     * Establishes timeout to refresh the Google OAuth2 access token used by the SDK.
     *
     * @param ***REMOVED***number***REMOVED*** delayInMilliseconds The delay to use for the timeout.
     * @param ***REMOVED***number***REMOVED*** numRetries The number of times to retry fetching a new token if the prior fetch
     *   failed.
     */
    FirebaseAppInternals.prototype.setTokenRefreshTimeout = function (delayInMilliseconds, numRetries) ***REMOVED***
        var _this = this;
        this.tokenRefreshTimeout_ = setTimeout(function () ***REMOVED***
            _this.getToken(/* forceRefresh */ true)
                .catch(function (error) ***REMOVED***
                // Ignore the error since this might just be an intermittent failure. If we really cannot
                // refresh the token, an error will be logged once the existing token expires and we try
                // to fetch a fresh one.
                if (numRetries > 0) ***REMOVED***
                    _this.setTokenRefreshTimeout(60 * 1000, numRetries - 1);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***, delayInMilliseconds);
    ***REMOVED***;
    return FirebaseAppInternals;
***REMOVED***());
exports.FirebaseAppInternals = FirebaseAppInternals;
/**
 * Global context object for a collection of services using a shared authentication state.
 */
var FirebaseApp = /** @class */ (function () ***REMOVED***
    function FirebaseApp(options, name, firebaseInternals_) ***REMOVED***
        var _this = this;
        this.firebaseInternals_ = firebaseInternals_;
        this.services_ = ***REMOVED******REMOVED***;
        this.isDeleted_ = false;
        this.name_ = name;
        this.options_ = deep_copy_1.deepCopy(options);
        if (typeof this.options_ !== 'object' || this.options_ === null) ***REMOVED***
            // Ensure the options are a non-null object
            this.options_ = ***REMOVED******REMOVED***;
        ***REMOVED***
        var hasCredential = ('credential' in this.options_);
        var errorMessage;
        if (!hasCredential) ***REMOVED***
            errorMessage = 'Options must be an object containing at least a "credential" property.';
        ***REMOVED***
        var credential = this.options_.credential;
        if (typeof credential !== 'object' || credential === null || typeof credential.getAccessToken !== 'function') ***REMOVED***
            errorMessage = 'The "credential" property must be an object which implements the Credential interface.';
        ***REMOVED***
        if (typeof errorMessage !== 'undefined') ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, "Invalid Firebase app options passed as the first argument to initializeApp() for the " +
                ("app named \"" + this.name_ + "\". " + errorMessage));
        ***REMOVED***
        Object.keys(firebaseInternals_.serviceFactories).forEach(function (serviceName) ***REMOVED***
            // Defer calling createService() until the service is accessed
            _this[serviceName] = _this.getService_.bind(_this, serviceName);
        ***REMOVED***);
        this.INTERNAL = new FirebaseAppInternals(this.options_.credential);
    ***REMOVED***
    /**
     * Returns the Auth service instance associated with this app.
     *
     * @return ***REMOVED***Auth***REMOVED*** The Auth service instance of this app.
     */
    FirebaseApp.prototype.auth = function () ***REMOVED***
        var _this = this;
        return this.ensureService_('auth', function () ***REMOVED***
            return new auth_1.Auth(_this);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Returns the Database service for the specified URL, and the current app.
     *
     * @return ***REMOVED***Database***REMOVED*** The Database service instance of this app.
     */
    FirebaseApp.prototype.database = function (url) ***REMOVED***
        var _this = this;
        var service = this.ensureService_('database', function () ***REMOVED***
            return new database_1.DatabaseService(_this);
        ***REMOVED***);
        return service.getDatabase(url);
    ***REMOVED***;
    /**
     * Returns the Messaging service instance associated with this app.
     *
     * @return ***REMOVED***Messaging***REMOVED*** The Messaging service instance of this app.
     */
    FirebaseApp.prototype.messaging = function () ***REMOVED***
        var _this = this;
        return this.ensureService_('messaging', function () ***REMOVED***
            return new messaging_1.Messaging(_this);
        ***REMOVED***);
    ***REMOVED***;
    /**
     * Returns the Storage service instance associated with this app.
     *
     * @return ***REMOVED***Storage***REMOVED*** The Storage service instance of this app.
     */
    FirebaseApp.prototype.storage = function () ***REMOVED***
        var _this = this;
        return this.ensureService_('storage', function () ***REMOVED***
            return new storage_1.Storage(_this);
        ***REMOVED***);
    ***REMOVED***;
    FirebaseApp.prototype.firestore = function () ***REMOVED***
        var _this = this;
        var service = this.ensureService_('firestore', function () ***REMOVED***
            return new firestore_1.FirestoreService(_this);
        ***REMOVED***);
        return service.client;
    ***REMOVED***;
    /**
     * Returns the InstanceId service instance associated with this app.
     *
     * @return ***REMOVED***InstanceId***REMOVED*** The InstanceId service instance of this app.
     */
    FirebaseApp.prototype.instanceId = function () ***REMOVED***
        var _this = this;
        return this.ensureService_('iid', function () ***REMOVED***
            return new instance_id_1.InstanceId(_this);
        ***REMOVED***);
    ***REMOVED***;
    Object.defineProperty(FirebaseApp.prototype, "name", ***REMOVED***
        /**
         * Returns the name of the FirebaseApp instance.
         *
         * @returns ***REMOVED***string***REMOVED*** The name of the FirebaseApp instance.
         */
        get: function () ***REMOVED***
            this.checkDestroyed_();
            return this.name_;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(FirebaseApp.prototype, "options", ***REMOVED***
        /**
         * Returns the options for the FirebaseApp instance.
         *
         * @returns ***REMOVED***FirebaseAppOptions***REMOVED*** The options for the FirebaseApp instance.
         */
        get: function () ***REMOVED***
            this.checkDestroyed_();
            return deep_copy_1.deepCopy(this.options_);
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    /**
     * Deletes the FirebaseApp instance.
     *
     * @returns ***REMOVED***Promise<void>***REMOVED*** An empty Promise fulfilled once the FirebaseApp instance is deleted.
     */
    FirebaseApp.prototype.delete = function () ***REMOVED***
        var _this = this;
        this.checkDestroyed_();
        this.firebaseInternals_.removeApp(this.name_);
        this.INTERNAL.delete();
        return Promise.all(Object.keys(this.services_).map(function (serviceName) ***REMOVED***
            return _this.services_[serviceName].INTERNAL.delete();
        ***REMOVED***)).then(function () ***REMOVED***
            _this.services_ = ***REMOVED******REMOVED***;
            _this.isDeleted_ = true;
        ***REMOVED***);
    ***REMOVED***;
    FirebaseApp.prototype.ensureService_ = function (serviceName, initializer) ***REMOVED***
        this.checkDestroyed_();
        var service;
        if (serviceName in this.services_) ***REMOVED***
            service = this.services_[serviceName];
        ***REMOVED***
        else ***REMOVED***
            service = initializer();
            this.services_[serviceName] = service;
        ***REMOVED***
        return service;
    ***REMOVED***;
    /**
     * Returns the service instance associated with this FirebaseApp instance (creating it on demand
     * if needed). This is used for looking up monkeypatched service instances.
     *
     * @param ***REMOVED***string***REMOVED*** serviceName The name of the service instance to return.
     * @return ***REMOVED***FirebaseServiceInterface***REMOVED*** The service instance with the provided name.
     */
    FirebaseApp.prototype.getService_ = function (serviceName) ***REMOVED***
        this.checkDestroyed_();
        if (!(serviceName in this.services_)) ***REMOVED***
            this.services_[serviceName] = this.firebaseInternals_.serviceFactories[serviceName](this, this.extendApp_.bind(this));
        ***REMOVED***
        return this.services_[serviceName];
    ***REMOVED***;
    /**
     * Callback function used to extend an App instance at the time of service instance creation.
     */
    FirebaseApp.prototype.extendApp_ = function (props) ***REMOVED***
        deep_copy_1.deepExtend(this, props);
    ***REMOVED***;
    /**
     * Throws an Error if the FirebaseApp instance has already been deleted.
     */
    FirebaseApp.prototype.checkDestroyed_ = function () ***REMOVED***
        if (this.isDeleted_) ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.APP_DELETED, "Firebase app named \"" + this.name_ + "\" has already been deleted.");
        ***REMOVED***
    ***REMOVED***;
    return FirebaseApp;
***REMOVED***());
exports.FirebaseApp = FirebaseApp;
