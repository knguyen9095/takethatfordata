/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var isNumber = require('is-number');
var randomize = require('randomatic');
var repeatStr = require('repeat-string');
var repeat = require('repeat-element');

/**
 * Expose `fillRange`
 */

module.exports = fillRange;

/**
 * Return a range of numbers or letters.
 *
 * @param  ***REMOVED***String***REMOVED*** `a` Start of the range
 * @param  ***REMOVED***String***REMOVED*** `b` End of the range
 * @param  ***REMOVED***String***REMOVED*** `step` Increment or decrement to use.
 * @param  ***REMOVED***Function***REMOVED*** `fn` Custom function to modify each element in the range.
 * @return ***REMOVED***Array***REMOVED***
 */

function fillRange(a, b, step, options, fn) ***REMOVED***
  if (a == null || b == null) ***REMOVED***
    throw new Error('fill-range expects the first and second args to be strings.');
  ***REMOVED***

  if (typeof step === 'function') ***REMOVED***
    fn = step; options = ***REMOVED******REMOVED***; step = null;
  ***REMOVED***

  if (typeof options === 'function') ***REMOVED***
    fn = options; options = ***REMOVED******REMOVED***;
  ***REMOVED***

  if (isObject(step)) ***REMOVED***
    options = step; step = '';
  ***REMOVED***

  var expand, regex = false, sep = '';
  var opts = options || ***REMOVED******REMOVED***;

  if (typeof opts.silent === 'undefined') ***REMOVED***
    opts.silent = true;
  ***REMOVED***

  step = step || opts.step;

  // store a ref to unmodified arg
  var origA = a, origB = b;

  b = (b.toString() === '-0') ? 0 : b;

  if (opts.optimize || opts.makeRe) ***REMOVED***
    step = step ? (step += '~') : step;
    expand = true;
    regex = true;
    sep = '~';
  ***REMOVED***

  // handle special step characters
  if (typeof step === 'string') ***REMOVED***
    var match = stepRe().exec(step);

    if (match) ***REMOVED***
      var i = match.index;
      var m = match[0];

      // repeat string
      if (m === '+') ***REMOVED***
        return repeat(a, b);

      // randomize a, `b` times
      ***REMOVED*** else if (m === '?') ***REMOVED***
        return [randomize(a, b)];

      // expand right, no regex reduction
      ***REMOVED*** else if (m === '>') ***REMOVED***
        step = step.substr(0, i) + step.substr(i + 1);
        expand = true;

      // expand to an array, or if valid create a reduced
      // string for a regex logic `or`
      ***REMOVED*** else if (m === '|') ***REMOVED***
        step = step.substr(0, i) + step.substr(i + 1);
        expand = true;
        regex = true;
        sep = m;

      // expand to an array, or if valid create a reduced
      // string for a regex range
      ***REMOVED*** else if (m === '~') ***REMOVED***
        step = step.substr(0, i) + step.substr(i + 1);
        expand = true;
        regex = true;
        sep = m;
      ***REMOVED***
    ***REMOVED*** else if (!isNumber(step)) ***REMOVED***
      if (!opts.silent) ***REMOVED***
        throw new TypeError('fill-range: invalid step.');
      ***REMOVED***
      return null;
    ***REMOVED***
  ***REMOVED***

  if (/[.&*()[\]^%$#@!]/.test(a) || /[.&*()[\]^%$#@!]/.test(b)) ***REMOVED***
    if (!opts.silent) ***REMOVED***
      throw new RangeError('fill-range: invalid range arguments.');
    ***REMOVED***
    return null;
  ***REMOVED***

  // has neither a letter nor number, or has both letters and numbers
  // this needs to be after the step logic
  if (!noAlphaNum(a) || !noAlphaNum(b) || hasBoth(a) || hasBoth(b)) ***REMOVED***
    if (!opts.silent) ***REMOVED***
      throw new RangeError('fill-range: invalid range arguments.');
    ***REMOVED***
    return null;
  ***REMOVED***

  // validate arguments
  var isNumA = isNumber(zeros(a));
  var isNumB = isNumber(zeros(b));

  if ((!isNumA && isNumB) || (isNumA && !isNumB)) ***REMOVED***
    if (!opts.silent) ***REMOVED***
      throw new TypeError('fill-range: first range argument is incompatible with second.');
    ***REMOVED***
    return null;
  ***REMOVED***

  // by this point both are the same, so we
  // can use A to check going forward.
  var isNum = isNumA;
  var num = formatStep(step);

  // is the range alphabetical? or numeric?
  if (isNum) ***REMOVED***
    // if numeric, coerce to an integer
    a = +a; b = +b;
  ***REMOVED*** else ***REMOVED***
    // otherwise, get the charCode to expand alpha ranges
    a = a.charCodeAt(0);
    b = b.charCodeAt(0);
  ***REMOVED***

  // is the pattern descending?
  var isDescending = a > b;

  // don't create a character class if the args are < 0
  if (a < 0 || b < 0) ***REMOVED***
    expand = false;
    regex = false;
  ***REMOVED***

  // detect padding
  var padding = isPadded(origA, origB);
  var res, pad, arr = [];
  var ii = 0;

  // character classes, ranges and logical `or`
  if (regex) ***REMOVED***
    if (shouldExpand(a, b, num, isNum, padding, opts)) ***REMOVED***
      // make sure the correct separator is used
      if (sep === '|' || sep === '~') ***REMOVED***
        sep = detectSeparator(a, b, num, isNum, isDescending);
      ***REMOVED***
      return wrap([origA, origB], sep, opts);
    ***REMOVED***
  ***REMOVED***

  while (isDescending ? (a >= b) : (a <= b)) ***REMOVED***
    if (padding && isNum) ***REMOVED***
      pad = padding(a);
    ***REMOVED***

    // custom function
    if (typeof fn === 'function') ***REMOVED***
      res = fn(a, isNum, pad, ii++);

    // letters
    ***REMOVED*** else if (!isNum) ***REMOVED***
      if (regex && isInvalidChar(a)) ***REMOVED***
        res = null;
      ***REMOVED*** else ***REMOVED***
        res = String.fromCharCode(a);
      ***REMOVED***

    // numbers
    ***REMOVED*** else ***REMOVED***
      res = formatPadding(a, pad);
    ***REMOVED***

    // add result to the array, filtering any nulled values
    if (res !== null) arr.push(res);

    // increment or decrement
    if (isDescending) ***REMOVED***
      a -= num;
    ***REMOVED*** else ***REMOVED***
      a += num;
    ***REMOVED***
  ***REMOVED***

  // now that the array is expanded, we need to handle regex
  // character classes, ranges or logical `or` that wasn't
  // already handled before the loop
  if ((regex || expand) && !opts.noexpand) ***REMOVED***
    // make sure the correct separator is used
    if (sep === '|' || sep === '~') ***REMOVED***
      sep = detectSeparator(a, b, num, isNum, isDescending);
    ***REMOVED***
    if (arr.length === 1 || a < 0 || b < 0) ***REMOVED*** return arr; ***REMOVED***
    return wrap(arr, sep, opts);
  ***REMOVED***

  return arr;
***REMOVED***

/**
 * Wrap the string with the correct regex
 * syntax.
 */

function wrap(arr, sep, opts) ***REMOVED***
  if (sep === '~') ***REMOVED*** sep = '-'; ***REMOVED***
  var str = arr.join(sep);
  var pre = opts && opts.regexPrefix;

  // regex logical `or`
  if (sep === '|') ***REMOVED***
    str = pre ? pre + str : str;
    str = '(' + str + ')';
  ***REMOVED***

  // regex character class
  if (sep === '-') ***REMOVED***
    str = (pre && pre === '^')
      ? pre + str
      : str;
    str = '[' + str + ']';
  ***REMOVED***
  return [str];
***REMOVED***

/**
 * Check for invalid characters
 */

function isCharClass(a, b, step, isNum, isDescending) ***REMOVED***
  if (isDescending) ***REMOVED*** return false; ***REMOVED***
  if (isNum) ***REMOVED*** return a <= 9 && b <= 9; ***REMOVED***
  if (a < b) ***REMOVED*** return step === 1; ***REMOVED***
  return false;
***REMOVED***

/**
 * Detect the correct separator to use
 */

function shouldExpand(a, b, num, isNum, padding, opts) ***REMOVED***
  if (isNum && (a > 9 || b > 9)) ***REMOVED*** return false; ***REMOVED***
  return !padding && num === 1 && a < b;
***REMOVED***

/**
 * Detect the correct separator to use
 */

function detectSeparator(a, b, step, isNum, isDescending) ***REMOVED***
  var isChar = isCharClass(a, b, step, isNum, isDescending);
  if (!isChar) ***REMOVED***
    return '|';
  ***REMOVED***
  return '~';
***REMOVED***

/**
 * Correctly format the step based on type
 */

function formatStep(step) ***REMOVED***
  return Math.abs(step >> 0) || 1;
***REMOVED***

/**
 * Format padding, taking leading `-` into account
 */

function formatPadding(ch, pad) ***REMOVED***
  var res = pad ? pad + ch : ch;
  if (pad && ch.toString().charAt(0) === '-') ***REMOVED***
    res = '-' + pad + ch.toString().substr(1);
  ***REMOVED***
  return res.toString();
***REMOVED***

/**
 * Check for invalid characters
 */

function isInvalidChar(str) ***REMOVED***
  var ch = toStr(str);
  return ch === '\\'
    || ch === '['
    || ch === ']'
    || ch === '^'
    || ch === '('
    || ch === ')'
    || ch === '`';
***REMOVED***

/**
 * Convert to a string from a charCode
 */

function toStr(ch) ***REMOVED***
  return String.fromCharCode(ch);
***REMOVED***


/**
 * Step regex
 */

function stepRe() ***REMOVED***
  return /\?|>|\||\+|\~/g;
***REMOVED***

/**
 * Return true if `val` has either a letter
 * or a number
 */

function noAlphaNum(val) ***REMOVED***
  return /[a-z0-9]/i.test(val);
***REMOVED***

/**
 * Return true if `val` has both a letter and
 * a number (invalid)
 */

function hasBoth(val) ***REMOVED***
  return /[a-z][0-9]|[0-9][a-z]/i.test(val);
***REMOVED***

/**
 * Normalize zeros for checks
 */

function zeros(val) ***REMOVED***
  if (/^-*0+$/.test(val.toString())) ***REMOVED***
    return '0';
  ***REMOVED***
  return val;
***REMOVED***

/**
 * Return true if `val` has leading zeros,
 * or a similar valid pattern.
 */

function hasZeros(val) ***REMOVED***
  return /[^.]\.|^-*0+[0-9]/.test(val);
***REMOVED***

/**
 * If the string is padded, returns a curried function with
 * the a cached padding string, or `false` if no padding.
 *
 * @param  ***REMOVED*******REMOVED*** `origA` String or number.
 * @return ***REMOVED***String|Boolean***REMOVED***
 */

function isPadded(origA, origB) ***REMOVED***
  if (hasZeros(origA) || hasZeros(origB)) ***REMOVED***
    var alen = length(origA);
    var blen = length(origB);

    var len = alen >= blen
      ? alen
      : blen;

    return function (a) ***REMOVED***
      return repeatStr('0', len - length(a));
    ***REMOVED***;
  ***REMOVED***
  return false;
***REMOVED***

/**
 * Get the string length of `val`
 */

function length(val) ***REMOVED***
  return val.toString().length;
***REMOVED***
